1	rdfeo	1	There are k lists of sorted integers. Make a min heap of size k containing 1 element from each list. Keep track of min and max element and calculate the range. In min heap, minimum element is at top. Delete the minimum element and another element instead of that from the same list to which minimum element belong. Repeat the process till any one of the k list gets empty. Keep track of minimum range.  For eg. List 1: [4, 10, 15, 24, 26] List 2: [0, 9, 12, 20] List 3: [5, 18, 22, 30]  Min heap of size 3. containing 1 element of each list Heap [0, 4, 5] Range - 6  Remove 0 and add 9 Heap [4, 9, 5] Range - 6  Remove 4 and add 10 Heap [5, 9, 10] Range - 6  and so on....  Finally you will yield the result.	2014-12-10 11:47:43		
2	krxlv	1	nice solution	2014-12-10 11:47:43		
3	rdfeo	1	since the input lists are already sorted, we should take advantage of it rather than creating a new minHeap.	2014-12-10 11:47:43		
4	qywrh	1	can you please tell me how you are keep an account of minimum range in this. How you are going to find out which range is minimum because you going forward without keeping the record of range. for instance: If you are taking an array for tracking the records then each time you have to find the smallest element of the array and you have to compare it with current result and so on .... till you are getting minimum. I m taking array here only for explanation, for that you can use a heap also. but any how you have to provide extra code to keep track for ranges to find minimum range and the proper possession of each and ever combination with range, for that you require another data structure.	2014-12-10 11:47:43		
5	sqzqo	1	When you are creating the heap for the first time, make a separate variable that keeps track of max number in the heap. Everytime you add a new element into the heap, check the new element against this variable. That way you can get the max-min range	2014-12-10 11:47:43		
6	nwkeg	1	Nice solution only one thing is missing which is how to make use of sorted nature of lists as rightly pointed by @Vinod K	2014-12-10 11:47:45		
7	ftfck	1	nice idea!!!I have implemented it quickly. @Vinod K @aka, What do you mean "how to make use of sorted nature of lists" ?	2014-12-10 11:47:45		
8	ufdxg	1		2014-12-10 11:47:45		
9	mrjku	1		2014-12-10 11:47:45		
10	ethan	1	How can we prove the correctness of this algorithm? What if we remove the element from the heap which has next minimum value, instead of removing the minumum value itself? Which one would be correct? Both, or none?	2014-12-10 11:47:45		
11	qywrh	1	That a good idea. I also wrote the code. It will be better to use vectors instead of array in real applications.	2014-12-10 11:47:45		
12	jippy	1		2014-12-10 11:47:45		
13	krxlv	1		2014-12-10 11:47:45		
14	gilit	1	It does use the sorted feature of K lists. If you try to prove the correctness of this algorithm, it does depend on the properties that "each element in the list is in increasing order"	2014-12-10 11:47:45		
15	ewigy	1	what is the time complexity of this algorithm?	2014-12-10 11:47:45		
16	zeice	1	This is based on a problem in CLRS. Read heap chapter, there is a problem that talks about how to sort k sorted lists. This problem is just extension of that.  Here java code,	2014-12-10 11:47:45		
17	dkebi	1		2014-12-10 11:47:45		
18	dgjji	1		2014-12-10 11:47:45		
19	bexbp	1	This is how I reason about this solution.  Think of drawing points from k lists on a X axis line. We first consider the minimum point from all lists. Lets assume it is from list A. For any range involved this point, the minimum range is the range involving the other k-1 points, each of which is the minimum of the other k-1 different lists. Let use R to indicate this range. So the minimum range involving all k lists is among R and the minimum range involving the k-1 lists and list A with the minimum removed. Repeat this process until one of k lists is empty.	2014-12-10 11:47:45		
20	admin	1	aasshishh's solution in Python:  def minRange(lll): import heapq heap = [] num_elts = 0 for k in range(0,len(lll)): li = lll[k] if len(li)==0: print 'none of the lists can be empty' return 0 num_elts += len(li) heapq.heappush(heap,(li[0],k)) oldrangemin = min(heap)[0] oldrangemax = max(heap)[0] oldheaprange = oldrangemax - oldrangemin for i in range(0,num_elts): heap_min_elt = heapq.heappop(heap) k = heap_min_elt[1] heap_new_elt = lll[k].pop(0) heapq.heappush(heap, (heap_new_elt,k)) rangemin = min(heap)[0] rangemax = max(heap)[0] newheaprange = rangemax - rangemin if newheaprange < oldheaprange: oldheaprange = newheaprange oldrangemin = rangemin oldrangemax = rangemax if len(lll[k])==0: break return [oldrangemin, oldrangemax]  >>>my_list_of_lists = [[2,50,60],[10,20,40],[2,3,100],[4,5,6]] >>>minRange(my_list_of_lists) >>>[2, 10]	2014-12-10 11:47:45		
21	ftfck	1	This is the same as: merge all the N lists into one long array, then keep a sliding window of N.	2014-12-10 11:47:45		
22	wbqzu	1	Here's my Python version of that. heapq.merge should be better than heappush, taking advantage of the already sorted lists.	2014-12-10 11:47:45		
23	ethan	1		2014-12-10 11:47:45		
24	vanul	1		2014-12-10 11:47:45		
25	nhibd	1	What if the min or max appears multiple time. Say k = 6 current heap is 2 2 2 6 6 6 And a new element say 3 is replacing 2 in 1st list. Getting min is not an issue as its a minheap an still we will get 2 as a minm.  What if i replace last 6 with 5 ? I feel that somewhere we need to maintain the counts of elements in the heap.	2014-12-10 11:47:45		
26	qywrh	1	This can be solved easily as below. 1. initialize smallest_range as MAX_INT 2. keep 3 pointers/index p1, p2 and p3 which points to the first elements of lists L1, L2 and L3 respectively. 3. find the max value and min value pointed/indexed by p1, p2 and p3 4. difference of max value and min value discovered in step 3 is the current range. compare it with smallest_range and update it, if found smaller. 5. increment the pointer/index of min value found in step 3. 6. repeat step 3 to 5 until the pointer/index of min value is in range.  constant space and O(n) time.	2014-12-10 11:47:45		
27	azmjc	1	Correct.... no doubt sol is fantastic..... I like the way of presenting your sol.... great job...	2014-12-10 11:47:45		
28	rdfeo	1		2014-12-10 11:47:45		
29	vanul	1		2014-12-10 11:47:45		
30	xhgls	1	It is actually O(N*k) time with O(1) space.  Step 3: find the max value and min value pointed/indexed by p1, p2 and p3, will have O(k) time execution every time.  It is a nice solution!	2014-12-10 11:47:45		
31	eucmc	1	@xint - time will be O(n) only.  I had taken an example of 3 lists above. we can generalize it.  Instead of 3 pointers, take an array of K pointers which initially points to the first elements of K lists. Now find the minValue and maxValue among this K pointers. Find the range and update smallest_range, if needed. Increment the pointer points to minValue and compare the value now pointed with minValue and maxValue and update it, if needed. so this will take only constant time.(no need to find the minValue and maxValue among K pointers each time since we are already tracking min and max among the K pointers ) repeat till end of list  time - O(n), space - O(k)	2014-12-10 11:47:45		
32	ewigy	1	your code stop when one list reach the end, right? But in some case, the optimal solution need to look through all elements in every list. Let me know if I am wrong.	2014-12-10 11:47:45		
33	wbqzu	1	I mean yogi.rulzz's code	2014-12-10 11:47:45		
34	fowai	1	Oh, I think I know the problem. Once one of the list reach the end, other list's elems will always greater than current ones. Hence the min_range will not be affected. Sorry for the misunderstanding.	2014-12-10 11:47:45		
35	rrmeu	1	plz read the question again, it asks k lists. solution becomes O(nk)	2014-12-10 11:47:45		
36	dkebi	1	List 1: [1, 2, 3, 80] List 2: [1, 2, 3, 90, 200] List 2: [1, 2, 3, 99, 300] I think your approach doesn't work for this.	2014-12-10 11:47:45		
37	fmzze	1	First, combine all lists into one big list, for each item keeping track of the list it's from and the value of the item. You get a data structure that (conceptually) looks like this:	2014-12-10 11:47:45		
38	azmjc	1		2014-12-10 11:47:46		
39	fowai	1		2014-12-10 11:47:46		
40	vanul	1	Now you start going through this new list item by item until you have the first item from each list (in this case 0,4,5), and you calculate the range (5). Now you move through the list one element at a time. Each time you find an element from a given list, you select that element (so you have three indices, and you always move the one to whose list the current element belongs to that element). So the first step is to replace the 4 by the 9, yielding (0,9,5) with a range of 9. If the range is smaller than the minimum range, remember it, else ignore it, so ignore the (0,9,5) range. The next couple of ranges: (10, 9, 5), (10,12,5), (15, 12, 5), (15, 12, 18), (15, 20, 18), (18,20,24), (18,20,26), (26, 20, 30).  Since you visit every element in every list once, complexity is O(N) where N is the number of elements in the lists all added up.	2014-12-10 11:47:46		
41	sqzqo	1	I also thought of that method which looks correct, but the complexity looks O(N log k). When combining I think you have to decide form which list you are going to pick the next element(like k-way merging). So for each of N element it takes O(log k).	2014-12-10 11:47:46		
42	admin	1	good solution. the issue is with the extra space. for keeping the actual index we need extra space. And if the input lists cannot be altered, then we weed an additional list to merge all 3 lists.	2014-12-10 11:47:46		
43	ufdxg	1	This algorithm doesn't work. Suppose the 5 were an 8 instead. Then the first valid range you get is (0,4,8), with a size of 8. Then you see the 9, consider (0,9,8), and ignore it because it has size 9. Next you see the 10 and consider (10,4,8), which you accept because it has size 6.  The algorithm has missed the better solution of (8,9,10).	2014-12-10 11:47:46		
44	nwkeg	1	You don't ignore (0,9,8) but just do not update your current best solution (0,4,8). So when you see 10 you'll be considering (10,9,8).	2014-12-10 11:47:46		
45	fowai	1	It is O(k) space and O(N*k) time solution. N : total no. of elements from all the the lists.	2014-12-10 11:47:46		
46	rdfeo	1	since list are already ordered, you can in generate the sorted list of all of them fast, and keep an additional array with the original list they belonged to:  In the example	2014-12-10 11:47:46		
47	eucmc	1		2014-12-10 11:47:46		
48	gilit	1		2014-12-10 11:47:46		
49	nwkeg	1	Once you have that, you just have to find the subsequence in the right column which contains K different symbols (at least length K). If there is more than one sequence of length K, just take the one with the minimum range in the right column  I've implemented the sorting in a customized python iterator	2014-12-10 11:47:46		
50	gilit	1		2014-12-10 11:47:46		
51	admin	1		2014-12-10 11:47:46		
52	ethan	1	It could be optimized for the case of disjoint intervals defined by the groups, where the sequence would be [0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1] by not enlarging the list when adding 3+ items from the same original list.	2014-12-10 11:47:46		
53	azmjc	1	Keep three pointers to the beginning of each of the lists and advance the pointer on the list that has the next smallest value until you reach the end of one of the lists that has the lowest number out of the three. Store the smallest range along the way. So the iterations become (the current index of the pointer is shown in parentheses)	2014-12-10 11:47:46		
54	fowai	1		2014-12-10 11:47:46		
55	nhibd	1		2014-12-10 11:47:46		
56	cfzie	1		2014-12-10 11:47:46		
57	nhibd	1		2014-12-10 11:47:46		
58	krxlv	1		2014-12-10 11:47:46		
59	ethan	1		2014-12-10 11:47:46		
60	admin	1		2014-12-10 11:47:46		
61	zeice	1		2014-12-10 11:47:46		
62	nhibd	1		2014-12-10 11:47:46		
63	admin	1		2014-12-10 11:47:46		
64	nhibd	1		2014-12-10 11:47:46		
65	fmzze	1		2014-12-10 11:47:46		
66	cfzie	1		2014-12-10 11:47:46		
67	tenuw	1		2014-12-10 11:47:46		
68	eucmc	1		2014-12-10 11:47:46		
69	dgjji	1		2014-12-10 11:47:46		
70	xhgls	1		2014-12-10 11:47:46		
71	bjsiw	1		2014-12-10 11:47:46		
72	jippy	1	You can stop at this point since the lowest number in the range belongs to the list that has no more elements, which means you can't improve upon this.	2014-12-10 11:47:46		
73	ewigy	1	Instead of starting it from first element, we can start that same process with the median elements of all arrays. It will optimize the solution further.  BTW, its a simple and great approach!	2014-12-10 11:47:46		
74	fowai	1	How can we prove the correctness of this algorithm? It is somewhat similar to the one with highest votes, except that it removes the element from the set which has next minimum value, whereas the other answer removes the element which itself is minumum.  So which one is correct? How to prove it?	2014-12-10 11:47:46		
75	dkebi	1	We do not need to start from the beginning, as suggested here. Instead, start at tails. The smallest of the tails is the lower bound of the range guaranteed. The issue is to find the upper bound. Of course the upper bound cannot be more than the max of all tails.  So start with the max of tails as upper bound. To best this estimation, compare the next smaller number than this tail (in the same list as the max of tails, of course). If this number is greater than lower bound (which is fixed), then continue looking. Stop when your number is smaller than lower bound.  This way, you don't need search all the K lists. Here is the pseudo code:	2014-12-10 11:47:46		
76	tenuw	1		2014-12-10 11:47:46		
77	xhgls	1		2014-12-10 11:47:46		
78	jippy	1	1 4 7 100 200 300 500 2 5 8 125 225 325 525 3 6 9 150 250 350 550  All of u guys, both who r starting from the begining of the list and those who r starting frm the end of the list jst check ur algo. for the above example and comment the correctness of ur algo...!!!	2014-12-10 11:47:46		
79	sgiwy	1	1.Do a k-way merge. Use k pointers to point to the start of each list. 2.Find the min and max elements among these k elements and find the difference as range (min and max are elements of range). If range is less than previous range, update it 3.Move to the next index in the list having the minimum value. Go to step 2	2014-12-10 11:47:46		
80	gilit	1		2014-12-10 11:47:46		
81	krxlv	1		2014-12-10 11:47:46		
82	fowai	1	As it is, this runs in O(n.k) where n is the total number of elements in all lists and k is the number of lists. To make it run in O(n.log k), use a heap to keep M sorted for min value.	2014-12-10 11:47:46		
83	bjsiw	1		2014-12-10 11:47:46		
84	plapd	1		2014-12-10 11:47:46		
85	xhgls	1	The merging and coloring solution is the general correct approach. Here's my implementation in Java, it takes O(n*log(k)) i believe, where n is the total number of elements in all k lists.	2014-12-10 11:47:46		
86	bjsiw	1		2014-12-10 11:47:46		
87	ewigy	1		2014-12-10 11:47:46		
88	nhibd	1	This problem can be solved in O(nlogk)	2014-12-10 11:47:46		
89	wbqzu	1		2014-12-10 11:47:46		
90	sgiwy	1		2014-12-10 11:47:46		
91	bexbp	1	Working solution	2014-12-10 11:47:46		
92	vanul	1		2014-12-10 11:47:46		
93	eucmc	1		2014-12-10 11:47:46		
94	rrmeu	1		2014-12-10 11:47:46		
95	cfzie	1		2014-12-10 11:47:46		
96	fowai	1		2014-12-10 11:47:46		
97	mrjku	1		2014-12-10 11:47:46		
98	vanul	1		2014-12-10 11:47:46		
99	plapd	1		2014-12-10 11:47:46		
100	ftfck	1	Python code	2014-12-10 11:47:46		
101	zeice	1		2014-12-10 11:47:46		
102	rrmeu	1		2014-12-10 11:47:46		
103	gilit	1	output : [20, 24]	2014-12-10 11:47:46		
104	wbqzu	1	Here is my solution written in C#	2014-12-10 11:47:46		
105	ewigy	1		2014-12-10 11:47:46		
106	bexbp	1		2014-12-10 11:47:46		
107	ftfck	1		2014-12-10 11:47:46		
108	tenuw	1		2014-12-10 11:47:46		
109	fmzze	1	My idea is that the range's lower bound is the minimum of the largest element in the k lists, so it is range_lower_bound = min( 26, 20, 30 ) in the example. Then we try to find a set(call it smallest_larger_than_lower_bound_set, ={ 24, 22 } in the example ) of elements, who is the smallest element that is larger than the range_lower_bound in every array, if we find that the array contains range_lower_bound, we emit the array because it means the range will contain at least one element of the array(the range_lower_bound, actually), then range_upper_bound = max( smallest_larger_than_lower_bound_set ). The proof is simple, if lower bound v > range_lower_bound, then array that contains the range_lower_bound as largest element will not have a element in the range, so range_lower_bound is the optimal lower bound; if the upper bound v < range_upper_bound, and obviously v >= range_lower_bound, and the array contains the range_upper_bound will not have a element in the range, because the there're only two kinds of element in the array: elements < range_lower_bound and elements >= range_upper_bound > v, so no elements in the array will occurs in the range. And here is my code in C++, the time complexity is O(kn), where k is the number of lists, and n is the number of elements in the list:	2014-12-10 11:47:46		
110	rrmeu	1		2014-12-10 11:47:46		
111	plapd	1		2014-12-10 11:47:46		
112	ufdxg	1	Just simple O(N) space and O(N) time can work. 1. Merge these array into one in O(N) time, 2. Initial two pointer L,R to cover first K minimum numbers. 4. Calculate the "Range". 3. Delete pointer L's number which belong to X array(we suppose), move R to right until meet a number also belong to X array. 5. repeat 3-4 until R beyond range  It's the idea of "window move". And it's O(N) time.	2014-12-10 11:47:46		
113	sqzqo	1		2014-12-10 11:47:46		
114	rrmeu	1		2014-12-10 11:47:46		
115	rrmeu	1		2014-12-10 11:47:46		
116	ethan	1		2014-12-10 11:47:47		
117	admin	1	Im not sure this is bugfree.... L(i) is the shorted list, then for each element in L(i), find the nearest element in other list, memory this range, then loop for other element in L(i). then according to the memory, find the shortest range	2014-12-10 11:47:47		
118	fmzze	1	My solution: 1) Find the list with the least number of elements. Let's call that list K. 2) Loop through all elements of list K 3) For each element of K[i], find the closest range that can include K[i], using numbers from other lists. 4) Compare all the ranges we found in step 3: best range for K[0], best range for K[1],... . Pick the best range out of them all.  Example List 1: [4, 10, 15, 24, 26] List 2: [0, 9, 12, 20] List 3: [5, 18, 22, 30]  1) List 2 and List 3 both have same number of elems. We can pick List as the seed List. 2) Loop through all elements of List 2 3) For '0': best range that can represent '0' is [0,5] For '9': best range that can represent '9' is [5,10] For '12': best range that can represent '12' is [12,18] For '20': best range that can represent '20' is [20,24]  Out of those 4 ranges, [20,24] is the best	2014-12-10 11:47:47		
119	ufdxg	1	JavaScript Solution:	2014-12-10 11:47:47		
120	azmjc	1		2014-12-10 11:47:47		
121	bexbp	1		2014-12-10 11:47:47		
122	rrmeu	1	For each integer in any list between the biggest small number and the largest number find the nearest number in each list and compute the range. You might of course find multiple solutions.	2014-12-10 11:47:47		
123	cfzie	1	Another js solution, does bruteforce, not optimal but works.	2014-12-10 11:47:47		
124	sqzqo	1		2014-12-10 11:47:47		
125	huiqq	1		2014-12-10 11:47:47		
126	nhibd	1	My solution: 1. Create an Item object for every value containing a min value, max value, and referenced lists 2. For every Item object, compare every list. - If the list is already referenced, return - If the value within the range of min & max, add this list as reference and return - If the value is greater than a temporary max for this item, update temporary max and continue - Update maxValue for item and reference this list, continue 3. For every item, call GetRange() and compare with temporary range, if its smaller, make it new temp  Here's my code in c#:	2014-12-10 11:47:47		
127	mrjku	1		2014-12-10 11:47:47		
128	ftfck	1		2014-12-10 11:47:47		
129	wbqzu	1	My solution in C++, based on aasshishh idea. I use C++ STL priority_queue to maintain the smallest element.	2014-12-10 11:47:47		
130	ethan	1		2014-12-10 11:47:47		
131	krxlv	1		2014-12-10 11:47:47		
132	azmjc	1	assume 3 lists of elements list1:(4,10,16,24,32} list2:{7,8,12,23,51} list3:{20,22,25,41,43}  -choose the max element of each list -max_element={32,51,43} -take the smallest value of max_element and use it as starting range, START=32. -so, eliminate list1 since we have one value from the list as a starting range. -Next, scan through list 1 and list 3 to find the smallest value which is bigger than START. -Example, list 2 is 51, list 3 is 41. so smalVal={51,41} -get the largest Value from smalVal as ending range, END=51  so, the answer will be 32-51.	2014-12-10 11:47:47		
133	azmjc	1	"-Next, scan through list 1 and list 3 to find the smallest value which is bigger than START."  sorry, its suppose to scan list 2 and list3, not list1.	2014-12-10 11:47:47		
134	fowai	1	assume 3 lists of elements list1:(4,10,16,24,32} list2:{7,8,12,23,51} list3:{20,22,25,41,43}  -choose the max element of each list -max_element={32,51,43} -take the smallest value of max_element and use it as starting range, START=32. -so, eliminate list1 since we have one value from the list as a starting range. -Next, scan through list 2 and list 3 to find the smallest value which is bigger than START. -Example, list 2 is 51, list 3 is 41. so smalVal={51,41} -get the largest Value from smalVal as ending range, END=51	2014-12-10 11:47:47		
135	cfzie	1		2014-12-10 11:47:47		
136	ethan	1		2014-12-10 11:47:47		
137	rdfeo	1		2014-12-10 11:47:47		
138	cfzie	1		2014-12-10 11:47:47		
139	dgjji	1		2014-12-10 11:47:47		
140	tenuw	1		2014-12-10 11:47:47		
141	ethan	1	// Worst case complexity O(mno) // But average case is much less	2014-12-10 11:47:47		
142	krxlv	1		2014-12-10 11:47:47		
143	admin	1		2014-12-10 11:47:47		
144	zeice	1	1)Find the minimum of all list's last index List 1: [4, 10, 15, 24, 26] List 2: [0, 9, 12, 20] List 3: [5, 18, 22, 30] which is 20 from List 2, take it as lower range. 2)Binary search in List 1 and List 3, and find its immediate greater value, which is 24 in List 1, and 22 in List 3. 3)Take the maximum of these two values as upper range(Which is 24). 4)Hence [20-24] is the required range.	2014-12-10 11:47:47		
145	sqzqo	1	I've not gone through all the solutions here but, but the ones I have gone through seem to be doing unnecessary things. Here's my solution, feel free to point out the error:  Find the minimum element from the list of last elements in each list. [20,26,30] minimum is 20. You can bet that 20 is the start of that smallest range (Range that we seek).  Now just find out the next element in the all other lists that are bigger than 20. Candidates are [22, 24] Maximum of this [22, 24] is the end of the smallest range.  so answer becomes [22, 24].  This is how you make use of the fact that lists are sorted already	2014-12-10 11:47:47		
146	bjsiw	1	Thank you! I was going crazy as to why this solution wasn't listed here. Running time is O(log n) I guess, where n is the size of the largest list.	2014-12-10 11:47:47		
147	eucmc	1	What happens if the lists are these? List 1: [1, 10, 15, 24, 26] List 2: [0, 9, 12, 18] List 3: [2, 18, 22, 30]  The smallest range should be [0, 2], while your algorithm would return [18, 24] right?	2014-12-10 11:47:47		
148	vanul	1	We do not need to start from the beginning, as suggested here. Instead, start at tails. The smallest of the tails is the lower bound of the range guaranteed. The issue is to find the upper bound. Of course the upper bound cannot be more than the max of all tails.  So start with the max of tails as upper bound. To best this estimation, compare the next smaller number than this tail (in the same list as the max of tails, of course). If this number is greater than lower bound (which is fixed), then continue looking. Stop when your number is smaller than lower bound.  This way, you don't need search all the K lists. Here is the pseudo code:	2014-12-10 11:47:47		
149	krxlv	1		2014-12-10 11:47:47		
150	fowai	1		2014-12-10 11:47:47		
151	dgjji	1	1)Find the minimum of all list's last index List 1: [4, 10, 15, 24, 26] List 2: [0, 9, 12, 20] List 3: [5, 18, 22, 30] which is 20 from List 2, take it as lower range. 2)Binary search in List 1 and List 3, and find its immediate greater value, which is 24 in List 1, and 22 in List 3. 3)Take the maximum of these two values as upper range(Which is 24). 4)Hence [20-24] is the required range. Kindly correct me, if i am wrong.	2014-12-10 11:47:47		
152	rdfeo	1	what if the lists are as following? List 1: [1, 2, 3, 80] List 2: [1, 2, 3, 90, 200] List 2: [1, 2, 3, 99, 300]  In that case, your algorithm chooses [80, 99]. the range is 99-80 = 19. However the answer is [1, 2] where range is 1 ; i.e. 2-1.  that is why your algorithm won't work.	2014-12-10 11:47:47		
153	huiqq	2	This is a recursive version, alternatively it can be done using DP.	2014-12-10 11:47:49		
154	bjsiw	2		2014-12-10 11:47:49		
155	dkebi	2		2014-12-10 11:47:49		
156	sgiwy	2	yeah, dp classical problem. in O(n^2)	2014-12-10 11:47:49		
157	krxlv	2	Check the recurrence within the solution. Formulate it within a 2-D DP structure.	2014-12-10 11:47:49		
158	rrmeu	2	Can you explain the logic ?	2014-12-10 11:47:49		
159	ewigy	2	For player A : he can pick up coin in first place or last place, for each of these case player B can further pick from first or last place from remaining coins. But for A to win/maximize coins, coins collected by B should be minimum while that of A should be maximized.  If A selects coin[i], then B can choose coin[i+1] or coin[array_size]  If A selects coin[array_last], then B can choose coin[i] or coin[array_last-1]  We will simulate such that every function call will start from A's turn. This will give us the given recursive function.	2014-12-10 11:47:49		
160	nhibd	2	Add DP to it by using map (or you can use 2-D array too)	2014-12-10 11:47:49		
161	fmzze	2		2014-12-10 11:47:49		
162	ewigy	2		2014-12-10 11:47:49		
163	nwkeg	2	this solution does not scale. what happens if n is too large? recursion is practically impossible.  this problem is similar to the problem of finding 'perfect' chess strategy. Only that it is a reduced version. At each turn you only have to consider 2 choices, where as in chess it is many.  when n is large, the best you can do is some kind of 'look-ahead' algorithm to make sure by kth move you are not in a worse off position.	2014-12-10 11:47:49		
164	bjsiw	2	i take back my comment. Just read Mihail's solution below and it is ingenious. This game does have a best strategy!  When n is even, it is true who ever moves first can choose the odd-pot series or the even-pot series, so whoever moves first wins.  When n is odd, whoever first is guaranteed to lose unless the first pot can be big enough to offset the difference between odd-pot series and even-pot series!	2014-12-10 11:47:50		
165	xhgls	2	Quick question: most (if not all) of the answers above follow this guideline: "for each move I make, calculate the minimum possible profit of the opponent, and select the move that yields the greatest profit", i.e.:	2014-12-10 11:47:50		
166	dkebi	2		2014-12-10 11:47:50		
167	cfzie	2		2014-12-10 11:47:50		
168	ftfck	2	But shouldn't it be the other way around? "for each possible move I make, calculate the *maximum* possible profit of the opponent, and choose the move that yields minimum losses"? i.e.:	2014-12-10 11:47:50		
169	qywrh	2		2014-12-10 11:47:50		
170	plapd	2		2014-12-10 11:47:50		
171	rrmeu	2	??	2014-12-10 11:47:50		
172	jippy	2	the thing is, you calculate the max profit of the opponent. suppose you take it from the front, your opponent can choose from F(a+2, b), F(a+1, b-1) , and since the opponent plays optimally, he/she would choose max(F(a+2, b), F(a+1, b-1)), which left you min(F(a+2, b), F(a+1, b-1));  same logic, if you choose from the end, your opponent can choose from F(a, b-2), F(a+1,b-1), and he/she would choose max(F(a, b-2), F(a+1,b-1)), which left you min(F(a, b-2), F(a+1,b-1))  so you actually need the max left-over so you max whatever your opponent left to you, which is the first formula above.	2014-12-10 11:47:50		
173	sqzqo	2	F(i, j) = Max { pot[i] + Min { F(i+2, j), F(i+1, j-1) }, pot[j] + Min { F(i, j-2), F(i+1, j-1) } }	2014-12-10 11:47:50		
174	huiqq	2	Say we start with an even number of pots  1 2 3 4 5 6 ... 2*n  Player A can choose the pots in such a way that he has X = 1st + 3rd + + (2n-1)th pots' gold and the player B has Y = 2nd + 4th + ... + (2n)th or vice versa. Since player A can choose whether to end up with X or Y, player A always wins.  In case the number of pots is odd, player B can follow the same strategy right after player A makes first move, so the result depends on the exact amount of gold in the pots, so no 100% winning strategy in this case.	2014-12-10 11:47:50		
175	fowai	2	This is right, but the question asks for _the_ optimal winning solution (i.e. which maximizes the sum assuming best play from both sides). What you have here is _a_ winning position.  Very nice proof though...	2014-12-10 11:47:50		
176	ftfck	2	It may not be the case as the pot can be picked from either end of the line. So 1st , 2nd , 3rd pot is possible as well.	2014-12-10 11:47:50		
177	mrjku	2	It seems the question ask for __a__ winning strategy for player A, and not for __the__ winning position for player A, actually it may happen that player A has no way to win the game if player B plays optimally.	2014-12-10 11:47:50		
178	fmzze	2	@Mihail: If the question was asking for _a_ winning strategy, why even talk about maximizing and optimal solutions?  If it was as you say, this will become a purely mathematical problem, and an AHA question, not suitable for a tech-interview.  On the other hand, trying to maximize/finding optimal will be a good algorithmic problem.	2014-12-10 11:47:50		
179	azmjc	2	This answer does not deserve a downvote.	2014-12-10 11:47:50		
180	krxlv	2	this is nice Mihail!  When n is even, it is true who ever moves first can choose the odd-pot series or the even-pot series, so whoever moves first wins.  When n is odd, whoever first is guaranteed to lose unless the first pot can be big enough to offset the difference between odd-pot series and even-pot series!	2014-12-10 11:47:50		
181	ftfck	2	hugh.hn, if the post is a strategy, it's not a winning one. Consider a four-pot game with the following pots:  6, 3, 1, 4  The first player can indeed choose to receive the first and third pots, but it results in a tie. The player can win, however, by choosing to receive the first and second pots.	2014-12-10 11:47:50		
182	fowai	2		2014-12-10 11:47:50		
183	sqzqo	2		2014-12-10 11:47:50		
184	eucmc	2		2014-12-10 11:47:50		
185	jippy	2		2014-12-10 11:47:50		
186	dgjji	2	IMO in such games it is a norm to assume that number of moves made by both players is the same and no one is at advantage by having extra moves. The fact that you have odd number of pots violates this essential condition. My small thought. Any comments?	2014-12-10 11:47:50		
187	ufdxg	2	Not necessary that A Win... Consider the below example..... in any case A will lose...  Ex 1: 26, 70 ,11 Ex 2: 26,25,78,12,17  BR, Asheesh Goyal	2014-12-10 11:47:50		
188	nwkeg	2	IMO in such games it is a norm to assume that number of moves made by both players is the same and no one is at advantage by having extra moves. The fact that you have odd number of pots violates this essential condition. My small thought. Any comments?	2014-12-10 11:47:50		
189	nwkeg	2	we should assume A and B both want to win. In example (26, 1, 70 ,11) there is no way an 'A' can win. For 'A' to win B has to choose (11,1) or (26,1). But given problem statement that B also wants to win, he will definitely select (1,70). There is no way 'A' can restrict 'B' from selecting '1,70'.	2014-12-10 11:47:50		
190	qywrh	2	@sagar: In the case of (26, 1, 70, 11), A can win as follows:  1. A selects 26 2. Now B has to select either 1 or 11 from (1, 70, 11). 3. B selects either 11 or 1. 4. A selects 70. 5. B gets the other one.  So A can make a decision which forces B to not be able to choose 70. I think you probably read the question wrong.	2014-12-10 11:47:50		
191	dgjji	2	Guys I need bit more explanation here. As per the given question, player's don't have any benefit or restriction. I mean, how can a player A choose ?? as it is certain he must have to pick a pot and that too present in a certain position.. Is there any option for him to skip a pot if he did not wish to collect it ?? How can the decision is been generated ? without that the game is straight forward and is totally depends upon arrangement of pots rather than player	2014-12-10 11:47:50		
192	jippy	2	If they allowed players to "pass" on a turn, an algorithm could be written such that the game would never end.	2014-12-10 11:47:50		
193	fmzze	2		2014-12-10 11:47:50		
194	admin	2		2014-12-10 11:47:50		
195	admin	2	A - input array. S(x,y) - sum of element from x to y. We can get it for O(1) with O(n) preproccesing using 2 array. Of course, with solution with Max of two Min of two F(...) is a bit faster (no need to calculate sum), but as for me - this is simple to understand.  F(x, x) := A[x] F(x, y) := Max( A[x] + S(x+1, y) - F(x+1, y), A[y] + S(x, y-1) - F(x, y-1) )  We get first or last: A[x] or A[y] Then see how many can get opponent in new array: F(x+1, y) or F(x, y-1) Because of constant amount of points: S(x+1, y) - F(x+1, y) or S(x, y-1) - F(x, y-1)	2014-12-10 11:47:50		
196	jippy	2	Obviously, this is reqursion/dynamic problem. So we need formula.  Let's say, that F(i, j) - is max possible coins that 'first' player can collect on board with packets from i to j. And by 'first' player I mean player whos turn now. F(0, n-1) - will be the answer.  Ok, now for F(i, j), first player can take v[i] or v[j].	2014-12-10 11:47:50		
197	sgiwy	2		2014-12-10 11:47:50		
198	gilit	2		2014-12-10 11:47:50		
199	rrmeu	2	And he will collent x or y coints. Of course he will choose the maximum option:	2014-12-10 11:47:50		
200	ufdxg	2		2014-12-10 11:47:50		
201	rdfeo	2		2014-12-10 11:47:50		
202	ethan	2	Why (Sum[i+1, j ] - F(i+1, j ) )? Thats simply. After the first player took the coins, the turn passes to the second. And he also wnat to win. And now he is the first player but on the board (i+1, j) or (i, j-1). The Sum is fixed, so all that he will not take - is our coins. _________________________________________________ But do we really need to calculate Sum? No! Lets go deeper! in recursion : ) I skip here computing. In two words: If we 'open' F(i+1, j ) and F( i, j-1) - sum will be reduced and using that	2014-12-10 11:47:50		
203	sgiwy	2		2014-12-10 11:47:50		
204	bexbp	2		2014-12-10 11:47:50		
205	admin	2	and we will get:	2014-12-10 11:47:50		
206	jippy	2		2014-12-10 11:47:50		
207	huiqq	2		2014-12-10 11:47:50		
208	bjsiw	2	On each iteration size of board will be reduced on 2. _________________________________________________ To avoid re-computation, we need to store all done computation:	2014-12-10 11:47:50		
209	sgiwy	2		2014-12-10 11:47:50		
210	azmjc	2		2014-12-10 11:47:50		
211	dkebi	2	ArrayInfo can be simply int[n][n]. if you don't care about the amount of memory used. But we'll get to that later.  First, we need to initialize the smallest boards answers. There are two different situation. If N is odd, then F(i, j) = F(i, i) = v[i]	2014-12-10 11:47:50		
212	ethan	2		2014-12-10 11:47:50		
213	vanul	2		2014-12-10 11:47:50		
214	rdfeo	2	If N is even, then F(i, j) = F(i, i+1) = MAX(v[i], v[i+1])	2014-12-10 11:47:50		
215	nhibd	2		2014-12-10 11:47:50		
216	ufdxg	2		2014-12-10 11:47:50		
217	rrmeu	2	And now, we increasing the size of the board for 2 and calculate answers for all possible boards:	2014-12-10 11:47:50		
218	fowai	2		2014-12-10 11:47:50		
219	bjsiw	2		2014-12-10 11:47:50		
220	zeice	2	_________________________________________________ Returning to the ArrayInfo. There is only 1 sub-board starting fron i=n-1. (n-1, n-1) There are only 2 sub-board starting fron i=n-2. (n-2, n-2) and (n-2, n-1) ... Additionaly, we have only odd or only even lenght sub-boards, because we reduce it on 2 each time. So we don't need N*N space. We can impliment ArrayInfo such way:	2014-12-10 11:47:50		
221	bjsiw	2		2014-12-10 11:47:50		
222	cfzie	2		2014-12-10 11:47:50		
223	gilit	2	And it will used	2014-12-10 11:47:50		
224	rdfeo	2		2014-12-10 11:47:50		
225	nwkeg	2		2014-12-10 11:47:50		
226	krxlv	2	that's in 4 time less.  working code: http://ideone.com/ZzbMRt	2014-12-10 11:47:50		
227	dkebi	2	HERE ARE A SIMULATION:	2014-12-10 11:47:50		
228	fmzze	2		2014-12-10 11:47:50		
229	krxlv	2		2014-12-10 11:47:50		
230	rdfeo	2	mafafito@mafafito-Aspire-4752:~/programming$ java Amazon  100 , 1 , 20 , 30 , 40 , 10 , 20 , 30 , 90 , Taking the first one: A WINS PLAYER A 100 + 30 + 10 + 30 + 1 + = 171 PLAYER B 90 + 20 + 40 + 20 + = 170 Taking the Last one: B WINS PLAYER A 90 + 30 + 10 + 30 + 1 + = 161 PLAYER B 90 + 20 + 40 + 20 + 100 + 20 + 40 + 20 + = 350 Recursive call result: : 171	2014-12-10 11:47:50		
231	tenuw	2	Upvoting yourself doesn't work axeliux	2014-12-10 11:47:50		
232	tenuw	2	why it doesnt work?	2014-12-10 11:47:50		
233	nwkeg	2	Oh. you are not taking about my code.  about the upvoting thing, of course I know it does not work. ( or at least it shouldn't work) But I wonder, how do you know that I did try anyway?	2014-12-10 11:47:50		
234	krxlv	2	we are all in love with ourselves that's what careercup is for broken egos finding a playground to repair egos	2014-12-10 11:47:50		
235	bexbp	2	you havent break my ego anyway. But lets go back to bussiness:  What do you think about my program?  What about print the wining path inside the recursive call, do you think It could be interesting?	2014-12-10 11:47:50		
236	fmzze	2	This is a wrong question: 1, 3, 1. A cannot win. B wins.	2014-12-10 11:47:50		
237	admin	2	Implemented a solution using the minimax algorithm in C++ on github: github.com/benmurrell/PotsOfGold	2014-12-10 11:47:50		
238	sqzqo	2	Here is a java program that solves this question and has a simulation of the moves (prints out players moves and coin sums along with remaining gold pots)  The main answer to this question is in the maxCoins function at the bottom. It's a little bit cluttered because I'm returning a MaxCoinResults object instead of just an int (has additional info stored in it such as the choice that was made (start or end).  I'm doing a recursive function and caching results (so DP). Similar to a lot of other suggested answers:	2014-12-10 11:47:50		
239	sgiwy	2		2014-12-10 11:47:50		
240	vanul	2		2014-12-10 11:47:51		
241	eucmc	2	Here is some sample output: SIMULATION -- 2 -- --------------------------- Initial Coins:5,5,10,5,9,9,3,9,5,1 Expected A Winnings:33 Player A chooses the first coin with a value of:5 Player A now has a sum of 5 RemainingCoins:5,10,5,9,9,3,9,5,1 Player B chooses the last coin with a value of:1 Player B now has a sum of 1 RemainingCoins:5,10,5,9,9,3,9,5 Player A chooses the first coin with a value of:5 Player A now has a sum of 10 RemainingCoins:10,5,9,9,3,9,5 Player B chooses the first coin with a value of:10 Player B now has a sum of 11 RemainingCoins:5,9,9,3,9,5 Player A chooses the first coin with a value of:5 Player A now has a sum of 15 RemainingCoins:9,9,3,9,5 Player B chooses the last coin with a value of:5 Player B now has a sum of 16 RemainingCoins:9,9,3,9 Player A chooses the last coin with a value of:9 Player A now has a sum of 24 RemainingCoins:9,9,3 Player B chooses the last coin with a value of:3 Player B now has a sum of 19 RemainingCoins:9,9 Player A chooses the last coin with a value of:9 Player A now has a sum of 33 RemainingCoins:9 Player B chooses the last coin with a value of:9 Player B now has a sum of 28 RemainingCoins: Final Results ------------- Player A:33 Player B:28 END GAME.	2014-12-10 11:47:51		
242	gilit	2	Many people A always win, this is not the case. It depends on the randomness of the gold distribution, we can only maximize. Here is a test run with 100 pots each time, and run 10000 times. B consistently wins around 35% of the time, I did 10 different runs, so that's 100,000 times.  The actual % depends many variables, including, number of integers, and the random range of each integer.  Here is a prove: 1 3 1, A loses no matter what.  Here is the full code you can run it yourself, have fun.	2014-12-10 11:47:51		
243	sqzqo	2		2014-12-10 11:47:51		
244	zeice	2		2014-12-10 11:47:51		
245	tenuw	2	Your optimalPick function is not actually always optimal. For example consider: 5,7,20,24,6,3 According to your optimal pick function 5 - max (7, 3) = -2 3 - max (6, 5) = -3  So A would choose the pot with 5 coins. Then according to your algorithm, B would choose 3 next. Because: (7 - 20 )= -13 < (3 - 6) = -3 But if you think for a second it would be a better move for B to choose the pot with 7 coins (because if A chooses the pot with 20 coins on B's next turn, then B can then take the pot with 24 coins).  So if A chose 5 at the beginning, and B chose 7, depending on what A did on their next turn this game would end up: A = 5 + 3 + 24 = 32 OR 5 + 20 + 6 = 31 B = 7 + 20 + 6 = 33 OR 7 + 24 + 3 = 34  As you can see B won in both instances.  It actually would have been optimal for A to choose the pot with 3 coins in the beginning. With both players playing optimally the results would have been: A = 3 + 24 + 7 = 34 B = 6 + 5 + 20 = 31  This is an example of why you need to recurse deeper to get the optimal solution rather than just peak at the next move.  You are right however, that with an odd number of pots B has a chance of winning depending on how the coins are set up.  But if there are an even # of coins I believe A has an optimal strategy that will help him/her to win or tie every time.	2014-12-10 11:47:51		
246	sgiwy	2		2014-12-10 11:47:51		
247	ufdxg	2		2014-12-10 11:47:51		
248	zeice	2	Output for 1k pots : 7726 brute took 454 7711 algo took 0  N.B. The fast algo is pretty damn close and very fast but it's not accurate. Times are in milliseconds.	2014-12-10 11:47:51		
249	tenuw	2	If you need the values as well {{ def mc(l): if len(l) <= 2: return sorted(l, reverse=True) v1 = mc(l[1:]) v2 = mc(l[:-1]) if (l[0] + sum(v1[i] for i in range(1, len(v1), 2))) > \ (l[-1] + sum(v2[i] for i in range(1, len(v2), 2))): return [l[0]] + v1 else: return [l[-1]] + v2  def wsa(l): v = mc(l) return [v[i] for i in range(len(v)) if i % 2 == 0]  print wsa([13, 25, 20, 12, 3]) }}	2014-12-10 11:47:51		
250	zeice	2	- If number of pots of gold is odd: There's no optimal strategy that makes A win knowing that B is playing optimally as well. (Ex: [1,3,1]);  - Else: Player A must always pick the pot which produces the larger result for the equation (Number - Immediate Neighbor).  Ex: pots = [1,1,10,15,1,2]  A: picks pot[5] (2-1 > 1-1); B: picks pot[0] (1-1 > 1-15); So on...	2014-12-10 11:47:51		
251	dkebi	2	DP implementation in C lang. for recursive algo. stated by Cerberuz ===================================================	2014-12-10 11:47:51		
252	cfzie	2		2014-12-10 11:47:51		
253	rrmeu	2		2014-12-10 11:47:51		
254	rdfeo	2	I hope the code is self explanatory in the meaning.	2014-12-10 11:47:51		
255	sgiwy	2	max_coin_R() method is a recursive method:	2014-12-10 11:47:51		
256	ufdxg	2		2014-12-10 11:47:51		
257	rrmeu	2		2014-12-10 11:47:51		
258	huiqq	2	dp:	2014-12-10 11:47:51		
259	dgjji	2		2014-12-10 11:47:51		
260	krxlv	2		2014-12-10 11:47:51		
261	xhgls	2	Python Recursive algorithm with Caching.	2014-12-10 11:47:51		
262	sgiwy	2		2014-12-10 11:47:51		
263	vanul	2		2014-12-10 11:47:51		
264	bjsiw	2		2014-12-10 11:47:51		
265	zeice	2		2014-12-10 11:47:51		
266	dkebi	2		2014-12-10 11:47:51		
267	qywrh	2		2014-12-10 11:47:51		
268	fmzze	2	given {12,60,28,4} and the condition that A picks first, the algorithm mentioned in the first comment makes A lose. but A can win if it picks 4 and then 60. clarify this for me please	2014-12-10 11:47:51		
269	qywrh	2	I believe that this does the trick... simple recursion using golang, could be optimized to suit various requirements...	2014-12-10 11:47:51		
270	nwkeg	2		2014-12-10 11:47:51		
271	nwkeg	2		2014-12-10 11:47:51		
272	krxlv	2		2014-12-10 11:47:51		
273	jippy	2		2014-12-10 11:47:51		
274	bexbp	2	Please check if this is correct. Thanks! :D	2014-12-10 11:47:51		
275	sgiwy	2	ALGO:Take the best of left and right of the line.This should be done by A as he gets to choose first and B will choose what is left of the line after A has picked.	2014-12-10 11:47:51		
276	huiqq	2		2014-12-10 11:47:51		
277	gilit	2		2014-12-10 11:47:51		
278	jippy	2	TODO:Add memoization.	2014-12-10 11:47:51		
279	rrmeu	2	If the input is {1, 10, 1000, 10}, then the optimal strategy is to pick the 1. Picking the best of left and right doesn't work.	2014-12-10 11:47:51		
280	mrjku	2	google search for minimax algorithm. That's the answer to this problem. Given all the information, one can say that person who plays first will ALWAYS win...	2014-12-10 11:47:51		
281	gilit	2	Consider the pot's structure  1 3 1  Player A ends up with 2, and player B with 3 no matter how player A performs.	2014-12-10 11:47:51		
282	wbqzu	2	I was wondering why non one mentioned minimax? Not everything HAS to be solved by DP!	2014-12-10 11:47:51		
283	sgiwy	2		2014-12-10 11:47:51		
284	azmjc	2	I added some more comments to the question, however it was pretty much just that :-(	2014-12-10 11:47:51		
285	nhibd	2	It may not be the case as the pot can be picked from either end of the line. So 1st , 2nd , 3rd pot is possible as well.	2014-12-10 11:47:51		
286	ewigy	3	The question asks if we can transform the given string S into its reverse deleting at most K letters. We could modify the traditional Edit-Distance algorithm, considering only deletions, and check if this edit distance is <= K. There is a problem though. S can have length = 20,000 and the Edit-Distance algorithm takes O(N^2). Which is too slow.  (From here on, I'll assume you're familiar with the Edit-Distance algorithm and its DP matrix)  However, we can take advantage of K. We are only interested *if* manage to delete K letters. This means that any position more than K positions away from the main diagonal is useless because its edit distance must exceed those K deletions.  Since we are comparing the string with its reverse, we will do at most K deletions and K insertions (to make them equal). Thus, we need to check if the ModifiedEditDistance is <= 2*K Here's the code:	2014-12-10 11:47:52		
287	krxlv	3		2014-12-10 11:47:52		
288	qywrh	3		2014-12-10 11:47:52		
289	dgjji	3	We only process 2*K+1 columns per row. So this algorithm works in O(N*K) which is fast enough.	2014-12-10 11:47:52		
290	krxlv	3	Killer thinking, +1. Fresh out of college? Just kidding... :-)	2014-12-10 11:47:52		
291	rrmeu	3	sort of, but I love these kind of questions/problems :)	2014-12-10 11:47:52		
292	admin	3	It says by "removing at most k characters", not inserting, which makes it simpler.	2014-12-10 11:47:52		
293	wbqzu	3	ce we are comparing the string with its reverse, we will do at most K deletions and K insertions (to make them equal).  why insertions ??	2014-12-10 11:47:53		
294	ethan	3	Like I said in the post, we're making the string and its reverse equal. They have both N characters so if we remove K characters, we need to insert K as well to get to size N.	2014-12-10 11:47:53		
295	eucmc	3	Clever aproach, but I don't think it works. FIrst, there should be a correspondece between the characters inserted and deleted, which you are not controlling. Second, You can do (1 insertion + 1 deletion)*n times, and you will still be in the main diagonal	2014-12-10 11:47:53		
296	sgiwy	3	The correspondence between characters inserted and deleted is done because we're transforming the input string into its reverse. So those operations will lead to a palindrome.  "You can do (1 insertion + 1 deletion)*n times, and you will still be in the main diagonal" Sure, but the cost will be 2*N. As explained above, the final step is to compare DP[N][N] with 2*K. only then we decide the answer.	2014-12-10 11:47:53		
297	dgjji	3	I'm not sure this works.  Edit distance between 'abax' and 'xaba' is 2. However, to edit 'abax' to be a palindrome, we need just 1 delete.	2014-12-10 11:47:53		
298	bexbp	3	My bad. Please ignore my earlier comment.  I missed the '<= 2*K ' part.	2014-12-10 11:47:53		
299	qywrh	3	@Keith, that was explained before. The code answers 2 because it is transforming the string into its reverse. If we need 1 delete in the original string, we need another delete in the reversed string to make them equal. That's why we compare it with 2*K	2014-12-10 11:47:53		
300	jippy	3	@- Miguel Oliveira why not we just run it only till half of the string and save the rest half of the problem i dont have the complete code but if we are able to match the 1st half and 2nd half we dont need to do the vice-versa operation  btw nice solution indeed	2014-12-10 11:47:53		
301	wbqzu	3	memset the entire dp array takes O(N^2), so your implementation is actually O(N^2).	2014-12-10 11:47:53		
302	nwkeg	3	Eric, a N^2 table also wouldn't fit in memory. Refer to the comment in the code  // for simplicity. we should use only a window of size 2*k+1 or // dp[2][MAX] and alternate rows. only need row i-1	2014-12-10 11:47:53		
303	vanul	3	Also, I think the correct outcome for your second case should be 'Yes'(delete x).	2014-12-10 11:47:53		
304	nhibd	3	OOops, ignore the previous comment. It is correct.	2014-12-10 11:47:53		
305	rdfeo	3	in edit distance algorithm we are changing only one of the string and Why are you trying to keep the length constant here...insertions are not allowed at all....please clarify	2014-12-10 11:47:53		
306	qywrh	3	It doesnt work for ModifiedEditDistance("abc", "cba", 1).  Here the edit distance would be 2 (which is <=2*1), but wont form a palindrome for k=1 deletions.	2014-12-10 11:47:53		
307	dgjji	3	This is not a normal edit distance. I do not allow substitutions. If you run the code, you'll see that ModifiedEditDistance("abc", "cba", 1) returns 4 which is larger than 2*K	2014-12-10 11:47:53		
308	tenuw	3	Nice idea but it actually is different from the classical edit distance problem where the first string is transformed into the second. Here we need to perform adjustments on both strings but it works because the cost is the same for delete and add. Otherwise the algorithm should be slightly modified.	2014-12-10 11:47:53		
309	vanul	3	Shouldn't the following:	2014-12-10 11:47:53		
310	dgjji	3		2014-12-10 11:47:53		
311	tenuw	3		2014-12-10 11:47:53		
312	krxlv	3	be:  if (a[i] == b[j]) // same character dp[i][j] = dp[i-1][j-1];	2014-12-10 11:47:53		
313	sgiwy	3	No. Notice than both i and j are 1-indexed (1..n) due to the DP table. Hence the -1 to get the correct characters.	2014-12-10 11:47:53		
314	qywrh	3	I made a recursive algorithm	2014-12-10 11:47:53		
315	dgjji	3		2014-12-10 11:47:53		
316	rrmeu	3		2014-12-10 11:47:53		
317	plapd	3	I made a similar one in java, but I'm not sure if it works... If it doesn't, could you let me know why?	2014-12-10 11:47:53		
318	qywrh	3		2014-12-10 11:47:53		
319	azmjc	3		2014-12-10 11:47:53		
320	rdfeo	3	There are two approaches you may apply. The first one is to reverse the input string and find the LCS of the input string, and it's reversal. This gives you the lenght of the longest palindrom. Now you substract the LCS value from the lenght of the string and you get the k - so just check if it matches.  The second approach just looks for a palindrom. Let's say p[n] is a palindrom with lenght n. Let l will be begining, end e the end of a palindrom. Then we can see that: 1) p[l] == p[h], then we need to check p[l+1] == p[h - 1], i.e abcba, where p[l] == a == p[h] 2a) p[l] != p[h], then we need to check p[l+1],p[h] (we removed p[l]) 2b) p[l] != p[h], then we need to check p[l], p[h-1], (we removed p[h])  Now simply use this in your dynamic programming aproach. If you have a problem with that, I am more than glad to help you more.  As I was bored, I typed the code for the second solution:)	2014-12-10 11:47:53		
321	dkebi	3		2014-12-10 11:47:53		
322	mrjku	3		2014-12-10 11:47:53		
323	bexbp	3	This roughly equals to choose 30 from 20000, takes way toooooooo much time!	2014-12-10 11:47:53		
324	sgiwy	3	Does not work. LCS of reverse and and string need not be largest palindrome.	2014-12-10 11:47:53		
325	fowai	3	I think the LCS method works. Annonymous, can you give a counter-example?	2014-12-10 11:47:53		
326	qywrh	3	The problem is that LCS works in O(N^2) so it will be too slow with those limits. There should be another solution taking advantage of k.	2014-12-10 11:47:53		
327	nhibd	3	@Miguel. Try proving that it works.	2014-12-10 11:47:53		
328	vanul	3	(A web search should reveal a counter-example, though)	2014-12-10 11:47:53		
329	ethan	3	right, it's not necessarily a palindrome. there are ways to make a LCS based approach work though (just found on the web but can't link it here due to this site restrictions).  anyway, i've given an efficient solution to this problem based on edit-distance	2014-12-10 11:47:53		
330	nwkeg	3	I think that the LCS approach should work fine. The longest subset in this case would be a base of a palindrom, as we are comparing the same set, just in a different order. Please give a real counter example.	2014-12-10 11:47:53		
331	rrmeu	3	@joe_kidd: does this work for {"malayalxam"} with k=1?	2014-12-10 11:47:53		
332	nhibd	3	It looks like. The reversal is maxlayalam, so the longest common subsequence is: malayalam, the lenght difference 1, so it works.	2014-12-10 11:47:53		
333	ufdxg	3	@joe for the purpose of this problem, the simple LCS approach works. It would not work if we wanted to find out the palindromic string instead of just its length. Check the page wcipeg . com / Longest_palindromic_subsequence The longest palindromic subsequence is one of the LCSes but it's not guaranteed that every LCS is palindrome. "afala" and "alafa" are LCSes of "alfalfa" and its reverse, yet neither is palindromic.	2014-12-10 11:47:53		
334	azmjc	3	Thanks, the page seems to be very cool not only for this particular case.	2014-12-10 11:47:53		
335	ethan	3	@joe_kidd : I thought of the same solution as yours before I looked at posted solutions ! I am glad that you also came up that. Well, what do you think is complexity of the algorithm? I think it's O(n). Is that right?	2014-12-10 11:47:53		
336	eucmc	3	@Parin, it's O(N^2) which is too slow	2014-12-10 11:47:53		
337	sgiwy	3	I think this question can be solve by following idea. I define the function like this : bool isKPalindrom(string s, int start, int end, int k)  The input is string s , its begin position, its end position and k.  If s[start:end] is palindrome then return true else if k < 0 return false else if s[start] == s[end-1] then recursively call isKPalindrome(s,start+1,end-1,k) else return isKPalindrome(s,start+1,end,k-1 ) || isKPalindrome(s,start,end-1,k-1)  We can also use a array to record the result of whether s[start,end] is palindrome  The time complxity is (n^2)	2014-12-10 11:47:53		
338	eucmc	3	I would use recursion to solve this problem:	2014-12-10 11:47:53		
339	bjsiw	3		2014-12-10 11:47:53		
340	nhibd	3		2014-12-10 11:47:53		
341	huiqq	3	Given that array.subArray() is O(1). This also runs in O(n) doesn't it?	2014-12-10 11:47:53		
342	ewigy	3	subArray does not run in O(1) but O(N). anyway this recursive approach runs in exponential time	2014-12-10 11:47:53		
343	cfzie	3	@joe_kidd : I thought of the same solution as yours before I looked at posted solutions ! I am glad that you also came up that. Well, what do you think is complexity of the algorithm? I think it's O(n). Is that right?	2014-12-10 11:47:53		
344	jippy	3	@joe_kidd : I thought of the same solution as yours before I looked at posted solutions ! I am glad that you also came up that. Well, what do you think is complexity of the algorithm? I think it's O(n). Is that right?	2014-12-10 11:47:53		
345	rrmeu	3	This is a recursive approach, and works for all possible cases.  This is a back tract approach. Maximum matches can be n (n is the size of input array) and minimum matches can be n-k.	2014-12-10 11:47:53		
346	bexbp	3		2014-12-10 11:47:53		
347	wbqzu	3		2014-12-10 11:47:53		
348	wbqzu	3	Python code:  def isPalindrome(String): stringSize = len(String) start = 0 end = stringSize - 1 while start < end and String[start] == String[end]: start += 1 end -= 1 if start < end: return False else: return True  def isKPalindrome(String, k): if k > 0: for i in range(len(String)): subString = String[:i] + String[i+1:] if isKPalindrome(subString, k-1) == True: return True return False elif k == 0: return isPalindrome(String) else: print 'Error number k' return False   Testing Set: print isPalindrome('1') print isPalindrome('11') print isPalindrome('11111') print isPalindrome('11211') print isPalindrome('13231') print isPalindrome('1221') print isPalindrome('133121331')  print isPalindrome('11221') print isPalindrome('13211') print isPalindrome('23') print isPalindrome('123')  print isKPalindrome('abxa', 1) print isKPalindrome('abxa', 2) print isKPalindrome('abdxa', 2) print isKPalindrome('abdxa', 1)	2014-12-10 11:47:53		
349	ufdxg	3	How could I indent?	2014-12-10 11:47:53		
350	dkebi	3		2014-12-10 11:47:53		
351	vanul	3		2014-12-10 11:47:53		
352	cfzie	3	Correction to previous python solution:	2014-12-10 11:47:53		
353	zeice	3		2014-12-10 11:47:53		
354	rdfeo	3		2014-12-10 11:47:53		
355	bexbp	3	#include<stdio.h> #include<conio.h> int main() { int k,i=0,j,flag=1,count=0; char a[20]; printf("ENTER THE VALUE OF K"); scanf("%d",&k); printf("ENTER THE STRING"); scanf("%s",a); j=strlen(a); j=j-1; while(i<j) { if(a[i]!=a[j]) { if(a[i+1]==a[j]) { count++; } else if(a[i]==a[j-1]) { count++; } else { flag=0; break; } } if(count>k) { flag=0; break; } i++; j--;  } if(flag==0) printf("NO"); else printf("YES"); getch(); }	2014-12-10 11:47:53		
356	admin	3		2014-12-10 11:47:53		
357	eucmc	3		2014-12-10 11:47:53		
358	wbqzu	3	I think this piece of code should work and pretty much self descriptive. I'm still questioning what would be the complexity it's definitely O(n^2), but I think there is better estimation and should be lower, many branches will be cut by checking if k < 0 condition.  Does anybody have an idea?	2014-12-10 11:47:53		
359	rrmeu	3		2014-12-10 11:47:53		
360	gilit	3		2014-12-10 11:47:53		
361	eucmc	3	@maks - this does not work	2014-12-10 11:47:54		
362	azmjc	3	What about this one?  def palin_k(str, k): if k == 0 or str == str[::-1]: return str == str[::-1] l_index = 0 r_index = len(str) - 1 while str[l_index] == str[r_index]: l_index = l_index + 1 r_index = r_index - 1 return palin_k(str[l_index:r_index], k-1) or palin_k(str[l_index+1:r_index+1], k-1)	2014-12-10 11:47:54		
363	sqzqo	3	you can do something like that :	2014-12-10 11:47:54		
364	zeice	3		2014-12-10 11:47:54		
365	zeice	3		2014-12-10 11:47:54		
366	bjsiw	3	and call the function with : palindromeK(word, k, 0, word.length()-1, (char) 0);  Basically you successively look at the beginning / the end of your word, and you remove a character when you know you can't using it to make a palindrome. The cost if O(n2)	2014-12-10 11:47:54		
367	plapd	3		2014-12-10 11:47:54		
368	eucmc	3		2014-12-10 11:47:54		
369	dkebi	3	This is in javascript, I measure the distance of the palindrome of the string and divide it by 2, since it each extra character will appear twice	2014-12-10 11:47:54		
370	tenuw	3		2014-12-10 11:47:54		
371	zeice	3		2014-12-10 11:47:54		
372	mrjku	3	@miguel - great solution! i used the dp / edit distance approach like you suggested and i think it works.. not sure if i did it exactly like you said... but same general idea..	2014-12-10 11:47:54		
373	fmzze	3		2014-12-10 11:47:54		
374	eucmc	3		2014-12-10 11:47:54		
375	mrjku	3	never mind. i found a bug in my above code. it does not work for this input isKPalindrome("sbandanarb", 5)	2014-12-10 11:47:54		
376	vanul	3		2014-12-10 11:47:54		
377	ftfck	3		2014-12-10 11:47:54		
378	rrmeu	3	Hmm that's pure backtracking. Dynamic programming implies that you're saving subproblems results somewhere (like a table) and reusing them later.	2014-12-10 11:47:54		
379	cfzie	3	I agreed! :) Modified comments accordingly.	2014-12-10 11:47:54		
380	sgiwy	3		2014-12-10 11:47:54		
381	huiqq	3		2014-12-10 11:47:54		
382	qywrh	3	LCS should work, the worst case is O(N^2) when there is no match. But we would be able to return early when this is match with K.	2014-12-10 11:47:54		
383	bexbp	3		2014-12-10 11:47:54		
384	rdfeo	3		2014-12-10 11:47:54		
385	plapd	3	There is another DP solution: Firstly I will present a simple quadratic solution dp[l][r] - state where we hold minimum number of removes in order to transform the segnment s[l]...s[r] into palindrome. Transitions will be as follows: if(s[l] == s[r]) dp[l][r] = min(dp[l][r], dp[l + 1][r - 1]); else dp[[l][r] = min(dp[l][r], min(dp[l + 1][r], dp[l][r - 1]) + 1); But the problem is in that it works too slowly, therefore we can convert our solution by the following way: dp[l][k] - will hold the rightmost position in S where we can reach removing exactly k characters and starting from l; if(S[dp[l + 1][k]] == s[l]) dp[l][k] = max(dp[l][k], dp[l + 1][k] + 1); else dp[l][k] = max(dp[l][k], dp[l + 1][k - 1] + 1); The implementation demands to go through from right to left; At the end it is enough just to look at states dp[0][i], where 0<=i <= k; if(dp[0][i] == s.length()) then "yes" else "no";	2014-12-10 11:47:54		
386	gilit	3	Solution in java-  Take an array R of size 26.  Loop through each character of the string and increment the index of R for that character.  If a string is palindrome then the count of each character in R %2 will give 0 and if string length is odd then except one character rest of character's count %2 will be 0.  Now, if you want to calculate k-palindrom add the k to the comparison as shown below.	2014-12-10 11:47:54		
387	sgiwy	3		2014-12-10 11:47:54		
388	vanul	3		2014-12-10 11:47:54		
389	xhgls	3		2014-12-10 11:47:54		
390	dkebi	3		2014-12-10 11:47:54		
391	sgiwy	3	Quick explanation:  Start at the borders and collapse, if borders are equal, then continue with the rest of the string, otherwise, check if you can take one border out so that you can still form a valid palindrome with the other border, if not, take out both borders.  O(n) since you only traverse the string once.	2014-12-10 11:47:54		
392	sqzqo	3	find the longest palindromic subsequence. get its difference with length of string , say diff. if diff <= k , then its a k-pali string.	2014-12-10 11:47:54		
393	gilit	3	Below are my solutions in C++. The first one is a recursive function which gives a good idea of how to tackle the problem. This solution has a huge complexity (something like O(L * 2^K) though I cannot prove an exact formula - L is the length of the string).  The second one is a solution which uses a matrix of size 2*L*K^2 and which fills it step by step (a change of indices is used to avoid building a L * L * K matrix). This solution has O(L*K^2) complexity which is quite acceptable with the given parameters.	2014-12-10 11:47:54		
394	rrmeu	3		2014-12-10 11:47:54		
395	plapd	3		2014-12-10 11:47:54		
396	bexbp	3	Line 6 is	2014-12-10 11:47:54		
397	rrmeu	3		2014-12-10 11:47:54		
398	dkebi	3		2014-12-10 11:47:54		
399	ftfck	3	actually.	2014-12-10 11:47:54		
400	dgjji	3	Couldn't help adding a Scala solution. I believe that this runs in O(n/2 + 2*K)	2014-12-10 11:47:54		
401	dgjji	3		2014-12-10 11:47:54		
402	dkebi	3		2014-12-10 11:47:54		
403	huiqq	3	To prep:	2014-12-10 11:47:54		
404	ethan	3		2014-12-10 11:47:54		
405	ftfck	3		2014-12-10 11:47:54		
406	sgiwy	3	Runs:	2014-12-10 11:47:54		
407	xhgls	3		2014-12-10 11:47:54		
408	rdfeo	3		2014-12-10 11:47:54		
409	bjsiw	3	Couldn't help adding a Scala solution. I believe that this runs in O(n/2 + 2*K)	2014-12-10 11:47:54		
410	bexbp	3		2014-12-10 11:47:54		
411	vanul	3		2014-12-10 11:47:54		
412	xhgls	3	To prep:	2014-12-10 11:47:54		
413	dkebi	3		2014-12-10 11:47:54		
414	admin	3		2014-12-10 11:47:54		
415	ftfck	3	Runs:	2014-12-10 11:47:54		
416	eucmc	3		2014-12-10 11:47:54		
417	jippy	3		2014-12-10 11:47:54		
418	qywrh	3	Here is a naive solution in python, the time complexity is not acceptable for the input bounds but it may help you if you are stuck before moving to a faster solution posted above.  {{def isPalindrome(str): if (str == str[::-1]): return True else: return False  def isKPalindrome(str, k): if (len(str) <= 1 or k < 0): return False elif(isPalindrome(str)): return True  for i in range(len(str)): smallerStr = str[:i] + str[i+1:] if (isKPalindrome(smallerStr, k-1)): return True return False  print isKPalindrome("aaybbaxa", 2) print isKPalindrome("aaybbaxa", 1)}}	2014-12-10 11:47:54		
419	ewigy	3	Here is a naive solution in python, the time complexity is not acceptable for the input bounds but it may help you if you are stuck before moving to a faster solution posted above.	2014-12-10 11:47:54		
420	eucmc	3		2014-12-10 11:47:54		
421	admin	3		2014-12-10 11:47:54		
422	huiqq	3	Here's a recursive solution in Objective-C, with a complexity of `O(n)`, where `n` is the number of characters in the string.	2014-12-10 11:47:54		
423	zeice	3		2014-12-10 11:47:54		
424	admin	3		2014-12-10 11:47:54		
425	ufdxg	3		2014-12-10 11:47:54		
426	nwkeg	3		2014-12-10 11:47:54		
427	dkebi	3		2014-12-10 11:47:54		
428	huiqq	3		2014-12-10 11:47:54		
429	dgjji	3	Here's a solution in JavaScript:	2014-12-10 11:47:54		
430	fmzze	3		2014-12-10 11:47:54		
431	ufdxg	3		2014-12-10 11:47:54		
432	azmjc	3	A working version at - codepen.io/yusufnb/pen/veDBx?editors=001	2014-12-10 11:47:55		
433	eucmc	3		2014-12-10 11:47:55		
434	qywrh	3		2014-12-10 11:47:55		
435	bjsiw	3	Not sure if this will work...you guys critique. Written in Python3:	2014-12-10 11:47:55		
436	krxlv	3		2014-12-10 11:47:55		
437	azmjc	3		2014-12-10 11:47:55		
438	nwkeg	3	I made a C# method for it. This appears to work and I BELIEVE it'll cover cases that result from larger strings also. Little bit lengthy, but recursive method seemed most logical to handle the total number of removed characters. There's obviously driver code, but its not all that important.	2014-12-10 11:47:55		
439	jippy	3		2014-12-10 11:47:55		
440	zeice	3		2014-12-10 11:47:55		
441	sqzqo	3	I tested it, you are right it will not work with "axxba". So I am removing it.	2014-12-10 11:47:55		
442	zeice	3	This code does not work. Counter-example: "axxbababa", k = 2. Answer is True, but your code gives False	2014-12-10 11:47:55		
443	krxlv	4	An O(n) solution is possible.  We consider all "split points", i.e. points such that one subarray lies to the left of it, and one to the right, and compute the best for each possible split point.  Dynamic programming works.  Given Array A[1,...n]  Using the standard dynamic programming algorithm, we can compute for a given i, the maximum and minimum sum subarrays in A[1...i] and A[i+1 ... n]. Note that the point between i and i+1 is a split point.  This can be done by making two passes once from 1 to n, and other from n to 1 and give us four arrays with the max and min sub-array sums.  Now given the above four arrays, for split point between i and i+1, we can take the max and min combinations (max from right, min from left and max from left, min from left), and get the combination which gives the better result.  Once we have the max for each split point, we get the global optimum.  O(n) time, O(n) space.	2014-12-10 11:47:56		
444	bexbp	4	Nice solution Loler. I think it will work	2014-12-10 11:47:56		
445	plapd	4		2014-12-10 11:47:56		
446	mrjku	4		2014-12-10 11:47:56		
447	fowai	4		2014-12-10 11:47:56		
448	vanul	4		2014-12-10 11:47:56		
449	plapd	4	@loler: so let's run it on [4, -1, 7] For i:1 so we divide array as [0] & [1,2] [max 4 min 4] [max 7 min 6] For i:2 so we divide array as [0,1] & [2] [max 4 min 3] [max 7 min 7] so let's compare all the min and max arrays for each i i.e. split point. So we get 3 as the answer(7-3) Is this what you mean?	2014-12-10 11:47:56		
450	ethan	4	Looks like you got tricked into answering a live competition question: codechef.com/JUNE13/problems/DELISH	2014-12-10 11:47:56		
451	dkebi	4	@Loler: the solution which you presented is still O(n^2). Because for each split point you are finding max & min sub arrays in either sides in O(i) and O(n-i), for split at i. So, for all split points, the order comes out to O(n^2).	2014-12-10 11:47:56		
452	ewigy	4	@frager +1. I agree this is a quadratic algorithm. @Loler, can you post the code?	2014-12-10 11:47:56		
453	dkebi	4	@frager: but you can do it (computing the max/min) subarrays for each split point in O(n) if you cache previous results (hence O(n) space complexity). When you are at A[i] the max subarray is either max A[i-1] extended with A[i] or if this extension goes below 0 then the max subarray is the same subarray as for A[i-1].  Tell me if I'm wrong.	2014-12-10 11:47:56		
454	nhibd	4	@oOZz: I came up with the same algorithm as @Loler. Below is the code (ugly but I did it during my lunch break). It is O(n) time and O(n) space and passes the dreaded {4,-1,7} ;) But didn't test it extensively. P.S. I am full of respect for people who can come up and code it within 45mins, without a compiler and during an interview (stress). Took me 1hours with a compiler.	2014-12-10 11:47:56		
455	fowai	4		2014-12-10 11:47:56		
456	tenuw	4		2014-12-10 11:47:56		
457	sgiwy	4	If we want more - like exactly the subarrays we need to store the start/end indices for each split too (doesn't change the time complexity order, only the constant)	2014-12-10 11:47:56		
458	ftfck	4	@Up: two things: 1) noticed I copied my solution with a bug, while calculating the "revMax/Min" there should be revMin[0] = A[len]; instead of min[0] = A[len]; 2) depending on how we interpret the question there might be needed a slight change in the code. For instance what should be the output for [-1,-2,-3]. Should it be 4 (as abs( (-3-2) - (-1) )) or should we take the whole array and treat an empty array as the second one which would give us abs( (-3-2-1) - 0) = 6?	2014-12-10 11:47:56		
459	bexbp	4	@Anonymous. Respect my friend! The code mostly works (see below), but it's still impressive to come up with a DP solution in 1 hour during lunch. (+1) I also agree with you that the DP problems are hard to solve in 45 mins without a compiler and therefore, they're better suited for coding competitions than job interviews.  Your code for input [-1,-2,-3] fails. It outputs 1, but neither 4 nor 6. I've asked the same question to @LAP for clarification whether the empty set is a valid subarray and its sum is 0, but he/she didn't answer. I'd assume that it is. Then IMO, [-1,-2,-3] should return (0 - (-1,-2,-3)) = 6 and [4,-1,7] should return ((4,-1,7) - 0) = 10.  I've also just made a small change to the code that I posted above. It works with the empty set assumption. Though it's a O(N) time and O(1) space and only 20 lines, no one seems to not like it LOL Happy coding!	2014-12-10 11:47:56		
460	qywrh	4	@oOZz: the [-1,-2,-3] result is incorrect because I pasted my code with a bug to this site (long story short I couldn't do a ctrlc/ctrlv :). I mentioned it above.  Also I agree with that DP problems suck for interviews. Hopefully I will not have one (or at least a hard one) during my G interview today :))	2014-12-10 11:47:56		
461	krxlv	4	@aka: Yes something like that.  @eugene: Oops. Well played by LAP I suppose :-), and looks like it might be too late to delete now.  @frager/oOZz: It is O(n). Just store the intermediate results of Kadane's algorithm... (Kadane's is what I mean by "standard dynamic programming algorithm".)  @oOZz: During an interview they don't expect perfect code which will compile at the get go. If you want to use some library method, you can just assume it. I would say it is easier to write code in an interview, than using a compiler: you won't get bogged down by the useless details (like does strcpy take dst first or src?) and can concentrate on the parts that matter.  @Anonymous: I don't see a problem asking DP questions. The point of the questions is not to see whether you get the answer or not, but to see how you tackle it. You will be judged relative to other candidates on the same question (at least in Google), so everyone is in the same boat.  Sorry if I missed responding to someone.	2014-12-10 11:47:56		
462	ethan	4	@Loler: Do you work for Google? Wonderful!	2014-12-10 11:47:56		
463	plapd	4	@Dumbo. The information about the judging relative to other candidates is public. Gayle has herself said it multiple times. Even the recruiters tell you that, I believe.	2014-12-10 11:47:56		
464	bexbp	4	@Loler: Wonderful Loler, nice to know that great talent is around. Wanted to ask you for a favor - I have been working on question?id=12708671. Thought hard on the problem for days together and came up with a solution. Could you kindly verify if my idea works? [Kindly excuse my trumpeting there]. Apologies to all who find my post irrelevant to the current context - btw any other way of 1-1 communication possible here?	2014-12-10 11:47:56		
465	rrmeu	4	There is some issue with this DP approach, because the max/min sum of A[1..i] can not be generated from A[1..i-1]. Here are two examples: {-6 5 -7 6} => Min: {-6 5 -7 } = -8, Min = {6} = 6, Diff= 14 {-6 5 -7 2} => Min: {-7}, Max = {5}; Diff = 12 The Min for {-6 5} is {-6}, but from this Min, we cannot get Min for {-6 5 -7} = -8 Also @oOZz's code always assumes the min/max running sum continuing decrease/increase. They may decrease, increase and then decrease.  The split point approach is still valid.	2014-12-10 11:47:56		
466	sgiwy	4	@Dumbo: Try freenode IRC channel #algorithms if you have any doubts in algorithms.	2014-12-10 11:47:56		
467	krxlv	4	For the reverse max/min, we don't even need to store the result in array. We can simply make a reverse pass and at every point, we have the max and min. Using these two variables, we can simply calculate the absolute difference. The largest different would be the answer.	2014-12-10 11:47:56		
468	tenuw	4	@Anonymous. There are lots of bug in your code, apart from the one you already know. 1) Take input [-4,5], in this case your code will find max as -4+5=1 which is wrong, max should be 5, same for the min case. 2)I think your logic for calculating the min array is also wrong, recheck it one. Apart from these bugs, nice solution :) . Do post about your G interview :)	2014-12-10 11:47:56		
469	nwkeg	4	@sniper: about [-4,5] I think it should be |5-(-4)| = 9 and that's how my code acts :) But you are right I wasn't 100% sure how to interpret the question for instance what should be the result for [1,5]. Should it be |(5+1)-0| = 6 or |5-1|=4? It all depends is an empty subarray an array. I assumed no.  About the min array I still didn't find a counterexample that would give me an incorrect solution but indeed there might be bugs :)  The G interview was good, will post the question soon but it was very easy :)	2014-12-10 11:47:56		
470	rrmeu	4	@Anyonymous who just gave Google interview. Please do post the questions and what your answers were. And please also tell us if you got the job.	2014-12-10 11:47:56		
471	bjsiw	4	@oOZz's solution does work for an array containing only positive numbers. For example, [8, 1, 1, 1].	2014-12-10 11:47:56		
472	mrjku	4	I come up with the same algorithm as @Loler. I implement it in Python. Here is the code:	2014-12-10 11:47:56		
473	krxlv	4		2014-12-10 11:47:56		
474	azmjc	4		2014-12-10 11:47:56		
475	dkebi	4		2014-12-10 11:47:57		
476	krxlv	4		2014-12-10 11:47:57		
477	qywrh	4	I agree this is the best answer on the board, but I think it is still wrong.  Consider: -10 7 -3 2 2 -20 1  The best split point considering everything left and right is between -20 and 1, where the best solution is -20 and 7.	2014-12-10 11:47:57		
478	ufdxg	4	Why does this answer have so many likes? It doesn't take into account that the first array can start not from the beginning but rather from any other positions and the same is true for the second array. Actually there are three split points in this task. So, if we have an array {2, -4, -5, 3, 6, -1}, our split point will be: Split point 1 goes after 2 Split point 2 goes after -5 Split point 3 goes after 6 And the solution will be {-4, -5} and {3, 6}	2014-12-10 11:47:57		
479	krxlv	4	Use dp with kadane's algorithm for solving above problem...:-)  import java.io.*; public class Main {  public static void main(String args[]) throws IOException { BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); long a[]=new long[10000]; long b[]=new long[10000]; long max1[]=new long[10000]; long min1[]=new long[10000]; long max2[]=new long[10000]; long min2[]=new long[10000]; int n=Integer.parseInt(br.readLine()); String arr[]=br.readLine().split(" " ); int i=0; for(String s:arr) { a[i]=Integer.parseInt(arr[i]); b[i]=-a[i]; i++; }  long maxsofar=a[0],maxendinghere=a[0];max1[0]=a[0]; for(i=1;i<n;i++) { //maxendinghere=maxendinghere+a[i]>0?maxendinghere+a[i]:0; maxendinghere=maxendinghere+a[i]; maxendinghere=maxendinghere>a[i]?maxendinghere:a[i]; maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere; max1[i]=maxsofar; } max2[n-1]=maxendinghere=maxsofar=a[n-1]; for(i=n-2;i>=0;i--) { //maxendinghere=maxendinghere+a[i]>0?maxendinghere+a[i]:0; maxendinghere=maxendinghere+a[i]; maxendinghere=maxendinghere>a[i]?maxendinghere:a[i]; maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere; max2[i]=maxsofar;  } maxendinghere=maxsofar=b[0]; min1[0]=-b[0]; for(i=1;i<n;i++) { //maxendinghere=maxendinghere+b[i]>0?maxendinghere+b[i]:0; maxendinghere=maxendinghere+b[i]; maxendinghere=maxendinghere>b[i]?maxendinghere:b[i]; maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere; min1[i]=-maxsofar; } maxendinghere=maxsofar=b[n-1]; min2[n-1]=-b[n-1]; for(i=n-2;i>=0;i--) { //maxendinghere=maxendinghere+b[i]>0?maxendinghere+b[i]:0; maxendinghere=maxendinghere+b[i]; maxendinghere=maxendinghere>b[i]?maxendinghere:b[i]; maxsofar=maxsofar>maxendinghere?maxsofar:maxendinghere; min2[i]=-maxsofar; } long globalmax=0; /* for(i=0;i<n;i++) { System.out.println(a[i]+" "+b[i]+" "+min1[i]+" "+max1[i]+" "+min2[i]+" "+max2[i]); } */ for(i=1;i<n;i++) { long m1=max1[i-1]-min2[i]; m1=Math.abs(m1); long m2=max2[i]-min1[i-1]; m2=Math.abs(m2); m1=m1>m2?m1:m2; globalmax=globalmax>m1?globalmax:m1; } System.out.println(globalmax); }  }	2014-12-10 11:47:57		
480	xhgls	4	So abstract the list of ints to a list of three subsets.  list of numbers= {a, b, c} where a,b,c are sums of contiguous numbers in the array and a,b,c are contiguous.  Each of those subsets represents the sum of contiguous numbers in the array. We are looking for the highest and lowest. Note that it is impossible for A or C to have the same signage (positive or negative) as B. Also, if either A or C is the empty set, then the positive subset is the highest and the negative subset is the lowest. If both A and C are the empty set, then B is either the high subset or low subset based off of B's signage. Also lets specify that, B can never be an empty set unless both A and C are empty sets. Now the important thing to note here is that we are going to try to maximize the absolute value of B. This is important because it will allow us to take the highest absoulute value of either A or C and get the highest combined difference.  So let's take a look at some real numbers n = {a, b, c}	2014-12-10 11:47:57		
481	dkebi	4		2014-12-10 11:47:57		
482	gilit	4		2014-12-10 11:47:57		
483	xhgls	4	so n = {100, -506, 305}  So here we can see we should grab the array that adds up to -506 (-500, 2, -7, 50, -51) and the array that adds up to 305 (3, -2, 4, 300).  So basically the algorithm is this 1) Pass through the array and calculate the sums 2) Figure out the largest absolute value the sub array B can be 3) Figure out if either A or C should be the other array   Here is some code that I wrote that does what I outlined above. It was written before I really understood why the codeworks so it could be prettied up, but I am too lazy to do so :)	2014-12-10 11:47:57		
484	plapd	4		2014-12-10 11:47:57		
485	huiqq	4		2014-12-10 11:47:57		
486	ethan	4	NOTE: the second array is a SUBSET of either A or C if B is I-j, you should start with I-1 as the end of one of the potential arrays and j+1 as the start of one of the potential arrays.	2014-12-10 11:47:57		
487	krxlv	4	This solution in python is short, O(n), I hope this will help u.	2014-12-10 11:47:57		
488	gilit	4		2014-12-10 11:47:57		
489	jippy	4		2014-12-10 11:47:57		
490	xhgls	4	I forgot comments in my code, invert just multiply each element in the array by -1, The idea is to use find_max_sum also to find the minimun sum interval in a[i:].	2014-12-10 11:47:57		
491	bjsiw	4	Started throwing some numbers at it. Seems to have some issues.  >>> solve([0, 0, 100, -5, 50]) [145, 145, 145, 45, 50, -inf] 150 >>> solve([0, 0, 100, -5, 50, -1000]) [145, 145, 145, 45, 50, -1000, -inf] 1145 >>> solve([1, 100, -5, 50, -1000]) [146, 145, 45, 50, -1000, -inf] 1145	2014-12-10 11:47:57		
492	qywrh	4	Will the following solution work?  1. Find maxsubsequence sum M1 (using Kadane's algorithm) 2. Negate the whole array and find again maxSubsequenceSum M2 3. M1 + M2 should be the absolute max difference. [M1 and M2 must be appearing in disjoint contiguous subarrays, for if they overlap, M1 and -M2 cannot be maximum +ve and maximum -ve values respectively]. and we have a proof by contradiction below]	2014-12-10 11:47:57		
493	zeice	4	dumbo there can be numbers in the subarrays which are common to both hence they can overlap so I dont think it will work Can you please explain your algo using the example given above	2014-12-10 11:47:57		
494	gilit	4	It wont work with the following eg - [4,-1,7] => 1.-> (4,-1,7) 2. -> (1) . But the two subsets overlap	2014-12-10 11:47:57		
495	xhgls	4	@LAP, Nice test case. You are right, the range of minimum sum is completely within the range of maximum sum. When I checked using my java code below, the solution I proposed is working fine for the data given in the example. However, I need to think more about your test case.	2014-12-10 11:47:57		
496	vanul	4		2014-12-10 11:47:57		
497	dkebi	4		2014-12-10 11:47:57		
498	tenuw	4	@LAP, I think the degenerate cases of the minimum sum completely contained in the maximum sum or the maximum sum completely contained in the minimum sum can be handled separately.  Suppose Min is completely contained in Maximum subsum, the the maximum subsum would appear something like  P1 + N + P2, Where P1 is the +ve sum that is to the left of the the minimum sum M and P2 is the +ve sum that is to the right of N.  If P1 > P2 then |P1-N| should give the max absolute diff else it would be |P2-N|  if max subsum is completely contained in min subsum, then the min subsum would appear as  N1 + P + N2. Where N1 is the -ve sum that is to the left of the the maximum sum P and N2 is the -ve sum that is to the right of P.  if N1 > N2 then |N1-P| should be the maximum sum else |N2-P|  The min and max subsums can't overlap, for if they overlap, you can arrive at a proof by contradiction by splitting the sum of numbers into three parts: N + O + M Where N is the sum of the minimum subset excluding the overlapping part. O is the sum of the overlapping part S is the sum of the maximum subset excluding the overlapping part  For N+O to be minimum O has to be -ve M + O to be maximum O has to be +ve, a contradiction.	2014-12-10 11:47:57		
499	ftfck	4	He is expecting O(n) time algorithm	2014-12-10 11:47:57		
500	sgiwy	4	1. Find the max continues sum 2. Find the continues min sum 3. return 1-2	2014-12-10 11:47:57		
501	vanul	4		2014-12-10 11:47:57		
502	nhibd	4		2014-12-10 11:47:57		
503	ethan	4	Running time is O(n).	2014-12-10 11:47:57		
504	vanul	4	Making same mistake as others: [4, -1, 7]	2014-12-10 11:47:57		
505	jippy	4	Correct. I missed that edge case. I updated the code, how about now? the code above will return 10 for [4,-1,7]	2014-12-10 11:47:57		
506	huiqq	4	Does not work for [2,-1,-2,12,453,-9,2,8]	2014-12-10 11:47:57		
507	wbqzu	4	this is not disjoint	2014-12-10 11:47:57		
508	qywrh	4	What about this: Must the two subarrays be adjacent? Yes, because the part "in between", unless it is 0, can contribute to either subarray, making it more optimal.  If so, then let's find a split point defining subarrays A[0,i] and A[i+1,n], such that the maximal subarrays (spanning together over whole A) give the optimal absolute difference of sums, that can be easily done O(n).  Now, here comes an interesting bit. You can prove that the optimal global solution are possibly trimmed subarrays found in the first step. In other words, you cannot find the global optimal solution by trimming subarrays, which do not optimize the first step criterion.  And so, without further ado, to find the optimum solution we have to possibly trim one or both of the subarrays, or "expanding" subarrays starting from one-element subarrays on the left hand side and right hand side of a split point found in the first step, and this is done in O(n).  So final time complexity O(n), space complexity O(1).	2014-12-10 11:47:57		
509	zeice	4	can u give an example where an element is making both the subsets optimal?	2014-12-10 11:47:57		
510	fmzze	4	won't work for [-6,5,-7,2]. the split point between 5 and -7 won't be found because with out trimming it less than other split points.	2014-12-10 11:47:57		
511	cfzie	4	-4 3 -1 1 2 2 2	2014-12-10 11:47:57		
512	nhibd	4	#include<stdio.h> void main() { int a[]={2,-1,-2,1,-4,2,8},n=sizeof(a)/sizeof(int),max[n],min[n],max_max,min_min,i=0; max[0]=min[0]=max_max=min_min=a[0]; for(i=1;i<n;i++) { max[i]=(max[i-1]+a[i])>a[i]?max[i-1]+a[i]:a[i]; max_max=max[i]>max_max?max[i]:max_max; min[i]=(min[i-1]+a[i])<a[i]?min[i-1]+a[i]:a[i]; min_min=min[i]<min_min?min[i]:min_min; } printf("%d\n",max_max-min_min); } Is this ok? it will work in O(n). Are we supposed to identify the subsets also or need to print the difference only?	2014-12-10 11:47:57		
513	sqzqo	4	@Anonymous: check for input [4,-1,7]	2014-12-10 11:47:57		
514	qywrh	4	this wont work for [4 -1 7]	2014-12-10 11:47:57		
515	ufdxg	4	An O(n) solution by finding maximum subsequences using Kadane's algorithm  1. Find maxsubsequence sum M1 2. Negate the whole array and find again maxSubsequenceSum M2 3. M1 + M2 should be the absolute max difference. [M1 and M2 must be appearing in disjoint contiguous subarrays, for if they overlap, M1 and -M2 cannot be maximum +ve and maximum -ve values respectively. and we have a proof by contradiction above] 4. Separately handle degenerate cases such as 1) the maximum subsum being contained in the minimum subsum and 2) vice versa  Full working implementation in java is below. Provide Input to the program as: 4 -1 7 -4 1 -7 -9 -4 1 2 -5 -7 -8 9 4 -1 -2 5 7 8	2014-12-10 11:47:57		
516	wbqzu	4		2014-12-10 11:47:57		
517	qywrh	4		2014-12-10 11:47:57		
518	cfzie	4	doesnt work for 1, 2, 3, 4, 5	2014-12-10 11:47:57		
519	admin	4	@Anonymous  What result do you expect for this test case?	2014-12-10 11:47:57		
520	eucmc	4	2+3+4+5-1=13	2014-12-10 11:47:57		
521	tenuw	4	Haha. Ain't the difference (2+3+4+5+1) - 0 = 15 greater than 13? Lol.	2014-12-10 11:47:57		
522	sgiwy	4		2014-12-10 11:47:57		
523	mrjku	4		2014-12-10 11:47:57		
524	nwkeg	4	The code for this problem is given below.You can consider the following approach: a.Find maximum continuous sub-array sum using kadane's algorithm. b.Similarly find minimum continuous sub-array sum using the same approach. c.Find the difference between the maximum and minimum element.	2014-12-10 11:47:57		
525	ufdxg	4		2014-12-10 11:47:57		
526	azmjc	4		2014-12-10 11:47:57		
527	mrjku	4	Hi  this wont work for numbers which are all negative {-1,-3,-5,-2,-1,-4}	2014-12-10 11:47:57		
528	gilit	4	@DashDash i have edited the code it will work now..	2014-12-10 11:47:57		
529	eucmc	4	I think it will not work for this, try it out {2, -3, 5} and is 5 but your maxSumArray will give 4,	2014-12-10 11:47:57		
530	dgjji	4	It is working for every possible case..you can paste it and check it gives 5 not 4..and plzz first test it then you can comment for the correction..	2014-12-10 11:47:57		
531	dgjji	4	For handling with only negative numbers in an array I have added a seperate function for that you can check it..	2014-12-10 11:47:57		
532	sgiwy	4	you check your program for : {1,1,-1,-1} it gives 1, not 4.. :)	2014-12-10 11:47:57		
533	bexbp	4	So this is what I got, there are no error checking which is obviously bad but I assume we are all coding and making suggestions for valid entries primarily so keep that in mind:	2014-12-10 11:47:57		
534	zeice	4		2014-12-10 11:47:57		
535	tenuw	4		2014-12-10 11:47:57		
536	gilit	4	O(n) solution can be found at sites.google.com/site/spaceofjameschen/home/array/find-two-disjoint-contiguous-sub-arrays-such-that-the-absolute-difference	2014-12-10 11:47:57		
537	dgjji	4	this does not give right answer for [4 -1 7]	2014-12-10 11:47:57		
538	krxlv	4	While thinking over this problem I just realized that maximum and minimum subarrays can overlap in only two scenarios: 1) When sum of the common numbers is zero. If sum of common sequence would have been +ve then it would have been part of maximum subarray and not of minimum subarray. Vice verse for -ve sum for common subarray. 2) One subarray is part of other. For example 10, 9, -1, -2, 10 10  Based on the above two possiblilities 1) Find maximum subarray 2) Find minimum subarray 3) If common subarray is zero then it can go either on maximum or minimum side. 4) If one subarray is part of other then find left and right part (non overlapping) of larger subarray and find the difference between this larger part and common elements.  Hence the complexity of this algo is same as finding maximum/minimum subarray problem.	2014-12-10 11:47:57		
539	krxlv	4	4) is not a possibility. The min and max subarrays can either share only 0 as a common boundary or either of them can be present entirely in the other. See my proof by contradiction up in the post.	2014-12-10 11:47:57		
540	zeice	4	I could not get your point. As I understand, you are saying that point 4 is not correct. You say that max and min subarrays share only 0 as a common boundary or one of them is completely part of other. Even I am saying the same thing as you can see from the example I mentioned previously : 10, 9, -1, -2, 10, 10  Where max subarray is 10, 9, -1, -2, 10, 10 ans min subarray is -1, -2 which is part of max subarray.  If I misunderstood you point please provide me example here.	2014-12-10 11:47:57		
541	ftfck	4	#include <algorithm> using namespace std; int computMaxDiff(int *array,int len) { int *maxarray=new int[len]; int *minarray=new int[len]; maxarray[0]=array[0]; minarray[0]=-array[0]; int currentmax=maxarray[0]>0?array[0]:0; int currentmin=minarray[0]>0?minarray[0]:0; for(int i=1;i<len;i++) { currentmax+=array[i]; //max maxarray[i]=max(currentmax,maxarray[i-1]); if(currentmax<0) currentmax=0;  currentmin+=-array[i]; // max of -array minarray[i]=max(currentmin,minarray[i-1]); if(currentmin<0) currentmin=0; }  for (int i=0;i<len;i++) //min of array minarray[i]=-minarray[i];   int *revmaxarray=new int[len]; int *revminarray=new int[len]; revmaxarray[len-1]=array[len-1]; revminarray[len-1]=-array[len-1]; int revcurrentmax=revmaxarray[len-1]>0?revmaxarray[len-1]:0; int revcurrentmin=revminarray[len-1]>0?revminarray[len-1]:0; for(int i=len-2;i>=0;i--) { revcurrentmax+=array[i]; revmaxarray[i]=max(revcurrentmax,revmaxarray[i+1]); if(revcurrentmax<0) revcurrentmax=0;  revcurrentmin+=-array[i]; revminarray[i]=max(revcurrentmin,revminarray[i+1]); if(revcurrentmin<0) revcurrentmin=0; }  for (int i=0;i<len;i++) revminarray[i]=-revminarray[i];  int maxdiff=0; for (int i=0;i<len;i++) { int currMax=max(abs(maxarray[i]-revminarray[i]),abs(minarray[i]-revmaxarray[i])); if(currMax>maxdiff) maxdiff=currMax; }  return maxdiff; } int _tmain(int argc, _TCHAR* argv[]) { int array[5]={-3,4,-1,4,5}; int maxdiff=computMaxDiff(array,5); return 0; }	2014-12-10 11:47:57		
542	sgiwy	4	step 1 : find the sum of whole array. assign it TotalSum O(n) step 2 : Lets have a few variables SumFromBegining=0, SumFromEnd=TotalSum, MaxDifference=0, MaxDifferenceSplitIndex=0. all these are integers or long ---O(1) step 3 : Iterate through the array from beginning to end. for each iteration you need need to do the following 1. add the current array element ie. array[i] to SumFromBegining 2. subtract the current array element ie. array[i] from SumFromEnd 3. Difference=absolute(SumFromEnd-SumFromBegining) 4. if Difference > MaxDifference then MaxDifference=Difference and MaxDifferenceSplitIndex=i  now this process is of O(n)  After the iteration array[0 to MaxDifferenceSplitIndex ] and array[MaxDifferenceSplitIndex+1 to n] are the answer.  this is a solution with O(n)  hope i did not make a mistake..:-)	2014-12-10 11:47:57		
543	xhgls	4	I've been through all of these solutions and correct me if i'm wrong, but i think absolutely none of them work for all possible cases. There's one or two which work, but they aint 0(n).	2014-12-10 11:47:58		
544	tenuw	4	Loler's solution should work in O(n) and for all possible cases if implemented correctly.  The code posted in a comment to that answer was posted by someone else, and I have not verified it. People seem to have found some issues with it. But these are implementation issues, not problems with the idea.	2014-12-10 11:47:58		
545	dkebi	4	for this problem finding maximum and minimum contiguous don't work. for example consider this two test case: 1)array=[-6, 3, 5, 4, -1, -7, 17, 8] in this case maxSum=25 and minSum=-8 if we search disjoint contiguous subarray. so the absolute difference is equal 33. however, the max difference is 35 if we separate [-6] and [3, 5, 4, -1, -7, 17, 8]. sum1=-6, sum2=29 so difference is 35. 2)array=[4, -1, 5] the same above maximum absolute difference between two disjoint contiguous subarray is 6.[-1] and [5].	2014-12-10 11:47:58		
546	zeice	4	1. Given an array, find the following max/min continuous array: - left_min_array: continuous max array - left_max_array: continuous min array - right_min_array: reverse the array, calculate the continuous max array, reversed again - right_max_array: reverse the array, calculate the continuous min array, reversed again 2. Iterate the array, find the maximum among the following four integers: - abs(left_min_array[i]) + abs(right_min_array[i+1]) - abs(left_min_array[i]) + abs(right_max_array[i+1]) - abs(left_max_array[i]) + abs(right_min_array[i+1]) - abs(left_max_array[i]) + abs(right_max_array[i+1]) And store the largest result in an array, let's call result 3. The maximum difference is the max element in the result array  Code is attached at the end, following are the test cases: - {2,-1,-2,12,453,-9,2,8} - {7,-1,4} - {1,2,3,4,5} - {-1,-3,-5,-2,-1,-4}	2014-12-10 11:47:58		
547	rrmeu	4		2014-12-10 11:47:58		
548	wbqzu	4		2014-12-10 11:47:58		
549	wbqzu	4	step 1 : find the sum of whole array. assign it TotalSum O(n) step 2 : Lets have a few variables SumFromBegining=0, SumFromEnd=TotalSum, MaxDifference=0, MaxDifferenceSplitIndex=0. all these are integers or long ---O(1) step 3 : Iterate through the array from beginning to end. for each iteration you need need to do the following 1. add the current array element ie. array[i] to SumFromBegining 2. subtract the current array element ie. array[i] from SumFromEnd 3. Difference=absolute(SumFromEnd-SumFromBegining) 4. if Difference > MaxDifference then MaxDifference=Difference and MaxDifferenceSplitIndex=i  now this process is of O(n)  After the iteration array[0 to MaxDifferenceSplitIndex ] and array[MaxDifferenceSplitIndex+1 to n] are the answer.  this is a solution with O(n)	2014-12-10 11:47:58		
550	bjsiw	4	here's a O(n) solution:	2014-12-10 11:47:58		
551	ethan	4		2014-12-10 11:47:58		
552	ewigy	4		2014-12-10 11:47:58		
553	jippy	4	finished going through all the posts on here. :) Seems like my implementation is closest to what Loler suggested in C. Only difference is I am using two DA and each maintains structure that keeps track of max and min for the interval.	2014-12-10 11:47:58		
554	jippy	4	Can anybody comment on my approach . 1. find the max sum subsequence using DP. Store the sum and store the subsequence. Replace those elements by INT_MAX. 2. find the min sum subsequence using DP. store the sum and subsequence 3. Now calculate the difference, and print those sets. I think there is no way this subsets will overlap.  This is O(n) solution since steps 2 and 3 takes O(n) in DP.	2014-12-10 11:47:58		
555	rrmeu	4	WTH are you talking about	2014-12-10 11:47:58		
556	admin	4		2014-12-10 11:47:58		
557	ethan	4		2014-12-10 11:47:58		
558	wbqzu	4		2014-12-10 11:47:58		
559	bjsiw	4		2014-12-10 11:47:58		
560	ewigy	4	}	2014-12-10 11:47:58		
561	huiqq	4	I came across this problem and thought about this and came up with the possible solution. I am unable to find cases in order to fail this solution. Can someone please enumerate a set for the same?  My algorithm:  1.Calculate the continuous sum of all elements while going from 1 to n and store them in an array . Do the same while going from n to 1 2. In the first array mark a point which has minimum value and which has maximum value . Do the same for the second array 3. Check for four scenarios. a) Break array just after array 1 has hit a minimum value b) Break array just before array 1 has hit a max value c) Break array just before array 2 has hit a minimum value d) Break array just after array 2 has hit a max value 4. Max of (a,b,c,d) from above is the answer  Example: Array : 10,1,3,-10,2  Array 1: 10,11,14,4,6 Max: 14 Min: 4 Array 2: 6,-4,-5,-8,2 Max: 6 Min: -8 a) Break after Min:4 i.e Break after -10 in Array . Absolute Diff is 2 b) Break before Max:14 i.e Break before 3 in Array . Absolute Diff is 16 c) Break after Max:6 i.e Break after 10 in Array . Absolute Diff is 14 d) Break before Min: -8 i.e Break before -10 in Array . Absolute diff is 22  Max(a,b,c,d) = 22  Solution complexity is O(n)	2014-12-10 11:47:58		
562	bexbp	4	I came across this problem and thought about this and came up with the possible solution. I am unable to find cases in order to fail this solution. Can someone please enumerate a set for the same?  My algorithm:  1.Calculate the continuous sum of all elements while going from 1 to n and store them in an array . Do the same while going from n to 1 2. In the first array mark a point which has minimum value and which has maximum value . Do the same for the second array 3. Check for four scenarios. a) Break array just after array 1 has hit a minimum value b) Break array just before array 1 has hit a max value c) Break array just before array 2 has hit a minimum value d) Break array just after array 2 has hit a max value 4. Max of (a,b,c,d) from above is the answer  Example: Array : 10,1,3,-10,2  Array 1: 10,11,14,4,6 Max: 14 Min: 4 Array 2: 6,-4,-5,-8,2 Max: 6 Min: -8 a) Break after Min:4 i.e Break after -10 in Array . Absolute Diff is 2 b) Break before Max:14 i.e Break before 3 in Array . Absolute Diff is 16 c) Break after Max:6 i.e Break after 10 in Array . Absolute Diff is 14 d) Break before Min: -8 i.e Break before -10 in Array . Absolute diff is 22  Max(a,b,c,d) = 22  Solution complexity is O(n)	2014-12-10 11:47:58		
563	qywrh	4	I think Loler is right, the algorithm could be implemented in O(n), and here is my code:	2014-12-10 11:47:58		
564	mrjku	4		2014-12-10 11:47:58		
565	ufdxg	4		2014-12-10 11:47:58		
566	sgiwy	4	sites.google.com/site/spaceofjameschen/home/array/find-two-disjoint-contiguous-sub-arrays-such-that-the-absolute-difference	2014-12-10 11:47:58		
567	krxlv	4	i am assuming the minimum sum of a sub array is negative or empty. and that the maximum sum of a sub array is positive or empty. the problem can be defined as follow: 1. Find the max sub sum 2. Find the min sub sum  if they do not intersect return their difference; otherwise check if the min sub sum is starting after the max sub sum:  [maxSubSumStart ---------- minSubSumStart ----------------MinSubSumEnd--------maxSubSumEnd]  I want to prove that if intersection is not allowed then either the left max sub sum or the right sub sum is the largest sub sum. In this case each side of minSubSumArray is larger than the absolute value of minSubSumArray (otherwise their sum is below 0 and we would have taken only one part). assume the left sub array is the bigger one. That implies that it is also the biggest sub array in the array (because any other max sub array that wasn't added to the current max array, wasn't added because it is smaller (absolute value)than some minimum sub array, and therefore it is smaller then the minimum sub array and therefor smaller then the left and right parts of the maxsub array.  Therefore the result would be: max sub is the left side of the max array, and the min sub is the minimum sub array.  the same logic is true also in case the max array start in the middle of the min array  this is the code , i still need to do some re-factoring and also I might have some indexing issues:	2014-12-10 11:47:58		
568	gilit	4		2014-12-10 11:47:58		
569	tenuw	4		2014-12-10 11:47:58		
570	dkebi	4	1. Find the cumulative sum for 0<=i<n and store sum in cumulative[ ] 2. Find j, such that abs(cumulative[ j ] - cumulative [n-1]) is maximum 3. 0 to j is one subarray and j+1 to n-1 is the other subarray	2014-12-10 11:47:58		
571	nhibd	4	This solution should work for cases: 1 - compute kadane as follow: var kadane = function (arr, k, j, isMin) which should return min/max sum (according to isMin flag) for the arr elements starting at k index and end (inclusive) at j index. return value should be an object that includes the sum, start index, end index. 2 - find max when k==0 and j==arr.length-1. let's call it MAX and assume it has startIndex==si and endIndex==ei; 3 - find min when k==0 and j==arr.length-1. let's call it MIN and assume it has startIndex==si and endIndex==ei; 4 - for the output of 2 MAX - find min on the right side of it using k==MIN.endIndex+1 and j==arr.length and on the left side of it using k==0 and j==MIN.startIndex-1 (if possible and out of arr indexes). 5 - do the as in 4 step for the MIN (find max on both sides of it). 6 - out of the result in 4 and 5 take the highest and lowest among the two and calculate the range of them with MAX and MIN respectively. 7 - among the two pairs from step 6 - MIN and a max on its left/right and MAX and a min on its left/right choose the pair with the higher range and return it.	2014-12-10 11:47:58		
572	dgjji	4		2014-12-10 11:47:58		
573	krxlv	4		2014-12-10 11:47:58		
574	gilit	4	My solution in C++ (based on the same idea as some other answers with O(n) running time) :	2014-12-10 11:47:58		
575	azmjc	4		2014-12-10 11:47:58		
576	cfzie	4		2014-12-10 11:47:58		
577	nwkeg	4	If there are 2 elements in the array, or all the elements are zero, the solution is really trivial. If there are less than 2 elements, there is no solution.  If all the numbers are non-negative, the problem is completely different from if you have both signs, all positive is somewhat easier. The smaller sub-array will contain only 1 element, and the larger subarray will contain either the front or the back. Start with the front of the array being the 'large' value and the second item being 'small', we store this as our 'current optimum'. Now add the 2nd item to 'large' and call the next element 'small'; if this is better than our first solution, we store it as our current optimum. We go through the array forwards the whole way through, then we do the same thing going backwards. The optimal solution we find after both passes is the optimal solution. This solves in order n (3 passes through n elements). The same logic works if all the elements are 0 or negative.  If we have both positive and negative numbers, create a 2nd array (partioned array) 'partitioning' every positive and negative sequence: 2 -1 -2 1 -4 2 8 becomes [2] [-3] [1] [-4] [10]. I am pretty sure this is the right direction, but from here on out, I bet someone (possibly me with more time) comes up with something better than I have following.   Now create yet another array combining all the negative elements if and only if their sum is less than the number between them. Repeat this process until you cannot. So you get [-6] in this example. Now create yet another array doing this with the positive values, giving you [2][1][10]. The largest of the positive and smallest negative are the solution if we can ignore the requirement the arrays do not overlap, and the solution if they do not overlap. So far, we've done nothing beyond order n. If they overlap, we can find a place to split the segment that overlaps fairly easily, and this is almost always the correct solution, but you can come up with examples where it is not. I think going back to our partioned array and finding other combinations is the trick, but cannot think of better than n^2 way to do that.   Of course, you need to store a bit more to go back and find the array indexes, but that is trivial so I left it out.	2014-12-10 11:47:58		
578	rdfeo	4	Based upon comments above, I have written following code.  { public class DisjointSubarraysLinearTime { public static void main(String[] args) { int[] input = {2, -1, -2, 1, -4, 2, 8}; System.out.println("diff: " + getDifference(input)); } public static int getDifference(int[] a) { int[] MAX = new int[a.length]; int[] MIN = new int[a.length]; int result = Integer.MIN_VALUE; setMinMaxArrays(a, MIN, MAX); for (int i = 0; i < a.length-1; i++) { result = Math.max(result, Math.abs(MAX[i] - MIN[i+1])); } for (int i = 0; i < a.length; i++) { a[i] = -a[i]; } setMinMaxArrays(a, MIN, MAX); for (int i = 0; i < a.length-1; i++) { result = Math.max(result, Math.abs(MAX[i] - MIN[i+1])); } return result; } public static void setMinMaxArrays(int[] a, int[] MIN, int[] MAX) { MAX[0] = a[0]; int maxEndingHere = a[0]; for (int i = 1; i < a.length; i++) { if (maxEndingHere < 0) { maxEndingHere = a[i]; } else { maxEndingHere += a[i]; } MAX[i] = Math.max(maxEndingHere, MAX[i-1]); } MIN[a.length-1] = a[a.length-1]; int minEndingHere = a[a.length-1]; for (int i = a.length - 2; i >= 0; i--) { if (minEndingHere > 0) { minEndingHere = a[i]; } else { minEndingHere += a[i]; } MIN[i] = Math.min(minEndingHere, MIN[i+1]); } } } }	2014-12-10 11:47:58		
579	ewigy	4	Based upon comments above, I have written following code(formatted):	2014-12-10 11:47:58		
580	fmzze	4		2014-12-10 11:47:58		
581	qywrh	4		2014-12-10 11:47:58		
582	nhibd	4	I won't prove it, but it's true that you can find the max or min subsequence of an array in O(n) time and space.  Assuming that's true, compute the max and min subarrays. If they don't overlap, then you have your answer.  What if they do overlap?  If they overlap in the middle (e.g. [1, 5], [3, 10] overlap at [3, 5]), observe that if we remove the overlapping part from both (max and min) subarrays, that that will not change the absolute value of the difference of their sums.  WLOG, assume the min sequence contains the max sequence. Then, our disjoint max sequence will be *the* max sequence, and our disjoint min sequence will be either the left or right part that borders the inner max--return the side with smaller (more negative) sum.  It's a bit more involved to prove that the smaller side of the containing subsequence will still be the right one, but if you try and fail to find a counterexample, you'll see why.	2014-12-10 11:47:58		
583	tenuw	4		2014-12-10 11:47:58		
584	eucmc	4		2014-12-10 11:47:58		
585	sgiwy	4	This solution in python is short, O(n), I hope this will help u.	2014-12-10 11:47:58		
586	zeice	4		2014-12-10 11:47:58		
587	qywrh	4		2014-12-10 11:47:58		
588	dgjji	4		2014-12-10 11:47:58		
589	rdfeo	4		2014-12-10 11:47:58		
590	admin	4	the sets must consist of consecutive integers.	2014-12-10 11:47:58		
591	sgiwy	4	This problem can be divided into 2 subproblems: 1. Find a subset whose sum is maximum, it is O(n) algorithm 2. Find a subset whote sum in min, it is O(n) algorithm. 3. Also verify that solution from step 1 and step 2 dont overlap (they will not). Find the absolute difference between subsets find in steps1 and steps2 and take their absolute difference.	2014-12-10 11:47:58		
592	dgjji	4	Proof of the assertion that they will not overlap is missing from this post...  Example:  [-1 0 1]  One subarray with minimum sum is [-1 0] and one with maximum sum is [0 1], and yet they overlap.  Note: You talked about finding "a" subset and do not give a method to choose [-1] over [-1 0].	2014-12-10 11:47:58		
593	rdfeo	4	[4, -1, 7]  max - [4, -1, 7] and min [-1]. It completely overlaps.	2014-12-10 11:47:58		
594	rrmeu	4	@Anonymous: First off, a decent algorithm would never include 0 in the subsets if 0 is a boundary of interval, so the minimum sum and maximum sum subsets would be {-1} and {1} respectively and not {-1,0} and {0, 1}.  Secondly. the minimum sum subarray and maximum sum subarray can't overlap. they can however contain in each other completely. Proof: Proof is by contradiction: Suppose that they overlap: split the sum of numbers into three parts: N + O + M Where N is the sum of the minimum subset excluding the overlapping part. O is the sum of the overlapping part S is the sum of the maximum subset excluding the overlapping part  For N+O to be minimum O has to be -ve M + O to be maximum O has to be +ve, a contradiction.	2014-12-10 11:47:58		
595	gilit	4	@Dumbo: Huh? What is the definition of "decent"? Even the wiki page on max-sum subarray problem has C++ code which will return [0, 1] and [-1, 0]. Check it out. (the code to give the exact subarray is commented).  Didn't read the rest of your post, but [4, -1, 7] is good enough to smash googlybhai's assertions (noted elsewhere in this thread).	2014-12-10 11:47:58		
596	xhgls	4	@LAP what is the correct answer for [4, -1, 7]?  Is it (7) - (-1) = 8 or (4, -1, 7) - (empty set) = 10?	2014-12-10 11:47:58		
597	ewigy	4	I can be done using kandane. For maximum difference we need to find minimum contiguous sub array and maximum contiguous sub array. Then find the start and end index of both array and make sure they both are not colliding with each other if they are colliding then take maximum difference by including it into minimum subset and maximum subset.	2014-12-10 11:47:58		
598	fmzze	4	It can be done using kandane. For maximum difference we need to find minimum contiguous sub array and maximum contiguous sub array. Then find the start and end index of both array and make sure they both are not colliding with each other if they are colliding then take maximum difference by including it into minimum subset and maximum subset.	2014-12-10 11:47:58		
599	dkebi	4	onestopinterviewprep.blogspot.com/2014/03/namespace-arrayproblem-write-function.html	2014-12-10 11:47:58		
600	sgiwy	4	Is the exhaustive algo O(2^n * n) where n is # of digits in original set? Thats because you could make 2^n different pairs of subsets, and for each pair, you do sums of O(n).  I wonder if you could sort the origianal set and then walk up the sorted list, splitting it at each of the N points (forming the two subsets) and computing the difference of each of these subsets at each step, looking for the max? If so, you could optimize the sum, as you are just adding one new value to the sum of the first and removing it from the sum of the second.	2014-12-10 11:47:58		
601	zeice	5	This can be done in O(nlogn) using divide and conquer scheme. Before starting the algorithm, please see the following observation:  Observation: given an array A, say [1, -2, ..., 4], with n elements, we can get the inverse of A, denoted as A (4, ..., -2, 1), in \theta(n) time with O(1) space complexity.  The basic idea of the algorithm is as follows: 1. We recursively sort two smaller arrays of size n/2 (here sort is defined in the question) 2. Then we spend \theta(n) time merging the two sorted smaller arrays with O(1) space complexity. How to merge? Suppose the two sorted smaller array is A and B. A1 denotes the negative part of A, and A2 denotes positive part of A. Similarly, B1 denotes the negative part of B, and B2 denotes positive part of B. 2.1. Compute the inverse of A2 (i.e., A2) in \theta(|A2|) time; compute the inverse of B1 (i.e., B1) in \theta(|B1|) time. [See observation; the total time is \theta(n) and space is O(1)] Thus the array AB (i.e., A1A2B1B2) becomes A1A2B1B2. 2.2. Compute the inverse of A2B1 (i.e., B1A2) in \theta(|A2|) time. [See observation; the total time is \theta(n) and space is O(1)] Thus the array A1A2B1B2 becomes A1B1A2B2. We are done.  Time complexity analysis: T(n) = 2T(n/2) + \theta(n) = O(nlogn)	2014-12-10 11:48:01		
602	ftfck	5	Time: O(N), Space O(N)	2014-12-10 11:48:01		
603	eucmc	5		2014-12-10 11:48:01		
604	cfzie	5		2014-12-10 11:48:01		
605	dgjji	5	@Jason, I like this. Simple and O(n log n). I researched web and nobody claims to have O(n) time and O(1) space algorithm.	2014-12-10 11:48:01		
606	nwkeg	5	Why O(nlogn) solution when you are using O(N) extra space? If you are given O(N) extra space then you can do it in O(N) time.  1. Scan the input array and count no. of positive elements (countP) and negative elements (countN). 2. Populate output array (extra space) . scan input array from left to right for i = 0 to i = size-1. 3. if arr[i] > 0 then output[countN] = arr[i]; countN++ 4. if arr[i] < 0 then output[countP] = arr[i]; countP++  Please take care of boundary cases when there are no -ve or +ve elements in the array.	2014-12-10 11:48:01		
607	ftfck	5	@Jason. I like your three-reversion solution.	2014-12-10 11:48:01		
608	wbqzu	5	Time O(N) and space O(1)	2014-12-10 11:48:01		
609	nwkeg	5		2014-12-10 11:48:01		
610	fmzze	5		2014-12-10 11:48:01		
611	huiqq	5	@doug, if you have an array like this {1, 2, 3, 4, 5, -5, -4, -3, -2, -1}  Time is (N^2) for worse case, but still a good solution.	2014-12-10 11:48:01		
612	ftfck	5	please let me know if this has any prob ?  /* ============================================================================ Author : novice_programmer  Description : Given an array which has n integers. It has both positive and negative integers.Now you need to sort this array in such a way that,the negative integers should be in the front,and the positive integers should at the back.Also the relative position should not be changed. eg. -1 1 3 -2 2 ans: -1 -2 1 3 2.Required running time complexity is O(N) and the space complexity is O(1) Created Date : 26-JAN-2014 =========================================================================== */ #include<stdio.h>   void sort_array(int arr[],int n) { int count =0; int temp1=0; int pos_to_fill_with_positive_num=0; int pos1=0; int pos2=0; int just_moved =0; int num_remaining=0;  for(int i=0;i<n;i++) { if(arr[i]<;0) { count++; } } pos1 = count; num_remaining=count; for(int i=0;i<n;i++) { if(arr[i]<;0) { temp1=arr[pos2]; arr[pos2]=arr[i]; arr[i]=temp1; pos2++; if(pos1>=i && i>count) {pos1++; just_moved=1; }  num_remaining--; } else { if(pos2==count) break; else if((i>=count) && (i<pos1) &&(!just_moved)) continue; else if(just_moved) { just_moved=0; temp1=arr[i]; arr[i]=arr[pos2]; arr[pos2]=temp1; } else {  if(i<count) { temp1=arr[pos1]; arr[pos1]=arr[i]; if((pos_to_fill_with_positive_num>=pos2)&&(pos_to_fill_with_positive_num<count)) arr[pos_to_fill_with_positive_num]=temp1; else if(pos_to_fill_with_positive_num<count) arr[++pos_to_fill_with_positive_num]=temp1; else { pos_to_fill_with_positive_num=pos2; arr[pos_to_fill_with_positive_num]=temp1; } pos_to_fill_with_positive_num++; pos1++; } else { temp1=arr[pos1]; arr[pos1]=arr[pos_to_fill_with_positive_num]; arr[pos_to_fill_with_positive_num]=temp1; pos_to_fill_with_positive_num++; pos1++; } } }  if(num_remaining==0) break; } }  void main() { int n = 9; int arr[9]={-1,1,3,4,6,-3,1,-2,2}; //int arr[7]={-1,3,-2,4,5,-5,9}; //int arr[5]={-1,1,3,-2,2}; printf("\input array:"); for(int i=0;i<n;i++) printf(" %d ",arr[i]); sort_array(arr,n); printf("\noutput array"); for(int i=0;i<n;i++) printf(" %d ",arr[i]);  }	2014-12-10 11:48:01		
613	krxlv	5	There is a paper showing O(n) time and O(1) space algorithm "Stable minimum space partitioning in linear time." This shouldn't be an interview question.  diku.dk/hjemmesider/ansatte/jyrki/Paper/KP92b.pdf	2014-12-10 11:48:01		
614	ewigy	5	You shouldn't use recursion otherwise the required space won't be O(1). If you implement the same method iteratively it would be O(1) space though.	2014-12-10 11:48:01		
615	nhibd	5	@varun merge can be done in place, so this is a O(1) space solution if we do not consider function call stack.	2014-12-10 11:48:01		
616	nwkeg	5	public int[] negSort(int[] data) { int negCount = 0; int[] sorted = new int[data.Length];  for (int i = 0; i < data.Length; i++) { if (data[i] < 0) { sorted[negCount++] = data[i]; } }  for(int i=0; i< data.Length; i++) { if (data[i] > 0) sorted[negCount++] = data[i]; }  return sorted; }	2014-12-10 11:48:01		
617	plapd	5	If there is no repetitions then binary search tree with pre-order traversal will deliver. Again space is the con.	2014-12-10 11:48:01		
618	fowai	5	I really like your idea of divide and conquer. However, instead of your merging algorithm I used bubbling of positive integers from the left part to the right. I believe the space complexity is O(1), however, I really don't know the time complexity.	2014-12-10 11:48:01		
619	wbqzu	5		2014-12-10 11:48:01		
620	nhibd	5		2014-12-10 11:48:01		
621	rdfeo	5	O(nlogn) average case time, O(1) space solution:	2014-12-10 11:48:01		
622	azmjc	5		2014-12-10 11:48:01		
623	cfzie	5		2014-12-10 11:48:01		
624	dkebi	5	I didn't analyze it any further, anyone with an idea about worst case complexity?	2014-12-10 11:48:01		
625	mrjku	5	I think it is o(nlogn) time.En...this solution is the best here.	2014-12-10 11:48:01		
626	bexbp	5	Worst case time complexity is O(n^2), where n is the input size.	2014-12-10 11:48:01		
627	jippy	5	why the worst is o(n^2),Could you give a sample.	2014-12-10 11:48:01		
628	fmzze	5	Can some one explain what does it mean "relative position should not be changed."? Please also can some one give multiple examples to show how the output should be since the Question is not very clear.  Thanks	2014-12-10 11:48:01		
629	huiqq	5	if NlogN, why not using variation of the merge sort?	2014-12-10 11:48:01		
630	ufdxg	5	@Rocky, or quicksort for that matter...	2014-12-10 11:48:01		
631	ftfck	5	merge sort is an option, but how you do stable quicksort without additional space?	2014-12-10 11:48:01		
632	rrmeu	5	@uruk_hai: Stable in-place merge sort exists. Search the web.	2014-12-10 11:48:01		
633	bjsiw	5	@anonymous: true, but I was referring to quicksort	2014-12-10 11:48:01		
634	cfzie	5	Unfortunately, the time complexity in worst case is O(n^2). The formula is: T(n) = O(n) + T(k) + T(n - k), where k is the number of the negatives. So, if there is only one negative, the formula will change to T(n) = O(n) + T(n - 1) + O(1) = T(n -1) + O(n) = O(n^2). eg. 1 2 3 4 5 6 -1	2014-12-10 11:48:02		
635	dkebi	5	This is O(nlogn). but it can be modified in such a way that one part of the recursive tree is already sorted and you have again repeat same algo for another part. for better performance sort longest array(+ve or -ve ) and put in recurrence the other array. eg. if negative count is smaller startSearch = 0; i = first positive index j = first positive index where it supposed to be swap(a[i][, a[j]); if(a[i] < 0){ startSearch = i+1 a[i] = -a[i]; } i = next positive index; j++; if(i == first index positive supposed to){ i = startSearch; }  after this code positive array will be stable in order with only +ve numbers. repeat same for another array where only negative should be but still not in order. the number in this array is again -ve and +ve. use same algo.  thus only one tree computation is happening same as finding nth element in randomized partition.	2014-12-10 11:48:02		
636	azmjc	5	The original uruk post doesn't make sense to me. Could someone explain why it works?	2014-12-10 11:48:02		
637	xhgls	5	Method 1: O(n log(n)) for arrays Too complicated to code but leads to O(n log n) for arrays Start with an array A = [a1 b1 a2 b2 a3 b3 a4 b4 .... ak bk] where ai and bi are subarrays of positive and negative numbers. assume ni = len(ai) and mi = len(bi) Observation: [a1 b1] --> [b1 a1] in O(max(ni, mi)) which is obtained by repeatedly swaping the first, second, ... elements. For ni = mi it is obvious. For ni > mi, do it for the first mi, then ignore the first mi since they are in place, do it [ni - mi, mi] positive ones and put them in order. Repeat until you finish after ni swaps.  So recursively do this: Take [a1 b1 a2 b2] -> [b1 a1 a2 b2] -> [b1 b2 a1 a2] this is done in max(n1, m1) + max(n1 + n2, m2) < 2n1 + n2 + m1 + m2 For k pairs of [ai bi], we find k / 2 new pairs pairs. Reapeat the procedure. Note that in the second run, your new value of n1 is (n1 + n2) from previous step. The same for m1. For k pairs we need the time complexity T(k) = k / 2 * (2n1 + n2 + m1 + m2) + T(k / 2). Put averages here: (E[ni] = E[mi] = n / k. ET(k) = k / 2 * (5 n / k) + ET(k / 2) = 2.5 n + ET(k / 2). For k / 2, the sizes of ni and mi are doubled. So we have ET[k] = 2.5 n + 2.5 n + .... + 2.5 log2(k) times. Then ET[k] = O(nlog(k)). Finally, average over "k". Note that k is O(n) for random arrays. Therefore, the overall complexity = O(n log(n)) Repeat it for all the k / 2 pairs.	2014-12-10 11:48:02		
638	sqzqo	5		2014-12-10 11:48:02		
639	ftfck	5		2014-12-10 11:48:02		
640	gilit	5	Method 2: For arrays, simple code O(n^2)	2014-12-10 11:48:02		
641	zeice	5		2014-12-10 11:48:02		
642	azmjc	5		2014-12-10 11:48:02		
643	nwkeg	5	Method 3: Data stored in linked list O(n)	2014-12-10 11:48:02		
644	nwkeg	5		2014-12-10 11:48:02		
645	ethan	5		2014-12-10 11:48:02		
646	vanul	5	import java.util.Arrays;  public class NegativeAndPositive {  private static final int[] array = new int[] { 100, -1, 5, 4, -7, 11, 12, 0, -2, -1, -10, 11, -2 };  public static void main(String[] args) {  for (int i = 0, j = array.length - 1; i < j;) {  if (array[i] < 0) { i++; continue; }  if (array[j] > 0) { j--; continue; }  swap(i, j);  }  System.out.println(Arrays.toString(array));  }  private static void swap(int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; }  }	2014-12-10 11:48:02		
647	gilit	5		2014-12-10 11:48:02		
648	ewigy	5		2014-12-10 11:48:02		
649	fmzze	5	wrong code.. for input array { -1, 1, 3, -2, 2 }, the result is [-1, -2, 3, 1, 2]. Expected result: [ -1, -2, 1, 3, 2, ]	2014-12-10 11:48:02		
650	tenuw	5	Do an in-place partition (i.e. from the quick sort algorithm) on the pivot value 0. However, the partition algorithm is not stable, but we can fix that without too much extra work and constant overhead.  Example:	2014-12-10 11:48:02		
651	huiqq	5		2014-12-10 11:48:02		
652	ethan	5		2014-12-10 11:48:02		
653	krxlv	5	By the way, a stable_partition is already implemented in STL if using C++ that does exactly what this question is asking.	2014-12-10 11:48:02		
654	plapd	5		2014-12-10 11:48:02		
655	huiqq	5		2014-12-10 11:48:02		
656	sqzqo	5	If you have to implement the stable_partition manutally, you can always use the STL rotate for the last step!	2014-12-10 11:48:02		
657	tenuw	5		2014-12-10 11:48:02		
658	nwkeg	5		2014-12-10 11:48:02		
659	nhibd	5	LOL. "Easy"? Have you even tried doing it yourself, rather than fanning yourself while waving your hands?	2014-12-10 11:48:02		
660	qywrh	5	And yeah, -100.	2014-12-10 11:48:02		
661	azmjc	5	O(n) and O(n)	2014-12-10 11:48:02		
662	zeice	5		2014-12-10 11:48:02		
663	tenuw	5		2014-12-10 11:48:02		
664	rrmeu	5	Nice! This is quite possibly the best solution possible, as doing it with O(1) memory is impossible.	2014-12-10 11:48:02		
665	dkebi	5	Coding with O(n) space and O(n) time is too easy. Let's use A to the original array. Create a new array B.	2014-12-10 11:48:02		
666	rdfeo	5		2014-12-10 11:48:02		
667	ethan	5		2014-12-10 11:48:02		
668	jippy	5	O(n) O(1)!	2014-12-10 11:48:02		
669	ewigy	5		2014-12-10 11:48:02		
670	ethan	5		2014-12-10 11:48:02		
671	sgiwy	5	Nice! Best yet!	2014-12-10 11:48:02		
672	ftfck	5	Just Kidding! That's O(n^2) :P	2014-12-10 11:48:02		
673	tenuw	5	right, memmove is O(n) while being in T(n) cycle, so overall is O(n^2).	2014-12-10 11:48:02		
674	qywrh	5	The n^2 solution would be:  Keep trace of a first met positive number = P. If you find a negative number = N, and P is set, then store P into T, insert value of N into positon P, shift the table right from P to N positon, insert T into P+1.  Can we really do it in O(n) without extra space?	2014-12-10 11:48:02		
675	qywrh	5		2014-12-10 11:48:02		
676	ethan	5	I thought rather bout a single variable.	2014-12-10 11:48:02		
677	qywrh	5		2014-12-10 11:48:02		
678	wbqzu	5		2014-12-10 11:48:02		
679	cfzie	5	It works fine, but This is n^2. consider the case when all +ve are at front and all -ve are at end	2014-12-10 11:48:02		
680	fmzze	5	This should work. how to compute the time complexity ?	2014-12-10 11:48:02		
681	nhibd	5		2014-12-10 11:48:02		
682	ethan	5		2014-12-10 11:48:02		
683	ftfck	5	That's O(n^2)	2014-12-10 11:48:02		
684	plapd	5	Thanks. But can you please tell me how did you arrive at it ? I always struggle at it.	2014-12-10 11:48:02		
685	zeice	5	Take this [1, -1, 2, -2,...,k, -k]  In order to move the first negative to the first position you need to shift 1 positive to the right. Now you get [-1, 1, 2, -2,...k, -k]  To move the second negative to the second postition you need to shift 2 positives to the right. Finally, to shift the kth negative to the kth position you need to shift k positives to the right. In total that is 1 + 2 +... + k = k*(k-1)/2 = O(k^2) = O(n^2) (since k = n/2 ) operations.	2014-12-10 11:48:02		
686	dgjji	5	thanks	2014-12-10 11:48:02		
687	fmzze	5	@fire It's very easy for general cases. If u have a single level loop in ur program then it is o(n). If there is a loop inside the loop(2 level), then its O(n^2). If inner loop executes only log n times(approx) then it is O(nlogn). If u hav loop inside loop inside loop then its O(n^3) and so on.	2014-12-10 11:48:02		
688	nwkeg	5	//Author : A.Nasimunni #include<stdio.h> main() { int n; printf("\n\tEnter the length of the array : "); scanf("%d",&n); int a[n],b[n]; int i=0; printf("\n\n\tEnter the elements into array \n"); for(i=0;i<n;i++) {printf("\t\t Enter : "); scanf("%d",&a[i]); } int k=0; for(i=0;i<n;i++) { if(a[i]<0) { b[k]=a[i];k=k+1; } else {k=k;} }   for(i=0;i<n;i++) { if(a[i]>0){b[k]=a[i];k++;}else{k=k;} }  for(i=0;i<k;i++) { printf(" %d",b[i]); } }	2014-12-10 11:48:02		
689	nwkeg	5	//Author : A.Nasimunni #include<stdio.h> main() { int n; printf("\n\tEnter the length of the array : "); scanf("%d",&n); int a[n],b[n]; int i=0; printf("\n\n\tEnter the elements into array \n"); for(i=0;i<n;i++) {printf("\t\t Enter : "); scanf("%d",&a[i]); } int k=0; for(i=0;i<n;i++) { if(a[i]<0) { b[k]=a[i];k=k+1; } else {k=k;} }   for(i=0;i<n;i++) { if(a[i]>0){b[k]=a[i];k++;}else{k=k;} }  for(i=0;i<k;i++) { printf(" %d",b[i]); } }	2014-12-10 11:48:02		
690	vanul	5	import java.util.ArrayList;   class Test {   public static void main(String[] args){  int[] arr = {-1, 1, 3, -2, 2,5,-7,-6}; ArrayList<Integer> list = new ArrayList<Integer>();  for(int i=0;i<arr.length;i++){  if(arr[i]<0){  list.add(arr[i]); } }  for(int i=0;i<arr.length;i++){  if(arr[i]>0){  list.add(arr[i]); } }  System.out.println(list); } }	2014-12-10 11:48:02		
691	rdfeo	5	space ??? you are using arraylist	2014-12-10 11:48:02		
692	rdfeo	5	So you only have to swap the last item in a run of positives or negatives. So you only have to keep an index of the last index of the previous signage run. The following code is O(N) and has O(1) space.  I don't handle the 0 case, because it is unclear what to do with that case.	2014-12-10 11:48:02		
693	sgiwy	5		2014-12-10 11:48:02		
694	bexbp	5		2014-12-10 11:48:02		
695	xhgls	5	Doesn't work for { 11, 1, 3, -2, -5, 2 }; Original: [11, 1, 3, -2, -5, 2] Output: [-2, -5, 3, 11, 1, 2]	2014-12-10 11:48:03		
696	tenuw	5	public int[] sortInOrder(int[] data){  int pos=0; int negPos=0; for (pos=0;pos<data.length;) {  if(data[pos]>=0){ while(negPos<data.length && data[negPos]>=0 ){ negPos++; }  if(negPos==data.length) break; while(negPos>pos){ int temp=data[negPos]; data[negPos]=data[negPos-1]; data[negPos-1] = temp; negPos--; } } negPos++; pos++;  }  return data; }	2014-12-10 11:48:03		
697	ufdxg	5		2014-12-10 11:48:03		
698	wbqzu	5		2014-12-10 11:48:03		
699	mrjku	5		2014-12-10 11:48:03		
700	nwkeg	5		2014-12-10 11:48:03		
701	admin	5	Works but O(n^2). You are swapping each negative value with all positives before it. So, potentially you will do it for all negatives in the input. So, worst case: O(n^2)	2014-12-10 11:48:03		
702	krxlv	5	If 0 exists, partition around it..Otherwise, insert a 0 and then partition around it. Please confirm if it's possible to add a 0 to the array in O(1) space.	2014-12-10 11:48:03		
703	xhgls	5	You don't need to physically add the zero. But it won't work. Remember that this is an array and insertion not possible. You can only swap. Ex: {1 -1 2 -2} turns into {-1 -2 2 1}	2014-12-10 11:48:03		
704	bexbp	5	The conventional partition algorithm isn't stable, so you'll end up ruining the original order of elements, which is a necessary condition for solving this problem. You can make partition stable by using an extra O(n) memory, but that also isn't permitted here.	2014-12-10 11:48:03		
705	sgiwy	5	Code on C#, I think this is O(n)	2014-12-10 11:48:03		
706	nhibd	5		2014-12-10 11:48:03		
707	azmjc	5		2014-12-10 11:48:03		
708	azmjc	5	Last loop should be	2014-12-10 11:48:03		
709	vanul	5		2014-12-10 11:48:03		
710	zeice	5		2014-12-10 11:48:03		
711	fmzze	5	Memory O(n), but O(1) was requested.	2014-12-10 11:48:03		
712	fowai	5	int main() { int arr[7] = {-1,-1,-3,-3,-2,-2,-8}; int size = sizeof(arr)/sizeof(*arr); cout<<size<<endl; int n=0; for(int i=0;i<size;i++) { if(arr[i]<0) { int temp = arr[i]; int j=i; while(j>n){ arr[j] = arr[j-1]; j--;} arr[n++]= temp;}} for(int i=0;i<size;i++) { cout<<arr[i]<<" "; }  return 0;}	2014-12-10 11:48:03		
713	wbqzu	5		2014-12-10 11:48:03		
714	dgjji	5		2014-12-10 11:48:03		
715	dgjji	5	you are taking extra space O(n)	2014-12-10 11:48:03		
716	mrjku	5		2014-12-10 11:48:03		
717	dgjji	5		2014-12-10 11:48:03		
718	krxlv	5	The idea here is when we encounter a positive number in the slot we're examining, we find the next negative number, store it in a temp variable, then shuffle over all the positives. Finally, insert the saved negative number into the current slot.  i.e. if we had: [ -1, <1>, 2, 3, 4, -2, ..]  When we encounter the 1, we search forward til we find the index of the -2, and we store that value. We then copy between our current index and that index:  [ -1, <1>, 1, 2, 3, 4, ....]  Then finally insert the saved number into our current location.  [-1, <-2>, 1, 2, 3, 4, ...]  Then we move onto examining the next index.  <strike>This is O(n) in the worst case, because in [3,2,1,-3,-2,-1], we perform n/2 shuffles, where each shuffle swaps at most n/2 elements. n/2 * n/2 = O(n).</strike>  It's actually O(n^2), thanks for the correction lxduan.	2014-12-10 11:48:03		
719	huiqq	5		2014-12-10 11:48:03		
720	zeice	5		2014-12-10 11:48:03		
721	vanul	5	shouldn't it be O(n^2)?	2014-12-10 11:48:03		
722	ufdxg	5	Yep you're right. It's O(n) if you store an extra array with all the indices of negative numbers, but then that's O(n) space. My bad.	2014-12-10 11:48:03		
723	krxlv	5	Same as I thought, actually it can be optimized, the current_index can jump directly to the next_negative_index previously found. For example: [ -1, <1>, 2, 3, 4, -2, -3, ..] suppose after first iteration, we get: [ -1, -2 , 1, 2, 3, 4, -3 ..] then we can let current_index jump to <4> (the position of -2 before swap) directly instead of starting from <1> , and then repeat the iteration.  This is O(n) regardless of the swapping part...	2014-12-10 11:48:03		
724	ufdxg	5	we need two arrays ary1, ary2 ; both size of n, for positive values and negative values	2014-12-10 11:48:03		
725	cfzie	5		2014-12-10 11:48:03		
726	ftfck	5		2014-12-10 11:48:03		
727	admin	5	The fact that ary1 and ary2 are built up as we read the target array from bgn to end guarantees that relative positions between values of the same sign would not change	2014-12-10 11:48:03		
728	dgjji	5	1.arrange the first half as negative and second half as negative 2.then call quick sort for first half of the array check for abs(i) pos with abs(j) 3.then call quick sort for the second half of the array  the complexity is O(n) for arranging positive and negative numbers and O(nlogn)+O(nlogn) for sorting... still can we have better solution :)	2014-12-10 11:48:03		
729	jippy	5	In worst case quick sort takes o(n^2) time if the recurrence formulae is T(n) = T(n-1) + o(n) so the worst case timing is O(n^2) not O(nlogn)	2014-12-10 11:48:03		
730	krxlv	5	public class google {  public static void main(String[] args) { int[] a={-1,1,3,-2,2}; int neg=0; int pos=0;  for(int i=0;i<a.length;i++){ if(a[i]<0) neg++; else pos++; }  int countneg=0; int i=0; int j=1; int k=0; int temp=0; while(countneg<neg){ if(a[i]<0){ countneg++; i++; } else{ j=i; k=i; while(a[k]>0){ k++; } temp=a[j]; a[j]=a[k]; for(int z=k;z>j;z--){ a[z]=a[z-1]; } a[j+1]=temp; countneg++; i++; } }  for(i=0;i<a.length;i++){ System.out.println(a[i]); } }  }	2014-12-10 11:48:03		
731	qywrh	5		2014-12-10 11:48:03		
732	fmzze	5		2014-12-10 11:48:03		
733	gilit	5		2014-12-10 11:48:03		
734	qywrh	5		2014-12-10 11:48:03		
735	xhgls	5	How is this O(n)? Please explain.	2014-12-10 11:48:03		
736	qywrh	5	This takes O(n^2) time. You are shifting O(n) positive numbers for each of O(n) negative numbers.	2014-12-10 11:48:03		
737	jippy	5	#include <stdio.h>  void swapT(int* a,int* b, int *c){ int temp=*c; *c=*b; *b=*a; *a=temp; }  #define N 5  int main(){ int i, pos, mid, neg = 0; int a[] = {-1,1,3,-2,2}; for (i = 0; i < N; i++) printf (" %d ", a[i]); printf ("\n"); int totNeg = 0; for (i = 0; i < N; i++){ if (a[i] < 0) totNeg++; } mid = totNeg; pos = totNeg; while (totNeg > 0){ if (a[neg] < 0){ neg++; totNeg--; } else { while (a[pos] >= 0) pos++; swapT(&a[neg], &a[mid], &a[pos]); neg++; pos++; mid++; totNeg--; } }  for (i = 0; i < N; i++) printf (" %d ", a[i]); printf ("\n");  return 0; }	2014-12-10 11:48:03		
738	vanul	5		2014-12-10 11:48:03		
739	gilit	5		2014-12-10 11:48:03		
740	bexbp	5	My apology, previous code is not work for some special test data, so i edit and add the second one.	2014-12-10 11:48:03		
741	zeice	5		2014-12-10 11:48:03		
742	fmzze	5		2014-12-10 11:48:03		
743	sqzqo	5		2014-12-10 11:48:03		
744	gilit	5		2014-12-10 11:48:03		
745	admin	5	} It's O(N) time and (N) memory , i can't find solution with less memory.	2014-12-10 11:48:03		
746	jippy	5	public void sortIntegers(int[] intarray) { for(int h=0;h<intarray.length;h++) System.out.print(intarray[h]+ " ");  int lastnegative = 0; for(int i=0; i< intarray.length;i++) { if(intarray[i]<0) { swap(intarray,lastnegative,i); lastnegative = lastnegative+1; } } System.out.println(); for(int m=0;m<intarray.length;m++) System.out.print(intarray[m]+ " ");  } void swap(int[] intarray, int lnegative, int j) { int temp = intarray[j]; for(int k = j-1;k>=lnegative;k--) { intarray[k+1] = intarray[k]; } intarray[lnegative] = temp; }	2014-12-10 11:48:03		
747	tenuw	5	we can also use queue data structure like this in Java public class Sort {  public static void sortArray(int[] a) { int N = a.length; Queue<Integer> q1 = new Queue<Integer>(); Queue<Integer> q2 = new Queue<Integer>();  for (int i = 0; i<N; i++) { if(a[i] < 0 ) q1.enqueue(a[i]); else q2.enqueue(a[i]); } int i = 0; while (!q1.isEmpty()) a[i++] = q1.dequeue(); while(!q2.isEmpty()) a[i++] = q2.dequeue();  }  public static void main(String[] args) { int[] a = {-1,1,3,-2,2}; sortArray(a); for (int i =0; i<a.length;i++) System.out.println(a[i]); }   }	2014-12-10 11:48:03		
748	admin	5	NOT possible in o(n)time complexity and o(1) space complexity	2014-12-10 11:48:03		
749	huiqq	5	Yes, if o(n) means small Oh of n, which completely different from O(n), BigOh of n.  If you did mean BigOh, whatever proof you have, is likely wrong.  There was a link to a paper which just does that, somewhere in the comments on this question.	2014-12-10 11:48:03		
750	fmzze	5	If this wasn't an array it would be doable!  if you had a linked list you could easily do this in one pass!  Just link the negative list together then link the last item with the first positive.	2014-12-10 11:48:03		
751	wbqzu	5		2014-12-10 11:48:03		
752	cfzie	5		2014-12-10 11:48:03		
753	gilit	5	Otherwise, I do not believe this problem is solvable.	2014-12-10 11:48:03		
754	wbqzu	5	[ o(1) space, by time complexity is not o(n) :( ]	2014-12-10 11:48:03		
755	wbqzu	5		2014-12-10 11:48:03		
756	bexbp	5		2014-12-10 11:48:03		
757	zeice	5	In O(n) time and O(1) space.	2014-12-10 11:48:04		
758	azmjc	5		2014-12-10 11:48:04		
759	huiqq	5		2014-12-10 11:48:04		
760	vanul	5	It uses O(1) space but time used is O(m^2) where m is number of negetive integers there.	2014-12-10 11:48:04		
761	eucmc	5	This is like merge sort with a twist. The best solution I can think of for an O(1) space complexity is O(nlogn) time complexity. The trick is to think in terms of merge sort and perform matrix rotation through reverse	2014-12-10 11:48:04		
762	ufdxg	5		2014-12-10 11:48:04		
763	xhgls	5		2014-12-10 11:48:04		
764	huiqq	5	T(n) = 2T(n/2)+o(n). o(n) being the rotation function. Then time complexity is O(nlogn). I dont really think any type of sorting can occur in O(n) but if someone come up with a solution, thatd be good.	2014-12-10 11:48:04		
765	nhibd	5	Forgot to comment this on the code. The order function return the number of positive items in the array. So p1 is the positive items in the first half or the array. p2 is the positive items in the second half of the array.	2014-12-10 11:48:04		
766	nhibd	5		2014-12-10 11:48:04		
767	huiqq	5		2014-12-10 11:48:04		
768	wbqzu	5	ideone.com/jYtdmD	2014-12-10 11:48:04		
769	cfzie	5		2014-12-10 11:48:04		
770	cfzie	5		2014-12-10 11:48:04		
771	huiqq	5	I believe its in O(n) time and definitely O(1) space, Can some analyze for a worst case to prove otherwise.	2014-12-10 11:48:04		
772	dgjji	5	I haven't figured out the O(N) solution given an array, but it'd be easy to do with a linked list. Then you could just keep track of pointers for the end of the positive and negative lists, and then connect them in the end, with O(1) space (all you'd need is three pointers, one for the current position, one for the start of the positive list and one for the start of the negative).	2014-12-10 11:48:04		
773	bexbp	5	This is the best I got keeping the space on O(1) and O(n) without zeros Wasn't sure by the description if the array has zeros in it so added code to handle but not without extra time	2014-12-10 11:48:04		
774	plapd	5		2014-12-10 11:48:04		
775	fmzze	5		2014-12-10 11:48:04		
776	fmzze	5	function for the solution is given below,it solves the problem in O(n) time:	2014-12-10 11:48:04		
777	cfzie	5		2014-12-10 11:48:04		
778	admin	5		2014-12-10 11:48:04		
779	mrjku	5		2014-12-10 11:48:04		
780	dkebi	5		2014-12-10 11:48:04		
781	qywrh	5	Nice, but doesn't maintain order. (Swapping makes it unstable.) Ex: Input: 1 -2 3 -3 2 -1 1 -2 3 -3 2 -1 Output: -2 -2 -3 -3 -1 -1 1 1 3 3 2 2 Expected: -2 -3 -1 -2 -3 -1 1 3 2 1 3 2	2014-12-10 11:48:04		
782	nhibd	5		2014-12-10 11:48:04		
783	nhibd	5		2014-12-10 11:48:04		
784	rrmeu	5	public static void sort(int[] array){  int cout_pos = 0; int count_neg = 0; int sum_pos = 0; int sum_neg = 0; int neg_co = 1; int pos_co = 1;  for(int i=0; i!=array.length; ++i){ if(array[i] < 0){ neg_co *= 10; count_neg++; sum_neg += -1 * array[i] * neg_co;  } else{ pos_co *= 10; cout_pos++; sum_pos += array[i] * pos_co;  } }  //put them back in the array for(int i = count_neg -1; i!=0; --i){ array[i] = -1*(sum_neg / neg_co); sum_neg -= array[i] * neg_co; neg_co /= 10;  }  for(int i = array.length-1; i!=count_neg-1; --i){ array[i] = sum_pos / pos_co; sum_pos -= array[i] * pos_co; pos_co /= 10;  } }	2014-12-10 11:48:04		
785	bjsiw	5		2014-12-10 11:48:04		
786	huiqq	5		2014-12-10 11:48:04		
787	admin	5		2014-12-10 11:48:04		
788	xhgls	5		2014-12-10 11:48:04		
789	ewigy	5	1. Multiply all negative numbers by 10 and odd numbers by 10 and add 1 2. sort the array using stable sorting algorithm considering only the last digit of the number -10 -20 11 31 21 3. divide all elements by 10 -1 -2 1 3 2 This is O(N) and O(1) OR  2. O(NlogN) soln - sort using any standard algo considering only the last digit	2014-12-10 11:48:04		
790	huiqq	5		2014-12-10 11:48:04		
791	nwkeg	5		2014-12-10 11:48:04		
792	huiqq	5	This is linear time but also O(n) memory (for the hash map src_pos)	2014-12-10 11:48:04		
793	plapd	5	I know time complexity is O(n^2).	2014-12-10 11:48:04		
794	xhgls	5		2014-12-10 11:48:04		
795	xhgls	5		2014-12-10 11:48:04		
796	eucmc	5	Two Threaded solution: One thread starts from n direction left to right. Another thread from 1 right to left. LR thread stops if it encounters -ve and waits for RL to encounter positive. If so swap. Iteration breaks if two threads cross path. o(n), o(1).	2014-12-10 11:48:04		
797	zeice	5		2014-12-10 11:48:04		
798	admin	5		2014-12-10 11:48:04		
799	vanul	5	I believe I have achieved O(n) time and O(1) extra space complexity:-  Let us maintain such an invariant at all times:   The first n numbers of the array are negative. The next p numbers of the array are positive. So let the array look like this:  -ve -ve -ve ... -ve; +ve +ve +ve ... +ve; -ve .... n times p times remaining   Now let us find n1 and p1 such that  -ve -ve -ve ... -ve; +ve +ve +ve ... +ve; -ve -ve -ve ... -ve; +ve +ve +ve .... +ve; -ve .... n times p times n1 times p1 times remaining  Now let us try to 'consume' the n1 and p1 elements in the n and p elements. We can do this by swapping the 2nd and 3rd blocks(p and n1 elements). If we can do this in O(p+n1) time, then increment n to be n+n1 and p to be p+p1 and keep doing this, we should be able to do this for the whole array in O(n) time.  So the challenge is this:  x1 x2 x3 ... xp; y1 y2 y3 ... yq has to be rearranged to form y1 y2 y3 ... yq; x1 x2 x3 ... xp in O(p+q) time.  If p==q, then it's easy. Just keep on swapping x1, y1; x2, y2 and so on. If p!=q, suppose p>q without loss of generality. Then swap the elements y1..yq and x1..xq to get  y1 y2 y3 ... yq xq+1 xq+2 ... xp x1 x2 x3 ... xq  and repeat the procedure for the subarray xq+1 xq+2 ... xp; x1 x2 x3 ... xq  This way, it is possible to swap an unequal number of elements in place in O(n) time and O(1) extra space.  Code:	2014-12-10 11:48:04		
800	bexbp	5		2014-12-10 11:48:04		
801	azmjc	5		2014-12-10 11:48:04		
802	sqzqo	5	This code takes .325 seconds for 10,000 elements.	2014-12-10 11:48:04		
803	xhgls	5	Try proving it. It is likely wrong. (And don't ask for a counter-example).	2014-12-10 11:48:04		
804	eucmc	5		2014-12-10 11:48:04		
805	nwkeg	5		2014-12-10 11:48:04		
806	vanul	5	public static void reArrageArray(int []data) { int loopCount = 0; int nPos = -1; for (int i = 0; i < data.length; i++) { int nValue = data[i]; if (nValue < 0) { //2 if (nPos != i-1) { for (int j = i ; j > 0; j--) { if (data[j-1] >= 0) { data[j] = data[j-1]; data[j-1] = nValue; } else { nPos = j; } loopCount++; } } else { nPos = i; loopCount++; }  } else { loopCount++; } } System.out.println("Total loop count : " + loopCount); for (int i = 0; i < data.length; i++) { System.out.println(data[i]); }  }	2014-12-10 11:48:04		
807	wbqzu	5	How about do the "dividing" part of quicksort with the value 0 as the pivot. All values lesser than 0 will be on left and values greater than 0 will be on right.  Takes O(n) time.  Not sure about whether the relative positions are maintained.	2014-12-10 11:48:04		
808	ufdxg	5		2014-12-10 11:48:04		
809	tenuw	5		2014-12-10 11:48:04		
810	dkebi	5	It seems not that difficult, someone did mention 'mergesort' but no one mentioned how to make it O(N): So, how about using a special version of mergesort recursively, where "merge" involves inserting +ve and -ve parts of the 'right' sub-list into the 'left' sub-list, this "merge" will take O(1), leading to O(N) for the whole mergesort?	2014-12-10 11:48:04		
811	krxlv	5	This is not possible in O(1) space, O(n) time is fine. I guess interviewer wanted to see if interviewee is confident enough to say this.	2014-12-10 11:48:04		
812	nhibd	5	He would be confident and wrong. I guess that puts him squarely in the arrogant bucket.	2014-12-10 11:48:04		
813	tenuw	5	for O(1) space, can we not allocate max integer space and then fill it sequentially with occurred positive integers in given array, and then fill them back in original array from end of the array, here we will ensure that all -ve integers are pulled ahead. (filling up in original array should be easy). Help expand this logic if makes sense.	2014-12-10 11:48:04		
814	dgjji	5	<vector> A() algorithm group(A) { n<-- length(A) k=n+1 for i<-- 0 to n do { if(A[i]>0) { A[k]=A[i] A.erase(A.begin()+i) k=k+1 } } }	2014-12-10 11:48:04		
815	bjsiw	5	#include<iostream> using namespace std;  void swapp(int* a,int* b) { int t= *a; *a=*b; *b=t; }  int main() { int n; cin>>n; int* a=new int[n]; for(int i=0;i<n;i++) cin>>a[i];  int countneg=0,countpos=0; for(int i=0;i<n;i++) { if(a[i]<0)countneg++; else countpos++; } cout<<countneg<<" "<<countpos<<endl; int j=0,tempcount=countneg; for(int i=0;i<n;i++) { if(a[i]>0 && i<countneg) { swapp(&a[i],&a[tempcount]); tempcount++; } else if(a[i]<=0) { swapp(&a[i],&a[j]); j++;if(i>0) i--; } else continue;  } for(int i=0;i<n;i++) cout<<a[i]<<" "; delete []a; }	2014-12-10 11:48:04		
816	xhgls	5	Do an in-place partition (i.e. from the quick sort algorithm) on the pivot value 0. However, the partition algorithm is not stable, but we can fix that without too much extra work and constant overhead.  Example:	2014-12-10 11:48:04		
817	vanul	5		2014-12-10 11:48:04		
818	qywrh	5		2014-12-10 11:48:04		
819	azmjc	5	By the way, a stable_partition is already implemented in STL if using C++ that does exactly what this question is asking.	2014-12-10 11:48:04		
820	dkebi	5		2014-12-10 11:48:05		
821	bjsiw	5		2014-12-10 11:48:05		
822	sgiwy	5	If you have to implement the stable_partition manutally, you can always use the STL rotate for the last step!	2014-12-10 11:48:05		
823	ethan	5		2014-12-10 11:48:05		
824	fowai	5		2014-12-10 11:48:05		
825	sqzqo	5	The quicksort partition swaps at most n times, and compares each element once with the pivot giving a running time O(n).  The partition is done in-place, so only O(1) memory overhead.	2014-12-10 11:48:05		
826	zeice	5	With a singly linked list (instead of an array) you can obtain O(n) time complexity and O(1) space complexity:	2014-12-10 11:48:05		
827	ftfck	5		2014-12-10 11:48:05		
828	bjsiw	5		2014-12-10 11:48:05		
829	plapd	5	O(n) time O(1) space solution:	2014-12-10 11:48:05		
830	fowai	5		2014-12-10 11:48:05		
831	xhgls	5		2014-12-10 11:48:05		
832	cfzie	5	forgot to copy the initialization of i and j	2014-12-10 11:48:05		
833	fowai	5		2014-12-10 11:48:05		
834	sqzqo	5		2014-12-10 11:48:05		
835	ethan	5	I don't think this solution will maintain relative order. Can you give an example?	2014-12-10 11:48:05		
836	qywrh	5	complexity is little more than (n)...	2014-12-10 11:48:05		
837	krxlv	5		2014-12-10 11:48:05		
838	jippy	5		2014-12-10 11:48:05		
839	eucmc	5		2014-12-10 11:48:05		
840	nhibd	5		2014-12-10 11:48:05		
841	dkebi	5	O(n) :)	2014-12-10 11:48:05		
842	ethan	5	I have a completly different approach.  What I would suggest is to use Godel numbering to hold the array. we will have 2 Godel numbering. one for the positive numbers, and one for the negative ones.  The godel numbers will be created based on the position of the numbers in the array.  there are some issues in the solution, such as Godel number might grow exponentially with n, and also that if the numbers are not in N, this method won't work.  but still this is a cool approach, maybe someone can develop it a bit more.	2014-12-10 11:48:05		
843	ewigy	5	Using double pointers. The first pointer is to head and the other one to tail.  If the first pointer value is less than zero, first pointer move one step forward. Otherwise, if first pointer greater than zero, waiting second pointer scan from tail till find the first one which is negative.  The complex is O(1) (the constant is 1) and space is O(1) .	2014-12-10 11:48:05		
844	azmjc	5		2014-12-10 11:48:05		
845	zeice	5		2014-12-10 11:48:05		
846	nwkeg	5	int negatifindex=0; int prevnegatifindex=-1; int pozitifindex=4; // array.length-1 int nextpozitifindex=-1; while (negatifindex<=pozitifindex) { if(array[negatifindex]<0) { if (prevnegatifindex!=-1) swap(array[prevnegatifindex],array[negatifindex]) prevnegatifindex=-1; negatifindex++;  } if(array[pozitifindex]>0) { if (nextpozitifindex!=-1) swap(array[nextpozitifindex],array[pozitifindex]) nextpozitifindex=-1; pozitifindex--; } if (array[pozitifindex]<0 & array[negatifindex]>0) { swap(array[pozitifindex],array[negatifindex]) prevnegatifindex=negatifindex;, pozitifindex--; nextpozitifindex=pozitifindex; negatifindex++; } }  Time complexity is O(n) and space is O(1)	2014-12-10 11:48:05		
847	cfzie	5	Let's solve this problem by diving it into two much simpler problems: A) We want negative numbers to be at the right positions; we don't care about the positive one B) We move the positive numbers at the right positions, not caring about the negative one C) We apply A B on copies of the array and then combine the result to get the final solution  A and B can be easily solve linearly.  Solution for A: {{ void solveA(int* a, int n) { int p = 0; for (int i = 0; i < n; i++) if (a[i] < 0) { a[p] = a[i]; p++ } } }}  For B the solution is similar.  C) is also quite easy. We just need to count how many negative and positive number we have in order to know how many values to copies from the two partial solution.  Complexity: O(n) both time and space	2014-12-10 11:48:05		
848	ethan	5		2014-12-10 11:48:05		
849	mrjku	5		2014-12-10 11:48:05		
850	dgjji	5	O(n) and O(n)	2014-12-10 11:48:05		
851	tenuw	5		2014-12-10 11:48:05		
852	wbqzu	5		2014-12-10 11:48:05		
853	ethan	5	Here's the simple code, where you shift right everything when you encounter negative number.	2014-12-10 11:48:05		
854	admin	5		2014-12-10 11:48:05		
855	rdfeo	5		2014-12-10 11:48:05		
856	huiqq	5	This works in O(n) time and O(1) space.  Algorithm:	2014-12-10 11:48:05		
857	bexbp	5		2014-12-10 11:48:05		
858	fmzze	5		2014-12-10 11:48:05		
859	fmzze	5	Here is my solution O(n) time and constant space complexity 1) count number of negative numbers in the array 2) set the index where positive number is supposed to start as pivot 3) count number of positive numbers before pivot and after pivot 4) iterate each number in the array until pivot a) if number is negative proceed b) if number if positive initiate rearrangment to place each number in its correct position until we come back to current position.  c++ code	2014-12-10 11:48:05		
860	eucmc	5		2014-12-10 11:48:05		
861	wbqzu	5		2014-12-10 11:48:05		
862	ewigy	5	Instead of numbers we should work with segments of positive or negative numbers. Lets say the numbers are [1 2 -1 -2 -3 4 5 6 -7 -8 -9].  initial segments: [1 2], [-1 -2 -3]*, [4 5 6], [-7 -8 -9] step 1. [-1 -2], [1 2]*, [-3], [4 5 6], [-7 -8 -9] ... pushed right seg to left, 2 swaps step 2. [-1 -2 -3], [1 2 4 5 6]*, [-7 -8 -9] ... pushed left seg to right, 2 swaps step 3. [-1 -2 -3], [1 2], [-7 -8 -9]*, [4 5 6] ... pushed left seg to right, 3 swaps step 4. [-1 -2 -3 -7 -8], [1 2]*, [-9], [4 5 6] ... pushed right seg to left, 2 swaps step 5. [-1 -2 -3 -7 -8 -9], [1 2 4 5 6] ... pushed left seg to right, 2 swaps  Total 11 swaps.  Lets say the negative segment is N and the positive segment is P. Now, given a situation like "[all negative], P, N, [unknown]", we need to do the following.  1. If |N| >= |P|, send right segment to left, total swap needed |N|+|P| 2. If |N| < |P|, send left segment to right, total swap needed |N|+|P|  Amortized O(n).	2014-12-10 11:48:05		
863	nhibd	5	Please let me know if it has any problem? it is in O(N) time complexity and O(1) space.	2014-12-10 11:48:05		
864	admin	5		2014-12-10 11:48:05		
865	krxlv	5		2014-12-10 11:48:05		
866	qywrh	5		2014-12-10 11:48:05		
867	dkebi	5		2014-12-10 11:48:05		
868	eucmc	5	public static void main(String[] arg) { int[] arr = { -1, 1, 3, -2, 2, -7, 8 }; System.out.println(Arrays.toString(arr)); for (int i = 0; i < arr.length; i++) { if (arr[i] < 0) { checkAndSwap(arr, i); } } System.out.println(Arrays.toString(arr)); } private static void checkAndSwap(int[] arr, int currIndex) { for (int i = currIndex - 1; i > 0; i--) { if (arr[i] > 0) { int temp = arr[i]; arr[i] = arr[currIndex]; arr[currIndex] = temp; currIndex = i; } else { break; } } }	2014-12-10 11:48:05		
869	dkebi	5	{ public static void main(String[] arg) { int[] arr = { -1, 1, 3, -2, 2, -7, 8 }; System.out.println(Arrays.toString(arr)); for (int i = 0; i < arr.length; i++) { if (arr[i] < 0) { checkAndSwap(arr, i); } } System.out.println(Arrays.toString(arr)); } private static void checkAndSwap(int[] arr, int currIndex) { for (int i = currIndex - 1; i > 0; i--) { if (arr[i] > 0) { int temp = arr[i]; arr[i] = arr[currIndex]; arr[currIndex] = temp; currIndex = i; } else { break; } } } }	2014-12-10 11:48:05		
870	krxlv	5	public class TestLogic {  public static void main(String[] arg) { int[] arr = { -1, 1, 3, -2, 2, -7, 8 }; System.out.println(Arrays.toString(arr)); for (int i = 0; i < arr.length; i++) { if (arr[i] < 0) { checkAndSwap(arr, i); } } System.out.println(Arrays.toString(arr)); } private static void checkAndSwap(int[] arr, int currIndex) { for (int i = currIndex - 1; i > 0; i--) { if (arr[i] > 0) { int temp = arr[i]; arr[i] = arr[currIndex]; arr[currIndex] = temp; currIndex = i; } else { break; } } } }	2014-12-10 11:48:05		
871	xhgls	5	public class TestLogic {  public static void main(String[] arg) { int[] arr = { -1, 1, 3, -2, 2, -7, 8 }; System.out.println(Arrays.toString(arr)); for (int i = 0; i < arr.length; i++) { if (arr[i] < 0) { checkAndSwap(arr, i); } } System.out.println(Arrays.toString(arr)); } private static void checkAndSwap(int[] arr, int currIndex) { for (int i = currIndex - 1; i > 0; i--) { if (arr[i] > 0) { int temp = arr[i]; arr[i] = arr[currIndex]; arr[currIndex] = temp; currIndex = i; } else { break; } } } }	2014-12-10 11:48:05		
872	eucmc	5	The problem can indeed be solved in O(n) time and with O(1) complexity.  Below is my solution:	2014-12-10 11:48:05		
873	rrmeu	5		2014-12-10 11:48:05		
874	eucmc	5		2014-12-10 11:48:05		
875	gilit	5	Approach:  Think of the array as continguous streaks of positive and negative integers: [n0 p1, n1, p2, n2, p3, n3, ...]  Each streak can have any number of integers in it.  We can ignore the leading streak of negative integers (if any) because they are already in the sorted position.  Now we need to find a solution to sort each [pi, ni] pair or a positive streak followed by a negative streak.  After sorting [pi, ni] we get [ni, pi] -- essentially swap/switch the locations of the streaks.  To do this, do the following steps  -- Reverse pi to get rev(pi) -- Reverse ni to get rev(ni) -- Reverse [ rev(pi), rev(ni) ] to get [ rev(rev(ni)), rev(rev(pi)) ] which is equal to [ni, pi]  This is very similar to reversing all the words within a sentence (not the whole sentence).  I would appreciate it if you could correct me if i am wrong anywhere.	2014-12-10 11:48:05		
876	qywrh	5	My solution in C++ below. Running time is O(n) (two passes) and it's done in place (O(1) extra-space) :	2014-12-10 11:48:05		
877	jippy	5		2014-12-10 11:48:05		
878	nhibd	5		2014-12-10 11:48:05		
879	fmzze	5	There is a paper showing O(n) time and O(1) space algorithm "Stable minimum space partitioning in linear time." diku.dk/hjemmesider/ansatte/jyrki/Paper/KP92b.pdf	2014-12-10 11:48:05		
880	plapd	5		2014-12-10 11:48:06		
881	zeice	5		2014-12-10 11:48:06		
882	plapd	5		2014-12-10 11:48:06		
883	zeice	5		2014-12-10 11:48:06		
884	ethan	5	bool isNegative(int t) { return t < 0 ? true : false; }  void sort(int A[], int n) { std::stable_partition(A, A + n, isNegative); }	2014-12-10 11:48:06		
885	eucmc	5	bool isNegative(int t) { return t < 0 ? true : false; }  void sort(int A[], int n) { std::stable_partition(A, A + n, isNegative); }	2014-12-10 11:48:06		
886	huiqq	5	bool isNegative(int t) { return t < 0 ? true : false; }  void sort(int A[], int n) { std::stable_partition(A, A + n, isNegative); }	2014-12-10 11:48:06		
887	nhibd	5	bool isNegative(int t) { return t < 0 ? true : false; }  void sort(int A[], int n) { std::stable_partition(A, A + n, isNegative); }	2014-12-10 11:48:06		
888	zeice	5	The following solution seems like O(n) time and O(1) to me. Comments?	2014-12-10 11:48:06		
889	krxlv	5		2014-12-10 11:48:06		
890	rdfeo	5		2014-12-10 11:48:06		
891	gilit	5		2014-12-10 11:48:06		
892	ewigy	5		2014-12-10 11:48:06		
893	krxlv	5	}	2014-12-10 11:48:06		
894	rdfeo	5		2014-12-10 11:48:06		
895	zeice	5		2014-12-10 11:48:06		
896	nhibd	5	}	2014-12-10 11:48:06		
897	rdfeo	5	void reOrder(final int[] a, final int n) { int j = 0; for (int i = 0; i < n; i++) { if (a[i] < 0) { int k = i; while (k - 1 >= j && a[k - 1] > 0) { final int temp = a[k]; a[k] = a[k - 1]; a[k - 1] = temp; k--; } j++; } } }	2014-12-10 11:48:06		
898	dgjji	5	{ void reOrder(final int[] a, final int n) { // TODO Auto-generated method stub int j = 0; for (int i = 0; i < n; i++) { if (a[i] < 0) { int k = i; while (k - 1 >= j && a[k - 1] > 0) { final int temp = a[k]; a[k] = a[k - 1]; a[k - 1] = temp; k--; } j++; } } } }	2014-12-10 11:48:06		
899	eucmc	5	{code}  void reOrder(final int[] a, final int n) { // TODO Auto-generated method stub int j = 0; for (int i = 0; i < n; i++) { if (a[i] < 0) { int k = i; while (k - 1 >= j && a[k - 1] > 0) { final int temp = a[k]; a[k] = a[k - 1]; a[k - 1] = temp; k--; } j++; } } }	2014-12-10 11:48:06		
900	plapd	5	This works.  void reOrder(final int[] a, final int n) { // TODO Auto-generated method stub int j = 0; for (int i = 0; i < n; i++) { if (a[i] < 0) { int k = i; while (k - 1 >= j && a[k - 1] > 0) { final int temp = a[k]; a[k] = a[k - 1]; a[k - 1] = temp; k--; } j++; } } }	2014-12-10 11:48:06		
901	rrmeu	5	This works.  void reOrder(final int[] a, final int n) { // TODO Auto-generated method stub int j = 0; for (int i = 0; i < n; i++) { if (a[i] < 0) { int k = i; while (k - 1 >= j && a[k - 1] > 0) { final int temp = a[k]; a[k] = a[k - 1]; a[k - 1] = temp; k--; } j++; } } }	2014-12-10 11:48:06		
902	fowai	5	If anybody comes up with an O(1) space, O(n) time solution, we can work together and write a paper on in-place, stable, O(n logn) worst-case sorting algorithm.	2014-12-10 11:48:06		
903	vanul	5	Here is the java implementation for O(n) time complexity, O(1) space complexity solution. Pretty sure others would have answered it already on this forum...I just did not take time to go through all the solutions.	2014-12-10 11:48:06		
904	sqzqo	5		2014-12-10 11:48:06		
905	ftfck	5		2014-12-10 11:48:06		
906	wbqzu	5	Can anyone find something wrong with this? It should be O(n)/O(1).	2014-12-10 11:48:06		
907	bjsiw	5		2014-12-10 11:48:06		
908	rrmeu	5		2014-12-10 11:48:06		
909	rrmeu	5	Below is basically a merge-sort implementation. I did this in Python but easy to port to C. It is O(N logN) I think (log N calls to sort, merge is O(n)), and could be farmed out to multiple machines too for each independent part for scale. Not sure how to evaluate space usage -- do you count the stack? Also, the Python tuple concatenation and list division is not ideal in memory usage of course but could easily be improved and done in-place in C.	2014-12-10 11:48:06		
910	tenuw	5		2014-12-10 11:48:06		
911	sqzqo	5		2014-12-10 11:48:06		
912	nhibd	5	example: -1 , 1 , 3 , -2 , 2, -4 , 4 , 5 , -5  O(n) time O(1) space solution  Count the number of negative elements (k = 4 here) , as a first step try to get first 4 elements in correct order, every time you swap an element out record its index, let f be the encoding function for negatives and g for positives. Step1.1 : -1 , 1 , -4 , -5 , 2 , g(3,3), 4 , 5 , f(-2,4) Step1.2 ( f(x,y) will be in the order f(x1, y1), f(x2, y2), f(x3, y3) , ..., where y1 < y2 < y3 < .. , same property holds for g). But you have the rest of the negative elements in their final destinations, freeze these elements. Treat f(x,y) as your new negatives on an array, perform swaps similar to step1, let h be the encoding function for positives dislocated in this step: -1 , f(-2,4) , -4 , -5 , 2 , g(3,3) , 4 , 5 , h(1,2) Step2: Stable sort the unfrozen negative elements Step3: Now you are done with all the negatives. You have the property max(y / h(x,y)) < max(y / g(x,y)), again h(x,y) will appear in increasing order of y. Stable sort h union g relative to the other positives: <all negatives> , h(1,2) , g(3,3), 2 , 4 , 5  You can always pick to work on the positives first / negatives first based on the sizes of arrays appearing in the recursive step. So you would have T(n) = O(n) + T(a) + T(b) ( where a+b < 3n/4) so T(n) = O(n)  It is unreasonable to expect someone to solve this within 1 hour	2014-12-10 11:48:06		
913	wbqzu	5		2014-12-10 11:48:06		
914	plapd	5		2014-12-10 11:48:06		
915	ftfck	5		2014-12-10 11:48:06		
916	ufdxg	5		2014-12-10 11:48:06		
917	rrmeu	5		2014-12-10 11:48:06		
918	tenuw	5		2014-12-10 11:48:06		
919	ftfck	5	Bubble sort, only a[i]>0&&a[i+1]<0 will exchange each other Code:	2014-12-10 11:48:06		
920	krxlv	5		2014-12-10 11:48:06		
921	cfzie	5		2014-12-10 11:48:06		
922	krxlv	5	Bubble sort, only a[i]>0&&a[i+1]<0 will exchange each other Code:	2014-12-10 11:48:06		
923	dkebi	5		2014-12-10 11:48:06		
924	ewigy	5		2014-12-10 11:48:06		
925	sqzqo	5	Bubble sort, only a[i]>0&&a[i+1]<0 will exchange each other Code:	2014-12-10 11:48:06		
926	azmjc	5		2014-12-10 11:48:06		
927	cfzie	5		2014-12-10 11:48:06		
928	wbqzu	5	Bubble sort, only a[i]>0&&a[i+1]<0 will exchange each other Code:	2014-12-10 11:48:06		
929	dkebi	5		2014-12-10 11:48:06		
930	rdfeo	5		2014-12-10 11:48:06		
931	cfzie	5	Bubble sort, only a[i]>0&&a[i+1]<0 will exchange each other Code:	2014-12-10 11:48:06		
932	eucmc	5		2014-12-10 11:48:06		
933	fowai	5		2014-12-10 11:48:06		
934	fmzze	5	Bubble sort, only a[i]>0&&a[i+1]<0 will exchange each other Code:	2014-12-10 11:48:06		
935	jippy	5		2014-12-10 11:48:06		
936	cfzie	5		2014-12-10 11:48:06		
937	dkebi	5		2014-12-10 11:48:07		
938	jippy	5		2014-12-10 11:48:07		
939	vanul	5		2014-12-10 11:48:07		
940	jippy	5		2014-12-10 11:48:07		
941	fowai	5		2014-12-10 11:48:07		
942	rdfeo	5		2014-12-10 11:48:07		
943	rrmeu	5	n 0 1 2 3 4 value -1 1 3 -2 2  1. define boolean inProcess = false;  2. From 0 to n, if value(n) = negative, continue  else inProcess = true; tempA = n;  while(inProcess) {  if(value[n] = negative) inProcess = false;  tempB = value(n+1) shift value(n) from n to n+1  increase n until find a negative value (m). }  value[tempA] = tempB;  {{ int[] array = {-1, 1, 3, 4, -2, 2}; boolean inProcess = false; while(i<array.length) { if(array[i] < 0) { i++; } else { inProcess = true; tempNo = i; while(inProcess) {  if(tempB == null) tempA = array[i]; else tampA = tempB; tempB = array[i+1]; if(array[i+1] < 0) inProcess = false;  array[i+1] = tempA; i++; } array[tempNo] = tempB; } } }}	2014-12-10 11:48:07		
944	fmzze	5	n 0 1 2 3 4 value -1 1 3 -2 2  1. define boolean inProcess = false;  2. From 0 to n, if value(n) = negative, continue  else inProcess = true; tempA = n;  while(inProcess) {  if(value[n] = negative) inProcess = false;  tempB = value(n+1) shift value(n) from n to n+1  increase n until find a negative value (m). }  value[tempA] = tempB;	2014-12-10 11:48:07		
945	xhgls	5		2014-12-10 11:48:07		
946	fmzze	5		2014-12-10 11:48:07		
947	zeice	5		2014-12-10 11:48:07		
948	eucmc	5		2014-12-10 11:48:07		
949	plapd	5	I don't understand. Why not solving this problem in the simplest way? I think time is O(n) and space is O(l) a=[-1 1 3 -2 2] b=[] c=[] for _item in a: { if _item <0:} {{ b.append(_item)}} { else:} {{c.append(_item)}} print b.extend(c)	2014-12-10 11:48:07		
950	bjsiw	5	I dont understand. Why not trying the simplest way? I think the time is O(n) and space is O(l)  a=[-1 1 3 -2 2] b=[] c=[] for _item in a: {if _item <0:} {{b.append(_item)}} {else:} {{c.append(_item)}} print b.extend(c)	2014-12-10 11:48:07		
951	jippy	5		2014-12-10 11:48:07		
952	bjsiw	5		2014-12-10 11:48:07		
953	cfzie	5		2014-12-10 11:48:07		
954	fowai	5		2014-12-10 11:48:07		
955	ufdxg	5	space complexity O(1), time complexity O(N) It seems quite easy, I don't understand why it should be done in O(Nlog(N)).	2014-12-10 11:48:07		
956	eucmc	5		2014-12-10 11:48:07		
957	dgjji	5		2014-12-10 11:48:07		
958	rrmeu	5	#include<stdio.h> main() { int n; scanf("%d",&n); int a[n],b[n]; int i=0; for(i=0;i<n;i++) { scanf("%d",&a[i]); } int k=0; for(i=0;i<n;i++) { if(a[i]<0) { b[k]=a[i];k=k+1; } else {k=k;} }   for(i=0;i<n;i++) { if(a[i]>0){b[k]=a[i];k++;}else{k=k;} }  for(i=0;i<k;i++) { printf(" %d",b[i]); } }	2014-12-10 11:48:07		
959	vanul	5		2014-12-10 11:48:07		
960	nwkeg	5		2014-12-10 11:48:07		
961	tenuw	5	how can you preserve the relative position???????????	2014-12-10 11:48:07		
962	eucmc	5	It cannot be done in O(n) . If it can done in O(n), then lower bound for comparision based sorting is O(n) which is false. So, the order is O(nlogn) and space is O(1)	2014-12-10 11:48:07		
963	sgiwy	5		2014-12-10 11:48:07		
964	zeice	5		2014-12-10 11:48:07		
965	cfzie	5		2014-12-10 11:48:07		
966	zeice	5		2014-12-10 11:48:07		
967	dgjji	5	Very bad code, see what happens with the array {-1,1,3,-2,2}	2014-12-10 11:48:07		
968	bexbp	5	Part of the inplace quicksort algorithm?	2014-12-10 11:48:07		
969	mrjku	5	The inplace quicksort doesn't remain the order.  -1 1 3 -2 2 and pivot 0 it would give -1 -2 3 1 2 instead of -1 -2 1 3 2	2014-12-10 11:48:07		
970	bexbp	5	Joe Kidd I said *part* of, not the whole sorting procedure, but the dividing part, which moves all negative numbers to the left and moves all the positive numbers to the right....	2014-12-10 11:48:07		
971	huiqq	5	Here is an O(n) solution without extra space.	2014-12-10 11:48:07		
972	ufdxg	5		2014-12-10 11:48:07		
973	jippy	5		2014-12-10 11:48:07		
974	zeice	5	Nice one!	2014-12-10 11:48:07		
975	jippy	5	Doesn't work, check this for example -1 ,1 ,3 ,-2, -5, 2	2014-12-10 11:48:07		
976	wbqzu	5	1,2,3,-1,-2. your code fail on tghis 123,-1,-2 213,-1,-2 312,-1,-2 -1,1,2,3,-2 -1,1,2,-2,3	2014-12-10 11:48:07		
977	krxlv	5	1.Start counters i at 0th index and j at nth index of the array. 2.Increase i until arr[i]>=0 3.Decrease j until arr[j]<0 4.swap arr[i] ,arr[j] 5.repeat steps 2, 3,4 till i<j  time-O(n),space-O(1)	2014-12-10 11:48:07		
978	huiqq	5	Please read the question again....relative position not keeping.	2014-12-10 11:48:07		
979	azmjc	5		2014-12-10 11:48:07		
980	dkebi	5	Its said in o (n) time & o (1) space....	2014-12-10 11:48:07		
981	ufdxg	5	Man I 'm so sorry , here is the algo : e.g {-1,2,8,1,-2,4} is the array 1)start i as 0, j as 0 2)while j<n inc j by one if arr[j] is negative , make arr[i] as this neg number arr[j] inc i by 1 and shift all the elements from arr[i to j-1] by one position  but again i 'm afraid it is O(n^2) WC and O(1) space :| ,sorry for not having read the memory constraints above,,actually this shifting procedure is O(N) itself :/	2014-12-10 11:48:07		
982	mrjku	5		2014-12-10 11:48:07		
983	krxlv	5		2014-12-10 11:48:07		
984	eucmc	5	Order not maintained...	2014-12-10 11:48:07		
985	rdfeo	5		2014-12-10 11:48:07		
986	azmjc	5	Aren't you using extra space ?? New array is being created here.....	2014-12-10 11:48:07		
987	krxlv	5		2014-12-10 11:48:07		
988	eucmc	5	Impossible? Don't make claims about which you have no clue.	2014-12-10 11:48:07		
989	admin	5	This problem has a O(n) time and O(1) space complexity solution if relative ordering is not a factor. To keep space constant you have to use n^2 operations (swaps and compares) to rearrange the array. To keep operations constant you would need to allocate additional memory to keep track of where each positive/negative entry will need to land.  Also note that I am making the assumption that 0 is treated like a positive number, although I would clarify this point with the interviewer to ensure correctness.  O(n) time, O(1) space without ordering solution: 1. Start with two pointers, one at the front and one at the end ( i=0, j = array.length -1). While i is less than j repeat steps 2-4. 2. Evaluate i - if it is less than 0 increment it by 1 3. Evaluate j - if it is greater than or equal to 0 decrement it by 1 4. Evaluate i && j - if i is greater than or equal to zero AND j is less than 0 then swap the elements. Increment i and decrement j.  Here is a working sample:	2014-12-10 11:48:07		
990	dgjji	5		2014-12-10 11:48:07		
991	rdfeo	5		2014-12-10 11:48:07		
992	cfzie	5	@masterjaso  I don't think your algorithm will ensure the relative positions of both +ve and -ve numbers. Will you algorithm work for [-1 1 -2 2 -3 3]?	2014-12-10 11:48:07		
993	huiqq	5	This paper:  "Stable minimum space partitioning in linear time"  by  Jyrki Katajainen, Tomi Pasanen   does it in O(n) time and O(1) space, and maintains the relative order (which is what makes the problem difficult), and hence the usage of the word "stable" as the very first word in the title of the paper.	2014-12-10 11:48:07		
994	sqzqo	5	Can you explain that paper? It's over my head.	2014-12-10 11:48:08		
995	wbqzu	5	@ Erasmus  You are correct, my shown algorithm does not maintain the relative order (as disclosed in my comments). I do want to thank you for the sample, it helped me identify a bug and I have amended my post with updated and correct code.	2014-12-10 11:48:08		
996	azmjc	5	@Bryan. Don't worry if you don't understand, this is an impossible interview question.	2014-12-10 11:48:08		
997	fmzze	6	1. XOR all the n numbers. 2. Result will be knocked out for all the even pairs as a^a=0 The result now contains only XOR of the two odd out numbers. 3. Find the first bit position in the result that is 1. Definitely this bit position both the odd numbers have different bit values. i.e. one has a 0 and another has a 1 at this position. Let this position be x 4. XOR the elements that have 1 at x bit position and XOR the elements that have 0 at x bit position. The two XOR results would give the two odd count numbers.	2014-12-10 11:48:09		
998	jippy	6	last line of algorithm does not lead to result...so problem is, how could we find two numbers by knowing their XOR.	2014-12-10 11:48:09		
999	fmzze	6	Hey Minku, The algo dfinitely leads us to result. You will be XORing two different sets and each of them will have the two numbers separately. I am posting my implementation.	2014-12-10 11:48:09		
1000	mrjku	6		2014-12-10 11:48:09		
1001	rrmeu	6		2014-12-10 11:48:09		
1002	rdfeo	6	Time Complexity: O(n) Space Complexity: O(1)	2014-12-10 11:48:09		
1003	ethan	6	Nice solution	2014-12-10 11:48:09		
1004	mrjku	6	Dude, Hats off to solution	2014-12-10 11:48:09		
1005	eucmc	6	It took me a few minutes to grasp how he dragged the numbers out of the XORed bits.  The trick to it is that because we're trying to find the two numbers that was set in an ODD number of times.  So, if the bit was a "1". 1 XOR 1 = 0 XOR 1 = 1 So if there is a 1 in the XORed bit set, and because the sum of two odd numbers is always even. Anything XORed an even number of times. = 0  Thus, for all 0's in the XORed bit set, there must have been 1 in the original bits. And for all 1's in the XORed bit set, both original bit sets have to contain a 0 or 1 respectively.	2014-12-10 11:48:09		
1006	admin	6	What are the semicolons in "((x&;1)!=1)" and "x=x>>;1" ????? Are they typos?	2014-12-10 11:48:10		
1007	dgjji	6	Beautiful!	2014-12-10 11:48:10		
1008	wbqzu	6		2014-12-10 11:48:10		
1009	ewigy	6		2014-12-10 11:48:10		
1010	nwkeg	6	Time Complexity: O(n) Space Complexity: O(1)	2014-12-10 11:48:10		
1011	fmzze	6	Simpler solution at the cost of space:  - Create a hash set - Loop the integers -- If the element is in the hash set, remove it -- Otherwise, add it (since it's not already present) - The answer is the contents of the hash set (which scales to any number of odd numbers)  Complexity: O(n) (due to an O(1) get/put hash set).	2014-12-10 11:48:10		
1012	gilit	6	Correct... in case we do not want to us collections.... we can have an Array of size [unique occurrence of elements] with a simple logic to check 'If the element is not present in Array add it otherwise remove the occurrence in Array.	2014-12-10 11:48:10		
1013	eucmc	6	@PKT Your solution has a space complexity of O(n) and time complexity of O(n^2).	2014-12-10 11:48:10		
1014	wbqzu	6	@Eugene The comment was for PKT's solution where an array is being used and looked up every time.	2014-12-10 11:48:10		
1015	ufdxg	6		2014-12-10 11:48:10		
1016	ufdxg	6		2014-12-10 11:48:10		
1017	cfzie	6	1. XOR all the n numbers. 2. Result will be knocked out for all the even pairs as a^a=0 The result now contains only XOR of the two odd out numbers. 3. Find the first bit position in the result that is 1. Definitely this bit position both the odd numbers have different bit values. i.e. one has a 0 and another has a 1 at this position. Let this position be x 4. XOR the elements that have 1 at x bit position and XOR the elements that have 0 at x bit position. The two XOR results would give the two odd count numbers.	2014-12-10 11:48:10		
1018	zeice	6	How would you solve this in JAVA?	2014-12-10 11:48:10		
1019	ethan	6	Hey Satyajeet here you go. Should work without any change. Please let me know as I could not verify this.	2014-12-10 11:48:10		
1020	wbqzu	6		2014-12-10 11:48:10		
1021	xhgls	6		2014-12-10 11:48:10		
1022	sgiwy	6	Time Complexity: O(n) Space Complexity: O(1)	2014-12-10 11:48:10		
1023	ftfck	6	What does ;1 means in above code?? Plz ignore my ignorance..I am new to programming...	2014-12-10 11:48:10		
1024	ufdxg	6	That is a typo that came in automatically. remove the semicolons at both the places. It stays even after editing and updating.	2014-12-10 11:48:10		
1025	vanul	6	My java solution in O(n):	2014-12-10 11:48:10		
1026	qywrh	6		2014-12-10 11:48:10		
1027	fmzze	6		2014-12-10 11:48:10		
1028	eucmc	6	Output:	2014-12-10 11:48:10		
1029	huiqq	6		2014-12-10 11:48:10		
1030	sqzqo	6		2014-12-10 11:48:10		
1031	xhgls	6		2014-12-10 11:48:10		
1032	bexbp	6		2014-12-10 11:48:10		
1033	ethan	6	1. XOR all the numbers to get c = a^b 2. reiterate the array and get d = c^arr[i] & e = c^arr[i]' if (d = e') arr[i] is one number use the concept: d = (a^b)^a = b e = (a^b)^a' = b'	2014-12-10 11:48:10		
1034	cfzie	6		2014-12-10 11:48:10		
1035	admin	6		2014-12-10 11:48:10		
1036	zeice	6	Next code in javascript returns array of two needed numbers (8,4)	2014-12-10 11:48:10		
1037	sgiwy	6		2014-12-10 11:48:10		
1038	jippy	6		2014-12-10 11:48:10		
1039	xhgls	6		2014-12-10 11:48:10		
1040	nhibd	6		2014-12-10 11:48:10		
1041	ftfck	6	I had hard time understanding the solution(s) mentioned here. So if you guys are facing the same problem here is the link for better understanding. Upvote so everybody can see. geeksforgeeks.org/find-the-two-numbers-with-odd-occurences-in-an-unsorted-array/	2014-12-10 11:48:10		
1042	xhgls	6	last line of algorithm does not lead to result...so problem is, how could we find two numbers by knowing their XOR.	2014-12-10 11:48:10		
1043	krxlv	6		2014-12-10 11:48:10		
1044	bjsiw	6	If you really find some answer helpful, please up-vote. It helps people in finding valid answers. :)	2014-12-10 11:48:10		
1045	fowai	6	@Expressions: Unregistered users cannot vote I believe. But there is a bigger problem. This should be a comment on the answer for which it was intended.	2014-12-10 11:48:10		
1046	qywrh	6	My bad, failed to see the <anonymous/>	2014-12-10 11:48:10		
1047	plapd	7	First Let's see what all approaches we can take and then we check if it fits our requirement. 1. Brute Force: Select an element from 1 to N and check it frequency of occurrence. But this will be O(n2) and not O(n) . 2. XOR : but this technique won't work as question mentions an element can be repeated multiple times. so if element repeats 2 times or 4 times each time result of xor will be 0 so we cannot get the frequency of occurrences. 3. HashMap : We can create a HashMap in O(n) key will be elements and value will be their frequency of occurrence. But since we have to do it in O(1) space we cannot take this approach.  So we cannot opt for any of the above 3 approach. We have to check for some 4th approach.  Since we have range of numbers given to us we have to think in those lines. Array Index is from 0 to N-1 and range is from 1 to N. Can't we use the array as hash itself? where array "Index-1" represents the key (element) and value stored at index will represent the "frequency of occurrence".  But how will we take care that an element present at any index is not overwritten as this can cause problem? We can sort the array in that case value present at index i is I+1 itself.  What is the complexity of sorting the array? O(nlogn) if we opt for heap/merge/quick sort.  But since the range of element is given to us we can sort it in O(n).	2014-12-10 11:48:11		
1048	bjsiw	7	It was not as simple as I thought in first go, but with a little thinking I was able to code it.	2014-12-10 11:48:11		
1049	ethan	7		2014-12-10 11:48:11		
1050	zeice	7		2014-12-10 11:48:11		
1051	admin	7	you can check the complete executing code with explanation at : ms-amazon.blogspot.in/2013/07/you-are-given-array-of-n-integers-which.html	2014-12-10 11:48:11		
1052	ethan	7	Nice solution varun. One correction after checking if(arr[pos]<=0) apart from incrementing pos a continue statement can be given to continue the loop process from the beggining i.e if(arr[pos] <= 0){ pos++; continue; } Am i right?	2014-12-10 11:48:11		
1053	dkebi	7	counter example  {9,9,9,9,9,9,9,8,7,9,9}	2014-12-10 11:48:11		
1054	jippy	7	@vishnu yes you are right, I missed it thanks for pointing out.  @algos It words for your example, just try introducing continue as vishnu suggested.  Output for your example: Element = 1 Frequency = 0 Element = 2 Frequency = 0 Element = 3 Frequency = 0 Element = 4 Frequency = 0 Element = 5 Frequency = 0 Element = 6 Frequency = 0 Element = 7 Frequency = 1 Element = 8 Frequency = 1 Element = 9 Frequency = 9 Element = 10 Frequency = 0 Element = 11 Frequency = 0	2014-12-10 11:48:11		
1055	dgjji	7	Isn't it sorting in o(n) method will take o(n) extra space.???	2014-12-10 11:48:11		
1056	gilit	7	@sibendu If you are using counting sort then yes it will. Given range of array you can sort it in O(n) time.  And by range I mean no. of elements in range must be equal to the number of elements in array.  for eg. if we have 10 int array and range is (1,100) (any 10) then it is not possible but if range is (20,30) yes in this case it is possible.	2014-12-10 11:48:11		
1057	huiqq	7	@varun:im not talking about time complexity .Counting sort takes o(n) extra space which in that case is not allowed by the interviewer.	2014-12-10 11:48:11		
1058	ewigy	7	Sorry forgot to mention it will take O(1) space.  The simplest sorting algo with O(1) space and O(n) time complexity must have 2 conditions all elements must be in some range and all elements must be unique.  I believe this approach can be extended to arrays not satisfying the second condition, that will require some thinking.  In above I have not sorted instead manage to store the frequency without sorting, You can follow the other approach as well.	2014-12-10 11:48:11		
1059	fmzze	7	@varun: Hi, Sibendu is asking you *how* you can sort the array in O(n) time with O(1) extra storage space. I am interested too. Please tell us how this is (roughly) possible... Thanks. Btw nice solution!	2014-12-10 11:48:11		
1060	fowai	7	@chih.chiu this is a separate question, I have coded it for the case where all elements are unique in array.  Complexity: Time : O(n) Space: O(1)	2014-12-10 11:48:11		
1061	krxlv	7		2014-12-10 11:48:11		
1062	ufdxg	7		2014-12-10 11:48:11		
1063	qywrh	7	But giving a second thought to it, why do we even need to sort it when range is given? All element are unique, we should simply overwrite the values and continue moving forward in array.	2014-12-10 11:48:11		
1064	eucmc	7	We can solve this in two scans Time complexity: o(n) ans space complexity o(1)  1) In first scan for each of occurrence of an element add the array size to that element. 2) In second scan Divide the element value by n gives frequency of occurrence.	2014-12-10 11:48:11		
1065	sqzqo	7		2014-12-10 11:48:11		
1066	rdfeo	7		2014-12-10 11:48:11		
1067	ewigy	7	very nice solution venkatesh, +1 from my side.	2014-12-10 11:48:12		
1068	plapd	7	can someone explain Venkatesh's solution?	2014-12-10 11:48:12		
1069	ftfck	7	@varun, etc: While very clever, this is an O(n) space algorithm. You are relying on the fact that every integer has a free sign bit. In the general case, this is not true - the algorithm fails for instance with an array of 255 unsigned bytes. While this solution is quite valid in the case of a signed integer array, I feel standard complexity analysis labels it O(n); you need to "allocate" one bit per element as a flag for stating if the corresponding element is a count or input data.	2014-12-10 11:48:12		
1070	dgjji	7	@hj: both varun and venkatesh's solution are based on counting sort coupled with the fact that every element <= n-1. Thus if we divide any element by n, it is 0. So they use counting sort in-place and add n to elements. In the second pass, while dividing by n, the original content does not matter and we get the frequency. So we are not using any 'extra' space!	2014-12-10 11:48:12		
1071	sgiwy	7	Alternative approach, encode fields which specify a normal value as positive, those that contain a count as negative, then proceed through the array. If the value we see is smaller than the index, simply decrement the field for the value (since we must already have removed any value there) if it is larger, then swap the value in that field currently with the current value and set the field value to -1, except if the field is already negative, in which case just decrement. Afterwards, the array is filled with negative values which are the counts, so just pop a minus in front of them and voila.  It's a little hard to follow, so here's the code:	2014-12-10 11:48:12		
1072	vanul	7		2014-12-10 11:48:12		
1073	cfzie	7		2014-12-10 11:48:12		
1074	fowai	7	While very clever, this is an O(n) space algorithm. You are relying on the fact that every integer has a free sign bit. In the general case, this is not true - the algorithm fails for instance with an array of 255 unsigned bytes. While this solution is quite valid in the case of a signed integer array, I feel standard complexity analysis labels it O(n); you need to "allocate" one bit per element as a flag for stating if the corresponding element is a count or input data.	2014-12-10 11:48:12		
1075	ewigy	7	just store value as (val + count * N)	2014-12-10 11:48:12		
1076	eucmc	7		2014-12-10 11:48:12		
1077	bexbp	7		2014-12-10 11:48:12		
1078	nwkeg	7	While very clever, this is an O(n) space algorithm. You are assuming you have additional free bits to add N in which may not be true. Standard complexity analysis would show this as O(n); you need to "allocate" one bit per element as a flag for stating if the corresponding element is a count or input data.	2014-12-10 11:48:12		
1079	gilit	7	If you can generate a sequence of primes P(1) to P(n) you can create single number that will represent a digest of the data set (there are formulas out there like f(n)=n^2n+41 that will do that for you). For example, you could use the prime sequence 3,5,7,11,13,17 to represent the set of numbers 1,2,3,4,5,6 where P(1)=3, P(2)=5, P(3)=7, P(4)=11, P(5)=13, P(6)=17.  Start with your digest as equaling 1 (call it D). Every time you see a 1, multiply it be P(1). Every time you see a 2, multiply it by P(2) etc... Thus if your sequence is: 1,2,4,5,1,1 the 'digest' is: D = P(1)*(2)*P(4)*P(5)*P(1)*P(1) or another wards D = 3 * 5 * 11 * 13 * 3 * 3  Then once you're done. Go through D and divide it with each P(n) in sequence and so long as you get a remainder 0 result you know there's another P(n) in there. In this example:  -Start dividing by 3, you will see that D divides by 3 exactly three times (hence the number 1 repeats exactly 3 times, print this information) -Then move onto the next prime 5 and you will see that D divides by 5 exactly once (so there is exactly one instance of 2 in the list, print this information) -Them move onto the next prime 7 and you will see that D divides by 7 zero times (so there are no 3's present in the list, print this information)  Continue doing this until the prime representing P(n) is reached. This entire process will require two passes through the data set, the initial construction of the digest D and the one more to print out the results. This solution will work so long as a number large enough to contain P(1)*(#occurrences of 1) ... * P(n) * P(1)*(#occurrences of n) can be allocated.	2014-12-10 11:48:12		
1080	krxlv	7	Clever, but not O(1) space. D is not constant sized, but rather a linear function of the input size. In particular, D may require N bits of storage.	2014-12-10 11:48:12		
1081	bexbp	7	Simple solution in java:	2014-12-10 11:48:12		
1082	gilit	7		2014-12-10 11:48:12		
1083	nhibd	7		2014-12-10 11:48:12		
1084	dgjji	7	This is O(n) space; you allocated a new array of the original's size.	2014-12-10 11:48:12		
1085	mrjku	7	Solution goes like this....  {8,1,9,2,5,1,1,1,1} can be treated as the test data.....  {58,11,9,2,15,1,1,11,11} would be the processed data....  The process goes as follows.... 8 - > add 10 to location 8 {8,1,9,2,5,1,1,11,1} 1 -> add 10 to location 1 {18,1,9,2,5,1,1,11,1} 9 -> add 10 to location 9 {18,1,9,2,5,1,1,11,11} 2 -> add 10 to location 2 {18,11,9,2,5,1,1,11,11} 5 -> add 10 to location 5 {18,11,9,2,15,1,1,11,11} 1 -> add 10 to location 1 {28,11,9,2,15,1,1,11,11} 1 -> add 10 to location 1 {38,11,9,2,15,1,1,11,11} 11 -> special process ( if element is > 10) compute the modulo and add 10 to that location...11 % 10 = 1 ...so add 10 to location 1 {48,11,9,2,15,1,1,11,11} 11 -> special process ( if element is > 10) compute the modulo and add 10 to that location...11 % 10 = 1 ...so add 10 to location 1 {58,11,9,2,15,1,1,11,11}   {58,11,9,2,15,1,1,11,11} 58 - yields 58 / 10 times 1 and the original value is 58 % 10 and so on for each value....Array values are not lost....  Note : 10 is size of the array + 1...in code we have used 20 as our array size	2014-12-10 11:48:12		
1086	bexbp	7		2014-12-10 11:48:12		
1087	admin	7		2014-12-10 11:48:12		
1088	jippy	7		2014-12-10 11:48:12		
1089	dgjji	7		2014-12-10 11:48:12		
1090	nhibd	7		2014-12-10 11:48:12		
1091	huiqq	7		2014-12-10 11:48:12		
1092	admin	7	Result:  Elements that don't exist in array A 1 2 3 4 5 6 11 Elements that exist in array A and their frequency 7: 1 8: 1 9: 8 10: 1	2014-12-10 11:48:12		
1093	gilit	7	I suspect this is impossible under strict definitions of O(1) space. There exist no sorting algorithms with worst-case parameters of O(n) time and O(1) space. Any solution to this problem would allow you to do a linear time, constant space counting sort where the range_of_numbers <= length of array. If you could do that, you should publish a paper.  As noted in comments I've made on other answers (e.g. storing negative numbers or a number larger than len(N) in an element), all solutions thus far provided stretch the definition of O(1) space and in the general sense are O(N).	2014-12-10 11:48:12		
1094	ewigy	7	My solution is O(n) time and O(1) space. I did not sort the array.	2014-12-10 11:48:12		
1095	eucmc	7	You have the same issue everyone else does. You are using numbers outside the domain, specifically negative numbers. Your algorithm requires an additional bit per element to store a sign bit.. N bits in total, meaning O(N) space complexity.	2014-12-10 11:48:12		
1096	fowai	7	My solution changes the input array. I did not use an extra array, so the amount of extra memory is constant.	2014-12-10 11:48:12		
1097	mrjku	7	@xuzheng:  To show that your algorithm (as a general algorithm) is O(n) space, let's use a simple counter-example. Java's a little weird in that you don't have unsigned types, so let's use C.   void elements(unsigned char * A) { ...  //Issue #1 A[i] = -1;  //Issue #2 A[A[i] - 1]--;   Let's say A has 255 elements; the domain for input numbers is 1-255. The issue #X lines both are problematic. You are going to underflow, as a negative is outside the domain. The subtraction creates a large positive number indistinguishable from your original input data -- causing the algorithm to fail.  This isn't so obvious if you use Java, as all integers in Java are signed. In this particular language, you just happen to have that an extra bit of unused space in each element in the input array which you can use for your purposes. But this is not true in general (as in the C example given above).  You cannot rely on such the input array being inefficiently stored. If it is efficiently stored (e.g. as an unsigned type), you must allocate N new bits to store that "count or input" flag.. making it an O(N) space algorithm.	2014-12-10 11:48:12		
1098	eucmc	7	The range 1 to n is a restriction on the input array, however this does not mean we can't change elements in the input array to an integer that is outside the range. Of course, this solution only works if I can make the assumption that the input is an array of signed integers.	2014-12-10 11:48:12		
1099	ftfck	7	How about that idea. If you encounter element on position i and it is not equal to i. Than you have to place value a[i] to position with index a[i] e.g a[a[i]] = a[i]. But if this position is already captured with right element you go forward. It is preproccessing made by O(n). The next cycle you just scan array, and if value of element with index i isn't equal to i it means that we haven't element with value i. Here is code of my solution.	2014-12-10 11:48:12		
1100	ethan	7		2014-12-10 11:48:12		
1101	rrmeu	7		2014-12-10 11:48:12		
1102	azmjc	7	Your solution is the same as my solution. I think it works well, but you forgot to print out the number of occurrences of the elements that do appear in the input array.	2014-12-10 11:48:12		
1103	dgjji	7	Yep,you are right. Your idea about counting is good))	2014-12-10 11:48:12		
1104	admin	7	This is solution on sorted array. Very basic but it is working fine.	2014-12-10 11:48:12		
1105	azmjc	7		2014-12-10 11:48:12		
1106	huiqq	7		2014-12-10 11:48:12		
1107	vanul	7	This is solution on sorted array. Very basic but it is working fine.	2014-12-10 11:48:12		
1108	admin	7		2014-12-10 11:48:12		
1109	vanul	7		2014-12-10 11:48:12		
1110	fmzze	7	My solution in c++ : we use the input array as a container for the counter. Elements i encoutered in the array is associated with a counter at position i-1.	2014-12-10 11:48:12		
1111	dkebi	7		2014-12-10 11:48:12		
1112	admin	7		2014-12-10 11:48:12		
1113	ftfck	7	First, we need the array to store the count since space is limited at O(1). So we need A[i] to store the count for number i. But how can we distinguish the number itself and the count? We can use negative numbers to store the count. The O(1) space is a pointer to the array for the current number. The solution is raw, with O(1) space and O(n) time, without any sorting.  E.g.  [4, 3, 2, 3, 5] => [3,3,2,-1,5] => [2,3,-1,-1,5] => [3, -1, -1, -1,5] => [0, -1, -2 ,-1, 5] => [0,-1, -2, -1, -1]	2014-12-10 11:48:12		
1114	ethan	7		2014-12-10 11:48:12		
1115	ewigy	7		2014-12-10 11:48:12		
1116	nhibd	7	my solution: {{ void prep(int arr, int n) { for(int i=0; i<n; ++i) { int v = arr[i]; if (!v || v > n) continue; arr[i] = 0; while(v && v<=n) { if (arr[v-1] > n || arr[v-1] == 0) { arr[v-1] += v; break; } else { int v1 = arr[v-1]; arr[v-1] = n+v; v = v1; } } } }  void print_dup(int arr[], int n) { for(int i=0; i<n; ++i) { if(arr[i]==0 || (arr[i]-n)/(i+1) == 1) continue; printf("pos[%d] dup times: %d\n", i+1, (arr[i]-n)/(i+1)); } } void print_missing(int arr[], int n) { for (int i=0; i<n; ++i) { if (!arr[i]) printf("%d missing\n", i+1); } }  }}	2014-12-10 11:48:12		
1117	nhibd	7		2014-12-10 11:48:12		
1118	fowai	7		2014-12-10 11:48:12		
1119	wbqzu	7	print missing is simple, check arr[i] == 0.	2014-12-10 11:48:12		
1120	fmzze	7	{{ public static void findMissingNumbers(int array[]) { for(int i=0;i<array.length;++i) { if(array[i]!=(i+1) && array[array[i]-1]!=array[i]) { int temp = array[array[i]-1];  array[array[i]-1]=array[i];  array[i]=temp; --i; } } for(int i=0;i<array.length;++i) { if(array[i]!= i+1 ) { System.out.println("the number is not present " + (i+1) );  if(i==0) array[i] = ( i + 2); else { array[array[i]-1] = array[array[i]-1] + array[i]; } } }  for(int i=0;i<array.length;++i) {  if(array[i]/(i+1)>=2) { System.out.println("The number" + (i+1) + " repeated for " + array[i]/(i+1) ); } } } }}	2014-12-10 11:48:12		
1121	fmzze	7		2014-12-10 11:48:13		
1122	rdfeo	7		2014-12-10 11:48:13		
1123	qywrh	7	}	2014-12-10 11:48:13		
1124	nwkeg	7	package code_exercise;  public class CodeExercise5 { public static void main(String[] args) { // swap(a1, b1); int a[] = {10, 2, 2, 5, 3, 4, 9, 10, 9, 10, 5}; solve(a); }  public static void swap(Integer a, Integer b) { a ^= b; b ^= a; a ^= b; }  private static void solve(int [] a) { int tval = 0; // determine max val for (int i = 0; i < a.length; ) { if (a[i] > 0) { tval = a[a[i] - 1]; if (tval > 0) { if (a[i] - 1 == i) { a[a[i] - 1] = -1; } else { a[a[i] - 1] = -1; a[i] = tval; } } else if (tval <= 0) { a[a[i] - 1] += -1; a[i] = 0; i++; } } else { i++; } } for (int i = 0; i < a.length; i++) { System.out.println("NUM:" + (i+1) + ", OCC:" + Math.abs(a[i])); } } }	2014-12-10 11:48:13		
1125	bjsiw	7	Clever, but I don't think the problem is fully defined. The size of the array is not specified as size N. If you were guaranteed values 1-n and an array specified as size n, then your solution would work. Still pretty clever.	2014-12-10 11:48:13		
1126	huiqq	7	It says that given an array of n integers. Below is the output generated for array arr[] = {6,4,1,4,3,2,5,2,1}; Element = 1 Frequency = 2 Element = 2 Frequency = 2 Element = 3 Frequency = 1 Element = 4 Frequency = 2 Element = 5 Frequency = 1 Element = 6 Frequency = 1 Element = 7 Frequency = 0 Element = 8 Frequency = 0 Element = 9 Frequency = 0	2014-12-10 11:48:13		
1127	nwkeg	7	@someguy what does an array of N integers mean ?	2014-12-10 11:48:13		
1128	nhibd	7	My bad, was late misread	2014-12-10 11:48:13		
1129	zeice	7	IS the array sorted??	2014-12-10 11:48:13		
1130	gilit	7	#include<iostream> using namespace std; int main() { int a[]={3,3,2,1,1}; cout<<"repeated:"<<endl; for(int i=0;i<5;i++) { if((a[abs(a[i])-1]) > 0) { a[abs(a[i])-1]=- a[abs(a[i])-1];  } else { cout<<a[i]<<endl; } } cout<<"missing:"<<endl; for(int i=0;i<5;i++) { if(a[i]>0) cout<<i+1<<endl; } getchar(); return 0; }	2014-12-10 11:48:13		
1131	dgjji	7	let's consider - 4,3,5,1,2,9,4,2,7,10 n = 10  start iterating the array like count sort with a slight modification that we add n^i to i-th array entry for each occurrence of i in th array- since n is 10 we will add 10^i so 4,3,5,1,2,9,4,2,7,10 will end up like - 4+10^1, 3+10^2+10^2, 5+10^3, 1+10^4+10^4, 2+10^5, 9+0, 4+10^7, 2+0, 7+10^9, 10+10^10  Now iterate the array from beginning dividing each entry by n^i, result will be the corresponding counts for integer i (0 will be for absent integers) - for index 1 - 4+10^1 mod 10 ^1 = 1 for index 2 - 3+10^2+10^2 mod 10^2 = 2 and so on resultant array is - 1,2,1,2,1,0,1,0,1,1 1 is present once, 2 is present twice ...6 and 8 are missing	2014-12-10 11:48:13		
1132	fowai	7		2014-12-10 11:48:13		
1133	sqzqo	7		2014-12-10 11:48:13		
1134	mrjku	7	I used the following algo in my code which the interviewer accepted at once ....  1.Start traversing the array . Let there be n elements and array be a[]. 2.if a[a[i]-1] > 0 and a[i] >0 , then make a[a[i]-1] negative . This will help to keep track of absent nodes . 3.else if a[i]>0 and a[a[i]-1] <0 , subtract n from a[a[i]-1] . This will help to keep the count of multiple visited nodes. 4. else if a[i]<0 and a[i] >= -n , subtract n from a[-a[i]-1]. 5. else if a[i] < -n , find subtract n from a[ (-a[i])%n-1 ] . 6. Now traverse the list and if any a[idx] is positive , that means number idx+1 isn't present in the array . 7. If a[idx] is between -n to -1 , that means idx+1 has occured only one time . 8. else if a[idx] is less than -n , that means idx+1 has occured ( int ) ( -a[idx]/n ) + 1 times .   P.S. I wasn't selected for the next round after telling this answer within 5 minutes .	2014-12-10 11:48:13		
1135	bjsiw	7	I had to clear 1 written 3 tech and 1 HR in total but I was ousted after the 2nd round of Interviews in which this question was asked .	2014-12-10 11:48:13		
1136	zeice	7	campus placements for Blore team.	2014-12-10 11:48:13		
1137	sqzqo	7	Voted up cause the solution is almost correct :) Please see note from <vishnuJayvel>, he is pointing out a very important case handling.	2014-12-10 11:48:13		
1138	mrjku	7	Use hash map.  it takes o(n) time and o(1) space. Correct me if i made mistake	2014-12-10 11:48:13		
1139	mrjku	7		2014-12-10 11:48:13		
1140	xhgls	7		2014-12-10 11:48:13		
1141	nwkeg	7	cheers Krishna	2014-12-10 11:48:13		
1142	plapd	7	You are using hashmap which is extra space, so O(1) space condition is violated.	2014-12-10 11:48:13		
1143	bexbp	7	A very simple approach :	2014-12-10 11:48:13		
1144	xhgls	7		2014-12-10 11:48:13		
1145	gilit	7		2014-12-10 11:48:13		
1146	mrjku	7	little correction.. in the lower for loop condition will be : a[i]!=1+1	2014-12-10 11:48:13		
1147	zeice	7	little correction.. in the lower for loop condition will be : a[i]!=i+1	2014-12-10 11:48:13		
1148	bjsiw	7		2014-12-10 11:48:13		
1149	gilit	7	The solution you're suggesting is O(n) space due to aux array and the question states that there is O(1) solution.	2014-12-10 11:48:13		
1150	fmzze	7	I don't know why this answer is downvoted.This seems to be correct answer.	2014-12-10 11:48:13		
1151	rrmeu	7		2014-12-10 11:48:13		
1152	ethan	8	I presume that the probabilities of move up/donw/left/right are equal(0.25). Then P(x, y, n, step) = (P(x-1, y, n, step-1) + P(x+1, y, n, step-1) + P(x, y-1, n, step-1) + P(x, y+1, n, step-1)) / 4. (x, y) is the position. (n) is the size of island. (step) is the remaining step. The following code is my Java implementation with some simple tests. Dynamic Programming is also used.	2014-12-10 11:48:14		
1153	fmzze	8		2014-12-10 11:48:14		
1154	bjsiw	8		2014-12-10 11:48:14		
1155	mrjku	8	How the probability for (0,0,1) be 0. As the (0,0) coordinate person can move to (0,1) or (1,0) in one chance. So according to the assumption of 0.25 probability for each move the total P = 0.50 (Person dies only in case he chooses (0,-1) or (-1,0))	2014-12-10 11:48:14		
1156	ftfck	8	@ctrlV: dude u r calculating wrong..the code is correct... it is giving 0.5 probability.	2014-12-10 11:48:14		
1157	eucmc	8	@ctrlV: (0, 0, 1) means the initial position is (0, 0) and the row/column of island is 1, which means the island contains only one position: (0, 0). Therefore (0, 1) and (1, 0) are also dead positions.	2014-12-10 11:48:14		
1158	dgjji	8	Idea of using DP with memorization is good, this should save us some time; btw, could we do it using tabulation approach? I am still thinking but couldn't make one yet.	2014-12-10 11:48:14		
1159	krxlv	8	What is complexity of this algorithm? O(n^2)?	2014-12-10 11:48:14		
1160	ewigy	8	I think the time complexity for any solution to this problem should be exponential. Let me explain the mathematical way of calculating the probability here: The total number of outcomes are n^n. To calculate the number of outcomes which can lead to death of the person: For each of the four directions, check how many steps can lead to him going out of the matrix. Then, apply the high school probability formula. For e.g. suppose the total number of steps he can take are 5; (x, y) = (2,1) [indexing is 0-based]. So, he needs to take 3 steps in north dir. to fall out of island. Keeping them in a group: (NNN) and making other 2 steps as any of the 4 choices, we have the formula: 4*4*3. Similarly, for other 3 directions. Finally, the probality = (sum of the calculated death outcomes) / (total outcomes)  Hence, the complexity will be exponential.	2014-12-10 11:48:14		
1161	tenuw	8	the complexity should be O(n*N^2)	2014-12-10 11:48:14		
1162	sgiwy	8	Make some simplification of Alva0930's code:	2014-12-10 11:48:14		
1163	rrmeu	8		2014-12-10 11:48:14		
1164	rdfeo	8		2014-12-10 11:48:14		
1165	rrmeu	8	1. Generate NxN probability matrix P(x,y,1) for all (x, y) coordinates (x & y ranges from 0 to N-1). P(x,y,1) is the probability of staying alive after taking 1 step 2. Now using this, we need to calculate the NxN probability matrix P(x,y,2) for all x and y - will be P(x,y,1) * { {Valid among P(x+1, y, 1) + P(x, y+1, 1) + P(x-1, y, 1) + P(x, y-1, 1) } / num of valid adjascent slots }. Now we have P(x,y,2) probability matrix. 3. Using induction, we can calculate P(x, y, k) using P(x, y, k-1). Repeat this N times, we have our probability matrix after N steps	2014-12-10 11:48:14		
1166	rdfeo	8		2014-12-10 11:48:15		
1167	sqzqo	8		2014-12-10 11:48:15		
1168	eucmc	8	Believe this logic/code is correct. Please update if you find any issue	2014-12-10 11:48:15		
1169	eucmc	8	Looks good. Also, there are lots of symmetries here that allow you to reduce storage. A simple way to cut the processing in half is to only consider squares where x <= y, and if you need P(x,y,n) where x > y, then just find P(y,x,n). You can also take advantage of horizontal and vertical reflections.	2014-12-10 11:48:15		
1170	rdfeo	8	The N of the NxN matrix and the n of the n steps are different, I believe.  For large n (as compared to N) you might be better off using matrix multiplcation...	2014-12-10 11:48:15		
1171	admin	8	Do we really have to store the values? static double probability(int x, int y, int n, int xmax, int ymax) { double result = 0.0; if (x < 0 || y < 0 || x >= xmax || y >= ymax) return result;  if (n == 0) return 1;  if ((x < xmax)) { result += .25 * probability(x + 1, y, n - 1, xmax, ymax); } if (x > 0) { result += .25 * probability(x -1, y, n - 1, xmax, ymax); } if (y > 0) { result += .25 * probability(x, y-1, n - 1, xmax, ymax); } if (y <ymax) { result += .25 * probability(x, y + 1, n - 1, xmax, ymax); } return result; }	2014-12-10 11:48:15		
1172	ufdxg	8	I think , your answers are correct for 2,2 matrix the one you showed, but I doubt it will work for higher values. Just consider 3,3 matrix. The answer of the top left cell would be 0.1054 according to the induction but in reality its 0.28 (18/64). The number of possible moves is 64 and in only 18 (I counted) of them you will survive. Why 2,2 is working and the rest are not . What I think is this, again considering the top left cell, probability of surviving in two moves = probability of surviving in move1* probability of being in one of the two valid cells * probability of surviving in that cell in next move (probability of surviving in that cell in one move) + probability of surviving in move1* probability of being in the other valid cell * probability of surviving in that cell in next move (probability of surviving in that cell in one move) which is 0.5*0.5*0.75 + 0.5*0.5*0.75 which is the same thing you did.  But now (according to your algorithm) probability of surviving in top left cell in three moves = probability of surviving in that cell in two moves * probability of being in adjacent cell (which in your case we are always taking 0.5 (one of two valid cells) which is wrong because in two moves there are more valid cells that we can be in) * probability of surviving in that cell in two moves (which again does not make sense, you have already consider two moves , so now its two + two moves -- weird). The solution looks very impressive in the beginning which caught me for a long time but I still can't understand how its going to work for higher numbers.  Thanks	2014-12-10 11:48:15		
1173	sgiwy	8	Actually found the correct equation  P(x,y,k) = P(x,y,1) * { {Valid among P(x+1, y, k-1) + P(x, y+1, k-1) + P(x-1, y, k-1) + P(x, y-1, k-1) }/ num of valid adjascent slots }. Note: The first term remain P(x,y,1) and not P(x,y,k-1) which means 1,1 matrix for the rest of soln. I guess you were saying the same thing. Anyways thanks for solution. I guess this is the only correct one we have so far.	2014-12-10 11:48:15		
1174	ethan	8	@Arjun, see also: "Efficient Solution in Python (with tests)".	2014-12-10 11:48:15		
1175	tenuw	8	Is the complexity of this solution O(N^2 x n) ? We are calculating an NxN matrix n times. Please correct me if I'm wrong.	2014-12-10 11:48:15		
1176	cfzie	8	Efficient Solution in Python (with tests)  This is a DP solution that only computes one octant of the matrix, since all the other octants are just reflections. It also defers dividing by powers of four until the end.	2014-12-10 11:48:15		
1177	zeice	8		2014-12-10 11:48:15		
1178	ethan	8		2014-12-10 11:48:15		
1179	dgjji	8	The program's output shows that sample matrices for N=5.	2014-12-10 11:48:15		
1180	qywrh	8		2014-12-10 11:48:15		
1181	admin	8		2014-12-10 11:48:15		
1182	fmzze	8	Please put in algo form for easy understanding of logic first.	2014-12-10 11:48:15		
1183	nhibd	8	you start with 1 at all the positions as in 0 steps all positions have 0 probability of dying.. then it uses the updation rule where val(x,y) = sum of all valids((val(x+-1,y+-1)) which is evaluating 1 step at a time	2014-12-10 11:48:15		
1184	rrmeu	8		2014-12-10 11:48:15		
1185	rrmeu	8		2014-12-10 11:48:15		
1186	bexbp	8	--> else if (n==0) return 1;  consider prob(0,0,1) = 1/2	2014-12-10 11:48:15		
1187	ewigy	8	Well my assumption was that n equals 1 meant no more steps allowed.. but yeah, 0 makes more sense, my bad.	2014-12-10 11:48:15		
1188	vanul	8		2014-12-10 11:48:15		
1189	qywrh	8		2014-12-10 11:48:15		
1190	cfzie	8	Exponential time complexity! Bad bad.	2014-12-10 11:48:15		
1191	qywrh	8	@hello world you code fails in the very 1st section . ex (0,1,1) where ans should be 0.75 but your code will give 0.25. your if else conditions are intersecting among themselves...chk carefully	2014-12-10 11:48:15		
1192	dkebi	8		2014-12-10 11:48:15		
1193	nhibd	8		2014-12-10 11:48:15		
1194	zeice	8	Psuedocode for probabilityofdead :	2014-12-10 11:48:15		
1195	fmzze	8		2014-12-10 11:48:15		
1196	nwkeg	8		2014-12-10 11:48:15		
1197	ewigy	8	Hence ,probabilityofalive= 1- probabilityofdead	2014-12-10 11:48:15		
1198	krxlv	8	The probability can be higher than 1 in this case. You should divide by 4 to get the right answer	2014-12-10 11:48:15		
1199	dkebi	8	Also, the recursive calls should use n-1 as a parameter. The probability of dying from a square in n steps when the first step is a neighbor involves the probability of dying in n-1 steps from the neighbor.	2014-12-10 11:48:15		
1200	dkebi	8	I am doing n--- check out..tht means n becomes n-1.	2014-12-10 11:48:15		
1201	xhgls	8	A DP problem. Let's say the person is at (x0, y0) initially(instead of (x, y) in the question) Build a table W(n, N, N) whose entry W(k, x, y) is the number of ways to get to (x, y) from initial location(x0, y0) after k steps. Now, without considering the border,	2014-12-10 11:48:15		
1202	ethan	8		2014-12-10 11:48:15		
1203	bjsiw	8		2014-12-10 11:48:15		
1204	gilit	8	Then build W up to n steps, again, without considering the border. After that, just count the percentage of the locations (a, b) in W(n, a, b) that are out of the border, this is the probability.	2014-12-10 11:48:15		
1205	bjsiw	8	can u write a pseudocode?	2014-12-10 11:48:15		
1206	krxlv	8	You have a to be a little careful about considering the border. Once you step off the island, you're dead, whereas if you only consider the water at the end of N steps, you can count situations where folks stepped into the water and out of the water.	2014-12-10 11:48:15		
1207	zeice	8		2014-12-10 11:48:15		
1208	ufdxg	8		2014-12-10 11:48:15		
1209	gilit	8	This can be solved using DP	2014-12-10 11:48:15		
1210	dgjji	8		2014-12-10 11:48:15		
1211	ftfck	8		2014-12-10 11:48:15		
1212	zeice	8	can u elaborate more. this code doesnt seem to work for probability..	2014-12-10 11:48:15		
1213	dgjji	8	Dude, read question carefully. Do not jump immediately over writing the code!	2014-12-10 11:48:15		
1214	bjsiw	8	Oh I am sorry. A little modification to the code. Please do let me know If I am making some mistake here. Starting from x,y, the initial inputs for the array will be x, y  int fall =0; int calProb(int n, int m, int **arr, int steps) {  if( m<0 || n< 0) { fall++; return 0; } else if(step ==0) return 1; else { return CallProb(n-1,m,**arr,step--) + CallProb(n,m-1,**arr, step--) + CallProb(n-1,m-1,**arr,step--); } }  Now we can calculate Let say the output of this function be livProb i.e. livProb = calProb(x,y, arr, n);  therfore living probability = livprob \ (livprob + fall)	2014-12-10 11:48:15		
1215	sqzqo	8		2014-12-10 11:48:15		
1216	vanul	8		2014-12-10 11:48:15		
1217	sqzqo	8	deadAkive is an array with two value: deadAlive[0] = number of times dead deadAlibe[1] = number of timesAlive	2014-12-10 11:48:15		
1218	gilit	8	change the order of helper base case:	2014-12-10 11:48:15		
1219	plapd	8		2014-12-10 11:48:15		
1220	huiqq	8		2014-12-10 11:48:15		
1221	krxlv	8	Pseudo code  - Add x, y, N-x, N-y into sorted array - assume highest to lowest order is N-x, y, N-y, x for now - if n > N-x return 1 (means if person moves n steps at all any direction he will be dead) - if n < x return 0 ( means if person moves n steps any dir he will be alive) - if n is between N-x and y return .75 And so on	2014-12-10 11:48:15		
1222	eucmc	8	My Idea : 1> For area outside the NXM, the death Prob is 1, what ever the step is. (step>=0) 2> For area inside the NxM and step=0, death Prob is zero. 3> For Other x, y, and step, probDeath(x,y,step)=1/4*(probDeath(x-1,y, step-1) + probDeath(x+1,y, step-1)+probDeath(x,y-1, step-1) +probDeath(x,y+1, step01)). Assume the person runs randomly. 4> The logic above also added a array to store the shared calculated result (as does dynamic programming) to save the computation time during the recursive call. 5> ProbLive(x,y, step)=1-ProbDeath(x,y,step).  My Code:	2014-12-10 11:48:15		
1223	wbqzu	8		2014-12-10 11:48:16		
1224	sqzqo	8		2014-12-10 11:48:16		
1225	krxlv	8	Test Code: int main() { squareProb_t cb; double p1, p2, p3; squareProbInit(&cb, 2,2, 5); p1=squareProbDead(&cb, 0, 0, 1); p2=squareProbDead(&cb, 0, 0, 2); p3=squareProbDead(&cb, 0, 0, 5); printf("p1 is %f\n", p1); printf("p2 is %f\n", p2); printf("p3 is %f\n", p3);  }	2014-12-10 11:48:16		
1226	eucmc	8	Test Result:Test Result of my code: p1 is 0.500000 p2 is 0.750000 p3 is 0.968750	2014-12-10 11:48:16		
1227	fowai	8		2014-12-10 11:48:16		
1228	tenuw	8		2014-12-10 11:48:16		
1229	dgjji	8	This is Wrong:	2014-12-10 11:48:16		
1230	rrmeu	8		2014-12-10 11:48:16		
1231	dkebi	8		2014-12-10 11:48:16		
1232	tenuw	8	Try making better use of O(n^3) space.	2014-12-10 11:48:16		
1233	qywrh	8		2014-12-10 11:48:16		
1234	azmjc	8		2014-12-10 11:48:16		
1235	eucmc	8	public static double prop2Alive(int x,int y, int N,int step){ if(x<0 ||y<0||x>=N||y>=N) return 0; else { if(step==0) return 1;  return (prop2Alive(x-1,y,N,step-1)+prop2Alive(x,y-1,N,step-1)+prop2Alive(x+1,y,N,step-1)+prop2Alive(x,y+1,N,step-1))/4; } }	2014-12-10 11:48:16		
1236	bjsiw	8	This is my code, it could be optimized by only calling checkBoundary on the borders and exiting the main loop once you reach i==x && j==y && steps == n, but i was going for simplicity of the code here.	2014-12-10 11:48:16		
1237	rrmeu	8		2014-12-10 11:48:16		
1238	mrjku	8		2014-12-10 11:48:16		
1239	wbqzu	8	Good Idea, but generalize your code where n != N. N: Size of matrix; n: no. of steps to take.	2014-12-10 11:48:16		
1240	mrjku	8	For below method, k: number steps. N: size of square matrix island.  Considering array alive[N][N][2], where each element in alive[i][j][steps%2] will keep count of the favourable cases. To calculate this count we just need the result from previous steps, i.e., top = alive[i-1][j][(steps-1)%2]; down = alive[i+1][j][(steps-1)%2]; left = alive[i][j-1][(steps-1)%2]; right = alive[i][j+1][(steps-1)%2];  So, favourable cases for alive[i][j][steps%2] = up + down + left + right;	2014-12-10 11:48:16		
1241	zeice	8		2014-12-10 11:48:16		
1242	jippy	8		2014-12-10 11:48:16		
1243	dkebi	8	update for last line:	2014-12-10 11:48:16		
1244	admin	8		2014-12-10 11:48:16		
1245	sgiwy	8		2014-12-10 11:48:16		
1246	fmzze	8	Model it as a graph search see how many nodes you visited and how many times you result in a death {{   def probabilityalive(x,y,nmoves,N): deaths,moves = getprob((x,y),nmoves,N,0,set()) return 1 - deaths/(1.0 * (moves - 1))  def getprob(xy,nmoves,N,depth,visited): if xy in visited or depth > nmoves: return 0,0 deaths = 0 x,y = xy if xy[0] > N-1 or xy[0] < 0 or xy[1] > N-1 or xy[1] < 0: return 1,1 moves = 1 visited.add(xy) successors = [(x,y+1),(x,y-1),(x-1,y),(x+1,y)] for s in successors: d,m = getprob(s,nmoves,N,depth+1,visited) deaths += d moves += m return deaths,moves  print probabilityalive(5,5,10,10)*100  }}	2014-12-10 11:48:16		
1247	xhgls	8		2014-12-10 11:48:16		
1248	jippy	8		2014-12-10 11:48:16		
1249	ufdxg	8		2014-12-10 11:48:16		
1250	fmzze	8		2014-12-10 11:48:16		
1251	nwkeg	8	Create a quadrant decision tree from the current co-ordinate with depth = n. While you are constructing the tree, if a branch reached an out of bound condition, increase deadly branches count by 1. And then move backwards using recursion to construct the next branch and so on. The final count of the bad branches/ the total number of branches is your probability. This is similar to what is used in gaming.	2014-12-10 11:48:16		
1252	xhgls	8	public class Island { private int islandSize = N; public float getSurvivalProbability(int x, int y, int n) { if ( x < 0 || x > N - 1 || y < 0 || y > N - 1) { return 0; } else if (n == 0) { return = 1; } else { return 0.25 * getSurvivalProbability(x - 1, y, n -1) + 0.25 * getSurvivalProbability(x, y - 1, n -1) + 0.25 * getSurvivalProbability(x, y + 1, n -1) + 0.25 * getSurvivalProbability(x + 1, y, n -1); } } public float getDeathProbability(int x, int y, int n) { return 1 - getSurvivalProbability(x, y); } }	2014-12-10 11:48:16		
1253	qywrh	8	This can be easily done using BFS. The equation I followed is as below: ProbAlive(after N steps) = ProbAlive(after 1 step) * ProbAlive(after 2 steps, given alive after 1 step) * * ... * ProbAlive(after N steps, given alive after N-1 steps)  To compute the term ProbAlive(after K steps, given alive after K-1 steps), BFS is used. When the BFS queue has only elements with positions for kth step, sample space is the queue-size. Iterate through all elements in the queue and if position is valid, add a probability of 1/queue-size to ProbAliveCurStep. During that time, enqueue all subsequent positions with step marked as k+1. Before processing queue with positions marked as k+1, update ProbAlive = ProbAlive * ProbAliveCurStep and reset ProbAliveCurStep.  e.g. For a 4x4 Matrix, max_step 2 and initial pos 0, 0 Iteration 1: Queue Contents: (x: 0, y: 0, step: 0) Pop Element: (0, 0, 0) Sample Space = 0; // Initial position is ignored for probability computation ProbAliveCurStep = 0; Enqueue Neighbours  Iteration 2: Queue Contents: (1, 0, 1), (-1, 0, 1), (0, 1, 1), and (0, -1, 1) Pop Element: (1, 0, 1) // Valid element, proceed Sample Space = 4 ProbAliveCurStep = 0.25 Enqueue Neighbours  Iteration 3: Queue Contents: (-1, 0, 1), (0, 1, 1) and (0, -1, 1) Pop Element: (-1, 0, 1) // Invalid element, continue ... ... After 13 iterations, ProbAliveCurStep for Step 1 = 0.5, ProbAliveCurStep for Step 2 = 0.75 ProbAlive = 0.357	2014-12-10 11:48:16		
1254	gilit	8		2014-12-10 11:48:16		
1255	plapd	8		2014-12-10 11:48:16		
1256	jippy	8	My solution in C++. We fill a matrix of size n*N*N in O(n*N^2) time :	2014-12-10 11:48:16		
1257	admin	8		2014-12-10 11:48:16		
1258	plapd	8		2014-12-10 11:48:16		
1259	admin	8	Heres my attempt, not sure if its completely sound. Any advice would be greatly appreciated :)	2014-12-10 11:48:16		
1260	nwkeg	8		2014-12-10 11:48:16		
1261	wbqzu	8		2014-12-10 11:48:16		
1262	ftfck	8		2014-12-10 11:48:16		
1263	azmjc	8		2014-12-10 11:48:16		
1264	mrjku	8		2014-12-10 11:48:16		
1265	sgiwy	8		2014-12-10 11:48:16		
1266	ewigy	8		2014-12-10 11:48:16		
1267	fmzze	8		2014-12-10 11:48:16		
1268	sgiwy	8	-----------------------------------  Unit tests:	2014-12-10 11:48:16		
1269	huiqq	8		2014-12-10 11:48:16		
1270	tenuw	8		2014-12-10 11:48:16		
1271	bexbp	8		2014-12-10 11:48:16		
1272	sgiwy	8		2014-12-10 11:48:16		
1273	nwkeg	8		2014-12-10 11:48:16		
1274	ufdxg	8		2014-12-10 11:48:16		
1275	bjsiw	8	Here is an O(1) solution:	2014-12-10 11:48:16		
1276	zeice	8		2014-12-10 11:48:16		
1277	mrjku	8		2014-12-10 11:48:16		
1278	huiqq	8	Let the simplicity of the answer sink in.  Given a square matrix of size NxN, for any single direction, the probability of dying is 1/N -- that is to say, those on an edge will go into the water. There are four possible directions, each with the same probability, so 4*((1/4)(1/N)) still equals 1/N chance of death on any given turn, or (1 - 1/N) chance of survival.  To survive X times, we raise this probability to that power: (1 - 1/N)^X  Again, look at the code above. Not all problems need to be complex. If you get this problem, don't go right for the formula. Show a 1x1 grid and convince someone that the odds of survival are 0. Repeat this for a 2x2 and a 3x3. Do it for just one step. Why can we just multiply probabilities for subsequent steps? It's because there is an equal probability of landing on any square after a given round. This means that each round is independent, and we can reach back to our statistics classes wherein we learn the the probabilities of independent events can be multiplied to come up with the combined probability.	2014-12-10 11:48:17		
1279	qywrh	8	I like the way you're thinking but the question is the probability of dying when starting from a particular square. If I were the person on the island, I would pace in a circle or sit down so as not to fall off but apparently the movements are supposed to be random.	2014-12-10 11:48:17		
1280	bexbp	9	Presuming a protocol exists that can ask three questions to each server:  * the score of a single url * the top 10 * the top n that satisfy score >= N  We program a two pass solution like so:  We denote the number of servers as S.  [First pass] (1) Ask every server for its own top ten  (2) merge the results. For all URLs in the merged set calculate correct values by asking all servers for their scores for each URL. Calculate a set of top ten from our sample.  (3) pick score of the now tenth URL as the threshold that we try to beat in the second round. We denote the threshold as T.  [Second pass] (4) Ask every server for all its top N that satisfy score >= T/S  (5) Merge these bigger samples again as in step (2)  (6) We now have the correct top ten with correct scores.	2014-12-10 11:48:18		
1281	wbqzu	9	I think they would expect a solution that spreads the work more uniformly among the different servers, which is hard with these constraints.  However, i think you have the merit of getting the right result. +1	2014-12-10 11:48:18		
1282	admin	9	Am not sure if this is going to work all the time. Please correct me if i am wong  X:Y Means Urls X has a count of Y We want top 2 uRLs  M/C A=> 1:100 2:96 7:98 M/C B=> 3:99 5:97 7:2 M/C C=> 4:98 6:95 7:2  1st Step A=>1,2 B=>3,5 C=>4,6  2nd Step Top two after merging 1,3 Urls are selected  3rd Step Threshold=99(Selected from url 3)  4th Step Score = 99/3=33 A=>1,2,7 B=>3,5 C=>4,6  5th Step Merging will again give us 1,3 when infact Url 7 has the highest count	2014-12-10 11:48:18		
1283	qywrh	9	Mihun, I think you're missing a step.  Step (2) says you merge the sets and *request* counts from all servers. This will give you the score of 102 for Url 7.	2014-12-10 11:48:18		
1284	cfzie	9	Mithun, you made a mistake in your example and I think you misunderstood the suggested approach. M/C A=> 1:100 2:96 7:98 , so 1 and 7 would be the top 2.  Anyway, even if we change it to M/C A=> 1:100 2:96 7:94 M/C B=> 3:99 5:97 7:4 M/C C=> 4:98 6:95 7:4  Where 7 is the most visited site as you intended, the merging in 5th step implies that "For all URLs in the merged set calculate correct values by asking all servers for their scores for each URL", so we would get 102 as the count for url 7.	2014-12-10 11:48:18		
1285	huiqq	9	Oh okok.. got it.. So in the worst case if all URLs satisfy the score of > T/S, all the URLs will be sent to the server for merging right ?	2014-12-10 11:48:18		
1286	nhibd	9	The approach is correct ... the only issue being that the solution will not scale and for a large number of machines the network traffic may be gargantuan. Consider an example with top ten counts in range of 1million and the number of servers in 10k range (which is not a big number considering the scale of amazon or google scale) so eventually you will ask for all URL which have count >= T/S which is 100 in this case. So you will end up sending a lot more data than is actually needed (as you will be sending URL for counts between 100 and 1 million). Also the bottleneck in such a solution would be central node processing this algorithm which wont scale but as I said earlier the solution is correct but not scalable.	2014-12-10 11:48:18		
1287	plapd	9	Thanks, vik, for your thoughts on scalability. I think this shows how open ended the question actually is. Without more knowledge about the topology of the machines, datacenters, loadbalancers, etc involved it is not possible to proof the quality and scalability of the algorithm in real life. A few things I would suggest to discuss about this:  - is it a typical weblog file? Typical weblogs have a steep declining start and a long flat tail, so the number of accesses on the tenth rank are usually high: if it is such a distribution, this algorithm is not bad.  - how biased are the loadbalancers? If the loadbalancers have a high degree of randomness built in, then the differences between the machines are statistically already similar enough that the first pass is quite good and the second pass is not much work.  - can clusters of machines be pre-merged? If racks or lines of racks can have a logserver that collects the full logs for the rack or line, then the number of servers to contact can be drastically reduced.  - how often are these calculations repeated? Which similar questions need to be answered? How often? How exact must the numbers be? How up-to-date? Each answer would influence the program and tuning we want to set up to produce fast and good numbers.	2014-12-10 11:48:18		
1288	wbqzu	9	Consider this example. Lets find the top 1 URL for now and we can extrapolate the question for top 10 URLs too.  3 Servers Server 1 : URL A-> 2 URL G->1 Server 2 : URL B->2 URL G -> 1 Server 3 : URL C -> 2 URL G -> 1  Wouldn't the above algo give URL A, B or C as the top visited URL where as the actual top URL should be G?	2014-12-10 11:48:18		
1289	nwkeg	9	Hi Izaaz, in your example the first pass finds the critical threshold T to be 2. The second pass would then calculate T=2 devided by S=3 and ask all servers for all URLs that have a score >= 2/3. In other words it would merge the complete set of URLs and thus get the URL G and the sum of the accesses to it in the second pass.	2014-12-10 11:48:18		
1290	fmzze	9	Sorry if I miss something. But I don't think it's going to yield the correct result by selecting Top N with or without threshold. Considering the following case:  Server A Y1 - 11 Y2 - 11 Y3 - 11 Y4 - 10 Y5 - 10 Y6 - 9 Y7 - 9 Y8 - 9 Y9 - 9 Y10 - 9 ... G1  4  Server B M1 - 12 M2 - 12 M3 - 11 M4 - 11 M5 - 10 M6 - 10 M7 - 10 M8 - 10 M9 - 10 M10 - 10 ... G1 - 9   The threshold 10 / 2 = 5.  In the second pass, G1 in server A wont be included for tally. In fact, G1 with total 13 visits could be the top 1. But it does not even get into top 10 based on the method. Do I miss something?	2014-12-10 11:48:18		
1291	jippy	9	@aka777, G1 is not part of the top of server A but it will be part of the top of server B with visits >= 10 / 2. So, the algorithm will ask for all G1 occurrences in other servers and it will correctly put this as top1.  it will yield the correct result, with possibly the cost of multiple rounds.	2014-12-10 11:48:18		
1292	ftfck	9	Thanks, Miguel. I got it. Theoretically, the algorithm will yield correct result. But Google has more than one million servers. I don't know how this is gonna work out. (Threshold is gonna be very low like vik said.)	2014-12-10 11:48:18		
1293	plapd	9	The constraints puzzle me a bit, especially the "using MapReduce directly, is not allowed" one. I would try to discuss what that means exactly in an interview. I'll give another shot at the question:  Denote N as the number of computers in our network.  1) Pick a good string hash function. This function must take urls as input and produce hash values uniformly in the range [0, MAX_HASH_VALUE]  2) Divide the hash range [0, MAX_HASH_VALUE] into N intervals with equal length MAX_HASH_VALUE / N, and assign each interval to 1 computer in the network, e.g. CPU_1) [0, length-1] CPU_2) [length, 2*length-1] CPU_3) [2*length, 3*length-1] ... CPU_N) [(N-1)*length, MAX_HASH_VALUE]  3) Each computer computes the hash values of its list of urls and sends the url and its visited information to the computer responsible by the hash of that url.  4) Each computer received a list of information url->visits for the urls in its hash interval. Now it must combine the visits of the urls and produce its top 10.  5) Each computer sends its top 10 to a central computer. This central computer will receive 10*N urls and compute the overall top 10.  Due to our good hash function, we expect that each computer will receive roughly the same amount of urls to process in the 4th step. I think this approach is the best we can do to distribute the work among the cluster.  About the constraints, they're not very clear. a) This is sending all urls over the network but not to a single computer. In order to produce an exact result, I think all approaches end up sending all urls over the network in the worst case. Again, we would need to discuss with the interviewer if this is ok (the "especially sending all of them to a central server" part).  b) This is similar to MapReduce. I think that by saying "using MapReduce directly is not allowed", the interviewer meant that we have to give a detailed explanation about how the work is distributed among the network of computers, instead of just saying "the MapReduce framework will distribute and combine the work for us".	2014-12-10 11:48:18		
1294	admin	9	I think this is the only reasonable solution. The word "especially" in the phrase "especially to a central computer" seems to imply that sending the maps in a distributed manner might be acceptable, which is the only constraint this solution violates. It is the only solution that produces the correct result and is guaranteed (modulo the goodness of the hash function) to not send all the urls to the same server in the worst case.	2014-12-10 11:48:18		
1295	mrjku	9	I think so as well. Someone -1 all my replies to this and a few other threads, for some reason, and I guess this reply was kind of forgotten.	2014-12-10 11:48:18		
1296	nwkeg	9	As you said , you are sending all of the urls on the network , which I guess is impossible as it's been said in the question. It works but it doesn't conform to the constraints.	2014-12-10 11:48:18		
1297	ftfck	9	This is the best solution I can come up with. It is effectively distribute the computations and traffic over the network. It does not need a central server.	2014-12-10 11:48:18		
1298	tenuw	9	Isn't this similar to Map-reduce ?	2014-12-10 11:48:18		
1299	rdfeo	9	what if two URLs have the same hash value??	2014-12-10 11:48:18		
1300	fowai	9	I don't think any of the suggested solutions are right. It is possible to imagine a situation where some url is ranked number 11 on every box, and so has very high visits overall, while every url in the top 10 on each individual box is seen nowhere else, so has low visits overall.  That said, I don't have any better ideas. This problem is hard!	2014-12-10 11:48:18		
1301	qywrh	9	The first pass gives you a lower bound. In the second pass, you will include that 11th url in your candidate set, since its overall visits is certainly greater than the 10th url found in the first pass.	2014-12-10 11:48:19		
1302	gilit	9	Anon is correct. The second pass will not help. Take the following situation: 3 servers: SERVER A: URL #1 - #10 : 2 counts URL #0 : 1 count SERVER B: URL #11-#20: 2 counts URL #0: 1 count SERVER C: URL #21-#30: 2 counts URL #0: 1 count  now the first pass will find URL #1-#30 but not URL #0, this will be completely missed. Yet it is the winning URL, with 3 counts. Hence the whole strategy is flawed.	2014-12-10 11:48:19		
1303	sqzqo	9	langeolli: it the two pass solution I described, you miss rule number 4:  Ask every server for all its top N that satisfy score >= T/S  In your example, T=2 and S=3, so the threshold is < 1 and consequently all three servers will have to deliver their full logfiles and the result will find URL #0 to have 3 hits.	2014-12-10 11:48:19		
1304	mrjku	9	I understand that with the given constraints it is not possible to get a trivial solution. but i thik we have to consider the senario where one url in the actual 10 top urls is visited by most of the machines but only a few times that will keep it out of the individual top 10 lists of each machine.  does that sound right?	2014-12-10 11:48:19		
1305	tenuw	9	I agree : This example would fail  Consider this example. Lets find the top 1 URL for now and we can extrapolate the question for top 10 URLs too.  3 Servers Server 1 : URL A-> 2 URL G->1 Server 2 : URL B->2 URL G -> 1 Server 3 : URL C -> 2 URL G -> 1  Wouldn't the above algo give URL A, B or C as the top visited URL where as the actual top URL should be G?	2014-12-10 11:48:19		
1306	rdfeo	9	You could possibly continually request the top urls until you have ten where the smallest value in the top10 list is not more then the highest value in any server using paginated sets. For example,:	2014-12-10 11:48:19		
1307	xhgls	9		2014-12-10 11:48:19		
1308	zeice	9		2014-12-10 11:48:19		
1309	sgiwy	9	Merge would keep no more than max values based on unique url and highest visits.	2014-12-10 11:48:19		
1310	bjsiw	9	I would recursively group the servers into sets of two and aggregate the URL's . Suppose there are 6 servers. a) Group s1s2, s3s4, s5s6. b) We know the entire map cannot be transmitted. Find out a safe message size for the network. Supposing n. Break the map in s1 into n size chunks and send over to s2. Similarly from s3-s4, s5-s6. c) This is the tricky part. The ques says we cannot do map-reduce directly. Does that mean map-reduce on the entire set? Is it allowed for individual machines? But it will be silly to solve this without ever getting a count of the URLs. So if map reduce is not allowed, write a procedure to sort the urls and track each one's count. This is done in s2, s4 and s6. d) Now, again group the machines. This time {s2s4}, {s6}. e) Repeat b, c . We will have s4, s6 left. Transmit from s4-s6 and perform a final count.	2014-12-10 11:48:19		
1311	mrjku	9	Lets assume, we can store count of k urls in the central machine. If the corpus is of size n, we get the top n/k elems from each server and send it to our central machine.  So, in our central machine, we have a set of k counters each initialized to 0 to start with. As we get our data from the stream, for every url, if it exists, we increment the counter. If not: case1: if there is size in our central machine to add the url, we add it and set its count case 2: if not, we delete the count of every url we have in the central machine. If there is any url that has a count of 0, we delete it.  Now, the moment we hit case 2 above, we record the max_count_so_far and take a snapshot of the top 10 elements.  We process the next set of top n/k elements from the machines and for every max_count_so_far elements we take a snapshot of the top 10 elements.  At some point, say after we have 10 such snapshots, we find the final top 10 elements from the snapshots we have so far	2014-12-10 11:48:19		
1312	sqzqo	9	On each server, we sort the urls based on their frequencies. Say total log file lines across all servers are N. Number of servers is s. Capacity of server is k. Now split the ranked urls such that there are k/s elems per group on each server. Label each group , there will be total N/(k/s) ids.  Now, from this set of ids, we randomly select s ids (i.e s groups) such that each id doesnt occur more than threshold times on one machine. (To keep it simple lets say threshold=1).  Now, we employ the following algorithm on the central machine: If there is size in our central machine to add the new group, we add it and set the count of each of the elems in the group. If not, we delete the count of every group/element in the group. We delete all urls that have a count of 0.  Now, one might argue that we might endup spending too much time on low frequency entries. We could then employ multiple iterations of elimination here. In the first pass, we can only consider frequencies that are above a certain threshold: say frequency above the median of the frequencies in each server. And divide those set of urls into groups. And consider random group from each server.	2014-12-10 11:48:19		
1313	ufdxg	9	have a centralized counter. every time a new hit is recorded, recalc the centralized counter for that url with properly synced data structure. then compare it with the top10 hit stack by popping out the ones smaller than the current count result. keep updating the top 10 stack every time the new hit is recorded and you can always query the top 10 stack for the top 10 hits.	2014-12-10 11:48:19		
1314	qywrh	9	I think that violates this "the maps are too large to transmit over the network (especially sending all of them to a central server "  there are too many visits to centralize a counter in one machine	2014-12-10 11:48:19		
1315	vanul	9	Lets say the number of servers is N. I think the solution requires 10 passes among the top ten scorers of each server. In each pass you can only identify one in the top ten. After each pass, the selected URL from the previous pass must be excluded from the evaluation in the subsequent passes, and the top ten scores from each server must be updated.  Think of the first pass. When all the top ten lists are considered, there must be at least one URL among these top tens which will land into the "real" top ten list. It is possible to generate scenarios where 9 of the real top ten list do not appear in the "current" top ten lists. But, there has to be at least one URL in the real top ten list which also appears in the 10N URLs that are collected from the servers' current top ten lists. Note that this is true only when N>=10. If N<10, all the real top ten list may not appear in the 10N URLs.  Also note that after collecting the 10N URLs, for some of them, you will have to ask the servers their frequencies so that you can sort the 10N URLs properly. Because, you want to sort the sum of visit frequencies of these URLs at each server.  After 10 such passes the real top ten list will emerge. The messaging complexity of each pass could be as bad as N^2 since you may have to collect the frequency values for each one of the 10N URLs. But, the computational complexity of each step is O(N) since you only need to find the max of 10N URLs.  If we were to design an algorithm that can find out not just 10 but the top K list. Then, we would be have to collect the top N scorers from each server .So, rather than 10N, we would bring together the top N^2 list at each pass. If K>N, this design is preferable.	2014-12-10 11:48:19		
1316	krxlv	9	Here's a counter example where the top 3 does not appear in the top 3 of any of the 3 servers:  s1= { a:10, b:9, c:8, d:7, e: 6, f: 5 }, s2= { g:10, h:9, i:8, d:7, e: 6, f: 5 }, s3= { j:10, j:9, l:8, d:7, e: 6, f: 5 }  the top 3 is {d: 21, e: 18, f: 15 }, so that approach also does not guarantee 100% correctness	2014-12-10 11:48:19		
1317	vanul	9	Good example..  In the first pass, it will find a (or g or j). In the second pass, d will be in the first three of s1 since a is kicked out of s1's top three. So, the second pass will find d. The third pass will, in turn, find e. I can see, however, that f will not be included in the top three list after three passes.  We can update the algorithm as follows:  After a pass, if a new fellow is selected that places into an unexpected spot (i.e., item found in the i th pass places into a spot < i th place in the top items list), then we increase the total number of passes by one.  This should do it..  If not, I think making N^2 passes should do it.	2014-12-10 11:48:19		
1318	huiqq	9	Actually, even top N^2 may not do it.. :) Here is one more update to the algorithm I proposed:  Find the max value among all the lists: This should be easy to do. Findmax for all lists. Let's say that the max value is M.  Then, apply the iterative algorithm (with the extra check I described in my prev post) among the top lists of each server such that the top lists include all the values greater than or equal to M/N.	2014-12-10 11:48:19		
1319	xhgls	9	Well, top N^2 lists will do it. :) But, cutting the top lists at M/N threshold will perform better on the avg case.	2014-12-10 11:48:19		
1320	dkebi	9	the logic is similar to tetris game algorithm. Or generalize voting algorithm.	2014-12-10 11:48:19		
1321	admin	9	We partition the work by using a hash on the url. The hash gives an address to an aggregator who is responsible counting a subset (as defined by the hash) of urls. Then we crawl through the aggregators and fill the top-ten list. As each url is mapped to exactly one aggregator the crawler only has to maintain a map with ten entries.  Step 1) send table with aggregator addresses: say we use 10k aggregators Step 2) on individual machine count all urls Step 3) on individual machine iterate through counted urls, find hash-key, modulo 10k gives you the address of responsible aggregator -> send to aggregator the count of said url. Step 4) aggregators accumulate the counts Step 5) initialize empty top-ten list, iterate through 10k aggregator machines and maintain the top-ten list	2014-12-10 11:48:19		
1322	admin	9	The easy solution to solve this kind of problem is MapReduce. Since MapReduce is not allowed, the other alternative is to sort the string (url) ==> int (visits) in each machine independently such that it is the increasing order of visits. Then each server can send their top 10 visited URLs, Visit mapping to one of the server.  This single server would receive data from all the others for the top 10 visited sites and do a merge to decide on the top 10 sites. ( A n-way merge sort of the URL vs visits).	2014-12-10 11:48:19		
1323	ftfck	9	That's not correct. There could be a URL that is not in the top 10 for any one server, but is in the top 10 overall. See tony's response to Miguel Oliveira's answer.	2014-12-10 11:48:19		
1324	sqzqo	9	edit: this is does not guarantee 100% correctness  The question says we can't use MapReduce directly because the amount of data is too large. However, the overall top 10 sites are *expected* to be in the top 10 of at least one of the computers.  Hence, we can sort the logs of each computer and emit the top 10 of each computer in the mapping phase. Then, the reduce phase aggregates the number of visits for each site. The result will be the top 10 of the aggregate.	2014-12-10 11:48:19		
1325	ufdxg	9	This is wrong. Imagine the most frequent terms are	2014-12-10 11:48:19		
1326	qywrh	9		2014-12-10 11:48:19		
1327	wbqzu	9		2014-12-10 11:48:19		
1328	bjsiw	9	Then the top three most frequent in the merged list should contain url4 as the top one though url4 is not the top three in any of the original lists.	2014-12-10 11:48:19		
1329	wbqzu	9	yeah, Anon gave an example in his answer. These types of questions require some discussion with the interviewer. I don't see a way to do it in a very efficient way given the constraints, maybe those constraints were not so strict as it seems.	2014-12-10 11:48:19		
1330	rdfeo	9	What if we manage a MaxHeap of top 10 sites at each node separately, and a heap of size 10 in central unit. The central heap can be updated according to :	2014-12-10 11:48:19		
1331	gilit	9		2014-12-10 11:48:19		
1332	tenuw	9		2014-12-10 11:48:19		
1333	nwkeg	9	Then at every pre-specified interval, we can request updates from the nodes whose responses are the content of their respective MaxHeap.	2014-12-10 11:48:19		
1334	sqzqo	9	the aggregated top 10 is not necessarily in the top 10 of a individual server. so it won't guarantee correctness	2014-12-10 11:48:19		
1335	ewigy	9	We could use a BFS, visit every node and add sum of the integers to the master map that has all the URL's checking, if the URL is already present, then just add the integer orelse create a new key and put it into the map. Then traverse through the map to find the top ten values or just sort descending and return the first 10 values.	2014-12-10 11:48:19		
1336	gilit	9	"the maps are too large to transmit over the network (especially sending all of them to a central server (..)"  can't go that way	2014-12-10 11:48:19		
1337	ftfck	9	There are N number of machines, Determine top 10 in every machine. Each machine transmits its top 10 to every other machine i.e (n-1)10 urls This Implies each machine also recieves (n-1)10 urls  Process these and determine the top 10 in every machine.  Each machine now sends its Top 10 to a single place,(n*10) The top 10 among these (n*10) will be the most visited URL's  I do not know if there is any way to avoid not replicating the data on each machine. But will N*(N-1)*10 url's be too much traffic for the network to handle, cos that will be the total number of replications required.  Other possible solutions I could think of was using P-S pattern to publish count of URL's periodically.	2014-12-10 11:48:19		
1338	xhgls	9	that's quite similar to the approach i posted before. this does not guarantee 100% correctness. the aggregate top 10 does not need to be in the top 10 of any individual server.	2014-12-10 11:48:19		
1339	jippy	9	My bad, had not read any answers, before replying.	2014-12-10 11:48:19		
1340	fmzze	9	1. tag the nodes as n1, n2, n3..... nk 2. First n1 sorts its list of URLs to find top10 3. n1 sends this list to n2. n2 adds this list to the data set, and gets a top 10 4. now n2 sends its top10 (calculated in step 3) to n3 5. keep doing it till we reach nk  nk will have the cumulative top 10	2014-12-10 11:48:19		
1341	cfzie	9	it will not. check anon and tony's posts above.	2014-12-10 11:48:19		
1342	wbqzu	10	This can be solved using rope data structure. It's like a binary tree except that each node maintains the number of nodes in the left subtree+1 for itself. Whenever a new number is inserted, if the value is smaller than the node's number it goes to the left otherwise right. When it goes to the right, the value of the node is decreased by the value of the branch node. Ex Nodes: 6 5 4 3 2 1 values: 0 0 0 2 2 4 1. Make 6 as the root of the tree, its value = 1; 2. Insert 5. Value of 5(0) < value of 6(1) so it goes to the left. New value of 6 = 2, value of 5=1; 3. Insert 4, value of 4 < value of 6 so goes to the left; again goes to the left of 5. New values of 4 = 1, value of 5 = 2, value of 6 = 3 4. Insert 3, goes to the left of 6 but to the right of 5. New values 6 = 4, value of 3 = 1, rest unchanged 5. Insert 2, goes to the left of 6, right of 5 (value of 2 is decreased by value of 5 so its now 0), left of 3. New values of 3 = 2, value of 2 = 1, value of 6 = 5 6. Insert 1, goes to the left of 6, right of 5, right of 3. Do an in-order traversal of tree. It is imperative to insert the nodes in decreasing order	2014-12-10 11:48:21		
1343	fowai	10	cool	2014-12-10 11:48:21		
1344	rrmeu	10	very nice solution.	2014-12-10 11:48:21		
1345	dkebi	10	why does a rope work here? doesn't seem very intuitive to use a rope...	2014-12-10 11:48:21		
1346	jippy	10	Without balancing, the worst case is still O(n^2)	2014-12-10 11:48:21		
1347	ufdxg	10	Though I like the idea of sorting using the comparator as mentioned above by amitb2108 but below is the approach that came to my mind first. lets say height[] = {3,1,2,4} pos[] = {0,2,1,0}; //no of persons greater height than him 1. create an array of person struct of size n and fill the data from the above two arrays struct person { int height; int num; }; 2. Sort the person array with height as the key in decreasing order. o(nlgn) index 0,1,2,3 person[] = {4,3,2,1} {0,0,1,2} //person.num 3. Remember the index of array represents the no of persons greater in front of the current index. e.g. person with height 3 has array index 1, so 1 person is in front of him with greater height. But we need to have 0 no of person greater than 3, so swap it with index 0. person[] = {3,4,2,1} //after swapping 3 //2 has only one person in front but index of 2 is 2 currently there are 2 persons //swap it with index 1 person[] = {3,2,4,1} //1 has only 2 persons in front but index of 1 is 3, so currently there are 3 persons //swap it with index 2 person[] = {3,2,1,4} the idea is, previous index, has a person with greater height than current index. The previous index person's position is already set. Now if we move this previous index person towards right it doesn't impact the position of this person. e.g. person with height 4, if we move this person towards the right, still the no of persons with greater height will be 0. Total complexity = o(nlogn)	2014-12-10 11:48:21		
1348	vanul	10	I don't think your solution is O(nlogn).For instance: 4321 0011 as your idea step 1: 3421 step 2: 3241 step 3: It should be 3124. Then I realize that it shouldn't be swap. It's insert. Just insert person.height to arr[person.num] is ok. The insertion complexity = o(n^2)  Anyway, thanks for your idea!	2014-12-10 11:48:21		
1349	mrjku	10	@dmxmails: The complexity can be further reduced if you use a clever data structure that supports fast insertion at an arbitrary position. This can be achieved using a modified skiplist (expected insertion time O(logN)) or a modified balanced binary tree for which we store the in each node the number of nodes in the subtree rooted at that node (worst case insertion time: O(logN)).  So, the final complexity of the algorithm would be O(N*log(N)).	2014-12-10 11:48:21		
1350	xhgls	10	@dmxmails - in step 3, why it should be 3124? In 3124, 1 has only one person in front with greater height. But as per the input height[] = {3,1,2,4} pos[] = {0,2,1,0}, 1 should have 2 persons with greater height in front.	2014-12-10 11:48:21		
1351	vanul	10	@dhiren.bhuyan my input is height[] ={4,3,2,1} pos[] = {0,0,1,1}	2014-12-10 11:48:21		
1352	admin	10	Newbie here. Can you explain how is the complexity O(n logn) ?	2014-12-10 11:48:21		
1353	nwkeg	10	If I understand correctly, you are swapping every element a with the element b in left holding a's actual position. But I guess just swapping will not work.you have to insert it in its proper position by shifting all elements from b to a.  try this example  9 9 8 7 5 4 3 2 0 0 0 3 0 5 1 7	2014-12-10 11:48:21		
1354	krxlv	10	sort the person by the height if the count is not zero, swap the person on the right who is higher until the count become zero  time: O(n^2)  example 1  235461 020004  sort  123456 402000  swap 1  234516 020000  swap 3  245316 000000  example 2  3 1 2 4 0 2 1 0  sort  1 2 3 4 2 1 0 0  swap 1  2 3 1 4 1 0 0 0  swap 2  3 2 1 4 0 0 0 0	2014-12-10 11:48:21		
1355	dgjji	10	your solution does not work well for the example below, 235461 030004	2014-12-10 11:48:21		
1356	rrmeu	10	You can sort the list of persons (person: height,numTallBeforePerson) using the following comparator:	2014-12-10 11:48:21		
1357	huiqq	10		2014-12-10 11:48:21		
1358	dgjji	10		2014-12-10 11:48:21		
1359	vanul	10	The idea is that a shorter person standing after a taller one will have larger number of tall people before him than the taller person. Time complexity: O(n log n)	2014-12-10 11:48:21		
1360	sqzqo	10	I don't think this problem can be solved in O(n log n). To indicate the bug in the above solution consider the following example. Assume people have heights from 1 to 20. Assume person with height 3 has rank 10 and person with height 5 has rank 9.  Then just by looking at 3 and 5 and their rankings you cannot conclude whether 3 is in front of 5 or 5 is in front of 3. It depends on where other elements are located. (You can actually construct two different examples where 3 is in front of 5 in one example and the other way around in the second example)	2014-12-10 11:48:21		
1361	sqzqo	10	i dont think the above solution for the input below I/P 235461 020004 O/P 245316	2014-12-10 11:48:21		
1362	rrmeu	10	In two sequences below 5 and 3 have the same corresponding number in array B but their order is different. So the idea above is not correct (front of the array is the right side) 12435 12534	2014-12-10 11:48:21		
1363	fowai	10	>> You can sort the list of persons (person: height,numTallBeforePerson) Does this mean persons[i] = new Person(heights[i], count[i])? If it is the case, the solution is incorrect.  The simplest counter example: Input: A: [1, 2] B: [0, 1] The expected output should be: [2, 1] However, the solution outputs [1, 2]	2014-12-10 11:48:21		
1364	rrmeu	10	This is my code and this code can be used in any amount of integers in an array  public class class2 { public static void main(String args[]){ int arr1[]={3,5,1,6,7}; int arr2[]={0,1,1,2,3}; for(int i=0;i<arr1.length;i++){ for(int j=i+1;j<arr1.length;j++){ if(arr1[i]<arr1[j]){ int n=0; n=arr1[i]; arr1[i]=arr1[j]; arr1[j]=n; } } }  int arr3[]=new int[arr1.length]; int k=1; while(k<=arr3.length){  arr3[arr3.length-k]=arr1[arr2[arr3.length-k]]; arr1[arr2[arr3.length-k]]=0; for(int i=0;i<arr1.length;i++){ if(arr1[i]==0){ for(int j=i;j<arr1.length-1;j++){ arr1[j]=arr1[j+1]; } arr1[arr1.length-k]=0; break; } } k++; } for(int s=0;s<arr3.length;s++){ System.out.println(arr3[s]); } } }	2014-12-10 11:48:21		
1365	wbqzu	10	Backtrack.  Let's say the first array is height array and the second is count array. Sort the count array from low to high (say [0,1,1]). Start from the first height 3 (corresponding to count 0), the root node of the backtrack tree is (3), then insert the second height 2, generating one child node (3,2). Then insert the third height 1, generating one child node (3,1,2). If a node does not generate any child node, then it is an dead end. In this case, backtrack to the upper level node to visit its next child node.  This way you can find all possible sequences satisfying the two arrays. And you can confidently know if there is no such sequence at all.	2014-12-10 11:48:21		
1366	ewigy	10	My algorithm: Time -- O (N LOG N) & Space --O(N) .. please let me know your comments... it seems to work for all cases, let me know if I am missing something...  Approach:  (1) Sort the input in descending order of size -- O(N LOG N) (2) Use a stack based approach -- O(N) : (find below)  Given:  A[] = {1,2,3,4,5} b[]= {3,1,1,1,0}  Step 1: Sort A (and hence B) --> A[] = {5,4,3,2,1} B= {0,1,1,1,3} // Here, this is still O(N.LOG N)  Step 2: Stack based algorithm (Say have 2 stacks: S1->stack.new, S2->stack.new)	2014-12-10 11:48:21		
1367	ftfck	10		2014-12-10 11:48:21		
1368	bexbp	10		2014-12-10 11:48:21		
1369	dgjji	10	Let: A[] = {5, 4, 3, 2, 1} B[] = {0, 0, 0, 0, 0}  Then your solution is O(n^2)	2014-12-10 11:48:21		
1370	mrjku	10	@Marathon -- interesting observation :) ... let me check this and get back with some improvement !	2014-12-10 11:48:22		
1371	mrjku	10	all persons height are unique how about persons with the same height.	2014-12-10 11:48:22		
1372	eucmc	10	int main (int arc, char * argv[]) { int arrHeight[] = {3,2,1}; int arrKeyGiven[] = {0, 1, 1};  int i, j, temp = 0, length = 0;  length = 3;//4;   /** LOGIC FOR RESETING THE POSITION ACCORING TO THE KEY GIVEN if Current position < keyPostion then : do one swap with teh previous one :) else : do one swap with the next one :) **/  for (i = 0; i < length; i++) { if ( arrKeyGiven[i] < i) { temp = arrHeight[i]; arrHeight[i] = arrHeight[i-1]; arrHeight[i-1] = temp; } } printf("REPOSITIONED ARRAY IS \n"); for (i = 0; i < length; i ++) printf("%d\t", arrHeight[i]);  return 0;  }	2014-12-10 11:48:22		
1373	ufdxg	10	THIS IS THE MODIFIED LOGIC:----- WORKS WELLL :) please have one try by assigning some logically correct values to arrHeight, and arrKeyGiven and see the result...if any issues plz revert to jitu059@gmail.com U need to edit, arrHeight/arrKeyGiven and length to test more problems ################################# int main (int arc, char * argv[]) { int arrHeight[] = {3,1,2}; int arrKeyGiven[] = {0, 2, 1};  int i, j, temp = 0, length = 0;  length = 3;//4;   /** LOGIC FOR RESETING THE POSITION ACCORING TO THE KEY GIVEN if keyPosition < Current Position then : do one swap with teh previous one :) else if keyPosition > Current Position then : do one swap with the next one :) else : DO NOTHING......current position is desired one :) **/  for (i = 0; i < length; i++) { if ( arrKeyGiven[i] < i) { printf("Swaping in process\n"); temp = arrHeight[i]; arrHeight[i] = arrHeight[i-1]; arrHeight[i-1] = temp; } else if( arrKeyGiven[i] > i) { temp = arrHeight[i]; arrHeight[i] = arrHeight[i+1]; arrHeight[i+1] = temp; } } printf("REPOSITIONED ARRAY IS \n"); for (i = 0; i < length; i ++) printf("%d\t", arrHeight[i]);  return 0;  }	2014-12-10 11:48:22		
1374	plapd	10	u code appears to be wrong for this input heights=[33 ,11 ,22 ,44 ,55 ]; rank=[0 ,2 ,1 ,1 ,0 ];  output=[33 ,22 ,11 ,55 ,44 ]	2014-12-10 11:48:22		
1375	fowai	10	Given Hight Arrays H[], Queue Arrays Q[], Return Output O[] 1. Sort H in desc order as H' 2.Loop while N--; pick Q[N] th element of H' as O[N]; adjuct H' // remove H'[Q[N]] in H'	2014-12-10 11:48:22		
1376	huiqq	10	Isn't the question incorrect: if the heights are 3,2,1 in some height-units, shouldn't the array be 0,1,2 - representing no one in front of 3, 1 guy in front of 2 and 2 guys in front of 1. Or maybe i am missing something that rest everyone is not - pls enlighten	2014-12-10 11:48:22		
1377	bexbp	10	The second array doesn't just indicate how many guys are standing in front of a particular guy, but specifically the number guys standing in front who are of *greater height*. So, even though guy of height 2 has two guys in front of him, there's only 1 guy in front of him of greater height.	2014-12-10 11:48:22		
1378	ufdxg	10	I found that the max element is at the rightmost position(call pos) whose value is zero in the array b, so everytime I insert the max element of the remaining elements, and all the elements on the right of pos in b should decrement by one, because one max element is eliminated on the left, and carry on untill no elements left in a, and here is my code:(O(n^2), I think my algorithm supports duplicate heights)	2014-12-10 11:48:22		
1379	bexbp	10		2014-12-10 11:48:22		
1380	ftfck	10		2014-12-10 11:48:22		
1381	dgjji	10	How about next idea. The last element of second array - let call it array of inversions in following, is always that we have in desc order. For example. 3 2 1. 2 0 1 1 - is element with index 1 in desc order. so it must be placed the in that way: * * 2 0 1 * so 1 - is element with 1 index in desc order without 2. it must be placed there * 1 2 and following 3 1 2  We process array from right to left. element i must be placed with element from first array without already processed element in desc order.	2014-12-10 11:48:22		
1382	gilit	10	Use an order stastisc tree: - Insert all the heights into an order statistic tree - for i from B.length -1 to 0: - what is the B[i] order statistic value in the order statistic tree - remove that value from the tree and insert it into the results array at i  Time is nlogn (n queries for order statistics) Space is n (order statistic tree size)	2014-12-10 11:48:22		
1383	vanul	10	Another O(n logn) time and O(n) space solution. Please correct me if there are issues.	2014-12-10 11:48:22		
1384	bjsiw	10		2014-12-10 11:48:22		
1385	ftfck	10		2014-12-10 11:48:22		
1386	zeice	10	One solution: Every time, select the smallest number with front[] = 0. e.g. height[] = {3, 1, 2, 4}, front[] = {0, 2, 1, 0} 1) Find the smallest number from height[] that has 0 in front[], in this case it is 3, then 3 is 1st element in the queue. 2) For rest of the elements i in height[], if it is smaller than 3, then front[i] - 1, otherwise keep front[i] the same. Go back to 1)  This is pretty much like topological sorting; each time remove the node with indegree == 0.	2014-12-10 11:48:22		
1387	sqzqo	10	Observe that in any arrangement of heights, the smallest element can have one and only one spot to go.  eg. { 3, 1, 2, 4 } {1, 2, 2, 0}  1 is the smallest element and needs to have 2 elements ahead of it. All other elements are larger, so it must only be able to go into ar[2]. After placing 1 in ar[2], count 2 empty spaces, skip 2 because it's taken and place 2 into ar[3]. 3 needs 1 empty space and goes into ar[1] and 4 into ar[0].  Fail if there are no available spots. Collisions or cases like  { 3, 1, 2, 4, 1 } {1, 2, 2, 0, 2}  are handled elegantly by the space counting.  Unoptimized this is O(n^2).	2014-12-10 11:48:22		
1388	gilit	10	Here is a python code that runs in O(n logn) time. If you use some sorting algorithm, say radix sort, that runs in O(n) time, then this algorithm will take O(n) time.	2014-12-10 11:48:22		
1389	cfzie	10		2014-12-10 11:48:22		
1390	admin	10		2014-12-10 11:48:22		
1391	admin	10	Consider line[] array where people have to be placed.  Assumption : all people have distinct height from 0 to N-1. so sort A and hence B array (along with A) in increasing order.  Now A=[0,1,2,3,4...].  So, now we can ignore A[] and only consider B[] ans array where B[i] is = number of people with greater height in front that person of height i.  Now, in line[], 0th person will be at index B[0] since there are exactly B[0] person > than 0th person. For second largest person if B[1] < B[0] 1 ahead of 0th person in line[]. else after 0th person. Eg  if B=[3,2,....] line = [--10-------] - is space to be taken by others. 0th person took 4th free seat. 1st took 3rd free  if B=[3,3,....] line = [---01------] => 0th person took 4th free seat. 1st took 4th free seat, after 0 took its seat. so 1 basically took 5th seat  notice how 1 after 0 in line.  So basically you have a set of free seats and each person comes and takes whatever is left.  So Algo : put 0th person at index B[0] in line[]. remove B[0] index from line[] from free seat list. next for ith person, traverse whatever free spaces are left in line[] from index 0 and place them there. pseudo code :	2014-12-10 11:48:22		
1392	ftfck	10		2014-12-10 11:48:22		
1393	sqzqo	10		2014-12-10 11:48:22		
1394	eucmc	10	Above is O(N*N)  can be reduced to O(N) is we can find out in O(1) which seat index a person will get currently if he has to skip x seats  O(nlogn) : Consider line as a skip linked list. node has value 0 to N-1. for each person , given x seats to skip - find xth node using bin search on skip list. delete that node. update skip list.  O(nlogn) : See line as a balanced BST. nodes have value of index 0 to N-1. each node also has the value 'number of nodes in this tree' in tree rooted at it.  construct N node such balanced BST in O(N) (yes, find out how this can be constructed in O(N) yourself) (or to simplify , make in O(logn))  Sort A hence B in inc order. Take B[i] for ith smallest person. Delete B[i]th "number" (not value) of node from the tree. this nodes value = persons index in line. Also update 'number of nodes in this tree' for all nodes effected by delete - O(logn) per person. total nlogn.	2014-12-10 11:48:22		
1395	xhgls	10	My take on this  1. we need to arrange the numbers based on the index difference given {3,2,1}->{0,1,1} means {3} has none taller in front, {2} has 1 taller, {1} has 1 taller so {3}>{1}>{2} or (3 greater than 1 greater than 2)  2. {5,4,3,2,1}->{0,0,0,0,0} means {5} has none taller in front, {4} has none taller in front, {3} has none taller in front, ... so {1}>{2}>{3}>{4}>{5}  3. {5,4,3,2,1}->{0,1,2,3,4} means {5}>{4}>{3}>{2}>{1}  4. looking at the options above we can easily build an iteration to move the person to the index on the second array, taken the example {3,2,1}->{0,1,1}, steps are -move {3} to position 0 - nothing to do -move {2} to position 1 - nothing to do -move {1} to position 1 - move {1} to position 1, {2} will need to move 1 position down  algorithm is quite simple	2014-12-10 11:48:22		
1396	wbqzu	10		2014-12-10 11:48:22		
1397	ftfck	10		2014-12-10 11:48:22		
1398	mrjku	10	Below should be true	2014-12-10 11:48:22		
1399	qywrh	10		2014-12-10 11:48:22		
1400	eucmc	10		2014-12-10 11:48:22		
1401	huiqq	10	Variant of tree travel/shortest path/bfs. with number of element in front as level. and on each level shortest first. or just sort the elements by value and then stable sort on number of elements greater	2014-12-10 11:48:22		
1402	ethan	10	My solution is in O(2n)	2014-12-10 11:48:22		
1403	ewigy	10		2014-12-10 11:48:22		
1404	nhibd	10		2014-12-10 11:48:22		
1405	fmzze	10	C++	2014-12-10 11:48:22		
1406	nhibd	10		2014-12-10 11:48:22		
1407	zeice	10		2014-12-10 11:48:22		
1408	cfzie	10		2014-12-10 11:48:22		
1409	mrjku	10		2014-12-10 11:48:22		
1410	zeice	10	O(n^2) 1. sort persons by height and num greater before 2. find place for each person (from short to high)	2014-12-10 11:48:22		
1411	sgiwy	10		2014-12-10 11:48:22		
1412	cfzie	10		2014-12-10 11:48:22		
1413	vanul	10	O(n^2) 1. sort persons by height and num greater before 2. find place for each person (from short to high)	2014-12-10 11:48:22		
1414	tenuw	10		2014-12-10 11:48:22		
1415	rrmeu	10		2014-12-10 11:48:22		
1416	mrjku	10	I think an elegant solution to this problem would be to sort the array of heights and also put array B in that order O(nlogn)  Make another array of size n as our position array. Then get the element of the smallest height and see how many people are in front of him and place him into the index of that our position array.  Keep taking the next smallest element with x people in front of him. Start from the beginning of the array and count x non filled spaces in the array and place it there.  This is because the non filled spaces in the array will have height greater than that of our element while the filled spaces will have height less than our element so we can ignore those elements.  So our overall complexity is O(nlogn)	2014-12-10 11:48:22		
1417	nwkeg	10	With checking each element of the array if it has filled or not for all n elements would take O(n^2). could someone think of a way to make checking filled spaces O(logn)?	2014-12-10 11:48:22		
1418	fmzze	10	I have a very simple O(nlogn) solution I'm finding difficult to explain  Calculate a prefix big enough so that it's bigger than every other number prefix = pow(10, ciel(log10(n)) + 1))  now create an array where each cell's value is height + prefix * number_heigher_infront  Now, sort the new array ascending and remove from each number (prefix * number_heigher_infront)  Voila!	2014-12-10 11:48:22		
1419	eucmc	10	My solution in C++. The list of (Heights, Count of people in front) is sorted based on the height. Then each person is added - in order - at the position given by the count of people in front of him. We maintain a "jump" table at each step in order to jump over position occupied by a smaller person. The algorithm time complexity is O(n log n). Reviews are welcome :	2014-12-10 11:48:22		
1420	dkebi	10		2014-12-10 11:48:22		
1421	vanul	10		2014-12-10 11:48:23		
1422	dkebi	10	There is a bug in my previous answer in the way the jump list is maintained. Here is a better solution using a binary search tree to maintain the available positions set (I used a C++ set<int> which relies on a BST). This solution has O(n log n) time complexity.	2014-12-10 11:48:23		
1423	dgjji	10		2014-12-10 11:48:23		
1424	huiqq	10		2014-12-10 11:48:23		
1425	rdfeo	10	for the case vector<int> Heights; Heights.push_back(6); Heights.push_back(1); Heights.push_back(11); Heights.push_back(5); Heights.push_back(10); Heights.push_back(4); vector<int> Counts; Counts.push_back(2); Counts.push_back(4); Counts.push_back(0); Counts.push_back(1); Counts.push_back(0); Counts.push_back(0);  your ans return 4,5,6,10,1,11; but the right answer is 4,10,5,11,1,6.	2014-12-10 11:48:23		
1426	zeice	10	I solved it by recursive form. These are persudo code.	2014-12-10 11:48:23		
1427	cfzie	10		2014-12-10 11:48:23		
1428	ethan	10		2014-12-10 11:48:23		
1429	fowai	10	solution: create a binary tree using following steps: consider second array the one with no of peoples having more height as a priority for the first array.. now move one by one in array 1 and insert elements like this 1.if priority is greater move to right or less move to left 2.if priority is same move to right if height is greater else move left 3.balance the tree O(nlogn) ....... inorder is the answer...	2014-12-10 11:48:23		
1430	dgjji	10	I'm using LinkedList for the this. Sort the tallCount[] in ascending order and accordingly re-position the items in heights[]. This is capable of handling the duplicate elements also.	2014-12-10 11:48:23		
1431	jippy	10		2014-12-10 11:48:23		
1432	sqzqo	10		2014-12-10 11:48:23		
1433	admin	10	I get a O(N^3) algorithm. The idea is just search all possible arrangements, upon number of taller violation, backtrack.	2014-12-10 11:48:23		
1434	xhgls	10		2014-12-10 11:48:23		
1435	admin	10		2014-12-10 11:48:23		
1436	nwkeg	11	int atoi(char *p) { int total = 0; int i=0; while(p[i] != '\0') { total *= 10; total += p[i] - '0'; i++; } return total; }	2014-12-10 11:48:24		
1437	cfzie	11	Not bad as long as you don't pass in a sign, or null, or characters other than digits. :) Granted an interviewer is probably just looking for what you did.	2014-12-10 11:48:24		
1438	ftfck	11	last time I got an interview with Microsoft. The interviewer pointed out that you need to take care the sign, the base and actually need to handle every error case.	2014-12-10 11:48:24		
1439	ethan	11	int isDigit16(char* p) { return isDigit10(p) || ((*p) >= 'a' && (*p) <= 'f') || ((*p) >= 'A' && (*p) <= 'F'); }  int atoi(char* p) { int cur; int sign = 1; int base = 10; int total = 0;  if (!p || !p[0]) return 0;  while (p[cur] == ' ' || p[cur] == '\t') cur++;  if (!p[cur]) return 0;  if (p[cur] == '-') { sign = -1; cur++; }  if (p[cur] == '0') { if (p[cur+1] == 'x' || p[cur+1] == 'X') { base = 16; cur += 2; } else { base = 8; cur++; } }  while (p[cur]) { switch(base) { case 8: if (isDigit8(&p[cur]) { total = total * 8 + p[cur] - '0'; break; } else return sign*total; case 10: if (isDigit(&p[cur]) { total = total * 10 + p[cur] - '0'; break; } else return sign*total; case 16: if (isDigit16(&p[cur]) { int d = (p[Cur]<='9')?(p[cur]-'0'):(((p[cur]<='F')?p[cur]-'A':p[cur]-'a')+10); total = total * 16 + d; break; } else return sign*total; } cur++; } return sign*total; }	2014-12-10 11:48:24		
1440	zeice	11	forget to copy some of the prerequisites int isDigit10(char* p) { return (*p) >= '0' && (*p) <= '9'; }  int isDigit8(char* p) { return (*p) >= '0' && (*p) <= '7'; }	2014-12-10 11:48:24		
1441	fmzze	11	damn, forget to handle the overflow	2014-12-10 11:48:24		
1442	ufdxg	11	check the official atoi spec, out of range result in undefined behavior. So the above implementation should be fine.	2014-12-10 11:48:24		
1443	jippy	11	Language: C++ Method: - Get the length of the cstring - Based on the length, we can figure out the base to start with. For example '123', gives a size of 3, therefore the starting base will be pow(10,3); - In the for-loop, we decrease base as we go down the char array - Multiply each (ascii code - ascii code ('0')) with the base; - Add the result to the variable temp (that keeps incrementing as we add values);	2014-12-10 11:48:24		
1444	huiqq	11		2014-12-10 11:48:24		
1445	xhgls	11		2014-12-10 11:48:24		
1446	krxlv	12	I can think of two approaches:  First approach - A naive approach using an adjacency map  The adjacency map is a Map whose keys are vertices and whose values are sets of vertices which are all the neighbors of the key vertex. For every vertex, we'll check for every pair of its neighbors whether there is an edge between them and increment the triangle counter if so.  The total number of triangles will be the number of triangles we counted divided by 6 (we count each triangle 6 times).  Code:	2014-12-10 11:48:26		
1447	krxlv	12		2014-12-10 11:48:26		
1448	rdfeo	12		2014-12-10 11:48:26		
1449	xhgls	12	Complexity: The overall run-time complexity is O(n*d^2) where n is the number of vertices and d is the maximum degree of a vertex in the graph. This is a good approach for graphs with small maximum vertex degree. But if the graph contains a vertex whose degree is O(n) then the overall complexity in this case would be O(n^3).    Second approach - Using matrix multiplication  Suppose A is the graph's adjacency matrix (A[i][j] = 1 if and only if there is an edge between i and j in the graph). It can be shown that trace(A^3)/6 is the number of triangles in the graph (using the fact that A^k[i][j] is the number of paths with k edges from i to j). This means that all we need to know the number of triangles is to calculate the matrix A^3 and its trace.  This means that our algorithm complexity would depend on the complexity of the matrix multiplication algorithm: Naive: O(n^3) Strassen: O(n^{2.8074}) Coppersmith-Winograd: O(n^{2.3729})  I can post a code for this approach using Strassen matrix multiplication but it's rather long and isn't pretty.	2014-12-10 11:48:26		
1450	zeice	12	Wow man, that matrix approach is brilliant!	2014-12-10 11:48:26		
1451	dkebi	12	Matrix approach is standard. But agree, it is brilliant.	2014-12-10 11:48:26		
1452	ewigy	12	You must pay attention to the fact that Strassen and the other matrix multiplication algorithms are great asymptotically speaking but have a big overhead. You don't want to use them for matrices with size below 1000. I don't know if this practical consideration was part of the question, but in real life, one should keep this in mind before choosing to implement the "best" complexity algorithm. Personally I would stick to the naive approach which is way more readable.	2014-12-10 11:48:26		
1453	ufdxg	12	1. The undirected graph can be represented as: class Vertex { List<Vertex> Adjacents; } 2. Traverse the undirected graph as BFS - Use a queue to traverse - Use a hash to track the vertices already visited 3. if current = current vertex - get all adjacent vertices to current - count the number of common vertices in current.adjacents (I remove the processed adjacent node to avoid counting the same vertex twice)	2014-12-10 11:48:26		
1454	ewigy	12		2014-12-10 11:48:26		
1455	nwkeg	12		2014-12-10 11:48:26		
1456	mrjku	12	Nice one! But your solution assumes that no three vertices will be on same line. And also there is no notion of length ( the question does not have this notion also )	2014-12-10 11:48:26		
1457	gilit	12	deep-first search. record the last two steps to judge the triangle.	2014-12-10 11:48:26		
1458	qywrh	12	Hi can you explain your approach in a little more detail.	2014-12-10 11:48:26		
1459	tenuw	12	Let me explain. If there is a triangle then its a closed loop. So from any vertex if i go 3 steps and reach it back then there is a closed loop of 3 edges => triangle. Now Since you will do this for all vertices of the graph final output will be number of triangles you found / 3 The scanning of the graph is done by DFS for this problem.	2014-12-10 11:48:26		
1460	gilit	12	Total amount of visited edges is O(E), triangles is about O(V^3).	2014-12-10 11:48:26		
1461	sgiwy	12	Does not work.	2014-12-10 11:48:26		
1462	eucmc	12		2014-12-10 11:48:26		
1463	ftfck	12		2014-12-10 11:48:26		
1464	krxlv	12	There are two things not explained in the problem: 1) Nodes have no X-Y locations. In Theory, there is no way to check it is a thriangle or not. In a Line or Not? 2) Is the memory a bottleneck?  Assume the two are not issues. Then the solution comes: A: Using Matrix to store Graph in the Memory. (it is always faster). B: The algorithm is: 1) New an empty std::unordered_set<std::string> to keep all triangles. ---------------- 2) Loop each node (v1) in V. [Big-O: O(n)] 3) For each pair of connected nodes (v2 and v3). [Big-O: O(d^2), d is the average node degree] 4) Check whether v2 and v3 are connected. [Big-O: O(1)] 5) If 4) get 'YES', then sort the node IDs and push the new triangle into unordered_set. [Big-O: O(1)] ---------------- 6) Finally, output triangles in the unordered_set. [Big-O: O(n)]  Thus, the total cost is Big-O: O(n * d * d), where d is the average node degree. In a complete graph, it is n^3; In a tree, it is O(n); (even through tree does not make sense in this problem)	2014-12-10 11:48:26		
1465	nwkeg	12	std::unordered_set<std::string> is a bad design. Should use objects here: std::unordered_set<Triangle>	2014-12-10 11:48:26		
1466	admin	12	I would use the BFS. a. Color root gray and push it into a queue. b. Pop from queue one by one. Scan the neighbours of current node based on BFS. If the node to which it is connected is in same level and the node is not black yet add one to count. c. Color current scnned node to black.	2014-12-10 11:48:26		
1467	wbqzu	12		2014-12-10 11:48:26		
1468	sqzqo	12		2014-12-10 11:48:26		
1469	plapd	12	Steps  1) Create Adjacency List for nodes.  As in given example graph is undirected so adj list will look like this 0 -> 1,2 1->0,2 2-->0,1 4-->1  2) Pick one edge and get adj list for both nodes. 3) Count number of common elements in adj list 4) Repeat step 2 and 3 for all the edges  Number of triangles= (Number of common elements)/6 as it's undirected graph for directed graph it will be divided by 3	2014-12-10 11:48:26		
1470	eucmc	12	Steps  1) Create Adjacency List for nodes.  As in given example graph is undirected so adj list will look like this 0 -> 1,2 1->0,2 2-->0,1 4-->1  2) Pick one edge and get adj list for both nodes. 3) Count number of common elements in adj list 4) Repeat step 2 and 3 for all the edges  Number of triangles= (Number of common elements)/6 as it's undirected graph for directed graph it will be divided by 3	2014-12-10 11:48:26		
1471	bjsiw	12		2014-12-10 11:48:26		
1472	dkebi	12		2014-12-10 11:48:26		
1473	dkebi	12	Here is an updated version using c#  int FindTriangles(Edge[] edges) { // Build Adjacent list SortedDictionary<int, List<int>> nodes = new SortedDictionary<int, List<int>>(); foreach (Edge e in edges) { if (nodes.Find(e.v1)) { nodes[e.v1].Add(e.v2); } else { nodes.add(e.v1, new List<int>(e.v2)); } if (nodes.Find(e.v2)) { nodes[e.v2].Add(e.v1); } else { nodes.add(e.v2, new List<int>(e.v1)); } }  int count = 0; foreach (KeyValuePair kv in nodes) { foreach(int i = 0; i < kv.Value.Length - 1; ++i) { if (kv.Value[i] < kv.Key) continue; foreach (int j = i + 1; j < kv.Value.Length; ++j) { if (kv.Value[j] < kv.Key) continue; if (nodes[kv.Value[i]].IndexOf(kv.Value[j]) != -1) { count++; } } }  return count; }	2014-12-10 11:48:26		
1474	tenuw	12	Finding the number of cycles with three nodes can give us the result.	2014-12-10 11:48:26		
1475	xhgls	12		2014-12-10 11:48:27		
1476	ewigy	12		2014-12-10 11:48:27		
1477	cfzie	12	The following is an example in Java of using matrix multiplication to find the number of triangles. A separate class Connections keeps track of the nodes that can be reached after a specific number of steps (multiplication by adjacency matrix).	2014-12-10 11:48:27		
1478	rdfeo	12		2014-12-10 11:48:27		
1479	nwkeg	12		2014-12-10 11:48:27		
1480	eucmc	12	HI i would do something like this :-  Do a union find algorithm (reason to choose this is that this algo is used to find loops in a graph and remember a triangle is a loop). While doing union-find do following steps as well - 1) for every vertex or node maintain a count as to how far is it from the parent. ( after doing the path compression and rank in algorithm) 2) if an edge comes that creates a loop check the attribute i.e. the height from parent and if it's the same then it's a triangle else skip that edge and continue.	2014-12-10 11:48:27		
1481	sgiwy	12	a basic idea is to have 3 nested loops i, j, and k, then test if i,j,k can form a triangle, cost is o(n^3). with hashset, you can improve it to o(n ^ 2), because based on the first two edges, you can find if the set has the required remaining edge with a lookup.	2014-12-10 11:48:27		
1482	eucmc	12		2014-12-10 11:48:27		
1483	cfzie	12		2014-12-10 11:48:27		
1484	ufdxg	12	using BFS algorithm, find the number of triangles for each level, and sum them up, divided by 6. public static void main(String[] args){ Node n0 = new Node(0); Node n1= new Node(1); Node n2 = new Node(2); Node n3 = new Node(3); Node n4 = new Node(4);  n0.connections.add(n1); n0.connections.add(n2);  n1.connections.add(n0); n1.connections.add(n2);  n2.connections.add(n0); n2.connections.add(n1); n2.connections.add(n4);  n4.connections.add(n1); n4.connections.add(n2);   ArrayList<Node> list = new ArrayList<Node>(); list.add(n0); list.add(n1); list.add(n2); list.add(n3); list.add(n4);  int triangle = findTotalTrangle(list, 5); triangle = triangle/6;  System.out.println("the number of triangle is "+ triangle); }  public static int findTotalTrangle(ArrayList<Node> root, int size){ int count =0; ArrayList<Node> visited = new ArrayList<Node>(); ArrayList<Node> queue = new ArrayList<Node>(); ArrayList<Node> second = new ArrayList<Node>(); queue.addAll(root); while(!queue.isEmpty()){ second.clear(); queue.removeAll(visited); count += findTrangleByLevel(queue, second); for(Node node: queue){ if(!visited.contains(node)){ visited.add(node); } } queue.clear(); queue.addAll(second); if(visited.size() == size ){ break; } } return count; }  public static int findTrangleByLevel(ArrayList<Node> list, ArrayList<Node> second){ int count = 0; //ArrayList<Node> second = new ArrayList<Node>(); //find all the neighbors of the list. ArrayList<Node> third = new ArrayList<Node>(); //find all the neighbors of the second list. for(Node node: list){ for(Node neigh : node.connections){ if(!second.contains(neigh)){ second.add(neigh); } } } if(!second.isEmpty()){ for(Node node: second){ for(Node neighb : node.connections){ if(list.contains(neighb)){ count++; }  } } }  return count; //this is the triangle number begining with the node in the first list. }	2014-12-10 11:48:27		
1485	vanul	12	Suppose that a graph has been constructed as follows: - All nodes are ordered by its value. - Each node has an sorted list of edges. - An edge belongs to only at a single node with less value among two nodes.  For example, the above graph will be represented by 0: {1, 2} 1: {2, 4} 2: {} 4: {}  Then, the number of triangles can be obtained by counting the number of common nodes between every pair of nodes (n0, n1) where n0 < n1.	2014-12-10 11:48:27		
1486	xhgls	12		2014-12-10 11:48:27		
1487	jippy	12		2014-12-10 11:48:27		
1488	sgiwy	12	The time complexity of this algorithm consists of two parts. First, constructing the graph will be inserting each edge to the proper node. Each insertion of an edge takes O(E/N). (Assume that the number of edges connected for each node is even). So, graph construction takes O(E*log(E/N)). Second, counting the number of triangles takes O(N * E/N * E/N). The outer loop and inner loop iterate N and E/N times, respectively, and countIntersection takes O(E/N).  If we assume dense graph, i.e., E=O(N^2), then the time complexity is O(N^3). If it is sparse, i.e., E=O(N), then O(N).	2014-12-10 11:48:27		
1489	vanul	12		2014-12-10 11:48:27		
1490	ewigy	12		2014-12-10 11:48:27		
1491	rdfeo	12		2014-12-10 11:48:27		
1492	sgiwy	12		2014-12-10 11:48:27		
1493	tenuw	12	Some of the codes above are so complex .Heres the easiest solution.	2014-12-10 11:48:27		
1494	cfzie	12		2014-12-10 11:48:27		
1495	ethan	12		2014-12-10 11:48:27		
1496	krxlv	12	It doesnt work..  01 2 3 1 2  out put - 1 --> wrong	2014-12-10 11:48:27		
1497	xhgls	12	This solution is by using the adjacency matrix. if a[0][1]==1 and a[1][2]==1 then we check if a[0][2]==1 then one triangle exists We scan the matrix just downwards in the upper half of the marix for example if we have 5 nodes then scan starts from 0th node from a[0][1] and check starts from a[1][2] And then 1st node from a[1][2] and compared with next node from a[2][3] and so on In this way we avoid making duplicates  #include<iostream> using namespace std; int main() { int n,i,j,k,entries,no=0; cout<<"enter no of nodes:\n"; cin>>n; int a[n][n]; cout<<"enter no of entries:\n"; cin>>entries; for(i=0;i<n;i++) { for(j=0;j<n;j++) a[i][j]=0; } for(i=0;i<entries;i++) { cin>>j>>k; a[j][k]=1; a[k][j]=1; } for(i=0;i<n;i++) { for(j=i+1;j<n;j++) { if(a[i][j]==1) { for(k=j+1;k<n;k++) { if(a[j][k]==1) { if(a[i][k]==1) no++; } } } } } cout<<"no of triangles="<<no<<endl; return 0; }	2014-12-10 11:48:27		
1498	jippy	12		2014-12-10 11:48:27		
1499	ewigy	12		2014-12-10 11:48:27		
1500	ftfck	12	I simply used BFS and checked if the value of the node I was visiting at that moment existed in the list of Nodes left to visit.  This scenario occurs when a triangle is present because of the following: Suppose nodes 1, 2, and 3 are connected to each other. Start at node 1. - Node 1 is visited, adding 2 and 3 to the list of nodes to visit. - Node 1 is marked as visited. - Node 2 is visited, adding 3 to the list of nodes to visit (only add nodes that have not been visited, so node 1 is skipped). - Node 3 is visited, node 3 observes that it is still on the list of nodes to visit. Mark 3 as visited and incrementing triangles count. Also remove the duplicate node 3 entry from the to visit list.  Code:	2014-12-10 11:48:27		
1501	huiqq	12		2014-12-10 11:48:27		
1502	bjsiw	12		2014-12-10 11:48:27		
1503	fowai	12	Complexity is O(n^2) as each node must check the list of nodes yet to visit.	2014-12-10 11:48:27		
1504	sgiwy	12	public int getNumberOfTriangles(int[] v){ HashMap<Integer, HashSet<Integer>> edges = new HashMap<Integer, HashSet<Integer>>(); int result = 0;  for(int i = 0; i < v.length / 2; i++){ int i1 = v[2 * i]; int i2 = v[2 * i + 1];  HashSet<Integer> hs1 = edges.get(i1); if(hs1 == null){ hs1 = new HashSet<Integer>(); edges.put(i1, hs1); }  HashSet<Integer> hs2 = edges.get(i2); if(hs2 == null){ hs2 = new HashSet<Integer>(); edges.put(i2, hs2); }  for(Integer test : hs1){ if(hs2.contains(test)){ result++; } }  hs1.add(i2); hs2.add(i1); }  return result; }	2014-12-10 11:48:27		
1505	mrjku	12		2014-12-10 11:48:27		
1506	dgjji	12		2014-12-10 11:48:27		
1507	vanul	12		2014-12-10 11:48:27		
1508	dkebi	12		2014-12-10 11:48:27		
1509	huiqq	12	Dont know why people write this mammoth code for simple problems. Will google appreciate this and will you have enough time on blackboard to explain all these ..	2014-12-10 11:48:27		
1510	azmjc	12		2014-12-10 11:48:27		
1511	zeice	12		2014-12-10 11:48:27		
1512	wbqzu	12	A minor modification, mark the visited node ..	2014-12-10 11:48:27		
1513	huiqq	12		2014-12-10 11:48:27		
1514	eucmc	12		2014-12-10 11:48:27		
1515	dgjji	12	We can do that in O(n^2) and no BFS / DFS	2014-12-10 11:48:27		
1516	bjsiw	12		2014-12-10 11:48:27		
1517	ewigy	12		2014-12-10 11:48:27		
1518	rrmeu	12	1we have a two-dimensional array to represent the adjacent between two vertexes; also each vertex have a adjacent list of vertexes whose id are larger than the vertex itself; 2For every vertex list,we check its adjacent vertex pair,and find the reasonable pairs through the 2-dim array; Time complexity is min(O(edge^2),O(n*d^2));(d represent the degree of the vertex),but I think my solution avoid the redundant computation. A little better than the first solution.	2014-12-10 11:48:27		
1519	krxlv	12	For each vertex traverse all its edges in pairs. For each edge pair see if the vertices are connected, if so its a triangle. Since the same triangle will be reported 3 times (for each vertex), divide the result by 3. This algorithm is O(n) complexity.  For example above:  0 1 2 1 0 2 4 1  Vertex 0 edge pair (0,1) and (0,2) , select any of the 2 connected vertices and see if there is an edge between them. There is (2,1) so add 1 to traingle count.  Repeat for vertices 1,2,4. your triangle count will be 3. Divide by 3 and you will get 1 which is the answer.	2014-12-10 11:48:27		
1520	nwkeg	13	solution : having complexity O(n)(time)+O(height of BST)(space) observation : if we are given a sorted array instead of a BST and the same question was asked then so solve this problem in O(n)+O(1) complexity, we keep two indexes one at start and 2nd one at end, and apply following algo.	2014-12-10 11:48:29		
1521	nwkeg	13		2014-12-10 11:48:29		
1522	sgiwy	13		2014-12-10 11:48:29		
1523	admin	13	so we apply the same concept here, because we don't have data stored in an array faction, so we need some space, now one way is tot store the data into an array and apply the same, but this require O(n) space, but if you think carefully, then we only require at max 2*height_of_BST, in first array of size height_of_BST, we store all elements which comes from	2014-12-10 11:48:29		
1524	azmjc	13		2014-12-10 11:48:30		
1525	ftfck	13		2014-12-10 11:48:30		
1526	cfzie	13	and in 2nd array we store	2014-12-10 11:48:30		
1527	nwkeg	13		2014-12-10 11:48:30		
1528	qywrh	13		2014-12-10 11:48:30		
1529	vanul	13	and we start with the last element of these two array, these array's are actually stack. now we get two element do we do the same comparison here also	2014-12-10 11:48:30		
1530	gilit	13		2014-12-10 11:48:30		
1531	vanul	13		2014-12-10 11:48:30		
1532	mrjku	13	Do we need multi threads here? I have the same logic as you. But I think I am not able to implement with single thread. Plz write code if possible	2014-12-10 11:48:30		
1533	gilit	13	we don't actually, we apply while loop here, and store node into stack(not just values), and in each loop we do above check, (mean updating the stacks), I will write single threaded code of it on this thursday, as i have some quizzes in this week.	2014-12-10 11:48:30		
1534	eucmc	13	I think it is great solution~	2014-12-10 11:48:30		
1535	nwkeg	13	A very good solution.	2014-12-10 11:48:30		
1536	dgjji	13	Someone please provide java code or explanation for this BST (after each iteration, with contents of S1, S2) -	2014-12-10 11:48:30		
1537	rrmeu	13		2014-12-10 11:48:30		
1538	eucmc	13		2014-12-10 11:48:30		
1539	sgiwy	13	I want to search for sum=5.2	2014-12-10 11:48:30		
1540	sqzqo	13	let s1 and s2 are two stack initially s1 contain : [3,2] and s2 contain : [5,8,9] we sum 2 and 9 and compare then with 5.2 and 11 is bigger then 5.2 so we look for left child of 9 which is not there, so we pop 9 from s2 now stacks contains s1 : [3,2] s2 : [5,8] again 2+8 > 5.2 so we pop 8 and push 6 now stacks contain : s1 : [3,2] s2 : [5,6] now again 2+6 > 5.2, we pop 6 from it now stacks contain : s1 : [3,2] s2 : [5] again 2+5 > 5.2 so we pop 5 from it and push [3,4] into it now stacks are : s1 : [3,2] s2 : [3,4] again 2+4 > 5.3 so we pop 4 and push 3.1 into it now stacks contains : s1 : [3,2]; s2 : [3,3.1] here 2+3.1 < 5.2 so we pop 2 from s1 and push 2.1 into it now stack contains : s1 : [3,2.1] s2 : [3,3.1] now 2.1 + 3.1 = 5.2 we get our answer, we print 3.1 and 2.1, if there is a possibility of having multiple pairs, then we won't stop here we go upto the condition that element of s1 is smaller then element of s2.	2014-12-10 11:48:30		
1541	dkebi	13	Test3:	2014-12-10 11:48:30		
1542	ufdxg	13		2014-12-10 11:48:30		
1543	fowai	13		2014-12-10 11:48:30		
1544	ufdxg	13	Your solution didn't seem to work when the left tree only contains one node.  e.g. create the tree with 7, 20, 2, 12, 17, 22 with target 37 s1 = [2] s2 = [7,20,22] 2 + 22 < 37 so you pop 2 .. now what? it has no right subtree - you can't check the left/right elements as the condition of your loop.	2014-12-10 11:48:30		
1545	bexbp	13	I forgot one thing to write here which is that root node is included in both the stacks, as i am checking the condition which is that stack1's element should be smaller then stack2's element, so this will not create any problem, but it solve problems like yours, thanks for that, here is the execution : s1 = [7,2] s2 = [7,20,22] 2+22 < 37 s1 = [7] s2 = [7,20,22] 7+22 < 37 s1 = [20,12] s2 = [7,20,22] 12+22 < 37 s1 = [20 17] s2 = [7,20,22] 17+22 > 37 s1 = [20,17] s2 = [7,20] 17+20 = 37;	2014-12-10 11:48:30		
1546	sqzqo	13	thanks - this code seems to work then:	2014-12-10 11:48:30		
1547	gilit	13		2014-12-10 11:48:30		
1548	zeice	13		2014-12-10 11:48:30		
1549	bexbp	13	In ur code if(A[1st_index] + A[2nd_index] < x) it this is true then there will be no two values with the required sum x.....then why are u subtracting 2nd_index--......	2014-12-10 11:48:30		
1550	huiqq	13	To readers,  FOR THE OBSERVATION PART (above): ===============================  Array example is considered to be sorted in non-increasing fashion.  " observation : if we are given a sorted array instead of a BST and the same question was asked then so solve this problem in O(n)+O(1) complexity, we keep two indexes one at start and 2nd one at end, and apply following algo.	2014-12-10 11:48:30		
1551	fmzze	13		2014-12-10 11:48:30		
1552	admin	13		2014-12-10 11:48:30		
1553	xhgls	13	"	2014-12-10 11:48:30		
1554	cfzie	13	Good work with printTwoNodeValueEqualToX()	2014-12-10 11:48:30		
1555	bjsiw	13	I think the code 'printTwoNodeValueEqualToX()' will fail to the following test case: {1, 2, 2, 10}, sum = 4 I think it should not use 'while (leftStack.peek().item < rightStack.peek().item);', because in the above example, the answer is {2, 2}, with the same value in the pair. I think it should use 'while (leftStack.peek() != rightStack.peek());'.  BTW, the follwoing is my Java implementation together with some simple tests, I'd appreciate any bug if you found:	2014-12-10 11:48:30		
1556	plapd	13		2014-12-10 11:48:30		
1557	huiqq	13		2014-12-10 11:48:30		
1558	tenuw	13	Isnt it like we are comparing the inorder and reverse inorder elements? This solution is pretty good.	2014-12-10 11:48:30		
1559	nhibd	13	@Alva0930 what is the running time and space for your solution? Could you please tell us?	2014-12-10 11:48:30		
1560	dgjji	13	Are your comparison operators flipped in the original post? I get the logic, based on later comment examples. However, when I look at the original post, it seems like I want to be doing the opposite of what each 'if statement' suggests to do.	2014-12-10 11:48:30		
1561	dgjji	13	Since the above code implementing @sonesh's idea is not clear enough, I submit the following simple implementation in Java:	2014-12-10 11:48:30		
1562	rdfeo	13		2014-12-10 11:48:30		
1563	sqzqo	13		2014-12-10 11:48:30		
1564	fowai	13	}	2014-12-10 11:48:30		
1565	dkebi	13	My fifty cents (full C++ solution, O(h) space complexity, O(n log n) time complexity) :	2014-12-10 11:48:30		
1566	cfzie	13		2014-12-10 11:48:31		
1567	fmzze	13		2014-12-10 11:48:31		
1568	plapd	13	//simple code for comparing using left and right stack //which is basically in order traversing using stack, //when you are traversing in left subtree using left stack, every //time pops, push the right child of the current node and all the //left child of the right child.   Stack left; while(root!=null){//initialize left.push(root.l); root=root.l;}  node root=left.pop();//when comparing using left stack if(root.right!=null){ left.push(root.r); root=root.r} while(root!=null){ left.push(root.l); root=root.l;}	2014-12-10 11:48:31		
1569	wbqzu	13		2014-12-10 11:48:31		
1570	mrjku	13		2014-12-10 11:48:31		
1571	nwkeg	13	good but brute!!!	2014-12-10 11:48:31		
1572	admin	13	Here is solution as per space complexity, but high time complexity. If any one get soln with less complexity will be better.	2014-12-10 11:48:31		
1573	zeice	13		2014-12-10 11:48:31		
1574	wbqzu	13		2014-12-10 11:48:31		
1575	azmjc	13	Logic : How do you find two values whose sum equal to X in a sorted array. - keep one pointer at start and another at end of an array and move your pointers according as per sum.  Used same logic, however instead of array, think how to do it in BST.	2014-12-10 11:48:31		
1576	sqzqo	13		2014-12-10 11:48:31		
1577	gilit	13		2014-12-10 11:48:31		
1578	nwkeg	13	/* Complexity O(nlogn) time. O(log n) space. Logic -- If(root < sum) find in tree sum - root. if( no answer found in previous step) repeat this algorithm for left subtree of root. move to the right subtree of root. if (root > sum) move to left subtree.. since all of the values in right subtree and root are useless  */ Code	2014-12-10 11:48:31		
1579	xhgls	13		2014-12-10 11:48:31		
1580	vanul	13		2014-12-10 11:48:31		
1581	ewigy	13	Find the least element in BST. Let it be x. Let y = k-x. Find the element that is equal to y or less than y. Traverse in inorder manner from x and in reverse inorder manner from y till either x+y = k or x==y. Use iterative inorder traversal method.	2014-12-10 11:48:31		
1582	mrjku	13	G, great solution	2014-12-10 11:48:31		
1583	ftfck	13	And the iterative (or rather, lazy) traversal can be implemented using yield. (Generator/Coroutines, as some other answer put it).	2014-12-10 11:48:31		
1584	rdfeo	13	But shouldn't we take into account every possible value of x up till k? That would shoot up the complexity.	2014-12-10 11:48:31		
1585	qywrh	13		2014-12-10 11:48:31		
1586	fmzze	13		2014-12-10 11:48:31		
1587	ftfck	13	the additional space is not O(height).Your solution will be work in just array	2014-12-10 11:48:31		
1588	jippy	13	Test1:	2014-12-10 11:48:31		
1589	dkebi	13		2014-12-10 11:48:31		
1590	bjsiw	13		2014-12-10 11:48:31		
1591	dkebi	13	Test2:	2014-12-10 11:48:31		
1592	sqzqo	13		2014-12-10 11:48:31		
1593	bjsiw	13		2014-12-10 11:48:31		
1594	bjsiw	13		2014-12-10 11:48:31		
1595	admin	13		2014-12-10 11:48:31		
1596	ftfck	13	bool find2Node(Node* root,double targetV,Node*& n1,Node*& n2){ if(root==NULL)return false;  n1=root,n2=root; stack<Node*> st1,st2;  bool hasFound=false; while(true){ while(n1!=NULL){ st1.push(n1); n1=n1->left; } while(n2!=NULL){ st2.push(n2); n2=n2->right; } if(st1.top()==st2.top())break; double nowV=st1.top()->v+st2.top()->v; if(nowV<targetV){ n1=st1.top()->right; st1.pop(); }else if(nowV>targetV){ n2=st2.top()->left; st2.pop(); }else{hasFound=true;n1=st1.top();n2=st2.top();break;} } return hasFound; }	2014-12-10 11:48:31		
1597	huiqq	13		2014-12-10 11:48:31		
1598	ethan	13		2014-12-10 11:48:31		
1599	nhibd	13	Solution: anandtechblog.blogspot.in/2010/07/given-binary-search-tree-of-n-nodes.html	2014-12-10 11:48:31		
1600	mrjku	13	BST data not modified but BST is converted to a Doubly Linked List.  O(n) time solution with O(BST_DEPTH) space as stack is consumed.	2014-12-10 11:48:31		
1601	nhibd	13	One simpler solution is follow same practice as in Array of elements, for moving to previous element, use InOrderPredcessor to find previous element.	2014-12-10 11:48:31		
1602	fmzze	13	Brillant idea of sonesh, and here is my implementation code in C++:	2014-12-10 11:48:31		
1603	fmzze	13		2014-12-10 11:48:31		
1604	nhibd	13		2014-12-10 11:48:31		
1605	zeice	13	My solution in C#	2014-12-10 11:48:31		
1606	admin	13		2014-12-10 11:48:31		
1607	ethan	13		2014-12-10 11:48:31		
1608	jippy	13	--  Indra Bayu Vrije Universiteit Brussel	2014-12-10 11:48:31		
1609	krxlv	13	Here is the logic for the case where all node values are positive. Starting from root node, IF (x <= root node value), then required two nodes with sum of values equals to x, if exists, will definitely be in left sub-tree of root ELSE required two nodes can be in either of left or right sub-tree, in which case, find node with value (x - root.value) in tree rooted at root.	2014-12-10 11:48:31		
1610	cfzie	13	WRONG!!	2014-12-10 11:48:32		
1611	vanul	13	coroutines!	2014-12-10 11:48:32		
1612	ewigy	13	People who don't understand should not downvote. This is an excellent (though cryptic) answer.	2014-12-10 11:48:32		
1613	krxlv	13	Yes, and to be specific, generators. Some languages like python and C# have support for it: yield.	2014-12-10 11:48:32		
1614	krxlv	13		2014-12-10 11:48:32		
1615	vanul	13		2014-12-10 11:48:32		
1616	plapd	13	its like doing Nested Inorder inside Inorder and searching the element sum-X. (X= every node of the element)Complexity((logn)(log(n)) without extra apace ...	2014-12-10 11:48:32		
1617	sqzqo	13	Your code have many bugs. Also I think your code will loop infinitely. As both functions are calling each other.	2014-12-10 11:48:32		
1618	fowai	13	@nitin : it is just a kind of an algo..not proper code..so all boundary value cases not handled....Please let me know if any issue with Logic of an Algo..	2014-12-10 11:48:32		
1619	jippy	13	@ravisingh: for every node you are checking the left and right subtree to see if it is equal to sum - current_node. I think it will fit the bill.	2014-12-10 11:48:32		
1620	nwkeg	13	@raviSingh - In method Nested_find_node(), you need to add check to ensure that (temp != head).  This brute force logic is coded well by	2014-12-10 11:48:32		
1621	ftfck	13		2014-12-10 11:48:32		
1622	bjsiw	13		2014-12-10 11:48:32		
1623	jippy	13	after your post.	2014-12-10 11:48:32		
1624	huiqq	13	[CORRECTION]: Sorry not 'annn' but 'Shashi'. My bad.	2014-12-10 11:48:32		
1625	rrmeu	13		2014-12-10 11:48:32		
1626	ethan	13	but the size of you hash is O(n) while there is a space restriction O(height of the tree)	2014-12-10 11:48:32		
1627	bexbp	13	Nice logic though.	2014-12-10 11:48:32		
1628	azmjc	13	You don't need a hash, use two iterators one inorder (starts at min) and one reverse inorder (starts at max). Here is the C++ code, the operators ++ just return the successor in the given order. You can change the code to output one pair, unique pairs, all pair	2014-12-10 11:48:32		
1629	ftfck	13		2014-12-10 11:48:32		
1630	eucmc	13		2014-12-10 11:48:32		
1631	nwkeg	14	Assumption: All numbers are distinct (otherwise, you need to tell us about the BST insertion algorithm).  One solution (but essentially same as the tree compare solution in spirit): you can do something like quicksort:  Given Arrays A and B, check if A[0] = B[0] (if not, return false).  Now construct A_more, A_less and B_more, B_less where A_more contains elements of A which are > A[0] (and appear in the same order as they appear in A). This is basically the partition step in quicksort. Note that you need the partition to be stable. It is possible to do that in-place, but is very complex.  Now, recursively compare A_more, B_more and compare A_less and B_less. You can add optimizations to compare lengths of arrays to bail out quicker.	2014-12-10 11:48:34		
1632	ewigy	14	quick sort works .. but there is a catch .. For the first time, we take first element as pivot from both arrays and divided the arrays.. For the 2nd iteration onwards, we have to take the same element as pivot in both arrays .. this needs O(n) time or we have to do some kind of pre-processing ...  Second approach is not accepted as it was stated in the question itself that we should give answer without constructing BSTs.	2014-12-10 11:48:34		
1633	rdfeo	14	@Bharath: The catch is that you need a stable partition: The relative ordering of elements must not change. Once you do that, you can do recursively, by comparing the first elements of the two partitions you get. You don't have to do any other preprocessing.  If you actually look to take the same element as pivot (as you seem to suggest), then you will get wrong answers, counterexample:  1 2 3 1 3 2	2014-12-10 11:48:34		
1634	gilit	14	How about using O(n) extra space to do partition in-place? Let quicksort's partition algorithm decide the correct position of an element only (Create a backup of original array before passing it to partition algorithm, then use it to partition stably). Time complexity would be O(nlogn) which is same as original algorithm and space complexity would be O(n).	2014-12-10 11:48:34		
1635	wbqzu	14	@Epic_coder: Then by definition it is not in-place. The point of an in-place algorithm is to save space...	2014-12-10 11:48:34		
1636	ethan	14	Very nice idea with partitioning, I was thinking about recursive check for left and right children, but qsort partitioning will do the work	2014-12-10 11:48:34		
1637	eucmc	14	coders-stop.blogspot.in/2012/03/compare-bsts.html	2014-12-10 11:48:34		
1638	azmjc	14	does not work for case  8 14 11 9 13 20 16 22 8 14 20 22 16 11 13 9	2014-12-10 11:48:34		
1639	bjsiw	14	@blackfever: the bsts formed with the sequences u gave are not same, try to represent them in the form of tree based on order.	2014-12-10 11:48:34		
1640	nhibd	14	I *think* this should work. When we're inserting any given key, it is always 'perfectly' inserted, that is it is inserted right after the maximum key that is still less than this key. Given that, we can go through the array and for each value from each array see if we've already inserted it in the other array, and if so if the insertion point is still the same. If not, we know that we would produce two different trees. If so, then we keep looking.  Right now I'm not checking to make sure that both trees contain the same elements, but that should be easy to add.  Also right now the findInsertAfter method does a brute-force search which makes the algorithm n^2, but if you replace that with a sorted data structure and binary search for the optimal element it should be n*log(n).	2014-12-10 11:48:34		
1641	vanul	14		2014-12-10 11:48:34		
1642	tenuw	14		2014-12-10 11:48:34		
1643	nhibd	14	Could you please explain what you are trying to do, in English?  I think an O(nlog n) algorithm will exist, but I haven't thought about it fully. Perhaps you have one.	2014-12-10 11:48:34		
1644	rdfeo	14	The basic idea is that when we're adding to a BST, a node is always added after the next-largest key. So if a given BST contains the values 1,2,3, then the value 4 will be added to the right of 3 no matter what the tree's shape.  So we can verify whether two trees are the same by checking for every value that its next-smallest value is the same as in the other tree.  There was a bug in my code, the corrected version is below: """ static boolean willMakeSame(int [] arr1, int [] arr2) { if(arr1.length != arr2.length || arr1[0] != arr2[0]) return false;  Map <Integer, Integer> insertedAt = new HashMap<>(); Set <Integer> insertedSetA = new HashSet <>(); Set <Integer> insertedSetB = new HashSet <>();  for(int at = 0; at < arr1.length; at++) { if(!insertedAt.containsKey(arr1[at])) { int insertAfter = findInsertAfter(insertedSetA, arr1[at]); insertedAt.put(arr1[at], insertAfter); } else { int insertAfter = findInsertAfter(insertedSetA, arr1[at]); if(insertAfter != insertedAt.get(arr1[at])) { return false; } } if(!insertedAt.containsKey(arr2[at])) { int insertAfter = findInsertAfter(insertedSetB, arr2[at]); insertedAt.put(arr2[at], insertAfter); } else { int insertAfter = findInsertAfter(insertedSetB, arr2[at]); if(insertAfter != insertedAt.get(arr2[at])) { return false; } } insertedSetA.add(arr1[at]); insertedSetB.add(arr2[at]); } return true; }  private static int findInsertAfter(Set<Integer> keySet, int i) { int maxThatIsSmaller = -1; for(int item : keySet) { if(item > maxThatIsSmaller && item < i) { maxThatIsSmaller = item; } } return maxThatIsSmaller; } """	2014-12-10 11:48:34		
1645	vanul	14	Actually, the assumption that next highest will be the right child is valid only for the root.  For instance consider  2 1 3  2 3 1  both these give the same tree, but I believe your algorithm will say no.	2014-12-10 11:48:34		
1646	dgjji	14	Actually it works, since for 1 the next-smallest in both cases is none and for 3 the next-smallest in both cases is 2.	2014-12-10 11:48:34		
1647	fmzze	14	It works, since 2 follows 1 in both cases and 3 follows 2. Code including some test cases is up here: shrib.com/5ULdxAua	2014-12-10 11:48:34		
1648	admin	14	I had to modify your code to run it (probably java version assumptions). I gave it a test input where I thought it might fail, but it didnt!  So, now I am not sure what your algorithm is.  What exactly is next-smallest? Can you please define it and give a couple of examples?  Thanks.  EDIT: This is a failing test case	2014-12-10 11:48:34		
1649	jippy	14		2014-12-10 11:48:34		
1650	huiqq	14		2014-12-10 11:48:34		
1651	tenuw	14	prints true, instead of false.	2014-12-10 11:48:35		
1652	nwkeg	14	Hello loler, as I mentioned in my original post right now it doesn't check that both have the same elements, but a simple set comparison will take care of that (I've already got both items in sets, so just check whether they completely overlap).  The next-smallest is the largest item currently in the array that is still smaller than the item we're trying to insert. So when inserting 5 into 1,2,4, the next-smallest is 4. If we were inserting 3, the next-smallest would be 2. For 0, the next-smallest is none. When you insert into a BST, the element always gets inserted after the next-smallest unless that space is already filled. However, if that space is already filled, then the algorithm will detect the error for the node that filled the space in one tree and not in the other.	2014-12-10 11:48:35		
1653	cfzie	14	For the record, this should fix the test case you mentioned:	2014-12-10 11:48:35		
1654	cfzie	14		2014-12-10 11:48:35		
1655	zeice	14		2014-12-10 11:48:35		
1656	rdfeo	14	Just stick it right before the return true.	2014-12-10 11:48:35		
1657	bjsiw	14	Ok, I had misunderstood you earlier. This works, and guaranteed O(nlog n). Good job!  I believe I have a proof, brief attempt below:  Given a permutation P of 1,2,3...,n, Call the signature S_P of P, the function f which maps {1,2,...,n} to {0,1,2..., n-1} such that f(k) = next-smallest according to your definition (replacing None by 0).  The claim is that two permutations P1 (a1,a2, ..,an) and P2 (b1,b2, ...,bn) give rise to the same binary tree if and only if S_P1 is identical to S_P2.  Assume S_P1 = S_P2  First we show that the first element of P1 and P2 must be same. Suppose b1 = aj for some j > 1. Then since S_P2(aj) = 0, we must have that a1 > a_j. So we must have that S_P1(a1) = 0 but S_P2(a1) >= aj as a1 appears after aj in P2.  Now we can parittion and show for the subtrees.  DIdn't try proving the other way.	2014-12-10 11:48:35		
1658	eucmc	14	What does "making bst from array" mean? More details!	2014-12-10 11:48:35		
1659	nhibd	14	Take first element as root and insert from then onwards in BST... Ex: A1[]={2,1,3} 2 1 3  A2[]={2,3,1} 2 1 3	2014-12-10 11:48:35		
1660	nhibd	14	@Bharat: Then don't 1,2,3 and 1,3,2 give different trees?	2014-12-10 11:48:35		
1661	fowai	14	@Bharath: Why don't you edit the question to also add what make BST from array means?	2014-12-10 11:48:35		
1662	ewigy	14	Simple solution (few assumptions made, obviously as question is quite vague):  Input: 2 int arrays Output: boolean - whether BST constructed from either array will be same  Idea: - first element has to be equal - loop till the end of array - if there is 1 more element left in both arrays, they have to be equal - advance 1 place - if there are 2 more elements in the array, they have to be equal when sorted - if swapped around, each must be on either side of the first element (i.e root of the BST)	2014-12-10 11:48:35		
1663	eucmc	14		2014-12-10 11:48:35		
1664	nwkeg	14		2014-12-10 11:48:35		
1665	vanul	14	}	2014-12-10 11:48:35		
1666	vanul	14	{#include<stdio.h> #include<stdlib.h> #define size 20 int check(int a1[],int a2[],int l,int r) { if(r==-1) return 1; if(a1[l]!=a2[l]) return 0; if(l==r) return 1; int b1[r-l+1],b2[r-l+1],b3[r-l+1],b4[r-l+1],k1=-1,k2=-1,k3=-1,k4=-1,i,pivot; pivot=a1[l]; for(i=l+1;i<=r;i++) { if(pivot<a1[i]) b1[++k1]=a1[i]; else b2[++k2]=a1[i]; if(pivot<a2[i]) b3[++k3]=a2[i]; else b4[++k4]=a2[i]; } if(k1==k3 && k2==k4 && check(b1,b3,0,k1) && check(b2,b4,0,k2)) return 1; else return 0; } void main() { int a1[]={3,1,0,2,5,4,6}; int a2[]={3,5,6,1,2,4,-1}; int n=sizeof(a1)/sizeof(int); printf("%d\n",check(a1,a2,0,n-1)); }} Can we do like this? Here I used extra space. Everytime I am selecting a pivot and putting the elements less than pivot in first array and the elements greater than the pivot in the second array, and recursively checking these arrays.	2014-12-10 11:48:35		
1667	fowai	14	and for in-place sorting this would work #include<stdio.h> void in_place(int a[],int n) { int save,i,j,k,pivot; pivot=a[0]; for(i=1;i<n;i++) { if(a[i]<pivot) { save=a[i]; for(j=i;a[j]!=pivot;j--); for(k=i-1;k>=j;k--) a[k+1]=a[k]; a[j]=save; } } } void main() { int a[]={3,7,8,2,5,4,9,1,6,0}; int n=sizeof(a)/sizeof(int); in_place(a,n); int i; for(i=0;i<n;i++) printf("%d ",a[i]); printf("\n"); }	2014-12-10 11:48:35		
1668	ewigy	14	Idea is based on qsort-partitioning where order of elements is preserved and done *in place*. As input function takes 2 arrays, applies partitioning on them and recursively processes each of 2 sub arrays.	2014-12-10 11:48:35		
1669	rdfeo	14		2014-12-10 11:48:35		
1670	tenuw	14		2014-12-10 11:48:35		
1671	wbqzu	14	For following test case, it is showing as false... but it should be true. {8,2,0,4,1,3,6,5,7,14,11,9,13,20,16,22} {8,14,20,22,16,11,13,9,2,4,6,7,5,3,0,1}	2014-12-10 11:48:35		
1672	admin	14	Thanks for pointing that out, I forgot to check the case when first indexes are bigger than last indexes, of course it should lead to TRUE	2014-12-10 11:48:35		
1673	rrmeu	14	the algo i thought...i will call a fn with 2 arrays A and B with same length n say with min=INT_MIN and max=INT_MAX,index1=0,index2=0 1. now starting from index1 in A and index2 in B,find 1st element in both arrays greater than min and less than max.If no such element in both the arrays,return true...If such element is only in 1 array return false.let index of such element in array A is i1 and array B is i2. If both elements are not same return false 2. call the same fn twice return isSameBST(A,B,A[i1],max,i1+1,i2+1) && isSameBST(A,B,min,A[i1],i1+1,i2+1).	2014-12-10 11:48:35		
1674	eucmc	14	only recursion stack used and time complexity is o(n*height of BST)	2014-12-10 11:48:35		
1675	xhgls	14		2014-12-10 11:48:35		
1676	mrjku	14		2014-12-10 11:48:35		
1677	ethan	14	My solutions in C++:	2014-12-10 11:48:35		
1678	rdfeo	14		2014-12-10 11:48:35		
1679	bjsiw	14		2014-12-10 11:48:35		
1680	tenuw	14	"A1[]={2,1,3} 2 1 3  A2[]={2,3,1} 2 1 3"  How are these really the same? Depending on the rules, the second number could always be the left parent and the third number could be the right parent. According to my rules, it would be  2 1 3  2 3 1  Totally different.	2014-12-10 11:48:35		
1681	plapd	14	It's a binary search tree. The left child is always smaller, and the right child is always larger.	2014-12-10 11:48:35		
1682	gilit	14		2014-12-10 11:48:35		
1683	gilit	14		2014-12-10 11:48:35		
1684	krxlv	14	Please share feedback on this approach 1. Check length of both the arrays. 1. if both are of equal length, sort them (we can do it in lg n) and then compare each element. If we find a mismatch, then both BSTs are not identical.	2014-12-10 11:48:35		
1685	gilit	14	Please share feedback on this approach 1. Check length of both the arrays. 1. if both are of equal length, sort them (we can do it in lg n) and then compare each element. If we find a mismatch, then both BSTs are not identical.	2014-12-10 11:48:35		
1686	plapd	14	2 bsts would not be identical	2014-12-10 11:48:35		
1687	nwkeg	14	2 bsts would not be identical	2014-12-10 11:48:35		
1688	vanul	14	First Element and size of both array should be same. All the element smaller than first element should be in same Order in both array. Slly: all the element greater than first element should be in same Order in both array.  (Assuming : all different element in array n1:- size of A1 n2:- size of A2 )	2014-12-10 11:48:35		
1689	bexbp	14		2014-12-10 11:48:35		
1690	vanul	14		2014-12-10 11:48:35		
1691	gilit	14	This will fail for  4 2 3 1 7  and  4 2 1 3 7	2014-12-10 11:48:35		
1692	plapd	14	1) check whether the size of both the arrays are equal. 2)if equal, then simply sort both arrays. 3)compare both the element in linear order.see a flag to track all the elements are equal are not.	2014-12-10 11:48:36		
1693	nwkeg	14	Step may be useful between 1 and 2 1.1) find sum of both of the array... in case not same return FALSE else proceed with step 2.	2014-12-10 11:48:36		
1694	ethan	14	dont think this will give correct answer. Once you sort both arrays, you have lost original order. Without the original order BST shape would be impossible to find and compare...	2014-12-10 11:48:36		
1695	dgjji	14		2014-12-10 11:48:36		
1696	ewigy	14	This approach gives false positives .. Ex: 123, 132 --> don't form same BSTs but , sorted order is same....	2014-12-10 11:48:36		
1697	krxlv	15		2014-12-10 11:48:38		
1698	zeice	15		2014-12-10 11:48:38		
1699	jippy	15	Good, very clean	2014-12-10 11:48:38		
1700	ftfck	15	Logic is outstanding... though the logic fails if N = 0. But thats a small change.	2014-12-10 11:48:38		
1701	ewigy	15	I am not very clear on the question itself. Could anyone please elaborate more?	2014-12-10 11:48:38		
1702	tenuw	15	good logic. it can be enhanced further with a return status on printRec to reduce some unnecessary traversing	2014-12-10 11:48:38		
1703	nhibd	15	N=1000 is just an example, the code works only for N=1000.	2014-12-10 11:48:38		
1704	sqzqo	15	I tried this in javascript code, doesn't work-- i dont see any difference in my code: function printTopN_inStringComparisonORder(n) { var printNum = function(str, n) { if (parseInt(str) > n) return console.log(str) for (j=0;j<10;j++) { printNum(str + j, n) } } for(var i=1; i<10; i++) { printNum(""+i, 1000); } }	2014-12-10 11:48:39		
1705	mrjku	15		2014-12-10 11:48:39		
1706	gilit	15	DFS comes to our rescue. if you observe a little you can find out that there is a nice pattern Start with a char 1-9 in that order (9 iterations). Add a 0-9 to right of string one at a time and recursively do dfs. if value<=n print it. recursively keep on adding char to the right. when value>n. return from dfs call.  Here is the fully working code in C++	2014-12-10 11:48:39		
1707	ethan	15		2014-12-10 11:48:39		
1708	plapd	15		2014-12-10 11:48:39		
1709	nwkeg	15	Same idea but just try to avoid over-generate the sequence and atoi in every loop	2014-12-10 11:48:39		
1710	plapd	15		2014-12-10 11:48:39		
1711	fowai	15		2014-12-10 11:48:39		
1712	plapd	15	Can you please elaborate your question ? When N=1000, why you selected only these number and only that sequence ? 1, 10, 100, 1000, 101, 102, ... 109, 11, 110,	2014-12-10 11:48:39		
1713	admin	15	An iterative solution that doesn't use strings, so there's no dynamic memory allocation behind the scenes (except, possibly, for printing on the screen).	2014-12-10 11:48:39		
1714	krxlv	15		2014-12-10 11:48:39		
1715	huiqq	15		2014-12-10 11:48:39		
1716	jippy	15		2014-12-10 11:48:39		
1717	huiqq	15		2014-12-10 11:48:39		
1718	eucmc	15	Nice one with no strings involved!	2014-12-10 11:48:39		
1719	bjsiw	15		2014-12-10 11:48:39		
1720	rdfeo	15		2014-12-10 11:48:39		
1721	cfzie	15		2014-12-10 11:48:39		
1722	wbqzu	15		2014-12-10 11:48:39		
1723	sgiwy	15		2014-12-10 11:48:39		
1724	wbqzu	15		2014-12-10 11:48:39		
1725	fowai	15	To make DFS more understandable just think about a tree with root 1. Root 1 has children 10,11,...,19. 10 has children 100,101,102,...,109. 11 has children 110,111,...,119. Do a DFS and if the node value is under given threshold print it.	2014-12-10 11:48:39		
1726	vanul	15		2014-12-10 11:48:39		
1727	dgjji	15		2014-12-10 11:48:39		
1728	nwkeg	15		2014-12-10 11:48:39		
1729	dkebi	15		2014-12-10 11:48:39		
1730	xhgls	15	Python solution	2014-12-10 11:48:39		
1731	dkebi	15		2014-12-10 11:48:39		
1732	nhibd	15		2014-12-10 11:48:39		
1733	fowai	15		2014-12-10 11:48:39		
1734	ftfck	15		2014-12-10 11:48:39		
1735	dkebi	15	/* Output top N positive integer in string comparison order. For example, let's say N=1000, then you need to output in string comparison order as below: 1, 10, 100, 1000, 101, 102, ... 109, 11, 110, ... */  #include "stdafx.h" #include <iostream> #include <conio.h> #include <algorithm> #include <map> #include <vector> #include <list> #include <iterator> #include <math.h> #include <numeric> #include <sstream> #include <stack> #include <string>  using namespace std;  struct Node { Node( int nValue ) { this->m_nValue = nValue; memset( this->m_SubTree, 0, sizeof( Node * ) * 10 ); }  int m_nValue; Node * m_SubTree[10]; };  class Solution { public: static void AddToTree( int nValue, Node * & pTree) { vector<int> vecTreePath; int nValueCopy = nValue; while ( nValueCopy > 0 ) { vecTreePath.push_back( nValueCopy % 10 ); nValueCopy /= 10; }  Node * pParent = pTree; { for ( size_t i = vecTreePath.size() - 1; i > 0; i -- ) pParent = pParent->m_SubTree[ vecTreePath[i] ]; }  pParent->m_SubTree[ vecTreePath[0] ] = new Node(nValue); }  static void CreateTree( int nValue, Node * & pTree ) { if ( nValue <= 0 ) return; pTree = new Node( 0 ); for ( int i = 1; i <= nValue; i ++ ) AddToTree( i, pTree ); }  static void PrintTreeInDFS( Node * pTree ) { if ( !pTree ) return;  // skip zero if ( pTree->m_nValue ) printf( "%d ", pTree->m_nValue);  for ( int ii = 0; ii < 10; ii ++ ) { if ( pTree->m_SubTree[ ii ]) PrintTreeInDFS( pTree->m_SubTree[ ii ] ); } }  static void DeleteTree( Node * & pTree ) { for ( int i = 0; i < 10; i ++ ) { if ( pTree->m_SubTree[i] ) DeleteTree( pTree->m_SubTree[i]); } delete pTree; pTree = NULL; } };   int _tmain(int argc, _TCHAR* argv[]) { Node * pTree = NULL;  Solution::CreateTree( 1000, pTree ); Solution::PrintTreeInDFS( pTree ); Solution::DeleteTree( pTree );  _getch();  return 0; }	2014-12-10 11:48:39		
1736	tenuw	15		2014-12-10 11:48:39		
1737	gilit	15		2014-12-10 11:48:39		
1738	rrmeu	15	two files:  Data class contains the integer and compares like string:	2014-12-10 11:48:39		
1739	nhibd	15		2014-12-10 11:48:39		
1740	fmzze	15		2014-12-10 11:48:39		
1741	ftfck	15	----------------------------------------------------------------  Main function:	2014-12-10 11:48:39		
1742	mrjku	15		2014-12-10 11:48:39		
1743	dgjji	15		2014-12-10 11:48:39		
1744	azmjc	15	String comparison done on the numbers will give the expected results.	2014-12-10 11:48:39		
1745	xhgls	15		2014-12-10 11:48:39		
1746	fmzze	15		2014-12-10 11:48:39		
1747	sgiwy	15	convert the int to char using a 1000*4 char array, then do radix sort.	2014-12-10 11:48:40		
1748	mrjku	15		2014-12-10 11:48:40		
1749	azmjc	15		2014-12-10 11:48:40		
1750	gilit	15	Simple C++ solution.	2014-12-10 11:48:40		
1751	cfzie	15		2014-12-10 11:48:40		
1752	krxlv	15		2014-12-10 11:48:40		
1753	admin	15		2014-12-10 11:48:40		
1754	rdfeo	15		2014-12-10 11:48:40		
1755	fowai	15		2014-12-10 11:48:40		
1756	bexbp	15		2014-12-10 11:48:40		
1757	ufdxg	16	#include<stdio.h> int check(int); main() { int N;   printf("\n Enter the N:"); scanf("%d",&N); if(check(N)) { printf("\n[%d] Perfect Square:\n",N);  }  else {  printf("\nNot perfect Square\n");  } } int check(int n) { int i=1;  while(n>0) { n-=i; printf("[%d]",n); i+=2;   } if(n==0) return 1;  return 0;  }  complexity:O(logn)in some cases and <o(n)	2014-12-10 11:48:42		
1758	ftfck	16	@NAX: Though you have written the program and it works pretty well, but it is of no consequence to anyone as the logic behind this (i.e. how it works?) is not mentioned by you and is not apparent either, which is by the way is very important rather than this code!!!People can write code in whatever language they want if they know the strategy, can't they?  Strategy: As we all know what is Arithmetic progression right?If not, then have a look at this en.wikipedia.org/wiki/Arithmetic_progression, so basically the logic used here comes from this arithmetic progression. What NAX is doing is this: He is increasing the counter(i+=2) in such a way that it becomes an arithmetic progression and which he is cleverly subtracting (n-=i) with the given number such that if the number is a square then the end result becomes 0.  To put in succinctly : N=25 Output of the program: [25] 1 = 24 (25-1) [24] 3 = 21 [21] 5 = 16 [16] 7 = 9 [9] 9 = 0 and if you notice properly- 1,3,5,7,9 is arithmetic progression and it sums up to (5*(1+9))/2=25 So effectively we are subtracting 25 from 25 and showing the results, however it will not work for non-square number right?Hope you understood why it won't work for non-square number.	2014-12-10 11:48:42		
1759	nhibd	16	The complexity is not O(log n). It's O(sqrt(n)), if n is the number to verify.	2014-12-10 11:48:42		
1760	fmzze	16	if the sum becomes negative just return the result that its not a perfect square, why won't it work?	2014-12-10 11:48:43		
1761	bjsiw	16	@aka +1. Thank you aka, most of us here to learn and understand these things, so I really appreciate the explanation.  @eugene.yarovoi +1. It's true. The programs runs O(sqrt(n)), which is bigger than O(log(n)).	2014-12-10 11:48:43		
1762	bexbp	16	See this image: en.wikipedia.org/wiki/Square_number#Properties	2014-12-10 11:48:43		
1763	krxlv	16		2014-12-10 11:48:43		
1764	huiqq	16		2014-12-10 11:48:43		
1765	ufdxg	16	Thus we can say that the sum of series >>> (1+3+5+7+9+ ... upto n terms) = n^2	2014-12-10 11:48:43		
1766	sqzqo	16		2014-12-10 11:48:43		
1767	ufdxg	16	STRONG NO HIRE (yes, those are Microsoft terms).	2014-12-10 11:48:43		
1768	fowai	16	So give us logarithmic solution which uses only addition and substraction.	2014-12-10 11:48:43		
1769	admin	16	Sum of first n odd numbers is n^2. So we can keep adding odd numbers. If we reach the number its a perfact square.	2014-12-10 11:48:43		
1770	admin	16	thats what the first answer is about	2014-12-10 11:48:43		
1771	fmzze	16	simply we can also keep on summing all odd numbers till we get desired num. If sum ends up with given number then it is perfectly square number otherwise if sum exceeds given number, number is not perfectly square and will return false.  all Square numbers are: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289  If we see the difference among these numbers, following figure we get: 3, 5, 7, 9, 11, 13, 15, 17, 19, 21  So, you see, every consecutive square number is Arithmetic progression. So if we can add number of this series to get desired result. Complexity will be O(sqrt(n)) As in case of square root of 25, we need 5 iteration of addition.	2014-12-10 11:48:43		
1772	krxlv	16		2014-12-10 11:48:43		
1773	plapd	16		2014-12-10 11:48:43		
1774	dkebi	16	Nice. +1 for good explanation and simple, clean code.	2014-12-10 11:48:43		
1775	vanul	16	Just to add a little mathematical explanation..  (n+1)square - n square=2 n+1, so if he have a perfect square number n, then the next perfect square number will be 2n+1 more than n.  Now for all n, 2n+1,4n+1,6n+1 will be always in Arithmetic Progression.	2014-12-10 11:48:43		
1776	krxlv	16	@pawan: nice explanation.	2014-12-10 11:48:43		
1777	sgiwy	16	here is the code:	2014-12-10 11:48:43		
1778	krxlv	16		2014-12-10 11:48:43		
1779	sqzqo	16		2014-12-10 11:48:43		
1780	cfzie	16	for an integer i > 0, compute the sum by summing up i for i times; compare the sum with the given number  when doing the summing up for each i, the complexity can be O(log i).	2014-12-10 11:48:43		
1781	xhgls	16	this solution has greater complexity. but the solution required should have min complexity	2014-12-10 11:48:43		
1782	azmjc	16	Could you elaborate? How do you chose i? How does this even work? Let's say for n=25. You have: i=1 -> 1 i=2 -> 3 i=3 -> 6 i=4 -> 10 i=5 -> 15 i=6 -> 21 i=7 -> 28  I think it should be for integers i > 1 add a number "i" times. For instance: i=2 -> 2+2=4 i=3 -> 3+3+3=9 i=5 -> 5+5+5+5+5=25 End when sum >= our number.  Use cache for lookup? Still pretty slow.	2014-12-10 11:48:43		
1783	krxlv	16	yes. it should be what you wrote. my bad. i'll edit my answer.	2014-12-10 11:48:43		
1784	wbqzu	16	Why we can't simply store all the perfect squares in an array(What do you think about this size of array-it won't be big me thinks). Now all we need to do is to find out if the given number exist in the array or not.That can be simply done by binary search. array[] - {2,4,16,25,36,49,64,81,100,121,169,196,225.......} This would be the fastest but I think this is not the answer your interviewer was looking for or is it?	2014-12-10 11:48:43		
1785	bexbp	16	This is a not bad solution when you want to perform this operation multiple times (you do need to calculate them the first time) and storage is not an issue.	2014-12-10 11:48:43		
1786	krxlv	16	Linear time complexity. O(N)	2014-12-10 11:48:43		
1787	zeice	16		2014-12-10 11:48:43		
1788	plapd	16		2014-12-10 11:48:43		
1789	vanul	16	@m@}{ : how this is different from below approach mentioned earlier?	2014-12-10 11:48:43		
1790	zeice	16		2014-12-10 11:48:43		
1791	vanul	16		2014-12-10 11:48:43		
1792	fowai	16	The complexity is O(N) not O(lgN).	2014-12-10 11:48:43		
1793	qywrh	16	You could also use binary like search for possible square. Time should be less then O(N).	2014-12-10 11:48:43		
1794	azmjc	16		2014-12-10 11:48:43		
1795	eucmc	16		2014-12-10 11:48:43		
1796	vanul	16		2014-12-10 11:48:43		
1797	huiqq	16		2014-12-10 11:48:43		
1798	plapd	16	There are some errors regarding the scope, but its fairly evident. Please take note of rectifying that.	2014-12-10 11:48:43		
1799	sqzqo	16	in for loop...float z= num/i;here 1st time i=0 and z=num/0 gives infinite...	2014-12-10 11:48:44		
1800	bexbp	16	package com.rakesh.topcoder;  import java.util.Scanner;  public class PerfectSquareWithAddition {  /** * @param args */ public static void main(String[] args) {  Scanner input = new Scanner(System.in); System.out.println("Enter a numer.."); int n = input.nextInt(); int finalval = findPerfectSquare(n); if(finalval == 0) System.out.println( n + " is a Perfect Square " ); else System.out.println(n + " is not a perfect square "); }  public static int findPerfectSquare(int n){ int a=1;  while(n>0){ n -= a; a += 2; }  return n; }  }	2014-12-10 11:48:44		
1801	ufdxg	16	To find out if 25 is a perfect square, i have to find a number which is greater than 1 but less than n=25 which n= 25 will be divisible by and when that number is multiplied by itself then it should be equal to n=25;  in my method; n = value the number that n should be divisible by = div; so div * div == value and value%div == 0; the for loop accomplishes div*div using addition instead; complexity root n * root n = n (not sure on this one, help is appreciated);	2014-12-10 11:48:44		
1802	sgiwy	16		2014-12-10 11:48:44		
1803	cfzie	16		2014-12-10 11:48:44		
1804	bjsiw	16	oh and the editor changes the code for this line for(int i=div; i>;0 ; i--) resulting in wrong java syntax when i post it right, not sure why.  i have improved my solution to be root n complexity; the solution is based on that 4+5 = 9 , 9+7 = 16,16+9 = 25,25+11 = 36 and so on..	2014-12-10 11:48:44		
1805	huiqq	16		2014-12-10 11:48:44		
1806	ethan	16		2014-12-10 11:48:44		
1807	ethan	16	use dynamic programming 1^2 = 1 (n+1) = n^2 + 2n + 1  calc 1^2 , 2^2 until n^2 >= value  the time complexity is O(n^0.5)	2014-12-10 11:48:44		
1808	nwkeg	16	hey you fool you cant use power. you can onlu use add &sub	2014-12-10 11:48:44		
1809	jippy	16	Be careful, Anon, people can easily understand that fool is YOU. (a+b)^2 = a^2 + 2ab + b^2. 1^2 = 1. Starting from the next line, b = 1 always => 2ab = (a+a) 2^2 = 1 + (1+1) + 1 = 4 3^2 = 4 + (2+2) + 1 = 9, etc. The complexity is sqrt(n), same as odds sum	2014-12-10 11:48:44		
1810	ufdxg	16		2014-12-10 11:48:44		
1811	eucmc	16		2014-12-10 11:48:44		
1812	bjsiw	16	Regarding the complexity of the arithmetic-progression algorithm, it is sqrt(n) in relation to the value of n, but it is n^2 to the size of n (for example, the size of 100 is 3 [3 digits] but it takes 10 arithmetic operations).	2014-12-10 11:48:44		
1813	cfzie	16		2014-12-10 11:48:44		
1814	xhgls	16		2014-12-10 11:48:44		
1815	gilit	16	read the question please ...	2014-12-10 11:48:44		
1816	azmjc	16	static public boolean checkPerfectSquare(int n) {  int i = 0; int j = 1;  while (i < n) { i +=j; if (i == n) return true; j+=2; }  return false; }	2014-12-10 11:48:44		
1817	krxlv	16	use this: f(x)=x^2 because (x+1)^2=x^2+2*x+1, so, f(x+1)=f(x)+2*x+1 the code is like below:	2014-12-10 11:48:44		
1818	cfzie	16		2014-12-10 11:48:44		
1819	bjsiw	16		2014-12-10 11:48:44		
1820	cfzie	16		2014-12-10 11:48:44		
1821	tenuw	16		2014-12-10 11:48:44		
1822	bjsiw	16	With the same logic as discussed above by adding values (2n+1) with preceding values eg. 1, 4(1+(1+2)), 9(4+ (3+2)), 16(9+ (5+2)).... and comparing with given value. Ruby Code -	2014-12-10 11:48:44		
1823	bexbp	16		2014-12-10 11:48:44		
1824	vanul	16		2014-12-10 11:48:44		
1825	bjsiw	16	With the same logic as discussed above by adding values (2n+1) with preceding values eg. 1, 4(1+(1+2)), 9(4+ (3+2)), 16(9+ (5+2)).... and comparing with given value. Ruby Code -	2014-12-10 11:48:44		
1826	eucmc	16		2014-12-10 11:48:44		
1827	nhibd	16		2014-12-10 11:48:44		
1828	wbqzu	16	With the same logic as discussed above by adding values (2n+1) with preceding values eg. 1, 4(1+(1+2)), 9(4+ (3+2)), 16(9+ (5+2)).... and comparing with given value. Ruby Code -	2014-12-10 11:48:44		
1829	rdfeo	16		2014-12-10 11:48:44		
1830	admin	16		2014-12-10 11:48:44		
1831	fmzze	16	I think this is most compact solution in C-style languages. O(sqrt(n)) complexity. C# code:	2014-12-10 11:48:44		
1832	sgiwy	16		2014-12-10 11:48:44		
1833	dgjji	16		2014-12-10 11:48:44		
1834	ewigy	16	Here is a Ruby solution using the rule of odd deltas:	2014-12-10 11:48:44		
1835	sgiwy	16		2014-12-10 11:48:44		
1836	rdfeo	16		2014-12-10 11:48:44		
1837	dgjji	16	Hi there! Here is my code, the easiest way to solve this problem:	2014-12-10 11:48:44		
1838	admin	16		2014-12-10 11:48:45		
1839	sgiwy	16		2014-12-10 11:48:45		
1840	azmjc	16	In O( sqrt(n) )	2014-12-10 11:48:45		
1841	bexbp	16	In a real interview you don't have the enough time to write huge codes like other solutions. This solution takes you only a few seconds to write in the whiteboard :)	2014-12-10 11:48:45		
1842	dkebi	16	gab i think you missed the part where they said only addition or subtraction....so no multiplication. your solution was also my first instinct but went back and looked at the problem again because i was suspicious as to why someone hadnt thought of it yet when it is so simple.	2014-12-10 11:48:45		
1843	xhgls	17	Typed it in directly... so expect bugs (or plain incorrectness :P ) BFS initiated from all guard positions and +1 for reaching a naked position (a '0') and add it to queue to keep the BFS search going.	2014-12-10 11:48:53		
1844	zeice	17		2014-12-10 11:48:53		
1845	ufdxg	17		2014-12-10 11:48:53		
1846	sgiwy	17	Lol treat G as 1 inside while loop	2014-12-10 11:48:53		
1847	nhibd	17	So, the queue keeps both position of G, and naked position '0'?	2014-12-10 11:48:53		
1848	azmjc	17	^^^ Yes, because all growing shortest paths start at a G and go through a '0' (they do not revisit a numbered node again).  My "Lol" comment above was referring to this fix:	2014-12-10 11:48:53		
1849	fowai	17		2014-12-10 11:48:53		
1850	fowai	17		2014-12-10 11:48:53		
1851	rdfeo	17	should be	2014-12-10 11:48:53		
1852	sgiwy	17		2014-12-10 11:48:53		
1853	rrmeu	17		2014-12-10 11:48:53		
1854	qywrh	17	Got it! Thanks.	2014-12-10 11:48:53		
1855	azmjc	17	Can this algorith ensure that the distance is from the nearest Guard point, I think we have to write like this :	2014-12-10 11:48:53		
1856	rdfeo	17		2014-12-10 11:48:53		
1857	gilit	17		2014-12-10 11:48:53		
1858	azmjc	17	I think the algorithm didn't handle the nearest gaurd points case. Your algorithm might return the longest routes to all the 0 from a given set of gaurds. What if the gaurd point you are starting is not the right candidate for a '0' zero node. There is a possibility that this '0' node can be reached from another gaurd point which is much close.  So we need to correct the logic to take the min( existing a[i][j] and new a[i][j])	2014-12-10 11:48:53		
1859	mrjku	17	This solution doesn't check if the cell is a obstacle and can not be crossed.	2014-12-10 11:48:53		
1860	sqzqo	17	Below is my code, I did some test. -2 for block, -1 for gurad.	2014-12-10 11:48:53		
1861	ewigy	17		2014-12-10 11:48:54		
1862	fmzze	17		2014-12-10 11:48:54		
1863	rrmeu	17	DFS goes deep as far as it can in one direction, before trying others.	2014-12-10 11:48:54		
1864	qywrh	17	@AngryAlgorist, that's true. But is there anything wrong with my code?	2014-12-10 11:48:54		
1865	ethan	17	I am not sure :( How can you guarantee that "step" is always the shortest path reachable from that guard? Can you explain it?	2014-12-10 11:48:54		
1866	wbqzu	17	Well, you can think this as some kind of paint-fill algorithm.	2014-12-10 11:48:54		
1867	nhibd	17	Paint fill is boolean filling of nodes...so dfs vs.bfs has same effect because u are just visiting all suitable nodes.  This is shortest distance filling... So dfs usually does not work.	2014-12-10 11:48:54		
1868	admin	17	Well, you can write some test cases to see if this works,LOL	2014-12-10 11:48:54		
1869	nhibd	17	@Mem, took a closer look, and I see what you are doing here. You are repeatedly trying all paths, even if they reuse the same spots, so long as going through the spot is cheaper than any previous path through that spot.  Cool idea!  The idea should work but it worst case complexity should be large.	2014-12-10 11:48:54		
1870	krxlv	17	BFS from every guard. However: once you reach node whose distance from guard you do not improve, ignore it. If the matrix has N cells and G guards the complexity is O(NG);	2014-12-10 11:48:54		
1871	eucmc	17		2014-12-10 11:48:54		
1872	dgjji	17		2014-12-10 11:48:54		
1873	ethan	17	bfs...	2014-12-10 11:48:54		
1874	xhgls	17	Yes, bfs. But interviewer said there is an optimal solution with O(n^2), which I haven't figured out. :(	2014-12-10 11:48:54		
1875	wbqzu	17	I think we can use bfs twice to solve this problem, from node (0,0) to (n,n), then reverse from (n,n) to (0,0)	2014-12-10 11:48:54		
1876	fmzze	17	bfs... initiate the queue with all "G" cells.	2014-12-10 11:48:54		
1877	admin	17	Could there be anything possibly wrong with using BFS and putting G nodes into the priority queue?	2014-12-10 11:48:54		
1878	plapd	17	Here's another approach, Find the coordinate of the G nodes. For each node, find the Manhattan distance between the Coordinates and the G nodes, assign the value as the smallest manhattan distance. This takes O(n^3) though. The BFS technique with all G nodes in the Priority queue should be the fastest (as someone else suggested)	2014-12-10 11:48:54		
1879	tenuw	17		2014-12-10 11:48:54		
1880	admin	17		2014-12-10 11:48:54		
1881	ewigy	17	time o(n) space o(n), get all the guard nodes to a min-heap and expand them to adjacent nodes, keep adding them to the min-heap if reachable. assuming obstacle is -2, guard is -1 for easy processing.	2014-12-10 11:48:54		
1882	bexbp	17		2014-12-10 11:48:54		
1883	krxlv	17		2014-12-10 11:48:54		
1884	ethan	17		2014-12-10 11:48:54		
1885	zeice	17		2014-12-10 11:48:54		
1886	bjsiw	17	public void setMatrix(char[][] matrix) { for (int i=0; i<matrix.length; i++) { for(int j=0; j<matrix[0].length; j++) { if (matrix[i][j] != 'B' && matrix[i][j] != 'G' && matrix[i][j] != '0') continue; matrix[i][j] = findDistanceToGuardFrom(matrix, new Point(i, j)); } } }  private int findDistanceToGuardFrom(int[][] matrix, Point n) { if (isGuard(n)) { return 0; } int result; for (Point ns : getNeighbors(matrix, n)) { result = 1 + findDistanceToGuardFrom(matrix, ns); if (matrix[n.x][n.y] == 0 || result < matrix[n.x][n.y]) { matrix[n.x][n.y] = result; } } return result; }	2014-12-10 11:48:54		
1887	rdfeo	17	Time Complexity O( n^2 log(n) )..... I have check for various test cases it gives perfect answer. input matrix will be like:	2014-12-10 11:48:54		
1888	tenuw	17		2014-12-10 11:48:54		
1889	nhibd	17		2014-12-10 11:48:54		
1890	huiqq	17	where 2 means Guard and 1 mean blocked or obstacle distance matrix is the output matrix, in which Max value means cant reach, 0 means, you are a guard otherwise other numeric values.  We keep checking whether the distance of any u, u_c has changed, if yes then we re-compute the distance matrix.	2014-12-10 11:48:54		
1891	dgjji	17		2014-12-10 11:48:54		
1892	rrmeu	17		2014-12-10 11:48:54		
1893	fmzze	17	Find the all the guards first, populate all the surrounding empty rooms at distance 1, keep track of these rooms. 1.Find the G cells 2.Update the distance of surrounding cells found in step 1 to 1, use a list to keep track these cells been updated 3.Distance+1, repeat step 2, if the cell's distance is already there, that's definitely the shortest distance, skip this cell  public static int[][] nearestGuard(char[][] input) { int[][] result = new int[input.length][input[0].length]; ArrayList<int[]> current = new ArrayList<int[]>(); for (int i = 0; i < input.length; i++) { for (int j = 0; j < input[0].length; j++) { if (input[i][j] == 'G') current.add(new int[] { i, j }); } } int distance = 1; while (!current.isEmpty()) { ArrayList<int[]> next = new ArrayList<int[]>(); for (int[] c : current) { guradHelper(input, c[0] + 1, c[1], distance, result, next); guradHelper(input, c[0] - 1, c[1], distance, result, next); guradHelper(input, c[0], c[1] + 1, distance, result, next); guradHelper(input, c[0], c[1] - 1, distance, result, next); } current = next; distance++; } return result; }  public static void guradHelper(char[][] input, int i, int j, int distance, int[][] result, ArrayList<int[]> next) { if (i < 0 || j < 0 || i >= input.length || j >= input[0].length || input[i][j] == 'G' || input[i][j] == 'B' || result[i][j] != 0) return; result[i][j] = distance; next.add(new int[] { i, j }); }	2014-12-10 11:48:54		
1894	bexbp	17	Dijkstra's algorithm should be better. And it has O(n^2) complexity.	2014-12-10 11:48:54		
1895	tenuw	17	Dijkstra's is not needed as this is a "every move/edge is 1 unit of weight" problem.	2014-12-10 11:48:54		
1896	rrmeu	17	What about find shortest path from all guards? Just put them into one queue initially.	2014-12-10 11:48:54		
1897	qywrh	17	Could you please elaborate a bit more. Interviewer does mention to start from G, and then bfs from there. but I've run out of time by then. Thanks	2014-12-10 11:48:54		
1898	zeice	17	This is what I thought, start from every G, go 4 direction, if we find current cell is B or another G we return, or if it is a number that smaller than the step we have from Current G, we also return other wise add 1 to current step and put it into current cell. Do the same recursion for current cell until no move can made. Do the same process for all G.	2014-12-10 11:48:54		
1899	wbqzu	17	@Mem, recursion would go deep in one direction before trying others (i.e., DFS).	2014-12-10 11:48:55		
1900	vanul	17	@AngryAlgorist. Yes, I admit that, but it is not possible here?	2014-12-10 11:48:55		
1901	rrmeu	17	What I actually have meant is to run breadth first search from all guards.	2014-12-10 11:48:55		
1902	dgjji	17		2014-12-10 11:48:55		
1903	krxlv	17		2014-12-10 11:48:55		
1904	bexbp	17	}	2014-12-10 11:48:55		
1905	wbqzu	17	Could the person who down vote the answer care to explain ?	2014-12-10 11:48:55		
1906	gilit	17	Could the person who wrote the answer, care to explain what the frack he is trying to do, first?	2014-12-10 11:48:55		
1907	krxlv	17	Mr. frack,  The code uses dynamic programming to find the minimum distance to the nearest guards. For example: Consider 3 points A, B, C  Distance: B to C = 3 (shortest distance) Distance: A to B = 2 (shortest distance) Distance: A to C = ?  Option 1: find shortest distance from A to C by traveling from A to C Option 2: Add shortest distance from A to B and shortest distance from B to C.  Above code uses Option 2.  Next time you down vote an answer, have a better reason than being lazy. Also please provide a test case that fails.  if you are at point A and you want to goto point C, and you re	2014-12-10 11:48:55		
1908	krxlv	17	I have hard coded the dimension as 3. -1 will represent block, -2 will represent guard.	2014-12-10 11:48:55		
1909	rdfeo	17		2014-12-10 11:48:55		
1910	jippy	17		2014-12-10 11:48:55		
1911	zeice	17	if you are posting actual compilable code , then why is your only comment "param args" ?????	2014-12-10 11:48:55		
1912	gilit	18	In this problem the rates at which glasses get filled in are rational numbers, whose numerators form the binomial coefficients and denominators are powers of 2 - specifically 2 raised to the power of level at which glasses are present.  A litre of water (overflowed from previous level) gets distributed among the glasses at each level as follows:	2014-12-10 11:48:57		
1913	ethan	18		2014-12-10 11:48:57		
1914	sgiwy	18		2014-12-10 11:48:57		
1915	fmzze	18	The above distribution pattern provides with a partial progress towards the actual algorithm that finds the amount of water in jth glass of ith row. The algorithm gets tricky because all the glasses at a level might not be completely filled yet, before water starts getting filled up in levels below (albeit, in an inverted triangle fashion).  ---------------------------------------------------------------------------- The above observation apart, a DP-like algorithm below(that remembers quantities in glasses of the previous row) to find out the amount of water in jth jug of ith row can solve the problem.  0. For each glass, maintain 2 variables - the amount of water it holds and the amount of water it overflows. 1. For a glass at index i in the given row, look up two glasses in the previous row at index i-1 & i. (Boundary cases of indices need to be checked though) 2. The inflow into the current glass = half of outflow of glass in the previous row at i-1 + half of outflow of glass in the previous row at index i 3. Based on the inflow, volume held in the current glass = min(1, inflow) and the overflow at the current glass = inflow - volume held by the current glass 4. Repeat steps 1 to 3 until we reach the required glass.  An implementation in java goes like the below:	2014-12-10 11:48:57		
1916	ftfck	18		2014-12-10 11:48:57		
1917	tenuw	18		2014-12-10 11:48:57		
1918	eucmc	18	"glass 5 will get water from both 2nd glass and 3rd glass"  level 0: 1 level 1: 1/2 1/2 level 2: 1/4 2/4 1/4 level 3: 1/6 2/6 2/6 1/6 level 4: 1/8 2/8 2/8 2/8 1/8	2014-12-10 11:48:57		
1919	zeice	18	The denominator should be 2*level not level^2, what happens when there's 7 liters and you want glass 8?	2014-12-10 11:48:57		
1920	vanul	18	@camelcase  While a solution for this problem is explored, there are several ways to look at this problem. My posting describes "the *rate* at which a particular glass(based on its position in the row) gets filled when a liter of water gets overflowed from all of the glasses above."  However, if only a few of the glasses in a row are overflowing at a given time, the above mentioned distribution pattern will not hold for a row beneath it.  Finally, the actual implementation of an algorithm to solve the problem has a different approach altogether than a mathematical way of looking at the problem.  About your argument, on what basis are you saying that denominator should be 2*level.Give reasons.	2014-12-10 11:48:57		
1921	ftfck	18	I believe the problem was not correctly interpreted: a glass can only fill the one below it *if* it is full! Therefore it can never happens some glass 5 is non-empty while glass 2 and 3 are only half filled.	2014-12-10 11:48:57		
1922	admin	18	@ Chih.Chiu.19  You are not quite correct. You haven't completely understood my statements. For the above configuration, work out what happens when the volume of water X = 5 & 6 and look at glass numbers 4, 5, 6 & 7, 8, 9, 10  At 5 liters you will see the following configuration, where the numbers in brackets denote the volume held.  At X= 5 4(1/2) 5(1) 6(1/2) 7(0) 8(0) 9(0) 10(0)  At X=6 4(3/4) 5(1) 6(3/4) 7(0) 8(1/4) 9(1/4) 10(0)  Do you now see that glass numbers 4 & 6 are not completely filled, yet glass numbers 8 & 9 get some volume inflow into them? That is what I mean when I say the all the glasses in the current row might not be completely filled, yet some glasses from lower row starts getting filled up.	2014-12-10 11:48:57		
1923	krxlv	18	@Ayahuasca Ok I see what you did now. You are right :) I was just confused by your "flow chart" table at the beginning, since for no situations will we have a configurations like that. Anyway, I see now that your solution is correct, thanks.	2014-12-10 11:48:57		
1924	nhibd	18	C# Code	2014-12-10 11:48:57		
1925	huiqq	18		2014-12-10 11:48:57		
1926	fowai	18		2014-12-10 11:48:57		
1927	rrmeu	18		2014-12-10 11:48:57		
1928	ftfck	18		2014-12-10 11:48:57		
1929	ewigy	18	A little modified version with 2D array	2014-12-10 11:48:57		
1930	krxlv	18		2014-12-10 11:48:57		
1931	wbqzu	18		2014-12-10 11:48:57		
1932	krxlv	18	#include<stdio.h>  void main(){ int noOfLiters = 0; int n = 0; //number of rows to print int j = 0; int i = 0; int presentRow = 0; int nextRow = 0; float boundary = 0; float middle = 0; float temp = 0;  printf("Enter the value of noOfLiters\n"); scanf("%d",&noOfLiters); printf("how many rows\n"); scanf("%d",&n);  i = 0; //row on which water is poured is taken as i =0 or zeroth row while(i<n){ presentRow = i*(i+1)/2; nextRow = (i+1)*(i+2)/2; if(presentRow < noOfLiters && nextRow <= noOfLiters){ printf("row %d has 1 liter\n",i); }  else if(presentRow > noOfLiters){ printf("row %d has no water \n",i); } else{ temp = noOfLiters; for(j = 0;j<i;j++){ temp = (temp-1)/2; } boundary = temp;  middle = noOfLiters - i*(i+1)/2 - 2*boundary; middle = middle/(i-1); printf("row %d has %f liters on boundary columns and %f liters in middle columns\n",i,boundary,middle); } i++; } }	2014-12-10 11:48:57		
1933	nwkeg	18	#include<iostream> int main() { int glass,ltr,rows=1; std::cout<<"INPUT:\nNo of glasses\namt of water\n"; std::cin>>glass>>ltr; while(glass>0) { glass=glass-rows; rows++; } rows--; std::cout<<"\n\tRows: "<<rows<<"\t"<<ltr<<"\n"; float arr[rows][rows];  for(int i=0;i<rows;i++) { for(int k=4-i;k>0;k--) { std::cout<<"\t"; } for(int j=0;j<=i;j++) {  arr[i][j]=0; std::cout<<arr[i][j]<<"\t"; } std::cout<<"\n"; } arr[0][0]=ltr; std::cout<<"1 : "<<arr[0][0]; for(int i=0;i<rows;i++) { for(int j=0;j<=i;j++) { std::cout<<"."<<i<<j; if(arr[i][j]>1) { arr[i+1][j]=arr[i+1][j]+(arr[i][j]-1)/2; arr[i+1][j+1]=arr[i+1][j+1]+(arr[i][j]-1)/2; arr[i][j]=1; }  } }  std::cout<<"\n"; for(int i=0;i<rows;i++) { for(int k=4-i;k>0;k--) { std::cout<<"\t"; } for(int j=0;j<=i;j++) {  std::cout<<arr[i][j]<<"\t"; } std::cout<<"\n"; } return 0;  }	2014-12-10 11:48:57		
1934	ewigy	18	#include "stdafx.h" #include "stdlib.h" void find(int i, int j, int water) { int x,y; float **jug; float remain; jug=(float**)calloc(i,sizeof(float *)); for (x=0;x<i;x++) { jug[x]=(float*)calloc(i,sizeof(float));  }  jug[0][0]=(float)water; for (x=0;x<i;x++) { for(y=0;y<=x;y++) { if (jug[x][y]>1) { remain=jug[x][y]-1; jug[x][y]=1; remain/=2; if ((x+1+1)<=i) { jug[x+1][y]+=remain; jug[x+1][y+1]+=remain; } }   } }   for(x=0;x<i;x++) { printf("\n"); for(y=0;y<i;y++) { printf("\t %f",jug[x][y]); } } printf("ith jth jug value=%f",jug[i-1][y-1]);  }  int main(int argc, _TCHAR* argv[]) {  int i,j; int water; printf ("Enter ith "); scanf("%d",&i); printf ("Enter jth value"); scanf("%d",&j); if (j>i) { printf ("values are not correctly entered (i>=j)"); return -1; } printf ("Enter the amount of water"); scanf("%d",&water);  find(i,j,water);  return 0; }	2014-12-10 11:48:57		
1935	ewigy	18	Isn't it related to Pascal's triangle?	2014-12-10 11:48:57		
1936	mrjku	18	This is an interesting problem, but it can be resolved with just math.  The total amount of water to completely fill the glasses up to the nth row is:  f(n) = n * (n + 1) / 2  The number of glasses in the ith row is really simple:  c(i) = i  Assuming the glass isn't completely full, the total water for a glass in the ith row is:  g(i) = (X - f(i - 1)) / c(i)  I'm going to be lazy and not reduce, but the only missing piece is including a stepwise function for X - f(i - 1) as well as g(i) because a glass can't be less than empty or greater than full. In pseudocode:  g(i) = min(1, (max(0, X - f(i - 1)) / c(i))	2014-12-10 11:48:57		
1937	xhgls	18	#include<stdio.h> #include<stdlib.h>  float min(float a, float b) { return a<b?a:b; } float winePour(int start, int dest, float qty,int k) {  float a=0,b=0; if(start > dest || qty < 0) return 0; if(start == dest) { printf("Start == destination \n"); return min(1,qty); }   qty=qty-1; printf("%d %d %f\n",start+k,dest,qty/2); a+=winePour(start+k,dest,qty/2,k+1); printf("%d %d %f\n",start+k+1,dest,qty/2); b+=winePour(start+k+1,dest,qty/2,k+1);  return min(1,a+b); } int main() { int glass=5; float qty=3.5; float x=0.0; x=winePour(1,glass,qty,1); printf("%f \n",x); return 0; }	2014-12-10 11:48:57		
1938	ethan	18	Here is the code in c++	2014-12-10 11:48:57		
1939	rrmeu	18		2014-12-10 11:48:57		
1940	vanul	18		2014-12-10 11:48:57		
1941	dgjji	18	public String findwater(int n ,int i, int j) { int temp =i*(i+1)/2; int left = n -temp; if(left > 0) { if((2(i-1) ) > left) return ""+1; else { float a=left/2(i-1) if(j==1 || j ==i) return ""+float/2; else return ""+float; } }  }	2014-12-10 11:48:57		
1942	ftfck	18	public String findwater(int n ,int i, int j) { int temp =i*(i+1)/2; int left = n -temp; if(left > 0) { if((2(i-1) ) > left) return ""+1; else { float a=left/2(i-1) if(j==1 || j ==i) return ""+float/2; else return ""+float; } } }	2014-12-10 11:48:57		
1943	tenuw	18	The problem is similar to pascal triangle. Only a little modification required for boundary conditions.	2014-12-10 11:48:58		
1944	admin	18		2014-12-10 11:48:58		
1945	bjsiw	18		2014-12-10 11:48:58		
1946	mrjku	18		2014-12-10 11:48:58		
1947	tenuw	18		2014-12-10 11:48:58		
1948	qywrh	18	I think this check is wrong x > totalGlassesUptoPreviousLevel . May be u have assumed that water reaches the next level only after the current level is full, which is wrong.	2014-12-10 11:48:58		
1949	bjsiw	18	I think it's just a dynamic programming. My code is as follows: #include <iostream> #include <string.h> using namespace std; #define GLASSES_NUM 100 #define TO_INDEX(i, j) (0.5 * (i) * (i - 1) + (j))  double f[GLASSES_NUM]; int water; double calculate(int i, int j) { int index = TO_INDEX(i, j); if (f[index] - 0.0 > 1.0e-6) { return f[index]; } else { if (i == 1 && j == 1) { f[index] = water; return f[index]; } else { double m1 = 0.0, m2 = 0.0; if ( j >= 2) { double temp = calculate(i-1, j-1); m1 = temp > 1 ? (temp - 1) : 0; } if (j <= 0.5 * i * (i -1)) { double temp = calculate(i-1, j); m2 = temp > 1 ? (temp - 1) : 0; } f[index] = 0.5 * (m1 + m2); return f[index]; } } } int main() { int i, j; memset(f, 0.0, sizeof f); cout << "Input the total water(L):" << endl; cin >> water; while(1) { cout << "Which glass do you want to know?" << endl; cout << "i = "; cin >> i; cout << "j = "; cin >> j; if (j > i) { cout << "j must not be bigger than i" << endl; continue; } double result = calculate(i, j); cout << "answer is " << (result > 1 ? 1 : result) << endl; } return 1; }	2014-12-10 11:48:58		
1950	azmjc	18	#include<stdio.h> void main() { float r,c,n; scanf("%f%f%f",&r,&c,&n); if(((r-1)*(r/2))>=n) printf("0"); else if(r*((r+1)/2)==n) printf("1"); else printf("%f",(float)((n-((r-1)*(r)/2))/r)); }	2014-12-10 11:48:58		
1951	cfzie	18	#include<stdio.h> void main() { float r,c,n; printf(" enter row no and col no and total water") scanf("%f%f%f",&r,&c,&n); if(((r-1)*(r/2))>=n) printf("total amt of water is 0"); else if(r*((r+1)/2)==n) printf("total amt of water is 1"); else printf("total amt of water is %f",(float)((n-((r-1)*(r)/2))/r)); }	2014-12-10 11:48:58		
1952	bexbp	18	Very similar idea, more OO way of implementation,  each Glass class is responsible for maintaining obtained water and how much overflow/spillover is from this glass.  Parent glass will just pour water to its children.	2014-12-10 11:48:58		
1953	rdfeo	18		2014-12-10 11:48:58		
1954	bjsiw	18		2014-12-10 11:48:58		
1955	dgjji	18		2014-12-10 11:48:58		
1956	rdfeo	18		2014-12-10 11:48:58		
1957	gilit	18		2014-12-10 11:48:58		
1958	fmzze	18		2014-12-10 11:48:58		
1959	fowai	18	Sorry, wrong code.Why? See Ayahuasca answer above. =(	2014-12-10 11:48:58		
1960	fowai	18	TL;DR; so lets see how the water flows down evel 0: 1 level 1: 1/2 1/2 level 2: 1/4 2/4 1/4 level 3: 1/6 2/6 2/6 1/6 level 4: 1/8 2/8 2/8 2/8 1/8 and so on.  So by analysing the above data a simple formula can be designed for the 2 different cases that we will have Case 1. if the glass is the outer most, either on left or on right. Case 2. if the glass is as inner glass.  For case 1 the formula will be: Amount of water in Glass(Y) = (X - (1+2+i-1)) / (2 * (i-1)) where i is the row and X is the total amount of water being poured.  And for case 2 just multiply the value of case 1(Y) by 2. and we have our desired output.	2014-12-10 11:48:58		
1961	ewigy	18	If x=6, i=4 and j=2, your solution gives 0 as output and correct answer is 0.25 (first litre fills (1,1) glass, next two fills (2,1) and (2,2) glasses, next two liters distributed between (3,1), (3,2) and (3,3) glasses as 0.5, 1.0 and 0.5, so glass (3,2) is filled. Now we put last liter, that distributes as 0.25, 0.25, 0.25, 0.25 between (3,1), (4,2), (4,3) and (3,3))	2014-12-10 11:48:58		
1962	admin	18	The numerator should be the value in pascal's triangle.	2014-12-10 11:48:58		
1963	nwkeg	18	Yes, here the rate at which the glasses are filled has also to taken into consideration. I strongly think this can be taken care by a formula, rather hen some complex code.	2014-12-10 11:48:58		
1964	huiqq	18		2014-12-10 11:48:58		
1965	sgiwy	18		2014-12-10 11:48:58		
1966	dgjji	18		2014-12-10 11:48:58		
1967	plapd	18		2014-12-10 11:48:58		
1968	rdfeo	18	The approach seems right but there are many issues in your code	2014-12-10 11:48:58		
1969	vanul	18	bu kadar basit gencler dagln	2014-12-10 11:48:58		
1970	nwkeg	18		2014-12-10 11:48:58		
1971	ufdxg	18		2014-12-10 11:48:58		
1972	jippy	18		2014-12-10 11:48:58		
1973	ftfck	18		2014-12-10 11:48:58		
1974	krxlv	18		2014-12-10 11:48:58		
1975	bjsiw	18	Well sorry my bad.Haven't read the question properly.	2014-12-10 11:48:58		
1976	azmjc	19	Don't know why your question got voted down- this is a reasonable design question to be asked during an interview. You sir get a +1.	2014-12-10 11:49:00		
1977	krxlv	20	The problem is same as finding the smallest window containing all the characters of a given string (here its 'ab'). If such a window is there return 'true'. Provide any alternate soln if there.	2014-12-10 11:49:02		
1978	fmzze	20	Yep. Create a set of letters from the smaller string (e.g. 'ab'). Advance character by character through the larger string, checking to see if current character is in the set. If it is, remove it from the set. If the set's empty, you're done. If not, keep advancing. If you find a character that's not in the set, advance to the next index, and repopulate the set from the smaller string.	2014-12-10 11:49:02		
1979	jippy	20	showell30, I don't know if set would be the correct data structure. What if there were duplicate characters?	2014-12-10 11:49:02		
1980	admin	20	@Frank. If characters can repeat, you can maintain the difference in counts (between the window and the target string) and this idea would essentially work. Once a character count becomes zero, that means the window has the exact number required for that character (as we are maintaining difference). You can move it to a different set.  To check if a window matches, just check the length of the different set.  This is O(n) time (n is the length of the larger string).	2014-12-10 11:49:02		
1981	ufdxg	20	@Loler: You mean to maintain the difference in count in a HashMap?	2014-12-10 11:49:02		
1982	ftfck	20	@Loler and @showell will this solution work if we are looking to find 'abc' within 'abac'  With this solution, when I hit the 2nd 'a' within 'abac' I would re-populate my set and advance to 'c'; which essentially tells me that the permutation of 'abc' is not present. Am I missing something obvious??	2014-12-10 11:49:02		
1983	krxlv	20	Given an input string A and the template string B, first use quicksort to sort B into B', and first |B| elements in A denoted as C; dynamically move C along A, each time the 1st element in C is removed and the next char is appended into C, just like insertion sort to sort C into C' and match C' == B'	2014-12-10 11:49:02		
1984	plapd	20	A reasonable solution.	2014-12-10 11:49:02		
1985	vanul	20	Most practical solution.  This will take nlog(n) time. Don't know if it's even possible to do it faster.	2014-12-10 11:49:02		
1986	xhgls	20	@Frank, it is possible. See my comment to the other upvoted answer.	2014-12-10 11:49:02		
1987	ethan	20	Good solution @zhou0620. Thanks	2014-12-10 11:49:02		
1988	krxlv	20	Are we assuming that Input string A is always sorted? If not, this algorithm will not work.	2014-12-10 11:49:02		
1989	dkebi	20	It's Not O(n log n). It's O(n*m) because the window moves n steps, at EACH step we insert+compare (log m + m) >>> that is n*(log m+ m) = O(n*m)	2014-12-10 11:49:02		
1990	jippy	20	lets say S1 is the main string and S2 is the substring why cant we do like this  S1= cdabfgd, S2=bac put s2 in character hash like hash[b]=1,hash[a]=1,hash[c]=1 and the length of s2 is 3 now iterate through s1 and check if the character exists in hash and decrement the corresponding hash value i.e when b is found in s1 make hash[b]-- lets maintain a global variable which increases it self when every time you decrease count in hash so when the global variable count becomes equal to length of s2 it means that the permutation of characters exist in s1.	2014-12-10 11:49:02		
1991	dkebi	20	I have an O(n) solution, please check the answer of mine below. I am using kmp search, more faster than you said.	2014-12-10 11:49:02		
1992	eucmc	20	Hi, This will work only if the given long string is sorted. But for overall solution, we can generate a permutation of a smaller string. And then for each permutation, we can use KMP search or any search algo, to search this permuted string in the bigger string.	2014-12-10 11:49:02		
1993	dkebi	20	Here is my thought: For the permutation of string, its simplified represents is the number of each character existed in the string. If you want to check if A's permutation is sub string of the B string, you only need to be sure that the number of each kind of character in A is less the number of the same character in the string B. So you can build a histogram of characters in A by going through A, then going through B, decrease the count of character histogram of A when it find the one in B. Return true when all histogram reach zero during the going through B, otherwise return false.	2014-12-10 11:49:02		
1994	cfzie	20	here is the code	2014-12-10 11:49:02		
1995	eucmc	20		2014-12-10 11:49:02		
1996	sqzqo	20		2014-12-10 11:49:02		
1997	jippy	20	- take each character in smaller string and add its position in larger string into sorted array - if all chars are there in larger string, check if all the position is in sequence  Eg String a = abcdefghij String = dcfe  Sorted positions will be 3 4 5 6 so will return true	2014-12-10 11:49:02		
1998	ufdxg	20	what if you have some chars occuring multiple times ? example: string_1 = abcdeeffghijc string_2 = dcfe  Also notice that by sorting the string, you disrupt the original order of chars in the string such that you have no way of telling for example if you are looking for "cat" in "tsakc" or "cat" in "ckast"	2014-12-10 11:49:02		
1999	vanul	20	Yes, this will work well only If string does not have repeating chars. Thanks for pointing it out	2014-12-10 11:49:02		
2000	fowai	20	but "dcfe" is not in "abcdeeffghijc" right? "dcfee" is in. Isnt it?	2014-12-10 11:49:02		
2001	krxlv	20	I am assuming it should return false for above case since lookalike question is a specific permutation of smaller string must be sub string of larger string	2014-12-10 11:49:02		
2002	huiqq	20	true but you are missing my point. i think your algorithm would return false for "abcabcabc" and "cab" when it should return true;	2014-12-10 11:49:02		
2003	krxlv	20	I agree orig algorithm need tweak but this example would work well.. Position of cab would be 3 1 2 and sorting it would put it in sequence so would return true..	2014-12-10 11:49:02		
2004	admin	20	yaker no that question is different	2014-12-10 11:49:02		
2005	rdfeo	20	public static bool isubstring(string S1, string S2) { int sumS1 = 0; int sumS2 = 0;  for (int i = 0; i < S2.Length; i++) { sumS2 += (int)S2[i]; } for (int i = 0; i < S1.Length - S2.Length + 1; i++) { int index = i; sumS1 = 0; for (int j = 0; j < S2.Length; j++) { sumS1 += (int)S1[index]; index++; } if (sumS1 == sumS2) return true; } return false;  }	2014-12-10 11:49:02		
2006	bexbp	20	what's poblem is this solution?	2014-12-10 11:49:02		
2007	dgjji	20	what's poblem in this solution?	2014-12-10 11:49:02		
2008	nwkeg	20	Few things  1) It is not correct. For instance, if adef is the long string and bc is the string sought, then you will say true, while it is clearly false. (Basically a+d = b+c)  Basically, sum being same does not imply you have gotten your string.  2) For long strings there is a good chance of overflows, and messing up your results even more, 1) not withstanding.  3) The runtime of this is O(|A||B|) where the string lengths are |A| and |B|.  (I should have stated, 2 and 3 are no biggies, but being incorrect is).	2014-12-10 11:49:02		
2009	ufdxg	20	1- if long string = "adef" and "bc" is the string sought code return false not true  2- overflow is difficult to occur beacuse if the length of long string is 1000000000 and the length of sougth string is 1000000 the sum of the string = 122*1000000 in worst case  3- this method when we need to use O(1) space	2014-12-10 11:49:02		
2010	sgiwy	20	ok , i know my mistake thanks loler	2014-12-10 11:49:02		
2011	ethan	20	for first case we need to check if sougth string contain one char of long string  if (sumS1 == sumS2 && S2.Contains(S1[index].ToString())) return true;	2014-12-10 11:49:02		
2012	sqzqo	20	but this poblem can solved if we use first 26 prime number as index for chars from a to z	2014-12-10 11:49:03		
2013	vanul	20	get a element from string A, search for that in string B1(Copy of second string B),If we dont find it go to next element in A. If we find element at position 'i' in B1, replace that element with 0 in B1(we did not modify anything in B). search for the next element in A in B1 and replace that element with 0 in B1 till we could not find the a .elements of A in B1 or all elements in B1 are 0. if all elements in B are 0.result is success.  if we could not find a element at position k of A in B1. get refresh B1 i.e copy from B. now find for that element in B(the original string) if we could not find it in B, Continue to repeate the same steps from position k+1 . if you find it in B,repeate steps from position i+1	2014-12-10 11:49:03		
2014	rdfeo	20	To solve this problem.. First find the maximum window in which all the character of given pattern is present. If max window length is equal to pattern length than it is going to be the permutation of given string other wise not.Code is given below let me know if it fails in any scenario it is working for me for test cases i think of.  int FindpatLen(char *str,char *pat) { if(!*str) return 0; int len1=strlen(str),len2=strlen(pat),count=0; int hasfound[26]={0},needtofound[26]={0}; int i=0,begin=0,max=999; for(i=0;i<len2;i++) needtofound[pat[i]-97]++; i=0; for(;i<len1;i++) { if(needtofound[str[i]-97]==0) continue; hasfound[str[i]-97]++; if(hasfound[str[i]-97]<=needtofound[str[i]-97]) count++; if(count==len2) { while((needtofound[str[begin]-97]==0) || (hasfound[str[begin]-97]>needtofound[str[begin]-97])) { if(hasfound[str[begin]-97]>needtofound[str[begin]-97]) hasfound[str[begin]-97]--; begin++; } if(max>(i-begin)) max=i-begin+1; } } return max; } bool Ispermutation(char *str,char *pat) { int len=strlen(pat); if(len==FindpatLen(str,pat)) return true; return false; } int main() { char str[]="abcabcabc"; char pat[]="cab"; bool res=Ispermutation(str,pat); getchar(); return 0; }	2014-12-10 11:49:03		
2015	qywrh	20	1.Create a temporary bitMap of <character,Bit> initialize them with character and bit value 0 2. Scan through the big array when you find a character in the small array update the bit map with the char and set it to 1 if the character bit has 0.  public static boolean checkPresence(char[] arr, char[] temp) {  int track = 0; Map<Character, Integer> tempMap = new HashMap<Character, Integer>(); for (char c : temp) { tempMap.put(c, 0); } int prev = 0; for (int i = 0; i < arr.length; i++) { char c = arr[i]; if (tempMap.get(c) != null && tempMap.get(c) == 0 && (prev == 0 || prev == i - 1)) { tempMap.put(c, 1); track++; prev = i; } } return track == temp.length ? true : false; }    Let me know if i miss any case	2014-12-10 11:49:03		
2016	dkebi	20	If long string has length n and the short has length m Best complexity I reached: -Assuming no repeated characters in either string >> O(n) -Allow repeated characters in the long string >> O(n) too -Allow repeated characters in either string >> O(n*log m)	2014-12-10 11:49:03		
2017	ftfck	20	Firstly, Sort the string and substring separatelyTime complexity is O(sqrt(n)) Secondly, use match algorithm on the ordered stringTime complexity is O(n) so the total complexity is O(n).	2014-12-10 11:49:03		
2018	mrjku	20		2014-12-10 11:49:03		
2019	dkebi	20		2014-12-10 11:49:03		
2020	vanul	20	The Algorithm i posted above its O(n) and i am using two constant size arrays. I handled all cases i suppose let me know if it fails in any case	2014-12-10 11:49:03		
2021	ethan	20		2014-12-10 11:49:03		
2022	rdfeo	20		2014-12-10 11:49:03		
2023	nwkeg	20	How about this, you just sort both the strings and then compare the index of the smaller string in the larger string. If it is -1, then the smaller string is not a part of the larger string.	2014-12-10 11:49:03		
2024	bjsiw	20		2014-12-10 11:49:03		
2025	sqzqo	20		2014-12-10 11:49:03		
2026	zeice	20	sort is not required, i think	2014-12-10 11:49:03		
2027	vanul	20	reverse the second string and use kmp search will be better. and also we can use suffix tree or suffix array, but they are too complicated. here is my program, and it will take O(n) time complexity(n: the length of first string) and O(m) space complexity(m: the length of second string):	2014-12-10 11:49:03		
2028	admin	20		2014-12-10 11:49:03		
2029	ftfck	20		2014-12-10 11:49:03		
2030	vanul	20	int[] count = new int[256]; for(char c: str1.toCharArray()) ++count[c]; for(char c: str2.toCharArray()) { if(count[c]==0) return false; } return true;	2014-12-10 11:49:03		
2031	nwkeg	20	I think of hashing all the characters into the hashtable and maintain the count. Then, for every character in S2, check if it exists in the hashtable. if so, then result is true. it takes o(n) where n is the size of the longest string.  This idea is not based on the order and it depends whether there exists every character of a string exists in the original string. When it exists, the permutation is possible (obviously)	2014-12-10 11:49:03		
2032	vanul	20	will this idea work pls correct me if I am wrong:) 1.create two hash tables one for string 1 and another for string 2 2.if the hash values of string 2 if it is contained within string 1 then string is accepted....	2014-12-10 11:49:03		
2033	huiqq	20	How about this:  p1 = &Array1; strcpy(Array3, Array2); while (*p1 != '\0') { for (i = (p1 - Array1); i < ((p1-Array1) + strlen(Array2)); i++) { for (j = 0; j < strlen(Array2); j++) { if (Array1[i] == Array2[j]) { Array2[j] = 'x'; count++; break; } } } if(count == strlen(Array2)) { success = 1; break; } else { p1++; strcpy(Array2, Array3); count = 0; } }  if (success == 1) { printf("Success"); } else { printf("Failure"); }	2014-12-10 11:49:03		
2034	nhibd	20		2014-12-10 11:49:03		
2035	plapd	20		2014-12-10 11:49:03		
2036	nhibd	20		2014-12-10 11:49:03		
2037	azmjc	20		2014-12-10 11:49:03		
2038	rdfeo	20	We can do this in O(n). The algorithm is simple, we move a window of |p| from left to right, and keep a counter of characters passed. We also update a counter d whenever a match between the moving counter and histogram of p happens or otherwise.	2014-12-10 11:49:03		
2039	eucmc	20		2014-12-10 11:49:03		
2040	mrjku	20		2014-12-10 11:49:03		
2041	fowai	20	Guys we need to find a substring of string 1 which consists of only characters of string2 and has same length as string 2, once while iterating you find such a substring then compare the count of each character in the substring and string 2 , if string 2 has all unique characters this problem becomes simply finding the longest substring in string 1 that consists of all unique characters , characters here being those of string 2 , then if the length of this longest substring equals length of string 2 , then this is the code  i m posting the c code	2014-12-10 11:49:03		
2042	sgiwy	20		2014-12-10 11:49:03		
2043	eucmc	20		2014-12-10 11:49:03		
2044	vanul	20	Please check out this generic solution, that will work on all cases, even if the text is not sorted. we create all possible permutations of a pattern and then simply compare.	2014-12-10 11:49:03		
2045	fmzze	20		2014-12-10 11:49:03		
2046	ethan	20		2014-12-10 11:49:04		
2047	sgiwy	20		2014-12-10 11:49:04		
2048	rrmeu	20		2014-12-10 11:49:04		
2049	bjsiw	20	}	2014-12-10 11:49:04		
2050	nwkeg	20	An easy solution assuming alphabets from 'a' to 'z' allowed. Time O(N) Space O(1)	2014-12-10 11:49:04		
2051	fowai	20		2014-12-10 11:49:04		
2052	azmjc	20		2014-12-10 11:49:04		
2053	zeice	20	sorry a minute correction its i + l2 -1 < l1	2014-12-10 11:49:04		
2054	tenuw	20		2014-12-10 11:49:04		
2055	cfzie	20		2014-12-10 11:49:04		
2056	fowai	20	in python:	2014-12-10 11:49:04		
2057	fowai	20		2014-12-10 11:49:04		
2058	tenuw	20		2014-12-10 11:49:04		
2059	rrmeu	20	C++ solution is below. Only one inefficiency: you need to repopulate the hash every time you don't have match.	2014-12-10 11:49:04		
2060	ufdxg	20		2014-12-10 11:49:04		
2061	rrmeu	20		2014-12-10 11:49:04		
2062	ewigy	20		2014-12-10 11:49:04		
2063	xhgls	20		2014-12-10 11:49:04		
2064	tenuw	20	cracking the coding interview has the same question in chapter 1	2014-12-10 11:49:04		
2065	dkebi	20	it's not exactly the same. The q in cc is to assume they should be permutation of each other - both sides.	2014-12-10 11:49:04		
2066	vanul	20	convert two arrays to numbers  S1 : abcdefg -------> 01234567 S2 : ba -------> 10 int sumS1 = 0; int sumS2 = 0;  for(int i = 0;i<S.length;i++) { sumS2+=S2[i]; } for(int i = 0;i<S1.length - S2.length + 1; i++) { if(S1[i] + S1[i+1] == sumS2) return true; }	2014-12-10 11:49:04		
2067	ethan	20	Compute all the permutations of the smaller string(easily done recursively). For each permutation, check if it is a substring of bigger string.	2014-12-10 11:49:04		
2068	ethan	20	This is highly inefficient if the smaller string is say, more than 15 characters.	2014-12-10 11:49:04		
2069	xhgls	20		2014-12-10 11:49:04		
2070	tenuw	20		2014-12-10 11:49:04		
2071	sgiwy	20	I don't claim it's optimized but it will work, 1) I find all substring's in the first word that are the length of the second word. 2) I generate all the permutations for a substring of the first word 3) check every permutation i generate and compare it to the second word	2014-12-10 11:49:04		
2072	fowai	20	O((n/k)(k)!), it's a horrible solution, but I already had the code for permutation. A better solution would be to look for every substring of size k in the longer string, and check that the number of occurrences of every letter is in this substring is same as the number of every occurrences of every letter in the smaller string.	2014-12-10 11:49:04		
2073	admin	20	HI i think this can be easily solved by Hash maps. Create a hash map for the second string and keep incrementing for a new instance found for a letter. ex: abdds: a(1),b(1),d(2),s(1). Then for the second string, keep decrementing if the same letter is found. if the first string ends and all the letters have the values associtaed to them as zeroes: return TRUE. The complexity is m+n, 1.e. of O(m)	2014-12-10 11:49:04		
2074	jippy	20		2014-12-10 11:49:04		
2075	admin	20	If you sort both strings, you will get a false positive for acb and ab.	2014-12-10 11:49:04		
2076	rrmeu	21	I think the key of this problem is to determine the initial first number and the second number. once it's decided, other numbers are automatically generated.  Below code is not optimized, but should work.	2014-12-10 11:49:05		
2077	nhibd	21		2014-12-10 11:49:05		
2078	wbqzu	21		2014-12-10 11:49:05		
2079	cfzie	21	your code works fine	2014-12-10 11:49:05		
2080	dkebi	21	Modified the code a wee bit in java. works for the test cases in the problem	2014-12-10 11:49:06		
2081	sqzqo	21		2014-12-10 11:49:06		
2082	ufdxg	21		2014-12-10 11:49:06		
2083	admin	21		2014-12-10 11:49:06		
2084	fowai	21	I think for the sake of the problem, it is better to assume that the second number is greater than the first.	2014-12-10 11:49:06		
2085	wbqzu	21	It doesn't work. check the case 1121325	2014-12-10 11:49:06		
2086	ewigy	21	@Anonymous it works for this case. it will pass when in match function 1 , 12 will go as the substrings. so it will become 11213 then 12+13 will happen i.e 1121325. The solution is absolutely correct	2014-12-10 11:49:06		
2087	sgiwy	21	@PAN, you modified version has some issues I think:  In the first method named isAggregatedNumber:	2014-12-10 11:49:06		
2088	jippy	21		2014-12-10 11:49:06		
2089	bexbp	21		2014-12-10 11:49:06		
2090	dkebi	21	In the second method named Match:	2014-12-10 11:49:06		
2091	ewigy	21		2014-12-10 11:49:06		
2092	nwkeg	21		2014-12-10 11:49:06		
2093	xhgls	21	I think shawn's proposed method is doing fine.	2014-12-10 11:49:06		
2094	plapd	21		2014-12-10 11:49:06		
2095	zeice	21		2014-12-10 11:49:06		
2096	admin	21	--- A mistake is a crash course in learning. Please comment on its correctness. ---	2014-12-10 11:49:06		
2097	mrjku	21	I think it is a linear solution!!	2014-12-10 11:49:06		
2098	azmjc	21	Mistakes Alg related: 1) After factor variable increases, i should start from 0 instead it starts from factor position. The problem line is "i = i + factor;" 2) make method does not return the sum variable. Syntax related: 3) function header should be int is_Aggregated(int *A, int n) 4) There should be a ; in line i = 0  Cheers! :)	2014-12-10 11:49:06		
2099	ethan	21	why do you assume that the two numbers that are to be summed have same number of digits?  you program doesn't solve 132411235: 1234+1=1235	2014-12-10 11:49:06		
2100	fowai	21	@VladP : Corrected. Thanks :)	2014-12-10 11:49:06		
2101	jippy	21	can you check for 1235813 - in this case all your assumptions are valid ( like second is > first number etc). Your input works only if A is given as { 1,2,3,5,8,13} but not { 1,2,3,5,8,1,3}. Correct me if I mistook. If you say you need to input the array as in the second case, you are back to the same problem, how will u partition the array to 13 or 1,3.	2014-12-10 11:49:06		
2102	ftfck	21	Agreeing to nikhil simha,  Assuming that the two numbers that are to be summed have same number of digits does not make up for satisfactory solution.  Solution proposed fails to solve example like: 1299111210, because 12+99=111, 99+111=210 1100101, because 1+100=101	2014-12-10 11:49:06		
2103	ufdxg	21	This code doesn't even compile, and after fixing it, it doesn't solve the following inputs: 1100101 12344680 1299111210	2014-12-10 11:49:06		
2104	sqzqo	21	I did it recursively in Python:	2014-12-10 11:49:06		
2105	huiqq	21		2014-12-10 11:49:06		
2106	azmjc	21		2014-12-10 11:49:06		
2107	bexbp	21	I think dynamic programming should be used here. I figured out a recurrence relation to solve this in O(n^5). Does anyone have a better idea?	2014-12-10 11:49:06		
2108	cfzie	21	One of the other answers mentions it: the key is to determine the initial first and second numbers, then rest is easy to verify.  There are Theta(n^2) possibilities for the first and second, and O(n) time to verify for each such possiblilty, so there is an O(n^3) algorithm.	2014-12-10 11:49:06		
2109	ftfck	21	It doesn't be the case- consider 1125126 - 1 + 125 = 126 but 1+1 could look like they are a good pick for aggregation	2014-12-10 11:49:06		
2110	sqzqo	21	@gizmo: What part of "there are theta(n^2) possibilities" didn't you understand?  1,1 is one possibility, but fails when you reach 5. So you try another one...	2014-12-10 11:49:06		
2111	vanul	21	Since the constraint is not specified, I will assume the number of digits is ~20. The question asks to divide the number into several parts, so a n-digit number can be divided at at most n-points ( between every two adjacent digits and minus point before first digit ). Hence, use backtrack to iterate through all 2^n possibilities and check for the condition.  Complexity should be O(2^n) and number for index i to index j can be pre-calculated	2014-12-10 11:49:06		
2112	bjsiw	21	Python version	2014-12-10 11:49:07		
2113	bexbp	21		2014-12-10 11:49:07		
2114	bexbp	21		2014-12-10 11:49:07		
2115	ftfck	21	My solution in Java. Also created an amount of unit tests. Also works for very big numbers (see last Unit Test), using BigInteger.	2014-12-10 11:49:07		
2116	wbqzu	21		2014-12-10 11:49:07		
2117	vanul	21		2014-12-10 11:49:07		
2118	nwkeg	21	-------------------------------------------------	2014-12-10 11:49:07		
2119	gilit	21		2014-12-10 11:49:07		
2120	wbqzu	21		2014-12-10 11:49:07		
2121	nwkeg	21		2014-12-10 11:49:07		
2122	nhibd	21		2014-12-10 11:49:07		
2123	nhibd	21		2014-12-10 11:49:07		
2124	krxlv	21		2014-12-10 11:49:07		
2125	huiqq	21		2014-12-10 11:49:07		
2126	bexbp	21		2014-12-10 11:49:07		
2127	tenuw	21	I think that we can identify whether the number can be decompose into 3 numbers a,b,c such that a+b = c first. And then if any subset of the number can be decomposed, we then propagate to the end of the number. It will take O(n^3)	2014-12-10 11:49:07		
2128	azmjc	21	A working solution in ruby. Like many people comment in here, the key is to get the first 2 elements. Given that, you just need to perform checks on the remaining elements. It requires a lot of switching between integers and strings.	2014-12-10 11:49:07		
2129	ewigy	21		2014-12-10 11:49:07		
2130	rrmeu	21		2014-12-10 11:49:07		
2131	qywrh	21	The working code is here  int main(void) {  char Str[]="112112224"; AgreegatedFunction(Str); } void AgreegatedFunction(char *inputstr) {   int NoofDigits = 1,resultdigits; int stridx=0; char operand[10],val[10]; int operand1,operand2; int i,result; int valid= 0; while(*(inputstr+stridx) != '\0') { // get operand 1 if(!valid) { for( i=0;i<NoofDigits && *(inputstr+stridx) != '\0';i++, stridx++) operand[i]=*(inputstr+stridx);   operand[i]='\0'; operand1 = atoi(operand);   // get operand 2 for( i=0;i<NoofDigits && *(inputstr+stridx) != '\0';i++, stridx++) operand[i]=*(inputstr+stridx);  operand[i]='\0'; operand2 = atoi(operand); }  resultdigits = Noofdigitsforresult(operand1+operand2); // get result for( i=0;i< resultdigits && *(inputstr+stridx) != '\0';i++, stridx++) val[i]=*(inputstr+stridx);  val[i]='\0'; result = atoi(val);  if((operand1 + operand2) != result ) { NoofDigits++; valid = 0; if( stridx < strlen(inputstr)) { stridx = 0; } } else { printf("operand one %d operand two %d result %d\n",operand1,operand2,result); valid = 1; operand1 = operand2; operand2 = result;  }  } if(valid) printf(" it is a aggregated number"); else printf(" it is not a aggregated number"); }  int Noofdigitsforresult(int result) { int noofdigits = 1;  while(result > 9) { result = result /10; noofdigits++; } printf("No.of digits %d",noofdigits); return noofdigits; }	2014-12-10 11:49:07		
2132	gilit	21		2014-12-10 11:49:07		
2133	gilit	21		2014-12-10 11:49:07		
2134	mrjku	21	We figure out first and second numbers, build aggregated number, and check if it is the given number. If it is not, take another digit to rebuild second number and repeat the process. This needs to continue for first number too if the built aggregated number is not the given one. Worst Case Scenario [for example 1123581323] : O(N^3) and Best Case Scenario [for example 1123581321]: O(N)	2014-12-10 11:49:07		
2135	jippy	21		2014-12-10 11:49:07		
2136	mrjku	21		2014-12-10 11:49:07		
2137	azmjc	21	For each possible pair of start numbers validate if the number string is same is sequence created by using them as seed values. If any such pair is found then true else false.	2014-12-10 11:49:07		
2138	jippy	21		2014-12-10 11:49:07		
2139	azmjc	21		2014-12-10 11:49:07		
2140	mrjku	21	Something like this. Idea is to scan from right to left. First look for the right most digit to see if it is sum of any two numbers on the left. if it is, recursively do the same thing for the rest of the number on left. if it also returns true then it's aggregated. if the recursive call returns false, then you look for the right most two digits and recursive again.. you do it until n/2 digits on the right, if you can't find it, return false. there are two recursive calls one dividing the number to left and right parts and second one is to look for the permutations of n*2 digits to see if any of permutations' sum gives the summation for the right most n digits..	2014-12-10 11:49:07		
2141	sqzqo	21		2014-12-10 11:49:07		
2142	dgjji	21		2014-12-10 11:49:07		
2143	vanul	21		2014-12-10 11:49:07		
2144	rrmeu	21		2014-12-10 11:49:07		
2145	rrmeu	21	/********************************************************************* * we will name a number "aggregated number" if this number has the following * attribute: just like the Fibonacci numbers 1,1,2,3,5,8,13..... * * the digits in the number can divided into several parts, and the later part * is the sum of the former parts. * * like 112358, because 1+1=2, 1+2=3, 2+3=5, 3+5=8 122436, because 12+24=36 * 1299111210, because 12+99=111, 99+111=210 112112224, because 112+112=224 so * can you provide a function to check whether this number is aggregated number * or not? * *********************************************************************/	2014-12-10 11:49:07		
2146	fowai	21		2014-12-10 11:49:08		
2147	sgiwy	21		2014-12-10 11:49:08		
2148	krxlv	21	I write a code in Java and pass all the cases appeared in this post. Let me know if it has any problem:  public boolean ST(String s){ for(int first = 1; first <= s.length()/2; first++){ for(int second = first+1; second <= (s.length()-first)/2 + first; second++){ if(CK(s.substring(0,first), s.substring(first, second), s.substring(second))){ return true; } } } return false; }  public boolean CK(String s1, String s2, String rest){ int i1 = Integer.parseInt(s1); int i2 = Integer.parseInt(s2); String sum = (i1 + i2) + ""; if(sum.length() > rest.length()){ return false; } if(sum.equalsIgnoreCase(rest.substring(0, sum.length()))){ if(sum.length() == rest.length()){ return true; } return CK(s2, sum, rest.substring(sum.length())); } return false; }	2014-12-10 11:49:08		
2149	eucmc	21	122122244112 122+122=244 and 1+1=2 does not pass.	2014-12-10 11:49:08		
2150	tenuw	21		2014-12-10 11:49:08		
2151	bexbp	21		2014-12-10 11:49:08		
2152	bexbp	21		2014-12-10 11:49:08		
2153	cfzie	21		2014-12-10 11:49:08		
2154	sgiwy	21	your code works fine for most numbers but fails for numbers like 112233 because you did not handle the logic for the cases where the first three digits agree the requirement and the rest dosenot but the number as a whole does... how ever i modified your code to make it work let me know if there are any special cases that the following code wont work for.....	2014-12-10 11:49:08		
2155	admin	21		2014-12-10 11:49:08		
2156	jippy	21		2014-12-10 11:49:08		
2157	bjsiw	21	hi rajesh, nice logic but it may fail for the this case 10111 -> 10+1->11	2014-12-10 11:49:08		
2158	vanul	22	Why not to consider this as Bernoulli trial, where: 1/M - probability of single success (that a value goes to a single slot) i - expected numbers of success (the success = the value goes exactly to the same slot) N - numbers of tries 1 - 1/M - a probability of failure:  So then having a Bernoulli trial formula where (N i) stands for binomial coefficient:  P(i)=(N i) * (1/M)^i * (1 - 1/M) ^(N - i)	2014-12-10 11:49:10		
2159	eucmc	22	What if N=2*i? There is a case that 2 slots with i elements in each and you are counting this case twice. What if N=k*i?	2014-12-10 11:49:10		
2160	vanul	22	But since there are M single slot for success, I think you should multiply it by M.	2014-12-10 11:49:10		
2161	bjsiw	22	I'm not sure what's posted is correct so far.  Looks like what joe kid posted gives the probability of this outcome: (1) Exactly i items will land in one particular bucket b. All other N-i items land in any of the other buckets. To me, this seems incomplete because it considers just one special bucket b.  As a correction, Charlie suggests multiplication by M to make this the probability of exactly i items landing in *any* bucket. This is using the assumption that the outcomes defined by (1) are mutually exclusive for each bucket b, because you would need that assumption to use the sum all M of them to get the probability of any of them occuring. However, they are not mutually exclusive. You can have i in one bucket and also have i land in another bucket by chance.	2014-12-10 11:49:10		
2162	huiqq	22	Base case, i=0. Probability of an element hashing in a slot = 1/M Probability of an element not hashing in a particular slot (ending in remaining M-1 slots) = (M-1)/M All N elements not hashing in that slot = (M-1)/M * (M-1)/M * (M-1)/M ... = ((M-1)/M)^N  Let us take the case of i=1. First element can hash at any possible slot, probability = 1. Now, probability of remaining N-1 elements not hashing in that particular slot = ((M-1)/M)^(N-1)   Let us take the case of i=2. First element can hash at any possible slot, probability = 1. Probability of second element going into same slot = 1/M Now, probability of remaining N-2 elements not hashing in that particular slot = ((M-1)/M)^(N-2) Probability of a slot having 2 elements = (1/M)*((M-1)/M)^(N-2)  To make it generic:  P(i) = ((M-1)/M)^N, when i=0 P(i) = (1/M)^(i-1) * ((M-1)/M)^N, otherwise	2014-12-10 11:49:10		
2163	krxlv	22	Very clear explanation. Sounds good to me.	2014-12-10 11:49:10		
2164	ewigy	22	I'm afraid it's wrong. You are calculating the probability that a particular slot has i elements, not "the probability that there will be a slot with i elements".	2014-12-10 11:49:10		
2165	krxlv	22	henryadam, you're thinking of (1/M)^i * ((M-1)/M)^N	2014-12-10 11:49:10		
2166	gilit	22	Hint: Inclusion-Exclusion Principle	2014-12-10 11:49:10		
2167	krxlv	22	(1/M)^i (M-1/M)^(N-i)	2014-12-10 11:49:10		
2168	rrmeu	22	This is wrong. The above formula is for question "what is the probability that slot x(i.e. a particular slot) has i elements".  The question is asking what is the probability that THERE WILL BE A SLOT with i elements.	2014-12-10 11:49:10		
2169	zeice	22	Do you mean (1/M)^i (1-1/M)^(N-i) ?  For example, say i=2 and suppose you have keys labeled K0, K1, K2... This would be the probability that a certain pair of keys, say K1 and K2 for example land in a particular spot (while all other keys land somewhere else). joe kid multilplies the above expression by N choose i and gets (for this example) the probably any possible pair landing in a particular bucket.	2014-12-10 11:49:10		
2170	mrjku	22	This is statistics math problem.  I would think it this way.  (1)P(there is one slot with i elements) = 1- P(there is no slot with i elements)  (2)P(there is no slot with i elements) = P(the first slot does not have i elements)*P(the second slot does not have i elements)*...*P(the last slot does not have i elements)  Because the probability of any slot does not have i elements is the same, we get  (2*) P(there is no slot with i elements) = P(a slot does not have i elements)^N  (3) P(a slot does not have i elements) = 1- P(a slot has i elements)  (4) P(a slot has i elements) = [(1/N)^i] * [(1-1/N)^(N-i)]  Use (1), (2*), (3), (4) to solve the problem.	2014-12-10 11:49:10		
2171	huiqq	22	I'm not sure if (2*) is correct, because the probabilities of "a slot does not have i elements" are not independent, so can you simply multiply them?	2014-12-10 11:49:10		
2172	ftfck	22	how about this: (c(N,i)*(M-1)^N-i)/M^N	2014-12-10 11:49:10		
2173	rdfeo	22	I might miss something, but you can choose the bucket in M ways, so you have to multiply numerator by M.	2014-12-10 11:49:10		
2174	ewigy	22	The probability of an element being in one slot = 1/M Consider i=2, probability that there will be a slot with i elements? will be 1/M*1/M  Since 1<i<N probability that there will be a slot with i elements =  1/M^i, where i=1 to N	2014-12-10 11:49:10		
2175	fowai	22	# of ways to drop N samples into M slots = M^N (denote this as denominator). binding i samples together, dropping the bundle into one of M slots, and dropping the other samples into the remaining M-1 slots, the number of ways to do this = C(N, i) * M * (M-1) ^ (N-i) (denote this as numerator). The probability is therefore numerator / denominator.	2014-12-10 11:49:10		
2176	cfzie	22	Obviously your answer hasn't eliminated duplicates. For example, N = 6, M =3, i =3. You can get the combination 123, 456, _ by binding 123 and 456 separately, thus you've counted it twice. (123), 456, _ 123, (456), _	2014-12-10 11:49:10		
2177	rdfeo	22	The probability that a particular slot has i elements = (1/M)^i * ((M-1)/M)^(N-i) No. of ways that slot can be chosen = C(M,1) = M Therefore probability that a slot has i elements = M * (1/M)^i * ((M-1)/M)^(N-i)  Note: There would be no C(N,i) because we do not get to choose which i elements go to that slot. It is already pre-decided by the hash function.	2014-12-10 11:49:10		
2178	ftfck	22	Probability of an event = No of occurences of an event / All possible event occurences  Total No of ways to put N objects in M slots = M^N Total No of ways such that there is a slot with i objects = No of ways to put i objects in a slot * no of ways to put N-i objects in M-1 slots  No of ways to put i objects in 'a' slot = choose a slot * choose i objects * 1^i (since there is a singel way to put i objects into a single chosen slot)  No of ways to put i objects in 'a' slot = MC1 * NCi * 1 No of ways to put N-i objects in M-1 slots = (M-1) ^ (N-i)  Probability = MC1 * NCi * (M-1)^(N-i) / (M^N)   but I am worried about how to eliminate the duplicates.	2014-12-10 11:49:10		
2179	xhgls	22	Let any one of m slots contains exactly i element and remaining n-i elements distributed among rest (m-i) slots = C(m,1)*C(n,i)*((1/m)^i)*((1-1/m)^n-1) ..1  But above formula counts multiple time if there can be more than 1 slot with i elements. Probability that more than 1 slot with i element = Summation over k = 2 to [n/i], (k-1)*C(m, k)*C(n, k*i)* C(k*i, i)*C((k-1)*i, i)*...C(i,i) *((1/m)^k*i)*((1-1/m)^(n-k*i)) ..2  Substract ..2 from ..1, we get the answer: C(m,1)*C(n,i)*((1/m)^i)*((1-1/m)^n-1) - Summation over k = 2 to [n/i], (k-1)*C(m, k)*C(n, k*i)* C(k*i, i)*C((k-1)*i, i)*...C(i,i) *((1/m)^k*i)*((1-1/m)^(n-k*i))	2014-12-10 11:49:10		
2180	ufdxg	22	Edit int  Let any one of m slots contains exactly i element and remaining n-i elements distributed among rest (m-i) slots = C(m,1)*C(n,i)*((1/m)^i)*((1-1/m)^n-1) ..1  But above formula counts multiple time if there can be more than 1 slot with i elements. Probability that more than 1 slot with i element = Summation over k = 1 to [n/2i], C(m, 2*k)*C(n, 2*k*i)* C(2*k*i, i)*C((2*k-1)*i, i)*...C(i,i) *((1/m)^2*k*i)*((1-1/m)^(n-2*k*i)) ..2 //Prob of odd no. of slots with i elements cancels out, so summation over 2k number of slots with i elements included  Substract ..2 from ..1, we get the answer: C(m,1)*C(n,i)*((1/m)^i)*((1-1/m)^n-1) - Summation over k = 1 to [n/2i], C(m, 2*k)*C(n, 2*k*i)* C(2*k*i, i)*C((2*k-1)*i, i)*...C(i,i) *((1/m)^2*k*i)*((1-1/m)^(n-2*k*i))	2014-12-10 11:49:10		
2181	gilit	22	This follows the binomial distribution with parameters (N, 1/M) and so P(X = i) = N Ci (1/M)^i(M-1/M)N-i. This is because all M slots were equally probable. If the probabilities of falling into a slot varies, that would be a multinomial distribution(with different probabilities for individual trial for each slot)	2014-12-10 11:49:10		
2182	bexbp	22	My attempt, feels right but probably wrong.  What is the probability that there will be at least 1 of m slots with (exactly) k elements in a hash table with n inserted elements.  Assuming k < n.  Total ways to bucket n elements into m slots = m^n  Pr [ the first slot has exactly k elements ] = = [number of ways n-k elements are in one of the other m - 1 buckets (which effectively enforces that k elements are in the first bucket)] / [number of ways n elements are in m slots] = (m-1)^(n-k) / (m^n)  Pr [ exactly 0 slots have exactly k elements] = product over i=1...m of Pr [ith slot does not have k elements] = product over i=1...m {1 - Pr [ith slot has exactly k elements]} = {1 - [(m-1)^(n-k) / m^n]}^m  Pr [ > 0 slots have exactly k elements] = 1 - Pr [ 0 slots have exactly k elements] = 1 - {1 - [(m-1)^(n-k) / m^n]}^m	2014-12-10 11:49:11		
2183	ethan	22	Pr("there exist a slot with exactly i items") = newtonSymbol(N,i) * M * (M-1)^(N-i) / M^N	2014-12-10 11:49:11		
2184	jippy	22	This is a problem of poisson approximation to the binomial distribution.  Total number of keys = N In an average if two keys hash to the same bucket, then N = 2M  P(i) ==> Probability that i keys collide  P(i) = e ^ (-lambda) * (lamda^i) / i!  where lambda = np  where n = total number of keys = 2M where p = probability that a bucket is chosen = 1/M  therefore lambda = 2. Hence p(i) = e^-2 * (2^i)/i!	2014-12-10 11:49:11		
2185	rrmeu	22	try this: (M+N-i-2)! / ((M-3)! * (N-i)!)	2014-12-10 11:49:11		
2186	nhibd	22	A typo in my above anwser:  (2*) P(there is no slot with i elements) = P(a slot does not have i elements)^M  (4) P(a slot has i elements) = [(1/M)^i] * [(1-1/M)^(N-i)]	2014-12-10 11:49:11		
2187	wbqzu	22	If M is 1, then (1-1/M)^(N-i) becomes 0, so the probability becomes 0, when it should be 1.	2014-12-10 11:49:11		
2188	sqzqo	22	Alex, lets say we have only one slot: M = 1. The values are always hashed in the same slot. So, we have only 2 possible results: probability = 1 if i = N and 0 otherwise.  N = i, leads to (1-1/M)^(N-i) = 0^0 = 1 by convention N != i leads to 0  the formula gives the expected values	2014-12-10 11:49:11		
2189	ethan	22	I believe your answer is correct, except for one small thing in Step 4. The expression should be multiplied by c(N, i).	2014-12-10 11:49:11		
2190	fowai	22	@Zoro, can you explain how did you reach the formula in step 4? I think, it should be (1/M)^(i-1) in the first part. See explanation below.	2014-12-10 11:49:11		
2191	mrjku	22	Let's re-sentence (2*) (3) (4) to avoid confusion here:  (2*) P(there is no slot with i elements) = P(the first slot does not have i elements)^M  (3) P(the first slot does not have i elements) = 1- P(the first slot has i elements)  (4) P(the first slot has i elements) = [(1/N)^i] * [(1-1/N)^(N-i)]	2014-12-10 11:49:11		
2192	wbqzu	22	The reasoning starts from (1) and goes to (4), to solve the problem, solve the equations in reverse order to solve (1).  (1)P(there is one slot with i elements) = 1- P(there is no slot with i elements)  (2)P(there is no slot with i elements) = P(the first slot does not have i elements)*P(the second slot does not have i elements)*...*P(the last slot does not have i elements)  (2)->(2*) because the slots have equal chance of having any element fall into it  (2*) P(there is no slot with i elements) = P(the first slot does not have i elements)^M  (3) P(the first slot does not have i elements) = 1- P(the first slot has i elements)  (4) P(the first slot has i elements) = [(1/M)^i] * [(1-1/M)^(N-i)]	2014-12-10 11:49:11		
2193	plapd	22	I just realize that Anish made a great point. To have i elements in the first slot, you are freely choosing any i from the N, therefore there's cases, each with the same probability.  (4) P(the first slot has i elements) = [(1/M)^i] * [(1-1/M)^(N-i)] * C(N,i)	2014-12-10 11:49:11		
2194	ethan	22	step 1. (1)P(there is one slot with i elements) = 1- P(there is no slot with i elements) should it be like (1)P(there is one slot with i elements) = 1- P(there is no slot with i elements) - P(there is two slots with i elements) ...etc?	2014-12-10 11:49:11		
2195	mrjku	22	This is incorrect. Suppose M = 10, N=1, and i=1. The formula does not yield the expected value of 1. The flaw in the analysis above is that (2) does not hold because the events are not independent.	2014-12-10 11:49:11		
2196	sgiwy	22	Probability of 1 slot having i elements P(1)=	2014-12-10 11:49:11		
2197	dkebi	22		2014-12-10 11:49:11		
2198	nwkeg	22		2014-12-10 11:49:11		
2199	mrjku	22	Probability of 2 slots having i elements P(2)=	2014-12-10 11:49:11		
2200	gilit	22		2014-12-10 11:49:11		
2201	fmzze	22		2014-12-10 11:49:11		
2202	sgiwy	22	Probability of 3 slots having i elements P(3)=	2014-12-10 11:49:11		
2203	plapd	22		2014-12-10 11:49:11		
2204	eucmc	22		2014-12-10 11:49:11		
2205	gilit	22	... and so on, so the probability of having A slot with i elements is: P(1)+P(2)+....+P(M) but I am not sure of a formula to generalize this equation.	2014-12-10 11:49:11		
2206	fowai	23	use bit vector to store each integer in single bit. 625 integers are required to store 20000 numbers  int arr[625] = {0};  ex: to store data 2000 arr index = 2000/32 = 62 bit position = 2000%32 = 16  now make bit position 16 of array index 62 arr[62] to 1  using this bit vectors we can store data range from 1 - 20000 in 625 integers..  after storing all data in bit vectors, check all bit positions of arr[0], arr[1]..... arr[625]... if any bit position is set to 1 then store back that data into array  lets arr[10] bit position 15 is set to 1 then this is equivalent to data 10*32+15 = 335	2014-12-10 11:49:13		
2207	huiqq	23	Simple and awesome :) +1	2014-12-10 11:49:13		
2208	fowai	23	nice solution +1 from me	2014-12-10 11:49:13		
2209	fmzze	23	@algos Can you please also provide the code on how you will sort the numbers	2014-12-10 11:49:13		
2210	cfzie	23		2014-12-10 11:49:13		
2211	admin	23		2014-12-10 11:49:13		
2212	ftfck	23	awesome man..+1	2014-12-10 11:49:13		
2213	cfzie	23	@algos can you explain for your example how the bit array is filled. Like for 97/32=3 that is arr[3] and bit position 97%3 is 1 but for 64/32=0 that is arr[0] the bit position is also 0 but how 2 and 32 are coming. Can you please again explain how the values in the bit array are filled. It will be of great help.	2014-12-10 11:49:13		
2214	azmjc	23		2014-12-10 11:49:13		
2215	dgjji	23		2014-12-10 11:49:13		
2216	dgjji	23	how to deal with the array with duplicate numbers? Say number x is duplicated y times, use the bit operation, we lost the information y. How to avoid this?	2014-12-10 11:49:13		
2217	fmzze	23	Sorry for the last comments. It said unique numbers.	2014-12-10 11:49:13		
2218	krxlv	23	@algos thanks..:)	2014-12-10 11:49:14		
2219	dgjji	23	Can we create an array of length 20000 when the question says that we can not load more than 1000 numbers into memory?	2014-12-10 11:49:14		
2220	azmjc	23	perfect ... :)	2014-12-10 11:49:14		
2221	qywrh	23	nice	2014-12-10 11:49:14		
2222	qywrh	23	If you can use C++ bitset, just use it	2014-12-10 11:49:14		
2223	gilit	23		2014-12-10 11:49:14		
2224	sgiwy	23		2014-12-10 11:49:14		
2225	fmzze	23	This soln. is so easy to understand and working.	2014-12-10 11:49:14		
2226	sgiwy	23		2014-12-10 11:49:14		
2227	zeice	23		2014-12-10 11:49:14		
2228	sqzqo	23	We can use external quicksort. In an external quicksort, instead of heaving a single pivot element used for partitioning the array, we have a group of elements called 'middle group' or 'pivot group'. In a generalized algorithm, we use a Doubly Ended Priority Queue, (DEPQ).	2014-12-10 11:49:14		
2229	vanul	23		2014-12-10 11:49:14		
2230	fmzze	23		2014-12-10 11:49:14		
2231	bjsiw	23	However, the question mentions that the range of integers is pretty much same as the number of elements and also the integers are unique.	2014-12-10 11:49:14		
2232	huiqq	23		2014-12-10 11:49:14		
2233	ufdxg	23		2014-12-10 11:49:14		
2234	wbqzu	23	Here is C# version	2014-12-10 11:49:14		
2235	plapd	23		2014-12-10 11:49:14		
2236	cfzie	23		2014-12-10 11:49:14		
2237	jippy	23		2014-12-10 11:49:14		
2238	fowai	23		2014-12-10 11:49:14		
2239	eucmc	24		2014-12-10 11:49:17		
2240	mrjku	24		2014-12-10 11:49:17		
2241	bexbp	24	Here is my program  package com.test;  import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator;  public class TestMe {  public static void main(String[] args) {  ArrayList<Integer> list = getInput();  HashMap<Integer, Integer> map = new HashMap<>();  Iterator<Integer> iterator = list.iterator();  int count = 0; int maxCount = 0;  while (iterator.hasNext()) { Integer key = iterator.next();  if (!map.containsKey(key)) { map.put(key, 1); count ++; } else { //count--; }  if (count > maxCount) { maxCount = count; } }  System.out.println("----------Max Length is ---------->" + maxCount);  }    private static ArrayList<Integer> getInput() { ArrayList<Integer> list = new ArrayList<>(); list.add(1); list.add(2); list.add(1); list.add(2); list.add(3); list.add(1); list.add(2); return list; }  }	2014-12-10 11:49:17		
2242	nhibd	24	Here is my working program	2014-12-10 11:49:17		
2243	bjsiw	24		2014-12-10 11:49:17		
2244	huiqq	24		2014-12-10 11:49:17		
2245	ewigy	24	There is no need to consume O(n) space by using hashtable. Use fixed size array instead as characters are limited.	2014-12-10 11:49:17		
2246	krxlv	24		2014-12-10 11:49:17		
2247	sgiwy	24		2014-12-10 11:49:17		
2248	ftfck	24	This is not working for some example. There is a bug!	2014-12-10 11:49:17		
2249	plapd	24		2014-12-10 11:49:17		
2250	rrmeu	24		2014-12-10 11:49:17		
2251	mrjku	24	import java.util.LinkedHashSet; import java.util.LinkedList; import java.util.List; import java.util.Set; public class MaxSubString { public static void main(String[] args) { Set<Character> subList = new LinkedHashSet<Character>(); List<Set<Character>> subStrList = new LinkedList<Set<Character>>(); String myStr = "abcdeavbcseabcdeabcsecser"; char[] myStrArray = myStr.toCharArray(); for (char ch : myStrArray) { if (!subList.add(ch)) { subStrList.add(subList); subList = new LinkedHashSet<Character>(); subList.add(ch); } } subStrList.add(subList); System.out.println("Max Length:" + getMaxSubStrLength(subStrList)); }  static int getMaxSubStrLength(List<Set<Character>> subStrList) { int lenth = 0; Set<Character> maxSubSet = null; for (Set<Character> subSet : subStrList) { if (subSet.size() > lenth) { maxSubSet = subSet; lenth = subSet.size(); } for (Character ch : subSet) { System.out.print(ch); } System.out.println(); } return maxSubSet.size(); } }	2014-12-10 11:49:17		
2252	bexbp	24	@techpanja I think your code wont work on "abcba", it returns abcb which is wrong, answer should be "abc".	2014-12-10 11:49:17		
2253	fmzze	24	O(1) space O(n) time solution  1. Scan the string from left to right and keep an array for saving position a character last encountered during the scan. 2. While scanning before updating the lastSeen array check if the character already encountered in the current scan so far. 3. If the character was not encountered that means you can add this to the longest SubString found so far. 4. Otherwise the character already encountered in the current scan which means we have encountered a duplicate. So, we ignore the substring from beginning to this position as this makes the future sequence containing duplicates. 5. While calculating longest substring so far encountered keep the tracking for absolute longest one.	2014-12-10 11:49:17		
2254	ewigy	24		2014-12-10 11:49:17		
2255	jippy	24		2014-12-10 11:49:17		
2256	ufdxg	24		2014-12-10 11:49:17		
2257	ewigy	24		2014-12-10 11:49:17		
2258	cfzie	24	Ajeet, why you fill up the careercup posting by separating all over? It is annoy people.  -Guest DS	2014-12-10 11:49:17		
2259	tenuw	24	Yea dude, i also realized that ... actually editing feature has been removed from careercup, so i re-posted it after formatting.  No option to remove junk\wrong one ... :(	2014-12-10 11:49:17		
2260	wbqzu	24	Similar to windowing solutions suggested in this thread, but a little better then them.  The idea is we do not need to move back the window to previous location of duplicate found in current window. Rather, we can continue from current location without ever moving back. Hence, can attain O(n) in true sense. This is on the lines of Knuth-Pratt-Morris algo.	2014-12-10 11:49:17		
2261	fowai	24		2014-12-10 11:49:17		
2262	fowai	24		2014-12-10 11:49:18		
2263	zeice	24	@mindless monk I did not get ur point ..."Hence, can attain O(n) in true sense. " Above solution is also O(N) .. we are not moving back, we are using previous index just for size of window.  Can you explain how is ur solution .. O(N) ... in true sense or with true sense... ? In each iteration you are searching a location in map.	2014-12-10 11:49:18		
2264	admin	24	@Ajeet  Lets consider this example. String: abcdaefgh  Method suggested by you: after finding duplicate 'a' at position 4, you start comparisons from b  My suggestion: You do not have to traverse b,c,d again  What you pointed about searching in map, is true. My solution does require you to traverse the map. But even your solution need to call clear on map. So, eventually you are also traversing the map and freeing the memory.	2014-12-10 11:49:18		
2265	bjsiw	24	@mindless monk  I tried to figure out the logc. However, i am not sure if i understand the meaning of	2014-12-10 11:49:18		
2266	rrmeu	24		2014-12-10 11:49:18		
2267	dgjji	24		2014-12-10 11:49:18		
2268	zeice	24	Following is an example, i tired the logic with.  Input - "bcacbbd"  (b) b -> 0 ; cur = 1 ; (c) max = 1 ; cur = 1 ; cur = 2 ; c -> 1 (a) max = 2 ; cur = 2 ; cur = 3 ; a -> 2 (c) max = 3 ; (pos = 1, erase(b), erase(c)) ; cur = 1 ; cur = 2 ; c -> 3 (b) cur = 2 ; cur = 3 ; b -> 4 (b) cur = 4 ; b -> 5 (d) max = 4 ; .... (incorrect)  Let me know what am i doing wrong.	2014-12-10 11:49:18		
2269	fowai	24	@mindless monk Ohhk i got your confusion . Just forgot this line:  "If an duplicate occurs than I just move start position to previous index of this character(Hash table has previous index)".  Editing feature is not available so i cant remove it . It was before modification in my algo. Just follow java implementation and visual representation.  "start pointer is never used to compare. It is "i"."And as you can see we never go back with "i". Just try visual representation of this algo .. i posted it using ... AABC".	2014-12-10 11:49:18		
2270	fmzze	24	You don't actually need to remove anything from the map. Just keep an index to track the starting position of the current substring and update the map with the last seen index of each character. Now that's true O(n).	2014-12-10 11:49:18		
2271	azmjc	24	public static int maxSizeNoDups(String s) {  int maxSize = 0;   for (int i = 0; i < s.length(); i++) { int currentSize = 0;  for (int j = i; j < s.length(); j++) { if (j != i) { if (s.substring(i, j).contains("" + s.charAt(j))) break; } currentSize++; maxSize = maxSize > currentSize ? maxSize : currentSize;  } }  return maxSize; }	2014-12-10 11:49:18		
2272	vanul	24		2014-12-10 11:49:18		
2273	ethan	24		2014-12-10 11:49:18		
2274	gilit	24	A simple O(n2) solution:	2014-12-10 11:49:18		
2275	bjsiw	24		2014-12-10 11:49:18		
2276	mrjku	24		2014-12-10 11:49:18		
2277	nhibd	24	Now an O(n) time + O(n) space	2014-12-10 11:49:18		
2278	dkebi	24		2014-12-10 11:49:18		
2279	gilit	24		2014-12-10 11:49:19		
2280	bexbp	24		2014-12-10 11:49:19		
2281	plapd	24		2014-12-10 11:49:19		
2282	dgjji	24	if input string is efabcah123456..then it will not print largest string bcah123456..so hare is bug in this code.	2014-12-10 11:49:19		
2283	qywrh	24		2014-12-10 11:49:19		
2284	wbqzu	24		2014-12-10 11:49:19		
2285	bexbp	24	Java solution with O(N) run time and O(1) space complexity.	2014-12-10 11:49:19		
2286	fowai	24		2014-12-10 11:49:19		
2287	ufdxg	24		2014-12-10 11:49:19		
2288	cfzie	24	My solution, time complexity O(N) space O(1):	2014-12-10 11:49:19		
2289	admin	24		2014-12-10 11:49:19		
2290	gilit	24		2014-12-10 11:49:19		
2291	sqzqo	24	oops !! duplicate, my bad.	2014-12-10 11:49:19		
2292	rdfeo	24	I think you need to reset the flags array whenever the beginOffset is reset to i. Take an example string of "BAABCdefghhijkl"	2014-12-10 11:49:19		
2293	ethan	24	Modified version of your code.	2014-12-10 11:49:19		
2294	bjsiw	24		2014-12-10 11:49:19		
2295	azmjc	24		2014-12-10 11:49:19		
2296	ewigy	24		2014-12-10 11:49:19		
2297	rdfeo	24		2014-12-10 11:49:19		
2298	nhibd	24	here is the output : s : s ss : s sas : sa ABCDEBFTR : CDEBFTR abcdefghijklmnopqrstuvwxyz : abcdefghijklmnopqrstuvwxyz abcdeffffffffghijklmnopq : fghijklmnopq abcdefcbhjklm : defcbhjklm	2014-12-10 11:49:19		
2299	jippy	24	all these O(1) space, O(strlen) time solutions.... Wow!  Now waiting for O(1) time and space solutions to be posted :P	2014-12-10 11:49:19		
2300	eucmc	24	If the characters are a-z, then O(1) space algorithms exist.  ############# Go away, troll. ###############	2014-12-10 11:49:19		
2301	dgjji	24	I never said they don't exist. "Uruk hai" is not me btw.  bigO notation is a total mess in the comp sci community to begin with. I would like to start a movement to clean it up, firstly by subscripting the O, theta, omega with the variables under consideration always when stating bounds.  So technically, if we consider bigO with _no_ subscripts pertaining to encoding size or alphabet size, then yes there are apparently O(1) space algorithms posted on this thread. Correct.  That is what my post you are responding to you hinted at. Not everyone's bigO is the same. But of course you knew that because you are an ultimate dumbass.  --------------  An important side note: For these problem usually it is implicit that O, theta, omega consider (are subscripted to consider) encoding size and/or alphabet size.  One very simple reason for this is because these algorithms start off declaring arrays that depend on such things, and such things _can_ vary in size, so excluding these as variables seems unnatural. Another reason is that in some sense string based questions automatically force us, when designing these algorithms you are talking about, to consider these variables. So it would seem unwise to not subscript the O with encoding size and alphabet size.  ------ Side side note: You are too dumb to have practiced to become a dumbass. There has to be more to it.	2014-12-10 11:49:19		
2302	dgjji	24	In other words, to dumb it down more for Subbu and/or Subbu's fan above:  O(1) , Omega(1), Theta(1) are technically meaningless. What is 1 a function of?  For that matter, what is O(n) ? Normally this means something like O(f(n)) where f(n) = n. But it could also mean we are considering a function of multiple variables and the bounds being spoken of only depends on one variable (n). Something like, O( f(n,m) ) where f(n,m) = n.  -------  For old time's sake:  "DO THIS ALGORITHM IN O(1) #### AMAZON WILL ASK ### BEST LOGIC ONLY LET'S SEE WHO GET THE O(1)"	2014-12-10 11:49:19		
2303	huiqq	24	@Urik. Dumbass.  Have you heard of the unit cost word ram model of computation? If not, go away. If you have indeed heard of it, you are an even bigger idiot than your posts imply.  ################# WHAT A MORON ##########################	2014-12-10 11:49:19		
2304	bexbp	24	No it is cache oblivious model of computation. Subbu is level 1 troll. Nothing compred to Anonymous.	2014-12-10 11:49:19		
2305	dkebi	24	@Oblivious anon/Urik/TrollCity:  LOL. You really are clueless, with a very high opinion of yourself. Dipshit.  A cache-oblivious algorithm is essentially a RAM algorithm.  Assuming 8 bit characters, we can in fact, give an O(1) algorithm.  ############ WHAT A FUCKING IDIOT ######################	2014-12-10 11:49:19		
2306	dkebi	24	i didn't disagree with you on the O(1) and i'm not uruk hai and i'm wasn't talking to you about any computational models , nor do I care about ram or cache here	2014-12-10 11:49:19		
2307	azmjc	24		2014-12-10 11:49:19		
2308	azmjc	24		2014-12-10 11:49:19		
2309	vanul	24	Yes, one _can_ consider above as O(1) storage. The storage size is compile time fixed so we can subscript it "off" (i.e., remove it as a variable) from the O notation... sure.	2014-12-10 11:49:19		
2310	mrjku	24	@u. Apologies for the identity mistake.  You do need to have an underlying model in mind, before talking about complexity (time/space).  Typically, when the model is not mentioned, the standard assumption is the unit cost word RAM model.  So if you are given a string of length n, the input size is n (n words).  So O(1), O(n^2) etc all make sense.  If you do not have a underlying model in mind, then talking about complexity is nonsense.	2014-12-10 11:49:20		
2311	wbqzu	24		2014-12-10 11:49:20		
2312	vanul	24		2014-12-10 11:49:20		
2313	tenuw	24	Requirement: 1. Find Max size of substring with no duplicates. 2. No need to find the substring, just its length. Have verified with this source string "asdfabb12345hh123456789hh" result=10, pretty much covers boundry conditions. How this works ?	2014-12-10 11:49:20		
2314	jippy	24		2014-12-10 11:49:20		
2315	vanul	24		2014-12-10 11:49:20		
2316	fmzze	24	My updated code, Requirement: 1. Find Max size of substring with no duplicates. 2. No need to find the substring, just its length. Have verified with this source string "asdfabb12345hh123456789hh" result=10, pretty much covers boundry conditions. How this works ?	2014-12-10 11:49:20		
2317	wbqzu	24		2014-12-10 11:49:20		
2318	eucmc	24		2014-12-10 11:49:20		
2319	zeice	24		2014-12-10 11:49:20		
2320	qywrh	24		2014-12-10 11:49:20		
2321	ufdxg	24	My solution:  public static int maxSize(String S){  int len = 0; int maxLen = 1; HashMap<Character, Integer> theMap = new HashMap<Character, Integer>();  for(int i=0; i < S.length(); i++){  if(theMap.containsKey(S.charAt(i))){ if(maxLen < len){ maxLen = len; } theMap.clear(); len=0; } else{ theMap.put(S.charAt(i), 1); len++; }  }  if(maxLen < len){ maxLen = len; }  return maxLen; }	2014-12-10 11:49:20		
2322	admin	24		2014-12-10 11:49:20		
2323	mrjku	24		2014-12-10 11:49:20		
2324	zeice	24	Here is my working code. It works for all the strings given above in comments.   public class DupCheck {    public static void main(String args[]) { int count=0; String name = "efabcah123456"; boolean duplicate = false; int currentLength = 0; int minIndex = 0; int maxIndex = 0; int maxLength = 0; int currentIndex = 0; String stringChars = "";  name = name.trim().toLowerCase();  System.out.println("Length = "+stringChars.length());  while(count<name.length()) {  for(int charCount = 0; charCount < stringChars.length();charCount++) { if(stringChars.charAt(charCount) == name.charAt(count)) { duplicate = true; System.out.println("Duplicate char "+name.charAt(count)+" at pos "+(count+1)); break; } }  if(!duplicate) { stringChars += name.charAt(count); System.out.println("String is "+stringChars);  if(stringChars.length() > (maxIndex-minIndex)) { maxIndex = currentIndex+stringChars.length(); minIndex = currentIndex; }   count++; } else { count = currentIndex+1; maxLength = currentLength;  if(stringChars.length() > (maxIndex - minIndex)) { maxIndex = currentIndex+stringChars.length(); minIndex = currentIndex; }  currentLength = 0; currentIndex = currentIndex+1;  duplicate = false; stringChars = "";  }    } System.out.println("Sub string with no duplicate letters is "+name.substring(minIndex,maxIndex));  System.out.println("Length of sub string is " + (maxIndex-minIndex)); } }	2014-12-10 11:49:20		
2325	admin	24	public class MaxSubStringNoDuplicate { public static void main(String[] args) { Scanner sc = new Scanner(System.in);  System.out.println("Ener String"); String str = sc.nextLine(); int limit = 0; char[] ch ; ch = str.toCharArray();   for(int i =0;i<ch.length-1;i++){ for(int l=i+1;l>0;l--){ if(l!=0){ if(ch[l-1]==ch[i+1]) limit = i;  } }  }  System.out.print("Max SubString Wih No Duplicates "); System.out.println(str.substring(0,limit+1));   }     }	2014-12-10 11:49:20		
2326	dgjji	24	net. solution	2014-12-10 11:49:20		
2327	ewigy	24		2014-12-10 11:49:20		
2328	sgiwy	24		2014-12-10 11:49:20		
2329	eucmc	24		2014-12-10 11:49:20		
2330	admin	24		2014-12-10 11:49:20		
2331	tenuw	24	C++ version.	2014-12-10 11:49:20		
2332	ethan	24		2014-12-10 11:49:20		
2333	ufdxg	24		2014-12-10 11:49:20		
2334	ftfck	24	Here is my solution: -- Java version.	2014-12-10 11:49:20		
2335	nwkeg	24		2014-12-10 11:49:20		
2336	dkebi	24		2014-12-10 11:49:20		
2337	gilit	24	Construct a suffix tree. Find the longest path in the suffix tree that doesn't have any overlap in characters.  For example ababc  Null / | \ c b ab / \ / \ abc c abc c we can see that the last path yields abc our req soln. There are good O(n) ways to construct suffix tree.	2014-12-10 11:49:20		
2338	rdfeo	24	Recursive approach	2014-12-10 11:49:20		
2339	sgiwy	24		2014-12-10 11:49:20		
2340	jippy	24		2014-12-10 11:49:21		
2341	wbqzu	24		2014-12-10 11:49:21		
2342	nwkeg	24		2014-12-10 11:49:21		
2343	dkebi	24		2014-12-10 11:49:21		
2344	bexbp	24		2014-12-10 11:49:21		
2345	azmjc	24	Solution with O(n) complexity and without Hash Map. This solution assumes that the string is comprised of only 'a-z' in lower case only. (But the solution can be extended for supporting other literals as well) Hope this helps.	2014-12-10 11:49:21		
2346	azmjc	24		2014-12-10 11:49:21		
2347	ufdxg	24		2014-12-10 11:49:21		
2348	bexbp	24	Solution with simple PHP	2014-12-10 11:49:21		
2349	plapd	24		2014-12-10 11:49:21		
2350	vanul	24		2014-12-10 11:49:21		
2351	xhgls	24		2014-12-10 11:49:21		
2352	huiqq	24		2014-12-10 11:49:21		
2353	eucmc	24	}	2014-12-10 11:49:21		
2354	eucmc	24	public static void main(String[] args) { String source = "abacaimbuaposwggytelcbpenvyr"; PriorityQueue<String> longestQueue = new PriorityQueue<String>(5, new Comparator<String>() { public int compare(String o1, String o2) { return o2.length()-o1.length(); } });  String sb = new String(); for (int i=0; i<source.length(); i++) { char ch = source.charAt(i); int positionOfChar = sb.indexOf(String.valueOf(ch)); if (positionOfChar<0) { sb = sb + ch; } else { longestQueue.add(sb); sb = sb.substring(positionOfChar+1)+ch; } } System.out.println(longestQueue.poll()); }	2014-12-10 11:49:21		
2355	jippy	24		2014-12-10 11:49:21		
2356	qywrh	24		2014-12-10 11:49:21		
2357	ewigy	24	#include<stdio.h> #include<string.h> #include<stdlib.h> main() { int t; scanf("%d",&t); while(t--){ char c[100001],ar[100001];int l,i,j,pos=-1,cnt=1,cur=1,max=1,x; scanf("%s",c);fflush(stdin); ar[0]=c[0]; l=strlen(c); for(i=1;i<l;i++) { x=0; for(j=pos+1;j<cnt;j++) { if(c[i]!=ar[j]) x++; else if(c[i]==ar[j]) pos=j; } if(x==cnt) { ar[cnt++]=c[i]; cur=cnt; } else { ar[cnt++]=c[i]; if(cur<cnt-(pos+1)) { cur=cnt-(pos+1); } } if(max<cur) { max=cur; } } printf("%d\n",max); } }	2014-12-10 11:49:21		
2358	tenuw	24	#include<stdio.h> #include<string.h> #include<stdlib.h> main() { int t; scanf("%d",&t); while(t--){ char c[100001],ar[100001];int l,i,j,pos=-1,cnt=1,cur=1,max=1,x; scanf("%s",c);fflush(stdin); ar[0]=c[0]; l=strlen(c); for(i=1;i<l;i++) { x=0; for(j=pos+1;j<cnt;j++) { if(c[i]!=ar[j]) x++; else if(c[i]==ar[j]) pos=j; } if(x==cnt) { ar[cnt++]=c[i]; cur=cnt; } else { ar[cnt++]=c[i]; if(cur<cnt-(pos+1)) { cur=cnt-(pos+1); } } if(max<cur) { max=cur; } } printf("%d\n",max); } }	2014-12-10 11:49:21		
2359	xhgls	24	Modify Kadane's algo to keep track of unique chars instead of sums. Have a max_so_far variable with the longest substring found and the variables which hold the indexes. Have another variable max_current and another 2 variables for indexes. Iterate over the array and update the max_current variable. Once you hit a duplicate if max_current is greater than max_so_far update max_so_far and the indexes and clear max_current. Time complexity O(N) space complexity O(1).	2014-12-10 11:49:21		
2360	nwkeg	24	Interesting if possible. Pseudocode for bigO (1) space alg?	2014-12-10 11:49:21		
2361	sqzqo	24	how you know a character is duplicate with o(1) space complexity? You actually need a hash to store the last seen index for each character and that's O(n) space. Alternatively you could traverse the current substring but that would make the time complexity O(n^2). It's a trade off you can not avoid.	2014-12-10 11:49:21		
2362	nwkeg	24	Cool name uruk !	2014-12-10 11:49:21		
2363	huiqq	24	Uruk is right, space complexity is actually O(n)	2014-12-10 11:49:21		
2364	xhgls	24	Agree. with uruk	2014-12-10 11:49:21		
2365	mrjku	24	Ajeet do it below O(n) but his code separating all over. But it is good codes.  -Guest DS	2014-12-10 11:49:21		
2366	fmzze	24		2014-12-10 11:49:21		
2367	tenuw	24		2014-12-10 11:49:21		
2368	dgjji	24	Visualization: Iteration 0: ------------ | "AABC" window = 0; sart =0; i = 0  Iteration 1: ------------- | "AABC" window = 1; (1 -0) start = 1; duplicate occurs so move it i = 1  Iteration 2: ------------- | "AABC" window = 1; start = 1; i = 2  Iteration 3: ------------- | "AABC" window = 3; (i - start) +1 start = 1; i = 3 // we are reaching end of string so check for last	2014-12-10 11:49:21		
2369	sqzqo	24	@Ajeet -> Why are you clearing the whole map on finding a duplicate character ? Eg : IF the string is "abac" . Then the expected o/p is "3" (string "bac").	2014-12-10 11:49:21		
2370	plapd	24	Your prog does not work for this input :  ABCDEBFRT (ans shud be 7 it gives 5)	2014-12-10 11:49:21		
2371	rdfeo	24	Your prog wont work for this case :  ABCDEBFTR  Solutions : Inside if loop when key is matched, start=i should be replaced with -  start = map.get(source.charAt(i))+1;	2014-12-10 11:49:21		
2372	bexbp	24	Thanks Alok. Yes it should be map.get(source.charAt(i))+1.	2014-12-10 11:49:21		
2373	fowai	24	Sorry ... it should be .. start = map.get(source.charAt(i)) + 1;	2014-12-10 11:49:22		
2374	eucmc	24	@Anonymous Yes it will work with out map.clear(). I was using this statement to reduce space allocation.	2014-12-10 11:49:22		
2375	zeice	24	After modification ..	2014-12-10 11:49:22		
2376	plapd	24		2014-12-10 11:49:22		
2377	zeice	24		2014-12-10 11:49:22		
2378	bexbp	24	Ajeet d u m p a s s ruin the whole cracking careercup.  MORON.	2014-12-10 11:49:22		
2379	nwkeg	24	@Ajeet what does O(size of window) mean? how size of the window is related to N? right, it's max N, means space complexity is O(N), and your attempt to decrease memory footprint looks funny taking into account it doesn't improve anything O-wise.	2014-12-10 11:49:22		
2380	nhibd	25	The key here is to use a heap (aka priority queue). Start with number 1 and add it to the heap. Then, do a loop a) Pop the minimum value from the heap b) Print this minimum c) Add minimum*2, *3, *5 and *7 to the heap  If we want N numbers, the complexity will be O(N log N). Note that since i,j,k,l >=0, the first number should be 1, not 2.	2014-12-10 11:49:23		
2381	ufdxg	25	Simply rocks! :)	2014-12-10 11:49:23		
2382	xhgls	25	+1	2014-12-10 11:49:23		
2383	fmzze	25	how to deal with when duplicate values arrives.. like 2*5,5*2,4*3,3*4.....?? also the series should be 2,3,4,5.....(4 is missing)	2014-12-10 11:49:23		
2384	ethan	25	To deal with duplicates, you can use a hash table. About the missing 4, it should be a mistake. 4 must be in the sequence (note that 8 is there)	2014-12-10 11:49:23		
2385	cfzie	25	Does this solution have a space complexity of 4^N?	2014-12-10 11:49:23		
2386	ethan	25	Why 4^N? It's O(N), this is a sample implementation for small values. Note that we ignore repeated values and we could also ignore values to the heap when we already have N values in the heap.	2014-12-10 11:49:23		
2387	ethan	25		2014-12-10 11:49:23		
2388	vanul	25		2014-12-10 11:49:23		
2389	xhgls	25	Yah Sorry wasn't thinking, its 4*N space. Awesome solution :)	2014-12-10 11:49:23		
2390	nhibd	25	Although this solution is easier to understand, vgeek's solution is O(N), thus better than this one.	2014-12-10 11:49:23		
2391	mrjku	25	This can be done in O(n). Will post my algo, when I will be free.	2014-12-10 11:49:23		
2392	gilit	25	@Miguel: Using this solution we will never get 22, 44 etc. But these numbers can be obtained from equation putting i = 11 and rest 0	2014-12-10 11:49:23		
2393	krxlv	25	if i=11 then 2^11 = 2048 not 22	2014-12-10 11:49:23		
2394	azmjc	25	This does not seem to be correct, according to this algorithm, the output will be: 1, 2, 3, 5, 7, 4, 6 10, 14, 9, 15 21... instead of: 1, 2, 3, 4, 5, 6, 7, 8....	2014-12-10 11:49:23		
2395	rrmeu	25	it's a heap (priority queue), not a queue. The heap will get the minimum value, not the FIFO order	2014-12-10 11:49:23		
2396	gilit	25	As we need to remove duplicates, a BST could serve better than heap: no need for the additional hash table. And still O(N log N). On the other hand, BST uses pointers and can't be stored in an array like a heap.  Also, we can't stop when we have N items in the tree - e.g. say N=4, the tree would contain 2, 3, 5, 7 after the first round. We must keep adding until we output all N items.	2014-12-10 11:49:23		
2397	gilit	25	this sol. applies for 2^x * 3^x * 5^x * 7^x  so your ans. set should be incomplete	2014-12-10 11:49:23		
2398	rdfeo	25	(y)	2014-12-10 11:49:23		
2399	jippy	25	explicitly avoid duplicate (according to the CTCI book)	2014-12-10 11:49:24		
2400	qywrh	25		2014-12-10 11:49:24		
2401	jippy	25		2014-12-10 11:49:24		
2402	vanul	25	Miguel Oliveira's is not optimized. it should be done in O(N) vgeek's is O(N)	2014-12-10 11:49:24		
2403	fowai	25	These are basically referred to as ugly numbers . Here is the code for it: a. Take variables for multiples of 2,3,5,7. b. Everytime find a minimum of the multiple. c. Store 1 in the first index as it is multiple of all. d. Find the minimum of all the multiples of 2,3,5,7. Whenever that minimum is equal to any of the multiples. Store that multiple in the indexes assigned for 2,3,5,7 and also multiply that element with the number to get the next higher multiple in next iteration.	2014-12-10 11:49:24		
2404	qywrh	25		2014-12-10 11:49:24		
2405	wbqzu	25		2014-12-10 11:49:24		
2406	bjsiw	25	very good solution!! +1	2014-12-10 11:49:24		
2407	wbqzu	25	@vgeek  I doubt the correctness of your algorithm. Could you please clarify if your procedure takes care of producing numbers that are multiples of a subset of powers of 2,3,5 & 7. For ex: will you algorithm be able to generate 2^2 * 3^2 * 5^2 * 7^2?	2014-12-10 11:49:24		
2408	zeice	25	yes, this algo generating below cases  2^2 * 3^2 * 5^2 * 7^2 -> 44100 2^1 * 3^2 * 5^2 * 7^2 -> 22050	2014-12-10 11:49:24		
2409	qywrh	25	This is an ugly number problem, and vgeek's solution is better. Miguel Oliveira 's solution is very easy to understand, but waste of space for the numbers which are currently not used, and increased the corresponding time on PUSH operation.	2014-12-10 11:49:24		
2410	jippy	25	this is sooo clever!	2014-12-10 11:49:24		
2411	jippy	25	1) it is very hard to argue about the correctness of this, because e.g. the number 11 will be missing ;)	2014-12-10 11:49:24		
2412	rrmeu	25	my mistake :) forget it	2014-12-10 11:49:24		
2413	nhibd	25		2014-12-10 11:49:24		
2414	plapd	25		2014-12-10 11:49:24		
2415	fmzze	25	This should do it in python.	2014-12-10 11:49:24		
2416	nwkeg	25	I ran that in Python and it did not generate 8 (i,j,k,l){3,0,0,0} or 12 (i,j,k,l){2,1,0,0} which should be part of the list of numbers generated.	2014-12-10 11:49:24		
2417	dgjji	25	below numbers can't be generated using this formula  1. all PRIME numbers that are greater than 7 2: all numbers that are divisible by PRIME numbers greater than 7  numbers excluding from above two cases can be generated	2014-12-10 11:49:24		
2418	ewigy	25	so in this question 2^i * 3^j * 5^k * 7^l  should mean 2 to the power of i multiplied by 3 to the power of j and so on.. thus for i=1,j=1,k=1,l=1 shouldnt the first number be 2*3*5*7 = 210 ?	2014-12-10 11:49:24		
2419	rdfeo	25	exponents >= 0, not >= 1	2014-12-10 11:49:24		
2420	qywrh	25	so even if exponents are 0, the first number would be 1 followed by 210 !! The sequence 2,3,5,6,7,8,9. seems incorrect to me !!	2014-12-10 11:49:24		
2421	mrjku	25	those 4 letters i,j,k and l mean that the exponents don't need to have the same value 2 = 2^1 * 3^0 * 5^0 * 7^0 3 = 2^0 * 3^1 * 5^0 * 7^0 4 = 2^2 * 3^0 * 5^0 * 7^0 etc Rohit made some mistakes, 1 and 4 are missing from the sequence	2014-12-10 11:49:24		
2422	cfzie	25	Thanks that was very helpful	2014-12-10 11:49:24		
2423	wbqzu	25	For the heap solution, please use java's BigInteger since numbers will get bigger for higher exponents.	2014-12-10 11:49:24		
2424	rdfeo	25	this should print out all the nos. whose only prime factors are 2,3,5 or 7. We will print out 1 by default. We should try to reduce a number to 1 by dividing it with different powers of 2,3,5 and 7. if the number reduces to 1 then print it out.  std::cout << 1 << " "; size_t n = 2;  void reduce( size_t& num, size_t divisor ) { while( num % divisor == 0 ) num /= divisor; }  int main() { std::cout << 1 << std::endl; size_t num = 2; while( true ) { num = reduce( num, 2 ); num = reduce( num, 3 ); num = reduce( num, 5 ); num = reduce( num, 7 ); if( num == 1 ) std::cout << num << std::endl; num++; } }  complexity: O(N)	2014-12-10 11:49:24		
2425	plapd	25	this is not complexity O(N). It is still O(NlogN). The logN comes from your reduce function.	2014-12-10 11:49:24		
2426	qywrh	25	For anybody that is interested, this question is very, very similar (and requires a nearly identical solution) to question 7.7 in Cracking the Coding Interview 5th ed.  "Design an algorithm to find the kth number such that the only prime factors are 3, 5, and 7."	2014-12-10 11:49:24		
2427	wbqzu	25	Here's a dynamic programming approach that I think does it in O(n) with a memory space of ~N.	2014-12-10 11:49:24		
2428	eucmc	25		2014-12-10 11:49:24		
2429	mrjku	25		2014-12-10 11:49:25		
2430	xhgls	25	you're mixing 2 different Ns: the n-th number we want and the magnitude (say M) of this number. While the above approaches state the time complexity in terms of "n". Your algorithm is O(M)	2014-12-10 11:49:25		
2431	qywrh	25	Miguel, you are right.  I'm a little hazy on big O notation, but with the constraints of the problem, I think it's still O(n).  To fix this solution, you could let M = 2*N (since 2 is one of the factors, it's not going to use more than 2*N space), then use M for the array length. At the end, you'd have to count how many numbers you had printed and stop when you'd printed the appropriate amount.  Because M is a fixed multiple of N, I believe you can still call it O(N).	2014-12-10 11:49:25		
2432	bexbp	25	Nevermind, I miscalculated. Using the logic above, it'd be exponential space, M=2^N.	2014-12-10 11:49:25		
2433	ethan	25	N = 1000, answer = 385875 N = 2000, answer = 7077888 N = 3000, answer = 50176000 N = 4000, answer = 228614400  This is clearly an exponential growth..	2014-12-10 11:49:25		
2434	azmjc	25	My idea is same as Miguel Oliveira's, and the time complexity is O(nlogn), here is my code:	2014-12-10 11:49:25		
2435	tenuw	25		2014-12-10 11:49:25		
2436	zeice	25		2014-12-10 11:49:25		
2437	gilit	25	Not going in to time complexity, this is how i wrote the program.	2014-12-10 11:49:25		
2438	gilit	25		2014-12-10 11:49:25		
2439	admin	25		2014-12-10 11:49:25		
2440	azmjc	25	its while(i>1 && .... not sure why it printed ; after i>	2014-12-10 11:49:25		
2441	huiqq	25	Any number that conforms to this formula is a number that is divisible by 2 or 3 or 5 or 7. So just loop over the integers and check if any is divisible by 2,3,5 or 7.	2014-12-10 11:49:25		
2442	fowai	25		2014-12-10 11:49:25		
2443	ufdxg	25		2014-12-10 11:49:25		
2444	azmjc	25	public class Solution{  public ArrayList<Integer> sortedOrder(int len){  PriorityQueue<Word> qe = new PriorityQueue<Word>(2*len , Word.com ); ArrayList<Integer> res = new ArrayList<Integer> (); qe.add(new Word(2,2)); qe.add(new Word(3,3)); qe.add(new Word(5,5)); qe.add(new Word(7,7)); int k = 0; while( k < len ){ k++; Word t = qe.poll(); res.add(t.val); switch( t.calss ){ case 2: qe.add(new Word(2,2 * t.val)); qe.add(new Word(3,3* t.val)); qe.add(new Word(5,5* t.val)); qe.add(new Word(7,7* t.val)); break;  case 3: qe.add(new Word(3,3* t.val)); qe.add(new Word(5,5* t.val)); qe.add(new Word(7,7* t.val)); break; case 5:  qe.add(new Word(5,5* t.val)); qe.add(new Word(7,7* t.val)); break; case 7: qe.add(new Word(7,7* t.val)); break; } } return res; } }  public class Word{ int class; int val; public Word(int cla, int v) { class = cla; val = v; }  public static Comparator<Word> com = new Comparator<Word>(){ @override public int compare(Word a , Word b){ if(a.val > b.val ) return 1; if(a.val < b.val ) return -1; return 0; } } }	2014-12-10 11:49:25		
2445	admin	25	why dont we simply take a loop over numbers and for any no see whether it is divisible by the combination of the given number. if it is then it can be generated else not..	2014-12-10 11:49:25		
2446	ftfck	25	that approach is much slower	2014-12-10 11:49:25		
2447	tenuw	25	think we should use four queues, initialy each queue has only one num 2,3,5,7,we name them q2,q3,q5and q7 then we compare the top of the four queues to get the min, and if min is from q2, then we add *2 to q2, and the *min to q3 q5andq7, if min is from q3, we only add *3 to q3 and the *min to q5 and q7, etc to avoid duplicates  for instance 2 2*2 3 3*2 5 5*2 7 7*2 then 3 is min so 2 2*2 3 3*2 3*3 5 5*2 5*3 7 7*2 7*3 then 4 from q2 is min so 2 2*2 4*2 3 3*2 3*3 3*4 5 5*2 5*3 5*4 7 7*2 7*3 7*4 etc	2014-12-10 11:49:25		
2448	fmzze	25	remeber pop when visit one min	2014-12-10 11:49:25		
2449	tenuw	25	The solution is very simple: if a number is divisible by 2, 3, 5 and 7, then that number can be generated by the equation. So, here is the code	2014-12-10 11:49:25		
2450	plapd	25		2014-12-10 11:49:25		
2451	xhgls	25		2014-12-10 11:49:25		
2452	cfzie	25	Question is not clear. Can you please explain the intent with an example or "Miguel Oliveira" can you please help with a pseudo code and a simulation around it please.	2014-12-10 11:49:25		
2453	fowai	25	I assume we should print number 1 as well. For large values, we should use a hash table and be careful with overflow in integers multiplication.	2014-12-10 11:49:25		
2454	qywrh	25		2014-12-10 11:49:25		
2455	xhgls	25		2014-12-10 11:49:25		
2456	fowai	25	Meh, going to have to heap it after all. Coffee first, then code :(  vgeeks algorithm is the best I can come up with. Here it is in Python:	2014-12-10 11:49:25		
2457	vanul	25		2014-12-10 11:49:26		
2458	ethan	25		2014-12-10 11:49:26		
2459	bexbp	25	This is incorrect. It fails with 22 for example - it is divisible by 2 but we can't get it through 2^i * 3^j * 5^k * 7^l This question is about factorization strictly by 2, 3, 5 *and* 7.	2014-12-10 11:49:26		
2460	sgiwy	25		2014-12-10 11:49:26		
2461	nwkeg	26	We check whether there's a substring of b, which has same size and same characters with a.	2014-12-10 11:49:27		
2462	gilit	26		2014-12-10 11:49:27		
2463	vanul	26		2014-12-10 11:49:27		
2464	rrmeu	26	Odd that the good solution is just lying there with 0 votes, but a very bad solution gets 3 net upvotes.	2014-12-10 11:49:28		
2465	cfzie	26	Agreed so why don't you upvote this solution.	2014-12-10 11:49:28		
2466	ethan	26	Anonymous users cannot vote.	2014-12-10 11:49:28		
2467	gilit	26	can you please explain what slide window does? Thanks.	2014-12-10 11:49:28		
2468	cfzie	26	upvoting this one as you are not trying to find all anagrams and then doing a string match which is an extensive process. Good one :)	2014-12-10 11:49:28		
2469	xhgls	26	Let me try to explain the sliding window. We calculate the histogram of string a (length 3). Then we calculate the historgram of the first 3 characters of string b. If it doesn't matches we calculate the histogram of the next set of 3 chars which are at position 1,2,3 and then next 3 which are 2,3,4 etc So it behaves as if we are sliding a windows across the length of string a. Hope it helps.	2014-12-10 11:49:28		
2470	mrjku	26	These cases don't work with this solution ("abcdefg", "abcfedgsfdaf") ("a", "cdsgsdgsa") ("abc", "ccccccabbbbbbb")	2014-12-10 11:49:28		
2471	ftfck	26	targetCount[128] is a nice one.	2014-12-10 11:49:28		
2472	admin	26	hi, what is the time complexity	2014-12-10 11:49:28		
2473	bexbp	26	the complexity is O(|src||target|) take this example target: aab src: aadaadaadaadaab	2014-12-10 11:49:28		
2474	huiqq	26	You can improve this solution. This solution is O(nm), n = lenght of src, m = length of target. We can do this in O(n) time.  In your code above, to check if a substring is an anagram takes O(m). //check if substring is an anagram for(j = 0; j < targetLen; ++j){ if(count[target[j]] != targetCount[target[j]]) break; }  You may do this in O(1) time. Maintain an int variable matchedCount that counts the number of matched characters in current substring(window) and target.  Store target chars in a HashSet to be able to use set.contains() which is O(1).  As you slide the window 1 step to the right, check the following: 1. Decrement matchedCount if the dropped character from the prev window is in target string (use the hashset to query) and if the count of that character after dropping it is now less than its target count. 2.Increment matchedCount if the new character in the new window is in target string (hashset) and if count of that character was less than the targetCount before it was added.  For each iteration (each window), check if matchedCount == target.length() and return true if it is.  Overall time complexity is n * O(1) = O(n)	2014-12-10 11:49:28		
2475	qywrh	26	The suggestion from j is not gone a work. eg. text ="AAABABAA" and pattern="AAAB" when the sub string is "BABA", the matchedCount will become 4 and this is wrong.	2014-12-10 11:49:28		
2476	bjsiw	26	My solution: 1- Sort characters of a 2- For each contiguous-character substring S of length == a.Length in b 2.1- Sort the characters of S 2.2- if S == a, return true 3- return false	2014-12-10 11:49:28		
2477	nwkeg	26		2014-12-10 11:49:28		
2478	dgjji	26		2014-12-10 11:49:28		
2479	huiqq	26	This solution could be improved this way: instead of sorting each substring (line: "Array.Sort(subArray)") as we move the sliding window through the big string, we can just delete one occurrence of the last character of the substring visited in the previous iteration from the current window's string, and insert-sort the character visited on the current iteration in the current window's string. This small part of the algorithm is only O(M) (M being the length of the anagram string), instead of O(MlogM) which is what it takes to sort it each time. I might publish the code later.	2014-12-10 11:49:28		
2480	admin	26	Correct me if I am wrong. Considering length of 'a' as m and 'b' as n, time complexity would be O(n*mlogm) for the naive approach and would be O(n*m) for the @danyluis' approach. This can be reduced to Time:O(n) and space:O(m) if we use hashtable	2014-12-10 11:49:28		
2481	mrjku	26	Below is a code in Java with O(n) time complexity and O(m) space complexity	2014-12-10 11:49:28		
2482	rrmeu	26		2014-12-10 11:49:28		
2483	vanul	26		2014-12-10 11:49:28		
2484	ethan	26	Great! It works just for ASCII though	2014-12-10 11:49:28		
2485	plapd	26	For Yash's solution, I think it will return true even when all characters from a are present in b but are not contiguous. Doesnt substring mean that all characters should be contiguous?	2014-12-10 11:49:28		
2486	rrmeu	26		2014-12-10 11:49:28		
2487	zeice	26		2014-12-10 11:49:28		
2488	ftfck	26	I think Yash's solution time complexity is also O(N*M). Like the below example(I saw somebody's example). target: aab src: aadaadaadaadaab	2014-12-10 11:49:28		
2489	huiqq	26	My algorithm String a; String b; get a.length start traversing b and use substring(i,n) chk for anagram return true if found else increment i till i+n<b.length.  code:	2014-12-10 11:49:28		
2490	azmjc	26		2014-12-10 11:49:28		
2491	bjsiw	26		2014-12-10 11:49:28		
2492	tenuw	26	works but why have written your solution multiple times	2014-12-10 11:49:28		
2493	sgiwy	26	Here's another solution using a sliding window.	2014-12-10 11:49:28		
2494	tenuw	26		2014-12-10 11:49:29		
2495	jippy	26		2014-12-10 11:49:29		
2496	mrjku	26	I like the histogram approach. Did you consider using a HashMap so you could compare histograms faster?	2014-12-10 11:49:29		
2497	plapd	26	Hi: yes! I also thought about doing it with a Dictionary (C#), and I think it would be particularly useful when the alphabet is big. And, also, it wouldn't be more difficult to implement than this solution. Would you be willing to write and post it?	2014-12-10 11:49:29		
2498	nhibd	26		2014-12-10 11:49:29		
2499	sqzqo	26		2014-12-10 11:49:29		
2500	tenuw	26		2014-12-10 11:49:29		
2501	dkebi	26		2014-12-10 11:49:29		
2502	ufdxg	26	This one really works	2014-12-10 11:49:29		
2503	zeice	26	Will this one work...  Search for the occurrence of any character of string a in string b. Let this character be x.  If found, generate all anagrams of string a starting with x and check whether the same pattern is found in string b.  If found return true, else continue finding the next character	2014-12-10 11:49:29		
2504	fowai	26	I am not sure if I am getting your solution right, the time complexity is O(k!n) right ? where k = len(string a) and n = len(string b)	2014-12-10 11:49:29		
2505	nwkeg	26	your solution doesn't handle sol for below mentioned scenario:  String 1: abc  String 2: xncbabkl  As per ur sol: i picked any char from string 1 lets say 'a' and then found all the anagrams starting with 'a':  abc acb  but both of the anagrams are not present in string 2 Your sol is missing checking 'cba' case.	2014-12-10 11:49:29		
2506	tenuw	26	No, my solution asks to look for any character of string a in string b..  From your example: characters in string a = {a,b,c} While traversing string b, it detects character c and then generate two possible combinations - cab, cba and check whether the combinations are present in string b which will be found. So, will return true..  We can maintain the characters of string a in a hashmap so that search will take just O(1) time for each of the characters of string b.	2014-12-10 11:49:29		
2507	nhibd	26	oh ok.... you comment "any character of string a" made to think of this corner case which can be handled easily as you mentioned. nice sol.	2014-12-10 11:49:29		
2508	zeice	26	simply store all characters of string b in hashtable.  Check whether all characters of string a is present in or not?	2014-12-10 11:49:29		
2509	zeice	26	Initialize an array of 26 slots each with the number of times every character appears on string a and then create a copy for such array.  For each character in string b, check if the count on the previously copied array is zero, if so reset the copied array to its original status. Otherwise, decrement the counter and check if all items in the array are now zero, if so, you've found a valid sub-string.  After the for-loop has ended, is safely to assume that no sub-string exists in b.  Time complexity: O(|b|) Space complexity: O(1)	2014-12-10 11:49:29		
2510	jippy	26		2014-12-10 11:49:29		
2511	ewigy	26		2014-12-10 11:49:29		
2512	admin	26	Almost correct. However there is a bug in the code. The worst case time complexity is O(NM) where N is length of search string and M is length of pattern string.  Pattern: aabb Search String : xxbabba When you are on first 'b' of search string, you start comparing aabb to babba and at last 'b' of search string, you will realize that pattern doesn't match (aabb is not anagram of babb), so instead of simply skipping, we need to compare aabb to abba and return true. To optimize, this requires to apply KMP algorithm so we can reduce time complexity from O(NM) to O(N)	2014-12-10 11:49:29		
2513	tenuw	26	your code can be fixed as below	2014-12-10 11:49:29		
2514	fowai	26		2014-12-10 11:49:29		
2515	ufdxg	26		2014-12-10 11:49:29		
2516	jippy	26	@mithya I am not familiar with KMP, but I like what your attempting to do. Resetting the first value that was decremented in the "current_stats" array once you've realized it does not fit in the pattern. Your proposed solution however seems flawed. It appears that the else statement you've added is unreachable. The above code will catch if a value is 0 in the array (and reset), or greater than zero (and decrement it by one). Since no values start at < 0, you will never get to your new code. Also, the current_count variable becomes disjointed with the current_stats array when the increment takes place. This may be by design but if so it's very confusing.	2014-12-10 11:49:29		
2517	fowai	26	Yes, I realized that. The if part will check for -1 instead. Idea is in array 26, default value should be -1, or a large value e.g. strlen(search_string)+1 because  // Check if the character at all belonged into pattern string if (current_stats[search_txt[index] - 'a'] == -1 or large value) { // Reset and continue } else {  }	2014-12-10 11:49:29		
2518	bjsiw	26	@Mithya Thanks for your observation!! You're right, I totally missed that case. Please take a look at this other solution I'm proposing that doesn't require KMP and still achieves O(|b|) time complexity with O(1) space:  The idea is to keep an index of the start of the sub-string initially pointing to zero and while reading the search string from left to right check:  a) If the counter in origin_stats for the current character is zero that means that current element is not part of a valid sub-string and it's safe to reset the current stats. Also, start index of sub-string can be changed to index + 1.  b) Else if the counter in current_stats for the current character has become zero, then we need to either regain a character with the same value along the current sub-string and update the start index so that the solution doesn't include it or forfeit the current sub-string if we weren't able to find one.  c) Else just decrement the counter in current_stats and see if we have already found all required characters (this is unchanged from my previous solution).  Cool thing about this is that we're now able to determine the start of the valid sub-string whenever one exists. Here's the code:	2014-12-10 11:49:29		
2519	ufdxg	26		2014-12-10 11:49:29		
2520	fmzze	26		2014-12-10 11:49:30		
2521	huiqq	26	Nice meh. I would however suggest a quicker reset method. A memcpy would work nice here considering your array is constant size.  Also a quick question for Mithya... Meh's fix would still run in linear time but as it is now O(2b) it is slightly less optimal. Your original attempt at fixing this did not introduce a second loop. You've modified your if statements to check for negative values to determine if the character exists in the patter, but Meh's solution now has a similar check. I'm wondering if you could post a corrected full implementation to show how this could be done without the use of a second loop (if you still believe it is possible). Thanks	2014-12-10 11:49:30		
2522	nhibd	26	what about this?  Get hash of substring we are searching for (in this case "xyz") and search for that hash using Rabin-Karp or any other rolling hash algorithm. So in this case we would be searching for the hash of "xyz" (which would be the same for any anagram of "xyz") in our string.	2014-12-10 11:49:30		
2523	dgjji	26	*EDITED* I don't know much about time complexities and whatnot, but this definitely works!	2014-12-10 11:49:30		
2524	rdfeo	26		2014-12-10 11:49:30		
2525	xhgls	26		2014-12-10 11:49:30		
2526	qywrh	26	I just add a main method to run it and put it in my IDE and it works perfectly. (There were a few bugs, but I haven't hand written code in forever!)	2014-12-10 11:49:30		
2527	dkebi	26		2014-12-10 11:49:30		
2528	rrmeu	26		2014-12-10 11:49:30		
2529	xhgls	26	^^^ Anagram doesn't mean "reverse of the word" :) You maybe need more test cases. Try searching for "abc" inside "zzzzbaczzzz" (should return true)	2014-12-10 11:49:30		
2530	wbqzu	26	That's really funny, I should look these things up!	2014-12-10 11:49:30		
2531	ufdxg	26		2014-12-10 11:49:30		
2532	bexbp	26		2014-12-10 11:49:30		
2533	rrmeu	26	Things to note : 1. Difference b/w substring and subsequence 2. Characters can be repeated  <b> The simple approach </b>:	2014-12-10 11:49:30		
2534	ufdxg	26		2014-12-10 11:49:30		
2535	ethan	26		2014-12-10 11:49:30		
2536	eucmc	26	time (n), space o(1)	2014-12-10 11:49:30		
2537	ftfck	26		2014-12-10 11:49:30		
2538	xhgls	26		2014-12-10 11:49:30		
2539	dkebi	26	Why didn't somebody write the approach instead lines of code? Iterate through text.size()-pattern.size()+1 substrings maintaining amount of each character in sliding window pattern.size() size and amount of matched characters. Whenever matched characters equals alphabet size we have found required substring.	2014-12-10 11:49:30		
2540	qywrh	26	How about this?  Sort the two strings and then find whether the 2nd contains the first as substring.	2014-12-10 11:49:30		
2541	xhgls	26		2014-12-10 11:49:30		
2542	admin	26		2014-12-10 11:49:30		
2543	dgjji	26		2014-12-10 11:49:30		
2544	fmzze	26		2014-12-10 11:49:30		
2545	sgiwy	26	/*using a array of size 26 to represent characters we can easily solve it by traversing base array and checking it against anagram array /*	2014-12-10 11:49:30		
2546	xhgls	26		2014-12-10 11:49:30		
2547	ewigy	26		2014-12-10 11:49:30		
2548	huiqq	26		2014-12-10 11:49:30		
2549	dkebi	26		2014-12-10 11:49:31		
2550	gilit	26	bool findAnagram (char* a, char* b) { int cnts[256] = {0}; char c; int alen = 0; while ( a != NULL && *a) { c = *a; cnts[c]++; alen++; a++; } int total_cnt = 0; while (b != NULL) { c = *b; if (--cnts[c] < 0) { int dt = 0; do { cnts[*(b - dt)]++; dt++; } while (dt <= total_cnt); total_cnt = 0; } else { if (++total_cnt == alen) { return true; } } b++; } return false; }	2014-12-10 11:49:31		
2551	azmjc	26	It can be done in O(m+n), where n is length of a and m is length of b Suppose a = string whose anagrams are to be found and b = string to be searched  Algo: 1. search for first occurrence of first character of a in b. If not found return false. 2. Suppose that location is i. 3. Now anagram can be present from i-n-1 to i+n-1 position. 4. Take next character of a and search in range found in step 3. 5. If found repeat step 4 with next character of a until length of a Else repeat step 1 starting at i+n position. 6. If all characters found return true;	2014-12-10 11:49:31		
2552	nhibd	26	Here is a Java solution with test cases folks.	2014-12-10 11:49:31		
2553	qywrh	26		2014-12-10 11:49:31		
2554	sgiwy	26		2014-12-10 11:49:31		
2555	mrjku	26	And the output:	2014-12-10 11:49:31		
2556	nwkeg	26		2014-12-10 11:49:31		
2557	dkebi	26		2014-12-10 11:49:31		
2558	vanul	26	bool HasAnagramSubstring(string data, string sample) { int lengD = data.Length; int lengS = sample.Length;  HashSet<char> map = new HashSet<char>(); foreach (char c in sample) { map.add(c); }  char[] arraySample = sample.ToCharArray(); Array.Sort(arraySample); string sortedSample = new string(arraySample);  for (int i = 0; i < lengD - lengS; ++i) { bool found = true; // find whether substring starting from i to i + lengS contains all chars for (int j = i; j < i + lengS; ++j) { if (!map.find(data[j]) { found = false; i = j; break; } }  if (found) { // sort the chars in the string string temp = data.Substring(i, lengS); char[] tempArray = temp.ToCharArray(); Array.Sort(tempArray);  // compare the string with sorted sample string if (sample.EqualsTo(new string(tempArray))) { return true; } } } }	2014-12-10 11:49:31		
2559	dkebi	26	find longest common subsequence of two strings,if LCS and second string is same will return true,else return false.	2014-12-10 11:49:31		
2560	tenuw	26	Huh? Did you even read the question?	2014-12-10 11:49:31		
2561	ewigy	26		2014-12-10 11:49:31		
2562	bexbp	26		2014-12-10 11:49:31		
2563	vanul	26	Java Implementation of this problem. Time complexit o(m*n)	2014-12-10 11:49:31		
2564	sgiwy	26		2014-12-10 11:49:31		
2565	cfzie	26		2014-12-10 11:49:31		
2566	rdfeo	26	Maybe this is not the optimal solution.. but works....	2014-12-10 11:49:31		
2567	zeice	26		2014-12-10 11:49:31		
2568	ufdxg	26		2014-12-10 11:49:31		
2569	jippy	26	An On solution as maximum time any character in the larger string is scanned is 2.	2014-12-10 11:49:31		
2570	ftfck	26		2014-12-10 11:49:31		
2571	sgiwy	26		2014-12-10 11:49:31		
2572	krxlv	26	simple order n solution would be:  1) covert string a into int value. eg if a="ab" then its value is 97+98; 2) now in the string b just iterate till length-2 converting all substrings of length 2 into integer values and compare the results.	2014-12-10 11:49:31		
2573	admin	26	but if the string has more than 2 chars, the sum may repeat	2014-12-10 11:49:31		
2574	ethan	26	Similar approach to Rabin-Karp string search algorithm.	2014-12-10 11:49:31		
2575	fmzze	26		2014-12-10 11:49:31		
2576	ewigy	26		2014-12-10 11:49:31		
2577	azmjc	26	Assume that A is already sorted. When a substring of B shows the same hash value with A, the substring is copied to T and compared one-by-one after being sorted. The time complexity will be O(n + c*m*logm) where n is length of B, m is length of A, and c is the number of false positive cases.	2014-12-10 11:49:31		
2578	sqzqo	26		2014-12-10 11:49:31		
2579	xhgls	26		2014-12-10 11:49:31		
2580	ewigy	26	Iterate the string b, if find one char which is contained by a, compare the following a.length() substring of b with a, to see if this substring is anagram of a. public static boolean isAnagram(String a, String b){ char[] aChars = a.toCharArray(); char[] bChars = b.toCharArray(); Arrays.sort(aChars); Arrays.sort(bChars); return String.copyValueOf(aChars).equalsIgnoreCase(String.copyValueOf(bChars)); } public static void main(String[] args){ String a ="xyd"; String b= "afdgzyxksldfm"; boolean flag = false; for(int i = 0; i<b.length(); i++){ String s = b.substring(i, i+1); if(a.contains(s)){ s= b.substring(i, i+a.length()); if(isAnagram(a, s)){ flag = true; break; } } } System.out.println("If string a "+a+" is contained by b "+b+" "+flag); }	2014-12-10 11:49:32		
2581	tenuw	26	My algorithm String a; String b; get a.length start traversing b and use substring(i,n) chk for anagram return true if found else increment i till i+n<b.length.  code:	2014-12-10 11:49:32		
2582	ethan	26		2014-12-10 11:49:32		
2583	fowai	26		2014-12-10 11:49:32		
2584	huiqq	26	My algorithm String a; String b; get a.length start traversing b and use substring(i,n) chk for anagram return true if found else increment i till i+n<b.length.  code:	2014-12-10 11:49:32		
2585	admin	26		2014-12-10 11:49:32		
2586	ethan	26		2014-12-10 11:49:32		
2587	jippy	26	My algorithm String a; String b; get a.length start traversing b and use substring(i,n) chk for anagram return true if found else increment i till i+n<b.length.  code:	2014-12-10 11:49:32		
2588	fmzze	26		2014-12-10 11:49:32		
2589	vanul	26		2014-12-10 11:49:32		
2590	fowai	26		2014-12-10 11:49:32		
2591	ewigy	26		2014-12-10 11:49:32		
2592	sgiwy	26		2014-12-10 11:49:32		
2593	sqzqo	26		2014-12-10 11:49:32		
2594	sqzqo	26	public boolean hasAnagram(String s, String t) { int[ ] windows = new int[256]; int[ ] record = new int[256]; int count = 0; for (int i = 0; i < s.length(); i++) record[s.charAt(i)]++;  for (int i = 0; i < s.length(); i++) { if (windows[t.charAt(i)] < record[t.charAt(i)]) { windows[t.charAt(i)]++; count++; } } if (count == s.length()) return true;  for (int i = 1; i + s.length() - 1 < t.length(); i++) { char begin = t.charAt(i - 1); char end = t.charAt(i + s.length() - 1); if (windows[begin] > 0) { windows[begin]--; count--; } if (windows[end] < record[end]) { windows[end]++; count++; } if (count == s.length()) return true; } return false; }	2014-12-10 11:49:32		
2595	tenuw	26		2014-12-10 11:49:32		
2596	rrmeu	26		2014-12-10 11:49:32		
2597	azmjc	26	Seems like a lost war with so many answers but this may be a good solution. From what I think it will work in O(n) time.	2014-12-10 11:49:32		
2598	sgiwy	26		2014-12-10 11:49:32		
2599	qywrh	26		2014-12-10 11:49:32		
2600	plapd	26	can you check this solution for,  smallString = abcd bigString = bghadabcfgh	2014-12-10 11:49:32		
2601	vanul	26		2014-12-10 11:49:32		
2602	ethan	26		2014-12-10 11:49:32		
2603	krxlv	26		2014-12-10 11:49:32		
2604	cfzie	26		2014-12-10 11:49:32		
2605	fowai	26		2014-12-10 11:49:32		
2606	plapd	26		2014-12-10 11:49:32		
2607	eucmc	26		2014-12-10 11:49:32		
2608	bjsiw	26		2014-12-10 11:49:32		
2609	plapd	26		2014-12-10 11:49:32		
2610	gilit	26		2014-12-10 11:49:32		
2611	ufdxg	26		2014-12-10 11:49:33		
2612	rdfeo	26		2014-12-10 11:49:33		
2613	wbqzu	26		2014-12-10 11:49:33		
2614	nwkeg	26		2014-12-10 11:49:33		
2615	fowai	26	aa	2014-12-10 11:49:33		
2616	huiqq	26		2014-12-10 11:49:33		
2617	dgjji	26		2014-12-10 11:49:33		
2618	bexbp	26	Assume string a with smaller size and string b with larger size Logic: 1. find all anagrams of a 2. check if each anagram is a substring of b 3. return true if find one, otherwise return false.  Code: /* * find if a string a and all its anagram is a substring of another string b */ public static boolean isAnagramsSubstring(String small, String large){ if(small==null||large==null) return false; if(small.length()>large.length()) return false; ArrayList<String> anagrams = findAnagrams(small); for(String s: anagrams){ if(isSubstring(s, large)) return true; } return false; } private static boolean isSubstring(String a, String b){ for(int i=0; i<b.length(); i++){ if(b.charAt(i)==a.charAt(0)){ if(b.length()-i<a.length()) return false; String part = b.substring(i, i+a.length()); if(part.equals(a)) return true; } } return false; } private static ArrayList<String> findAnagrams(String str){ if(str==null) return null; return findAnagrams(str, str.length()-1); } private static ArrayList<String> findAnagrams(String str, int curIndex){ ArrayList<String> result = new ArrayList<String>(); if(curIndex<0){ result.add(""); return result; } ArrayList<String> before = findAnagrams(str, curIndex-1); for(String s : before){ for(int i=0; i<=s.length(); i++){ String newstr = insert(s, str.charAt(curIndex), i); result.add(newstr); } } return result; } private static String insert(String str, char c, int pos){ String left = str.substring(0,pos); String right = str.substring(pos); return left + c + right; }	2014-12-10 11:49:33		
2619	huiqq	26	Moving window on B; O(b * a) ?  public boolean hasAnagramSubstring(String a, String b){ if(a == null || b == null || a.length() > b.length()){ return false; }  int[] targetCounts = new int[256]; int[] windowCounts = new int[256];  for(int i = 0; i < a.length(); i++){ targetCounts[a.charAt(i)]++; windowCounts[b.charAt(i)]++; }  int length = a.length();  for(int endCursor = a.length() - 1; endCursor < b.length();){ boolean test = isAnagram(targetCounts, windowCounts); if(test){ return true; }  windowCounts[b.charAt(endCursor - length + 1)]--; endCursor++; if(endCursor >= b.length()){ break; }else{ windowCounts[b.charAt(endCursor)]++; } }  return false; }  private boolean isAnagram(int[] targetCounts, int[] windowCounts){ for(int i = 0; i < targetCounts.length; i++){ if(targetCounts[i] > 0 && targetCounts[i] != windowCounts[i]){ return false; } }  return true; }	2014-12-10 11:49:33		
2620	sqzqo	26	The answer to this depends whether it's intended to be case sensitive or not, are they alpha numeric only or any character, the size of the character (wide or single byte character), ...etc, but basically, this should work for the basic case of exact matching, and if we wanted we can modify it for any change in the requirement...	2014-12-10 11:49:33		
2621	dgjji	26		2014-12-10 11:49:33		
2622	dkebi	26		2014-12-10 11:49:33		
2623	ewigy	26	public boolean isAnagram(String _source1, String _source2) {  int flag = 0, char_index = 0, counter = 0; if(_source2.length() < _source1.length()){ return false; } char[] _stringchar = _source1.toCharArray(); char[] _tocheck = _source2.toCharArray(); for(char character : _stringchar) { char_index = character - 'a'; if((flag & (1 << char_index)) == 0) flag |= (1 << char_index); }  for(char toCheckcChar : _tocheck) { char_index = toCheckcChar - 'a';  if((flag & (1 << char_index)) > 0) counter++; else counter = 0;  if(counter == _source1.length()) return true;  }  return false; }	2014-12-10 11:49:33		
2624	xhgls	26	public boolean isAnagram(String _source1, String _source2) {  int flag = 0, char_index = 0, counter = 0; if(_source2.length() < _source1.length()){ return false; } char[] _stringchar = _source1.toCharArray(); char[] _tocheck = _source2.toCharArray(); for(char character : _stringchar) { char_index = character - 'a'; if((flag & (1 << char_index)) == 0) flag |= (1 << char_index); }  for(char toCheckcChar : _tocheck) { char_index = toCheckcChar - 'a';  if((flag & (1 << char_index)) > 0) counter++; else counter = 0;  if(counter == _source1.length()) return true;  }  return false; }	2014-12-10 11:49:33		
2625	bexbp	26		2014-12-10 11:49:33		
2626	cfzie	26		2014-12-10 11:49:33		
2627	nhibd	26		2014-12-10 11:49:33		
2628	ufdxg	26		2014-12-10 11:49:33		
2629	eucmc	26		2014-12-10 11:49:33		
2630	zeice	26		2014-12-10 11:49:33		
2631	sgiwy	26	Create char array of first variable and sort it and then convert it back to a string. Now loop through 2nd variable each time picking number of character equal to length of first variable. Sort the picked characters and convert then back to a string and then compare with variable 1. As soon as there is a match break from for loop.	2014-12-10 11:49:33		
2632	bexbp	26	In C++, generate all the permutations of string a and check if they are substrings of b.	2014-12-10 11:49:33		
2633	rrmeu	26		2014-12-10 11:49:33		
2634	wbqzu	26		2014-12-10 11:49:33		
2635	krxlv	26	It can be solved using xor method.	2014-12-10 11:49:33		
2636	dkebi	26	algo: 1 Get XOR of current substring 2 XOR result with first few characters of text(few characters=length of substring) 3 Parse text and at each iteration remove last character and add new character till its end or xor==0	2014-12-10 11:49:33		
2637	fowai	26		2014-12-10 11:49:34		
2638	nwkeg	26		2014-12-10 11:49:34		
2639	bjsiw	26	import java.util.Arrays;  public class whether_any_anagram_of_string_a_is_a_substring_of_string { public static void main(String []args) { whether_any_anagram_of_string_a_is_a_substring_of_string obj = new whether_any_anagram_of_string_a_is_a_substring_of_string(); String a="xyz"; String b="afdgyzxksldfm"; System.out.println(obj.substringAnagram(a,b)); }  private boolean substringAnagram(String a, String b) { boolean table[] = new boolean[256]; boolean orig_table[] = new boolean[256];  Arrays.fill(table,false); Arrays.fill(orig_table,false);  for(int i=0;i<a.length();i++) { table[a.charAt(i)] = true; orig_table[a.charAt(i)] = true; }  int count = 0; for(int j=0;j<b.length();j++) { if(table[b.charAt(j)]==true) { count++; table[b.charAt(j)] = false;  if(count==a.length()) { return true; } }  else if(count>0) { count = 0; table = orig_table.clone(); } } return false; } }	2014-12-10 11:49:34		
2640	ethan	26	O(n) solution in Java.	2014-12-10 11:49:34		
2641	dgjji	26		2014-12-10 11:49:34		
2642	huiqq	26		2014-12-10 11:49:34		
2643	xhgls	26	O(n) solution in Java.	2014-12-10 11:49:34		
2644	krxlv	26		2014-12-10 11:49:34		
2645	zeice	26		2014-12-10 11:49:34		
2646	sgiwy	26	O(n) solution in Java.	2014-12-10 11:49:34		
2647	mrjku	26		2014-12-10 11:49:34		
2648	bexbp	26		2014-12-10 11:49:34		
2649	wbqzu	26	O(n) solution	2014-12-10 11:49:34		
2650	mrjku	26		2014-12-10 11:49:34		
2651	gilit	26		2014-12-10 11:49:34		
2652	nwkeg	26		2014-12-10 11:49:34		
2653	sgiwy	26		2014-12-10 11:49:34		
2654	nwkeg	26	import java.util.BitSet;  public class AnagramSubString {  public static void main(String args[]){ String str = "abcefghi"; String pat = "gefi";  BitSet p = new BitSet(256); for(int i=0; i<pat.length();i++) p.set((int)pat.charAt(i));  int np = pat.length(); for(int i=0; i<str.length()-np;i++){ BitSet s = new BitSet(256); for(int j=0; j<pat.length();j++) s.set((int)str.charAt(i+j)); if(s.equals(p)){ System.out.println("true"); return; } } System.out.println("false"); } }	2014-12-10 11:49:34		
2655	vanul	26	Simple O(n) code in C++  bool is_anagram_wSubstr(string a, string b) { if(a.length() > b.length()) return false; if(a.length() == 0) return true;  int counter[256]; memset(counter, 0, 256); for(int i = 0 ; i < a.length(); i++){ counter[(int) a[i]] ++; counter[(int) b[i]] --; }  int ind, l = 0, h = a.length() - 1;  while(true){  for(ind = 0 ; ind < a.length() ; ind++) if(counter[(int) a[ind]] != 0) break; if(ind == a.length()) return true;  counter[(int) b[l++]] ++; if(++h > b.length() - 1) return false; counter[(int) b[h]] --; } }	2014-12-10 11:49:34		
2656	dkebi	26	// 1. get all anagram strings of a // 2. for each string in the anagram list, check if it is a substring of b  bool AnagramIsSubString(string a, string b) { string[] anagrams = GetAllAnagram(a); bool found = false;  foreach (string anagram in anagrams) { if (b.IndexOf(anagram) != -1) { found = true; break; } } return found; }	2014-12-10 11:49:34		
2657	fowai	26	finding all anagram is expensive. use the other approach. Here is the c# code.  static bool AnagramIsSubstring(string a, string b) { if (a == null || b == null || a.Length > b.Length) { return false; }  char[] achars = a.ToCharArray(); Array.Sort(achars); string sorteda = new string(achars);  HashSet<char> aset = new HashSet<char>(); foreach (char c in achars) { aset.Add(c); }  for (int i = 0; i < b.Length - a.Length + 1; ++i) { bool found = true; for (int j = i; j < i + a.Length; ++j) { if (!aset.Contains(b[j])) { found = false; break; } }  if (found) { char[] bchars = b.Substring(i, a.Length).ToCharArray(); Array.Sort(bchars); string sortedb = new string(bchars);  if (string.Compare(sortedb, sorteda) == 0) { return true; } } }  return false; }	2014-12-10 11:49:34		
2658	ethan	26	Using the xor function	2014-12-10 11:49:34		
2659	nwkeg	27		2014-12-10 11:49:41		
2660	xhgls	27		2014-12-10 11:49:41		
2661	gilit	27	Have tested for following inputs:---  int[] ints = new int[] {6, 7, 8, 1, 2, 3, 9, 10}; int[] ints = new int[] {4, 7, 9, 8, 2}; int[] ints = new int[] {1, 11, 12, 7, 8, 9}; int[] ints = new int[] {1, 4, 2, 3}; int[] ints = new int[]{1, 11, 8, 9, 10, 14}; int[] ints = new int[]{10, 6, 11}; int[] ints = new int[]{1, 5, 10, 8, 9};	2014-12-10 11:49:41		
2662	bjsiw	27		2014-12-10 11:49:41		
2663	admin	27		2014-12-10 11:49:41		
2664	tenuw	27	getProdOfTwoLargest fails with this: nums = [1, 3, 2, 10, 8, 9] startIndex = 1 endIndex = 5 pivot = 2  It returns 30 instead of 72.	2014-12-10 11:49:41		
2665	bexbp	27	This doesn't work -- it could if you iterated backwards from the right and pick the next two largest numbers.	2014-12-10 11:49:41		
2666	cfzie	27	One solution can be modification of code from algorithmist.com/index.php/Longest_Increasing_Subsequence.cpp to get max product of increasing sub-sequence of 3.	2014-12-10 11:49:41		
2667	rdfeo	27		2014-12-10 11:49:41		
2668	eucmc	27		2014-12-10 11:49:41		
2669	qywrh	27	Space complexity is O(n) and time complexity is O(nlogn).	2014-12-10 11:49:41		
2670	krxlv	27		2014-12-10 11:49:41		
2671	cfzie	27		2014-12-10 11:49:41		
2672	krxlv	27	Here is a possible solution:	2014-12-10 11:49:41		
2673	cfzie	27		2014-12-10 11:49:41		
2674	nwkeg	27		2014-12-10 11:49:41		
2675	krxlv	27	Any suggestions would be helpful !	2014-12-10 11:49:41		
2676	rrmeu	27	The numbers will be stored in a,b and c.	2014-12-10 11:49:42		
2677	sqzqo	27		2014-12-10 11:49:42		
2678	rrmeu	27		2014-12-10 11:49:42		
2679	bexbp	27	Does it give right solution for 10 1 3 9 7 8 5	2014-12-10 11:49:42		
2680	bjsiw	27	good solution. Additionally, We can use stack to get the more array and the less array. It will increase the speed.	2014-12-10 11:49:42		
2681	dkebi	27		2014-12-10 11:49:42		
2682	dkebi	27		2014-12-10 11:49:42		
2683	ewigy	27	what happen if the first element of array is largest one ?? u r solu fail	2014-12-10 11:49:42		
2684	azmjc	27	@Anonymous - if first element is largest, as per the question, there is no solution since there is no second and third largest nos left to first array element.	2014-12-10 11:49:42		
2685	xhgls	27		2014-12-10 11:49:42		
2686	fowai	27		2014-12-10 11:49:42		
2687	sqzqo	27	@m3th0d.itbhu - step 14 to 17 will be executed only once for your input. That is when A[i] is 7. Then how the output will be 1*11*12 ???	2014-12-10 11:49:42		
2688	gilit	27	@vinod, yeah I got you, condition in step14 will be true only for A[i] = 7. Thanks :)	2014-12-10 11:49:42		
2689	sgiwy	27		2014-12-10 11:49:42		
2690	zeice	27		2014-12-10 11:49:42		
2691	gilit	27	here the sequence is not maintained  for eg: ip 10 6 11, required: no sequence found it outputs: 6*10*11	2014-12-10 11:49:42		
2692	eucmc	27	@coder - updated the solution.	2014-12-10 11:49:42		
2693	sgiwy	27	Code is not working if the sequence is: {1 5 10 8 9}  your solution gives: 1 5 10 expected output: 5 8 9	2014-12-10 11:49:42		
2694	gilit	27	What Order was he looking for ? O(n^2) or O(n) ?	2014-12-10 11:49:42		
2695	sgiwy	27	I think without using extra space you can do it in O(n log n). I doubt O(n) is possible.	2014-12-10 11:49:42		
2696	dkebi	27	O(n) is possible.  Input: 6 7 8 1 2 3 9 10  Program:  int f,s,t = a[0];  for(int i=0;i<n;i++) {  if(t<a[1+1]) { f=s; s=t; t=a[i+1]; } }  Print f,s,t;	2014-12-10 11:49:42		
2697	rrmeu	27	Minor change in my above program. Replacing n with n-1  Input1: 6 7 8 1 2 3 9 10 Input 2: 4, 7, 9, 8, 2  Program:  int f,s,t = a[0];  for(int i=0;i<n-1;i++) {  if(t<a[1+1]) { f=s; s=t; t=a[i+1]; } }  Print f,s,t;	2014-12-10 11:49:42		
2698	ftfck	27	I assume you mean i+1 instead of 1+1. However, even then the code does not work as it simply chooses the first rather than the largest sequence. For example take the sequence 1,9,7,8,10,9. Your solution produces 1,9,10, whereas the correct answer is 7,8,10.	2014-12-10 11:49:42		
2699	plapd	27	if we start from end of array will ur solution solves the problem?	2014-12-10 11:49:42		
2700	dgjji	27	if the first element is the biggest one and all others are 1, then this solution will give the first element 3 times as result.	2014-12-10 11:49:42		
2701	bjsiw	27	// Find_Max_Product.cpp : Defines the entry point for the console application. //  #include "stdafx.h" #include <iostream>  using namespace std;  int find_Min(int result[]) { int min; int min_index; if(result[0]<result[1]) { if(result[0]<result[2]) { min=result[0]; min_index=0; } else { min=result[2]; min_index=2; } } else { if(result[1]<result[2]) { min=result[1]; min_index=1; } else { min=result[2]; min_index=2; } } return min_index; }    int findMaxProduct(int arr[],int len) { int result[3];  if(len<3) return -1; if(len==3) return *arr;  result[0]=arr[0]; result[1]=arr[1]; result[2]=arr[2];  int min_index=find_Min(result); int min=result[min_index];    for(int i=3;i<len;i++) { for(int j=0;j<3;j++) { if(arr[i]>result[j]) { min_index=find_Min(result); result[min_index]=arr[i];    break;  } }  }  std::cout<<"output";  for(int i=0;i<3;i++) { std::cout<<result[i]<<" ";  } return 1;  }    int _tmain(int argc, _TCHAR* argv[]) { int arr[13]={6,7,8,1,2,3,9,10,2,5,12,15}; findMaxProduct(arr,13); return 0; }	2014-12-10 11:49:42		
2702	nwkeg	27	O(n2) solution:	2014-12-10 11:49:42		
2703	ethan	27		2014-12-10 11:49:42		
2704	ethan	27		2014-12-10 11:49:42		
2705	wbqzu	27	I don't think your solution is correct. Consider the case {1, 4, 2, 3} The solution is 1, 2, 3 but your code won't find it because it is looking for the first ascending number after the max so far. It starts with 1, then finds 4 and goes {1, 4} but nothing in the set is greater than 4 so it skips over 1 as the start of a sequence and returns no solution.	2014-12-10 11:49:43		
2706	zeice	27		2014-12-10 11:49:43		
2707	rdfeo	27		2014-12-10 11:49:43		
2708	fowai	27		2014-12-10 11:49:43		
2709	nhibd	27		2014-12-10 11:49:43		
2710	dkebi	27	hi jchen , i do not think your code preserved sequence	2014-12-10 11:49:43		
2711	admin	27	the question states "subsequence being in ascending order", didn't say to preserved the sequence	2014-12-10 11:49:43		
2712	wbqzu	27		2014-12-10 11:49:43		
2713	eucmc	27		2014-12-10 11:49:43		
2714	zeice	27	public static void main(String args[]){ int[] sat = {6,7,8,1,2,3,9,10}; int temp = sat[0];  for(int i=0;i<sat.length;i++){ for(int j=0;j<sat.length-1;j++){ if(sat[j]>sat[j+1]){ temp = sat[j]; sat[j]=sat[j+1]; sat[j+1]=temp; } } }  int sat1 = sat.length - 3;  for(int k=sat1;k<sat.length;k++){ System.out.print(sat[k] + " "); } }	2014-12-10 11:49:43		
2715	nhibd	27	I believe in this problem we need not worry about the product as the product of the maximum 3 numbers will be greater than any other 3 numbers. Hence the problem reduces to finding the max 3 numbers in ascending order. This is my code in C#. Please let me know if I am wrong somewhere. Thanks.	2014-12-10 11:49:43		
2716	huiqq	27		2014-12-10 11:49:43		
2717	zeice	27		2014-12-10 11:49:43		
2718	jippy	27	I think you need to check for iMax <= input[i] in case the array has duplicates. Also, at the end check that the list is atleast 3 elements long or you get incorrect answer	2014-12-10 11:49:43		
2719	bjsiw	27	Actually even then its wrong since you can have the max value as the first element: a = {10,6,7,8}  You code assumes sorted array	2014-12-10 11:49:43		
2720	azmjc	27	I think this is O(n^2).Just search for highest, second highest and third highest in the array as that will give the maximum product.	2014-12-10 11:49:43		
2721	xhgls	27		2014-12-10 11:49:43		
2722	dkebi	27		2014-12-10 11:49:43		
2723	bjsiw	27	As per the spec, it can't just be the 3 highest numbers, but the 3 highest that are in ascending order. For instance, [0,4,3,6,1,10,9]. The 3 highest are 10, 9, and 6, but what he is looking for are the 3 highest in ascending order, which would be 4,6,10. So your solution does not work	2014-12-10 11:49:43		
2724	rrmeu	27		2014-12-10 11:49:43		
2725	nhibd	27		2014-12-10 11:49:43		
2726	ewigy	27		2014-12-10 11:49:43		
2727	fowai	27		2014-12-10 11:49:43		
2728	ftfck	27	Sorry, my answer got posted twice.	2014-12-10 11:49:43		
2729	vanul	27	C# Code: --------------------	2014-12-10 11:49:43		
2730	gilit	27		2014-12-10 11:49:43		
2731	fmzze	27		2014-12-10 11:49:43		
2732	nwkeg	27		2014-12-10 11:49:43		
2733	ufdxg	27		2014-12-10 11:49:44		
2734	plapd	27	create a max heap from the given elements and display the top 3 elements	2014-12-10 11:49:44		
2735	fmzze	27	this will not work. for example.	2014-12-10 11:49:44		
2736	zeice	27		2014-12-10 11:49:44		
2737	gilit	27		2014-12-10 11:49:44		
2738	dgjji	27	but with max-heap approach we get 10*9*8. The important point is the subsequence has to be in ascending order.  This looks to be a variation of longest increasing subsequence problem.	2014-12-10 11:49:44		
2739	ethan	27	vector<int> Find_pro(int a[],int size){ vector<int> p; p.clear(); int product=0; for(int i=0;i<size;i++){ int f=a[i]; int s=a[i]; int t=a[i]; for(int j=i;j<size;j++){ if(a[j]>t){ f=s; s=t; t=a[j]; } } if(s!=f&&f*s*t>product){ product=f*s*t; p.clear(); p.push_back(f); p.push_back(s); p.push_back(t); } } return p; } C++ version	2014-12-10 11:49:44		
2740	huiqq	27		2014-12-10 11:49:44		
2741	krxlv	27		2014-12-10 11:49:44		
2742	admin	27	}	2014-12-10 11:49:44		
2743	huiqq	27	I have a java version for O(n^2) at worst case	2014-12-10 11:49:44		
2744	mrjku	27		2014-12-10 11:49:44		
2745	fmzze	27		2014-12-10 11:49:44		
2746	fmzze	27	Complexity : O (n)	2014-12-10 11:49:44		
2747	huiqq	27		2014-12-10 11:49:44		
2748	fowai	27		2014-12-10 11:49:44		
2749	ethan	27	your solution gives wrong answer for {1,5,10,8,9}  expected output - 5*8*9  your output- 1*5*10	2014-12-10 11:49:44		
2750	dkebi	27		2014-12-10 11:49:44		
2751	dgjji	27		2014-12-10 11:49:44		
2752	ewigy	27		2014-12-10 11:49:44		
2753	nhibd	27		2014-12-10 11:49:44		
2754	qywrh	27	I think this should work in o(n). Not fully tested.. might miss some corner cases..	2014-12-10 11:49:44		
2755	cfzie	27		2014-12-10 11:49:44		
2756	eucmc	27		2014-12-10 11:49:44		
2757	huiqq	27	Logic: Let array index start from 0 to n-1 (where n is the number of elements). Let i = n - 1 Step 1. Find the largest number from index = i to index = 2, let position of the number (n1) found = pos1  Step2. Find the largest number from index = pos1 - 1 to index = 1, let position of the number (n2) found = pos2  Step3. Find the largest number form index = pos2 - 1 to index = 0. Let the position of the number (n3) found = pos3  Step4. if n1 > n2 and n2 > n3 then find the product n1 * n2 * n3.  Step5. If product is more then the prev. product (i.e. max_prod), update max_prod  Step6. Do i-- and repeat step 1 to step 6 till i >= 2  Step 7. Required result is stored in max_prod.	2014-12-10 11:49:44		
2758	sqzqo	27		2014-12-10 11:49:44		
2759	ethan	27		2014-12-10 11:49:44		
2760	nhibd	27	Hi All  This is not too difficult. To note, an increasing sequence of three numbers that when multiplied yields the highest result is merely the three largest numbers in the array. This can be found in a single scan of the entire array.  Algorithm: (*) Initialize m1, m2, m3 to zero. (*) Loop through the entire array: (*) set m to be max(arr[i], m1) (where arr[i] is the current element in the array). (*) if m != m1, then m must be bigger. So set m3=m2, m2=m1, and m1 = m (*) else m = max(m2, arr[i]) (*) if m != m2 (m must be bigger than m2). So set m3=m2, m2 = m (*) else m3 = max(arr[i], m3)  The above algorithm is guaranteed to yield the three largest numbers in a single scan. This means storage is O(4), and time complexity is O(n).  Here is the algorithm:	2014-12-10 11:49:44		
2761	ufdxg	27		2014-12-10 11:49:44		
2762	dgjji	27		2014-12-10 11:49:44		
2763	dkebi	27	Hello anonymous first and foremost thing is we need to preserve the order, that is meant by sub-sequence. take the input as {1,5,10,8,9} your output is - 8*9*10 expected is - 5*8*9	2014-12-10 11:49:44		
2764	krxlv	27	I think this is possible in O(n), possible there are solutions already posted too..  Here is the logic (java biased).  1. Keep a result object with max, second_max, and third_max numbers. 2. Run through the array and record maximums, If you find a bigger value than max, push max to second_max, second_max to third_max and so on, until you have values in all. When you have values in all this is a possible result for you. Calculate the product and store the result. (result1) 3. Run through the rest of the array with a new result object.(result2). For any number greater than max in result1, recalculate result1 and clear result2. For any number less than third_max in result1, ignore. But for any number greater than result1.third_max, track it in result2, since we have a possibility of getting a better trio than result1. 4. If we get a better trio replace result2 with result1.  Time complexity is O(n). Space complexity is constant O(1)	2014-12-10 11:49:45		
2765	rdfeo	27	One more addition.  When capturing result into result2, for any number greater than result.third_max, then new number will be result2.second_max, and result2.third_max will be same as result1.third_max. result2.max will be unassigned for now. Then you get another number greater than result.max, then you apply this to both result1 and result2 and then, decide which will prevail.	2014-12-10 11:49:45		
2766	krxlv	27	Here's an O(n^2) solution:  Find out all the increasing subsequences and for each subsequence greater than or equal to length three, find the product of the last three elements of the sequence.	2014-12-10 11:49:45		
2767	zeice	27		2014-12-10 11:49:45		
2768	sqzqo	27		2014-12-10 11:49:45		
2769	gilit	27	for each element a[i],we need to find 1.largest elemnt smaller than current element from 0 to i-1..will be stored in an array.  2. largest element greater than current element from i+1 to n-will be stored in oder array,  1. for finding first,we'll create a balanced BST or AVL and find floor.  insert a[0] in AVL tree start loop from i=1 to i=n-2  search for floor in AVL and store in another array say b  insert a[i] in AVL 2. for second array,linear scan.(finding greatest element on right side). and store this value for each element in a diff array say c now check for every element  3.Now find index i for max a[i]*b[i]*c[i]   Time complexity--o(nlogn) for part 1 and o(n) for part 2 and 3..overall-o(nlogn) space complexity-o(n)	2014-12-10 11:49:45		
2770	wbqzu	27	So if I understand this correctly, the subsequence of 3 items has to be in ascending order and we must find the subsequence of 3 items which are in ascending order which has the largest product.  This is achievable in O(N) time and with no additional storage other than a few local ints (mostly there for clarity). Basically, you walk the array, testing three sequential elements at a time. If they are ascending, then they are eligible to have the highest product. Each time you find a valid ascending subsequence that has a higher product, store the index that it was found for later retrieval and store what that product was for future testing.	2014-12-10 11:49:45		
2771	dgjji	27		2014-12-10 11:49:45		
2772	sqzqo	27		2014-12-10 11:49:45		
2773	ethan	27	Hey JB The sequence does not have to be one after the other, there can be gaps between. take the input as {1,5,10,8,9} your output will be 1, 5, 10 if I read correctly but the expected output is 5, 8, 9	2014-12-10 11:49:45		
2774	ewigy	27	An interesting solution might be to sort those elements beforehand keep the indexes and look to the index table to find the max element. So step by step:  1. Sort the array. Keep which element was at which index. (That is O(NlogN) time computation plus O(2N) space for but the current array and the index table) So if we have an input like this: {1, 11, 12, 7, 6, 8, 9} we will have a sorted array like: {1, 7, 6, 8, 9, 11, 12} obviously and we will also have an indices array such as this: {0, 4, 3, 5, 6, 1, 2} (the index of 12 at the end of the sorted array had an index of 2 in the original array and so an.) 2. From the highest element in the sorted array, start finding highest 3 elements. Something like:	2014-12-10 11:49:45		
2775	plapd	27		2014-12-10 11:49:45		
2776	wbqzu	27		2014-12-10 11:49:45		
2777	dgjji	27	3. In the end just print the current_triple array.  This is an O(NlgN + N^2) computation and O(2N) space complexity solution. However if we find a faster way of traversing the index array, it might become faster.  But maybe I'm missing something out.	2014-12-10 11:49:45		
2778	qywrh	27	We need to process the data from right to left and create a relationship tree in the following manner for 6 7 8 1 2 3 9 10.  If smaller than current chains smallest element, cost O(1) 1. 10 2. 10 9 3. 10 9 3 4. 10 9 3 2 5. 10 9 3 2 1  If greater than current chains smallest element, binary search cost O(log n)  6. 10 9 3 2 1 ----------8  7. 10 9 3 2 1 ----------8 7  7. 10 9 3 2 1 ----------8 7 6  Now the answer is in one of the root to leaf paths, which can be found in O(n). So, total time O(n log n) and space O(n).	2014-12-10 11:49:45		
2779	wbqzu	27	Forgot to mention that we need to keep a copy of the current chain in an array for binary search.	2014-12-10 11:49:45		
2780	qywrh	27		2014-12-10 11:49:45		
2781	sqzqo	27		2014-12-10 11:49:45		
2782	xhgls	27	Solution in C++ with O(n) running time and O(n) space complexity:	2014-12-10 11:49:45		
2783	rdfeo	27		2014-12-10 11:49:45		
2784	qywrh	27		2014-12-10 11:49:45		
2785	sgiwy	27	O(n) solution:	2014-12-10 11:49:47		
2786	nwkeg	27		2014-12-10 11:49:47		
2787	admin	27		2014-12-10 11:49:47		
2788	jippy	27	O(n) solution: We maintain maximum and maximum pair(pair whose 1st element is maximum than any other pair) On finding a new element, check if the subseq of length three can be formed. If not (happens when elem<pair.first) check if max pair can be formed by comparing (elem <= max). If not, it is the maximum element. So update max.	2014-12-10 11:49:47		
2789	cfzie	27		2014-12-10 11:49:47		
2790	fowai	27		2014-12-10 11:49:47		
2791	fmzze	27	Edited: Sorry, misread the question.	2014-12-10 11:49:47		
2792	wbqzu	27	The subsequence has to be in ascending order. Consider {4, 7, 9, 8, 2} as your input. In this case, the three max numbers are {7, 9, 8} but this isn't a valid subsequence. The output in this case should be {4, 7, 9}	2014-12-10 11:49:47		
2793	eucmc	27	java function:	2014-12-10 11:49:47		
2794	admin	27		2014-12-10 11:49:47		
2795	xhgls	27		2014-12-10 11:49:47		
2796	vanul	27	The non-negative integers need not be consecutive, they just need to be in a subsequence	2014-12-10 11:49:47		
2797	wbqzu	27	I think,this is O(n). Any suggestion / input will be helpful  int sequence[]=new int[]{6,7,8,1,2,3,9,10}; int maxSum=0; for(int i=0;i<sequence.length-2;i++){ if(maxSum<sequence[i]+sequence[i+1]+sequence[i+2]){ maxSum=sequence[i]+sequence[i+1]+sequence[i+2]; firstMax=sequence[i]; secondMax=sequence[i+1]; thirdMax=sequence[i+2]; } System.out.println(firstMax+"*"+secondMax+"*"+thirdMax+" = "+firstMax*secondMax*thirdMax);	2014-12-10 11:49:47		
2798	ethan	28	let i be row number (0 to N-1), and j be col number (O to N-1)  diagonal 1 has i+j =0 diagonal 2 has i+j =1 ...   So define D = i+j  Loop with D from 0 to 2*(N-1)  Now if D = i+j then j=D-i So we have reduced the problem to two variables: D and i (two loops)	2014-12-10 11:49:49		
2799	fmzze	28		2014-12-10 11:49:49		
2800	huiqq	28		2014-12-10 11:49:49		
2801	admin	28	Check for bugs. And thanks for posting this fun question. You can think of the MxN case	2014-12-10 11:49:49		
2802	qywrh	28	brilliant solution! but you need a bounds check on i<N and (D-i)<N before printing.	2014-12-10 11:49:49		
2803	nwkeg	28		2014-12-10 11:49:49		
2804	gilit	28		2014-12-10 11:49:49		
2805	sqzqo	28	for(int d = 0; d < 2 * x; d++) { int a= 0; if( d >= x) a = (d%x) + 1; for( int i = (0+ a); i <= (d - a); i++) cout<< matrix[i][d-i]; cout<<endl; }	2014-12-10 11:49:49		
2806	ethan	28	this only works for NxN matrix if it MxN matrix your solution will not work. it is a recursive problem you need to think in it recursively first.	2014-12-10 11:49:49		
2807	eucmc	28		2014-12-10 11:49:49		
2808	ftfck	28		2014-12-10 11:49:49		
2809	jippy	28		2014-12-10 11:49:49		
2810	sgiwy	28		2014-12-10 11:49:50		
2811	krxlv	28		2014-12-10 11:49:50		
2812	bjsiw	28		2014-12-10 11:49:50		
2813	ewigy	28		2014-12-10 11:49:50		
2814	fowai	28		2014-12-10 11:49:50		
2815	ethan	28	A little change to make it more efficient:	2014-12-10 11:49:50		
2816	gilit	28		2014-12-10 11:49:50		
2817	ftfck	28		2014-12-10 11:49:50		
2818	fowai	28	We may print from right up to right left down, following is C++ code:	2014-12-10 11:49:50		
2819	azmjc	28		2014-12-10 11:49:50		
2820	ufdxg	28		2014-12-10 11:49:50		
2821	sgiwy	28		2014-12-10 11:49:50		
2822	vanul	28		2014-12-10 11:49:50		
2823	rrmeu	28		2014-12-10 11:49:50		
2824	sgiwy	28		2014-12-10 11:49:50		
2825	ftfck	28		2014-12-10 11:49:50		
2826	bjsiw	28		2014-12-10 11:49:50		
2827	sgiwy	28		2014-12-10 11:49:50		
2828	zeice	28		2014-12-10 11:49:50		
2829	azmjc	28		2014-12-10 11:49:50		
2830	ethan	28		2014-12-10 11:49:50		
2831	jippy	28		2014-12-10 11:49:50		
2832	fowai	28		2014-12-10 11:49:50		
2833	cfzie	28		2014-12-10 11:49:50		
2834	krxlv	28		2014-12-10 11:49:51		
2835	wbqzu	28	#include<iostream> #include<conio.h> /* Give a N*N matrix, print it out diagonally. Follow up, if it is a M*N matrix, how to print it out. Example: 1 2 3 4 5 6 7 8 9 print: 1 2 4 3 5 7 6 8 9 */  using namespace std; int a[100][100];  void printdiagonal(int a[][100],int m,int n) { int x=0; while(x<=n+1) { for(int i=0;i<m;++i) { for(int j=0;j<n;++j) { if(i+j==x) cout<<a[i][j]<<" ";  } } cout<<"\n"; x++;  }   }  int main() { int m,n; cout<<"\nEnter the number of rows:"; cin>>m; cout<<"\nEnter the number of columns:"; cin>>n; for(int i=0;i<m;++i) { for(int j=0;j<n;++j) cin>>a[i][j]; } printdiagonal(a,m,n); getch(); return 0;  }	2014-12-10 11:49:51		
2836	qywrh	28	This print for both N * N and M * N	2014-12-10 11:49:51		
2837	vanul	28		2014-12-10 11:49:51		
2838	jippy	28		2014-12-10 11:49:51		
2839	nwkeg	28	here the solution for MxN	2014-12-10 11:49:51		
2840	plapd	28		2014-12-10 11:49:51		
2841	dkebi	28		2014-12-10 11:49:51		
2842	vanul	28		2014-12-10 11:49:51		
2843	ewigy	28		2014-12-10 11:49:51		
2844	sqzqo	28	This can be problem can be treated in different way. If the top-left element is considered as root of the tree , then this problem boils down to level order traversal of the tree.  Only one special handling is required 1. If it's the right most element in the considered tree or the top row in the current diagonal, just push its right and then bottom element. 2. For other elements in the current diagonal, just push the bottom element.  Do this until any element left in the queue.	2014-12-10 11:49:51		
2845	rdfeo	28		2014-12-10 11:49:51		
2846	tenuw	28		2014-12-10 11:49:51		
2847	vanul	28	//visual studio 2010	2014-12-10 11:49:51		
2848	nwkeg	28		2014-12-10 11:49:51		
2849	ethan	28		2014-12-10 11:49:51		
2850	admin	28	public void do_prt_diag() {  int a[][] = { {1,2,3}, {4,5,6}, {7,8,9} }; // int a[][] = { {1,2,3,4,22}, {5,6,7,8,33}, {9,10,11,12,44} };  int j = 0; int k = 0; printDiagonally(a); } // start row then column // start at a[y][x], where y=0..n-1 and x=0...m-1 go down and left till out of bound. // start at a[y][x], where y=1..n-1 and x=m-1..0 go down and left till out of bound. private void printDiagonally(int[][] a) { int n = a.length; // col int m = a[0].length; // row int x = 0; int y = 0;  // do row for (int i = 0; i<m; i++) { x=i; while(x >= 0 && y <= n-1) { System.out.print(a[y][x] + " "); x--; y++; } y=0; //reset column System.out.println(); } //do column x=m-1; for(int i=1; i<n; i++) { y=i; while(x>=0 && y<=n-1) { System.out.print(a[y][x] + " "); y++; x--; } x=m-1; //rest row System.out.println(); } }	2014-12-10 11:49:51		
2851	tenuw	28	for a matrix of MxN, we will have a total of M+N-1 diagonals  at diagonal no. 0 - > we preint 0,0 at 1 -> 1,0 and 0,1 at 2 -> 2,0 1,1 and 0,2  See the pattern? for diagonal i, we print [ i-j ][ j ] for each j from 0 to i inclusive	2014-12-10 11:49:51		
2852	sgiwy	28		2014-12-10 11:49:51		
2853	vanul	28		2014-12-10 11:49:51		
2854	xhgls	28		2014-12-10 11:49:51		
2855	huiqq	28		2014-12-10 11:49:51		
2856	rdfeo	28	I just took a generic nxm matrix. It should work for square matrices as well... You can pass the matrix as an argument too	2014-12-10 11:49:51		
2857	fowai	28		2014-12-10 11:49:51		
2858	cfzie	28		2014-12-10 11:49:52		
2859	ftfck	28	Heres solution in c#:	2014-12-10 11:49:52		
2860	admin	28		2014-12-10 11:49:52		
2861	zeice	28		2014-12-10 11:49:52		
2862	dgjji	28	Outer loop runs for the diagonals. D=0,i=0,j=0;while(D<2*n-1) { if(D<n) i=0; else i++; k=i; p=j; while(p>=0 && k<n) { cout << arr[k][p]; p--; k++; } D++; if(D<n) j++; cout << endl;  } //Where p and k are used to print the numbers.	2014-12-10 11:49:52		
2863	admin	28		2014-12-10 11:49:52		
2864	admin	28		2014-12-10 11:49:52		
2865	bexbp	28	public class printMatrixDiagonally { public static void main(String[] args){ int row = 2 , col =3; int[][] input = new int[row][col]; for(int i =0 ; i< row ; i++){ for(int j= 0 ; j<col ;j ++){ input[i][j] = i+j; } } printStack(input);  //Here is to print it out diagonally. printStackDiag(input); }  //this method is to print out the matrix. public static void printStack(int[][] input){ int row = input.length, col = input[0].length; for(int i =0 ;i <row ; i++){ for(int j=0 ; j<col ;j++){ System.out.print(" "+input[i][j]); } System.out.println(); } }  public static void printStackDiag(int[][] input){ //. We need to print one line where their sum of i, j index is the same. //total is the max of i, j sum. int row = input.length , col = input[0].length, total = row+col -2 , sum = 0; while(sum>=0 && sum <= total){ for(int i = 0 ; i< row ; i++){ int j= sum -i; if(j>=0 && j< col){ System.out.print(" "+input[i][j]); } } sum++; System.out.println(); }  } }	2014-12-10 11:49:52		
2866	cfzie	28	C# Code  using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace Test { class Program { static void Main(string[] args) { var n = 3; var ip = new int[n,n]; ip[0, 0] = 1; ip[1, 0] = 2; ip[2, 0] = 3; ip[1, 0] = 4; ip[1, 1] = 5; ip[1, 2] = 6; ip[2, 0] = 7; ip[2, 1] = 8; ip[2, 2] = 9; MyMethod(ip,n); Console.ReadKey(); }  static IEnumerable<int> MyMethod(int[,] ip, int n) { var output = new List<int>(); for (var i = 0; i <= 2 * (n - 1); i++) { var iTemp = i; for (var j = 0; j <= i; j++) { if (iTemp >= 0 && iTemp < n && j >= 0 && j < n) { Console.WriteLine(iTemp + " " + j); } iTemp = iTemp - 1; } Console.WriteLine("inner loop ends"); } return output; } } }	2014-12-10 11:49:52		
2867	dkebi	28	#include <stdio.h>  int main() { int mat[5][5],i,j,k,m; scanf("%d",&m); for(i=0;i<m;i++) for(j=0;j<m;j++) scanf("%d",&mat[i][j]); for(i=0;i<m;i++) { for(k=0,j=i;j>=0;j--,k++) printf("%d ",mat[k][j]); printf("\n"); } for(i=1;i<m;i++) { for(j=m-1,k=i;k<m;k++,j--) printf("%d ",mat[k][j]); printf("\n"); } return 0; }	2014-12-10 11:49:52		
2868	krxlv	28	following should work for both nxn and nxm matrix	2014-12-10 11:49:52		
2869	rdfeo	28		2014-12-10 11:49:52		
2870	gilit	28		2014-12-10 11:49:52		
2871	fmzze	28		2014-12-10 11:49:52		
2872	ewigy	28		2014-12-10 11:49:52		
2873	bexbp	28		2014-12-10 11:49:52		
2874	admin	28		2014-12-10 11:49:52		
2875	cfzie	28		2014-12-10 11:49:52		
2876	qywrh	28		2014-12-10 11:49:52		
2877	zeice	28		2014-12-10 11:49:52		
2878	fowai	28		2014-12-10 11:49:52		
2879	plapd	28	BFS approach. Storing diagonals level wise. time O(nm)	2014-12-10 11:49:52		
2880	huiqq	28		2014-12-10 11:49:52		
2881	rdfeo	28		2014-12-10 11:49:52		
2882	ufdxg	28		2014-12-10 11:49:52		
2883	rrmeu	28		2014-12-10 11:49:52		
2884	nhibd	28		2014-12-10 11:49:52		
2885	azmjc	28		2014-12-10 11:49:52		
2886	tenuw	28		2014-12-10 11:49:52		
2887	krxlv	28		2014-12-10 11:49:53		
2888	bexbp	28	This works for NxM matrix. For a given element data(i)(j), the sum of the two indexes ranges between 0 and m+n-1. For a given row in the matrix we need to efficiently compute the start and end column index, which is Min(i, n-1) to Max(0, i-m+1) in descending order.  Implemented in scala:	2014-12-10 11:49:53		
2889	vanul	28		2014-12-10 11:49:53		
2890	fowai	28		2014-12-10 11:49:53		
2891	mrjku	28	how about zig-zag array?	2014-12-10 11:49:53		
2892	nwkeg	28	For m*n matrix	2014-12-10 11:49:53		
2893	nwkeg	28		2014-12-10 11:49:53		
2894	huiqq	28		2014-12-10 11:49:53		
2895	ftfck	28	Solution for N*N and N*M in C++ with vectors:	2014-12-10 11:49:53		
2896	huiqq	28		2014-12-10 11:49:53		
2897	dkebi	28		2014-12-10 11:49:53		
2898	bjsiw	29		2014-12-10 11:49:54		
2899	vanul	29		2014-12-10 11:49:54		
2900	krxlv	29	yep, it's more easier and understandable :)	2014-12-10 11:49:55		
2901	fowai	29	Great solution. I suggest one fix:	2014-12-10 11:49:55		
2902	cfzie	29		2014-12-10 11:49:55		
2903	bexbp	29		2014-12-10 11:49:55		
2904	fmzze	29	Great idea of finding root. I was thinking to dfs with each node and count number of nodes and which has all nodes visited would be root. but this approach is excellent	2014-12-10 11:49:55		
2905	ufdxg	29	After the root 'lifeform', you go next to 'animal', then how do you guarantee the next one is 'animal', and not 'animal'->'fish' or 'animal' ->'bird'?	2014-12-10 11:49:55		
2906	azmjc	29	As of finding the root, it can be done during the tree construction, no need to perform additional operations: 1) introduce a root variable (say currentRoot), set it to null 2) in the tree construction loop: if setOfNotRootElements does not contain parent then currentRoot = parent  At the end currentRoot will be set to the root parent (which was never found among setOfNotRootElements).	2014-12-10 11:49:55		
2907	rdfeo	29	Sorry, the approach I proposed in the previous comment does not work... The original solution is correct :)	2014-12-10 11:49:55		
2908	vanul	29	HashMap or HashSet didn't ensure preserving ordering of the input. We should use LinkedHashMap or LinkedHashSet here.	2014-12-10 11:49:55		
2909	eucmc	29	@kurobi: Not necessary. You find the root, and then you traverse based on the ordering of the children in the List. A List, as you should know, is an ordered data structure.	2014-12-10 11:49:55		
2910	fowai	29		2014-12-10 11:49:55		
2911	rdfeo	29		2014-12-10 11:49:55		
2912	krxlv	29		2014-12-10 11:49:55		
2913	huiqq	29		2014-12-10 11:49:55		
2914	wbqzu	29	Do we can use a prefix tree?  Will look like:-   [root]------------------------------------ | | | lion | | \ | | cat | | | | | mammal bird fish \ | | animal---------|----------------| | lifeform	2014-12-10 11:49:55		
2915	ftfck	29	Do we can use a prefix tree?  Will look like:-  ------------------[root]------ ------|--------------|-------- | -----lion-----------|-------- | ------|--------------|---------| ------cat-----------|-------- | ------|--------------|-------- | ----mammal--- bird----- fish ------|--------------|----------| -----animal-------|----------| ------| lifeform	2014-12-10 11:49:55		
2916	azmjc	29		2014-12-10 11:49:55		
2917	eucmc	29		2014-12-10 11:49:55		
2918	nhibd	29		2014-12-10 11:49:55		
2919	gilit	29		2014-12-10 11:49:55		
2920	fmzze	29		2014-12-10 11:49:55		
2921	ftfck	29		2014-12-10 11:49:56		
2922	rrmeu	29	C++	2014-12-10 11:49:56		
2923	tenuw	29		2014-12-10 11:49:56		
2924	plapd	29		2014-12-10 11:49:56		
2925	rrmeu	29	a bit verbose but simple to follow (I hope)	2014-12-10 11:49:56		
2926	ftfck	29		2014-12-10 11:49:56		
2927	nwkeg	29		2014-12-10 11:49:56		
2928	nwkeg	29		2014-12-10 11:49:56		
2929	cfzie	29		2014-12-10 11:49:56		
2930	krxlv	29	{{ import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.LinkedList; import java.util.List; import java.util.Map;  public class TreePrinter { public static class Relation { String parent; String child;  public Relation(String parent, String child) { this.parent = parent; this.child = child; } }  public static void print(int i, String key) { System.out.println("line " + i + ": " + key); }  public static class Node{ String key; Node parent; List<Node> childlen; Node(String key){ this.key = key; childlen = new LinkedList<Node>(); } public int printOut(int i){ print(i,key); i++; for(Node child:childlen){ i = child.printOut(i); } return i; } } public static void printTree(Iterable<Relation> rs) { // your code Map<String, Node> map = new LinkedHashMap<String, Node>(); for (Relation r : rs) { Node parent = map.get(r.parent); if(parent == null){ parent = new Node(r.parent); map.put(r.parent, parent); } Node child = map.get(r.child); if(child == null){ child = new Node(r.child); map.put(r.child, child); } parent.childlen.add(child); child.parent = parent; } int index = 1; for (String key : map.keySet()) { if (map.get(key).parent == null) { index = map.get(key).printOut(index); } } }  public static void main(String[] argv) { List<Relation> input = new ArrayList<Relation>(); input.add(new Relation("animal", "mammal")); input.add(new Relation("animal", "bird")); input.add(new Relation("lifeform", "animal")); input.add(new Relation("cat", "lion")); input.add(new Relation("mammal", "cat")); input.add(new Relation("animal", "fish")); printTree(input); } }  }}	2014-12-10 11:49:56		
2931	azmjc	29		2014-12-10 11:49:56		
2932	plapd	29		2014-12-10 11:49:56		
2933	tenuw	29	Very simple and clear solution. Get the root and do a DFS using adjacency list as tree data structure.	2014-12-10 11:49:56		
2934	azmjc	29	I love first solution. Anyway, I have implemented the other option, creating a homemade TreeNode quite simple.	2014-12-10 11:49:56		
2935	qywrh	29		2014-12-10 11:49:56		
2936	rdfeo	29		2014-12-10 11:49:56		
2937	ufdxg	29		2014-12-10 11:49:56		
2938	dkebi	29		2014-12-10 11:49:56		
2939	admin	29	Is it making a tree from list and then doing dfs.?	2014-12-10 11:49:56		
2940	ftfck	30	call	2014-12-10 11:49:58		
2941	rdfeo	30		2014-12-10 11:49:58		
2942	vanul	30		2014-12-10 11:49:58		
2943	rrmeu	30		2014-12-10 11:49:58		
2944	xhgls	30		2014-12-10 11:49:58		
2945	nhibd	30	Is there any chance to optimize, e.g. DP?	2014-12-10 11:49:58		
2946	bexbp	30	What is the complexity of this?	2014-12-10 11:49:58		
2947	bexbp	30	Basically, just go through the string recursively, always eating one and two characters (where possible).	2014-12-10 11:49:58		
2948	krxlv	30		2014-12-10 11:49:58		
2949	tenuw	30		2014-12-10 11:49:58		
2950	jippy	30	Looks good to me. How long did it take you ? I had roughly 30 minutes to finish this on whiteboard and I didn't do a good job.	2014-12-10 11:49:58		
2951	dgjji	30	@Anonymous: small correction....... your code doesn't work for "1020". or any input that can have 10/20.  Here is the working and modified code.....   package com.rakesh.topcoder;  import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Scanner; import java.util.Set;  public class GenAlphabetCodes {  public static void main(String[] args) { // TODO Auto-generated method stub  Scanner input = new Scanner(System.in); System.out .println("Please enter any length number but combination of 1 to 26 ....... "); String val = input.next();  System.out.println("All possible Alphabet codes for the give Number: " + val); for (String string : decode(val)) { System.out.println(string); }  }  public static Set<String> decode(String in) { char curChar = 'a'; Map<Integer, Character> numberToChar = new HashMap<Integer, Character>(); for (int i = 1; i <= 26; i++) { numberToChar.put(i, curChar); curChar++; } return decodeHelper(numberToChar, in, 0, new ArrayList<Character>()); }  private static Set<String> decodeHelper( Map<Integer, Character> numberToChar, String in, int charAt, ArrayList<Character> arrayList) { Set<String> result = new HashSet<String>(); if (charAt >= in.length()) { String str = ""; for (char c : arrayList) { str += c; } result.add(str); return result; } else { int charCode = Integer.valueOf(in.charAt(charAt) + ""); if (charCode == 0) { int precCharCode = Integer.valueOf(in.charAt(charAt - 1) + ""); if (precCharCode == 1) charCode = 10; if (precCharCode == 2) charCode = 20; } char curChar = numberToChar.get(charCode); arrayList.add(curChar); result.addAll(decodeHelper(numberToChar, in, charAt + 1, arrayList)); arrayList.remove(arrayList.size() - 1); if (in.length() > charAt + 1) { charCode = Integer.valueOf(in.substring(charAt, charAt + 2)); if (charCode <= 26) { curChar = numberToChar.get(charCode); arrayList.add(curChar); result.addAll(decodeHelper(numberToChar, in, charAt + 2, arrayList)); arrayList.remove(arrayList.size() - 1); } } } return result; } }  Output: Please enter any digit number but combination of 1 to 26 ....... 2010 All possible Alphabet codes for the give Number: 2010 taj baj btj tj btaj	2014-12-10 11:49:58		
2952	plapd	30	Can you explain how the code baj is generated?	2014-12-10 11:49:58		
2953	wbqzu	30	Also, if we make the assumption that the string contains zeros, then the code should handle cases like 20010. The code above doesn't.	2014-12-10 11:49:58		
2954	cfzie	30	Non recursive Java code:	2014-12-10 11:49:58		
2955	eucmc	30		2014-12-10 11:49:58		
2956	mrjku	30		2014-12-10 11:49:58		
2957	rdfeo	30	Yeah, so you can recursively solve the sub-problems and memoize the results using dynamic programming. In other words:	2014-12-10 11:49:58		
2958	jippy	30		2014-12-10 11:49:58		
2959	nwkeg	30		2014-12-10 11:49:58		
2960	eucmc	30	I am getting only the value 3 as the output for different inputs.	2014-12-10 11:49:58		
2961	huiqq	30	That's right. Try with "123123".	2014-12-10 11:49:59		
2962	bexbp	30	Output for "123123" is 9 and rightly so.	2014-12-10 11:49:59		
2963	wbqzu	30	This looks right. It is O(n) time and O(n) space.  I won't comment on the code though.	2014-12-10 11:49:59		
2964	bexbp	30	@Loler: anything wrong with the code/style? Feedback is most welcome.	2014-12-10 11:49:59		
2965	fowai	30	Ok, since you asked here are a few comments, one major, on neither major nor minor and the rest minor/nitpicks.  1) Major objection: You are making the caller of count_valid be responsible for allocating and passing in the array. Leaky interface. Can lead to bugs/unmodular code, in fact, see point 2 below.  2) You are not freeing memory. (You could argue that the program is exiting anyway, but then your program is not of much use then :-))  3) The use of substr, strncpy and atoi could _possibly_ end up pulling in unnecessary libs. (Perhaps not the case, but who knows).  4) You can get rid of the recursion: see one of the other answers which talks about a simple linear time algorithm, which is essentially the same (scan from left to right, instead of right to left), but is not recursive. Of course, your intent was probably to demonstrate recursion + memoization.  5) You are allocating an array of size+1 ( I suppose for cleaner count_valid) when you don't really need the extra byte, a potential sign that the code could be rewritten better. In fact if you try to get rid of the recursion, you will probably see that you will get clean code without this extra byte problem.  6) The use of -1 to denote unmemoized sub-problems (you have lost the ability to use an unsigned type there, for instance). You are in effect mixing data with metadata.  7) If this was C++ (which I am presuming not, hence minor comment), you are missing the const on str.  8) If this was C++, you don't need to declare i in main specifically. Scope it to the for loop. In fact the later C standards also support that I think.  The main problem is 1 (and to some extent 2), and the rest you can dismiss as nitpicks/irrelevant/wrong/clueless if you want.  Also, I do understand this was just a quick code to demonstrate what you were saying, but you asked for feedback :-)	2014-12-10 11:49:59		
2966	admin	30	Thanks Loler... appreciate your inputs!	2014-12-10 11:49:59		
2967	cfzie	30	f('101126') = 5, but get 8  or  f('101110') = 2, but get 3	2014-12-10 11:49:59		
2968	azmjc	30		2014-12-10 11:49:59		
2969	rdfeo	30		2014-12-10 11:49:59		
2970	nwkeg	30	In this case, you are saying that an empty string has one interpretation, but I would argue that it has zero valid interpretations. Why do you return one interpretation here?	2014-12-10 11:49:59		
2971	cfzie	30	@Raffi: That is kind of the "base case". We need it for the recursion to work.	2014-12-10 11:49:59		
2972	plapd	30	@chisingh you didn't use "array" ? Is it for getting back all the combinations?If yes can you show how you plan to use it?	2014-12-10 11:49:59		
2973	dgjji	30	the purpose of 'array' is this:	2014-12-10 11:49:59		
2974	qywrh	30		2014-12-10 11:49:59		
2975	fowai	30		2014-12-10 11:49:59		
2976	ufdxg	30	Just to remember the results of subproblems, and not re-calculate them. You could do it in other ways also, as suggested by Loler.	2014-12-10 11:49:59		
2977	zeice	30	This has a simple linear time algorithm. say the string is given as an array a[1...n]  You maintain another array which maintains the valid counts of prefixes, count[k] = valid count of a[1...k].  Now you scan a from 1 to n.  When you are considering j, there two possible splits involving j which end a j: "a[1...j-1]" :"a[j]" or "a[1...j-2]" : "a[j-1] a[j]"  Now all you need to do is add the relevant counts (already computed till j-1 in count array)	2014-12-10 11:49:59		
2978	huiqq	30	this is ok but how do you plan to write an algo for this?	2014-12-10 11:49:59		
2979	rrmeu	30		2014-12-10 11:49:59		
2980	azmjc	30		2014-12-10 11:49:59		
2981	nwkeg	30	Time complexity of this would be horrible.	2014-12-10 11:49:59		
2982	mrjku	30		2014-12-10 11:49:59		
2983	admin	30		2014-12-10 11:49:59		
2984	tenuw	30	Cool feature of python.	2014-12-10 11:49:59		
2985	gilit	30	The solution is more like fibonaci series where there is a choice F(n) = F(n-1)+F(n-2) or F(n) = F(n-1) and the condition is atoi(string[n-1] string[n] ) < 27	2014-12-10 11:49:59		
2986	huiqq	30		2014-12-10 11:50:00		
2987	ewigy	30		2014-12-10 11:50:00		
2988	rrmeu	30	Here is a simple code with recursion	2014-12-10 11:50:00		
2989	nhibd	30		2014-12-10 11:50:00		
2990	sqzqo	30		2014-12-10 11:50:00		
2991	sqzqo	30	It doesn't work for this input: "101523"  Output list cannot contain a. It must start with j since 10=a. But pretty close.	2014-12-10 11:50:00		
2992	vanul	30	@diffuser78 i have modified the code to handle such cases. Here it is. Also tell me if there is any other case i have missed in valid inputs (i have considered valid inputs only)	2014-12-10 11:50:00		
2993	ftfck	30		2014-12-10 11:50:00		
2994	mrjku	30		2014-12-10 11:50:00		
2995	admin	30	Works like a charm for most cases except these. Still a pretty good job.  "110203"	2014-12-10 11:50:00		
2996	xhgls	30		2014-12-10 11:50:00		
2997	mrjku	30		2014-12-10 11:50:00		
2998	ewigy	30	In python:	2014-12-10 11:50:00		
2999	rdfeo	30		2014-12-10 11:50:00		
3000	ufdxg	30		2014-12-10 11:50:00		
3001	xhgls	30	Generally, because there are some recomputations on the subproblems, we can use a hash map to store the sub solutions. The recursive calls on each string are sometimes called twice(because there might be combination of two numbers which are possible to map to a char) , and combine the two sub solutions into one, and then return.	2014-12-10 11:50:00		
3002	nhibd	30	This has an O(n) time and O(1) space algorithm, by noting that there are locations where only one choice is possible, which causes "breaks" and valid counts for substrings without breaks are fibonacci numbers.	2014-12-10 11:50:00		
3003	ewigy	30		2014-12-10 11:50:00		
3004	admin	30		2014-12-10 11:50:00		
3005	admin	30	It is failing in few cases. for 1221 it is returning 4. But the answer is 5 abba,lba,ava,abu,lu	2014-12-10 11:50:00		
3006	rrmeu	30		2014-12-10 11:50:00		
3007	bjsiw	30		2014-12-10 11:50:00		
3008	vanul	30		2014-12-10 11:50:00		
3009	rrmeu	30		2014-12-10 11:50:00		
3010	dkebi	30		2014-12-10 11:50:00		
3011	cfzie	30		2014-12-10 11:50:00		
3012	cfzie	30	And in linear time:	2014-12-10 11:50:00		
3013	eucmc	30		2014-12-10 11:50:00		
3014	fowai	30		2014-12-10 11:50:00		
3015	admin	30	Your company has got a project for developing a software system. A similar software system was developed in your previous company. You discover that your company's interpretation of requirements is different from the interpretation taken by your previous company. Cost of project will tremendously increase if ambiguities in requirements are not resolved. You have also an ethical responsibility of confidentiality to your previous company. Discuss what you should do in such a situation? :please help me in this topic and give me the answer solution because i am a juniour student of computer science	2014-12-10 11:50:01		
3016	fmzze	30	char arr[]={'-','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};  public void method2(String till,int numbers[],int from){ if(from==numbers.length){ System.out.println(till); return ; } char c=arr[numbers[from]]; method(till+c,numbers,from+1);  if((from<numbers.length-1)&&(numbers[from]*10+numbers[from+1])<=26){ method(till+arr[numbers[from]*10+numbers[from+1]], numbers, from+2);  }  } public static void main(String args[]){ stringval sv=new stringval(); int num[]={1,2,1,1}; sv.method2("",num,0);  }	2014-12-10 11:50:01		
3017	cfzie	30	Dynamic programming solution. O(n) time, O(n) space, can be optimized to O(1) space by just remembering the previous two values in the array.	2014-12-10 11:50:01		
3018	zeice	30		2014-12-10 11:50:01		
3019	admin	30		2014-12-10 11:50:01		
3020	sqzqo	30	Good observation.	2014-12-10 11:50:01		
3021	nwkeg	30	#include<iostream> #include<cstring> using namespace std; static int i=0; int numberstring(char*); int main() { char s[100]; cin>>s; if((s==NULL)||(strlen(s)==0)) return 0; else {i++;numberstring(s);} cout<<"number of strings "<<i<<endl; } int numberstring(char* s) { if((strlen(s))>1) { if((*s-'0')>2) numberstring(++s); else { char *t=s;t++; if(((*s-'0')==2)&&((*t-'0')>6)) numberstring(t); else { i++; if ((*t-'0')==0) { i--; if(strlen(t)>1) numberstring(++t);} else { if(strlen(t)>1) {char *r=t; if(*++r=='0') i--;numberstring(t);} } } } } }	2014-12-10 11:50:01		
3022	ewigy	30	O(1) space and time:	2014-12-10 11:50:01		
3023	bjsiw	30		2014-12-10 11:50:01		
3024	krxlv	30		2014-12-10 11:50:01		
3025	gilit	30	Could you please explain how this code works?	2014-12-10 11:50:01		
3026	ftfck	30	{ class FacebookQ1 { public static void GetInterpretationCount(int[] l) { Node head = new Node(); AddChild(head, 0, l); int x = FindCount(head); }   static void AddChild(Node n, int pos, int[] l) { if (pos < l.Length) { char y = (char)(l[pos] + 64); n.left = new Node(y); AddChild(n.left, pos + 1, l); if (pos + 1 < l.Length) { int x = l[pos] * 10 + l[pos + 1]; if (x <= 26) { n.right = new Node((char)(x + 64)); AddChild(n.right, pos + 2, l); } } } } private static int FindCount(Node head) { int x = 0; int y = 0; if (head.left != null) { x += FindCount(head.left); } if (head.right != null) { y += FindCount(head.right); } if (head.right == null && head.left == null) { return 1; } return x + y; } } class Node { public Node() { } public Node(char x) { c = x; } public char c; public Node left; public Node right; } }	2014-12-10 11:50:01		
3027	sqzqo	30	My code in C, linear time and space	2014-12-10 11:50:01		
3028	bjsiw	30		2014-12-10 11:50:01		
3029	admin	30		2014-12-10 11:50:01		
3030	sqzqo	30	My code in C, linear time and space	2014-12-10 11:50:01		
3031	zeice	30		2014-12-10 11:50:01		
3032	rdfeo	30		2014-12-10 11:50:01		
3033	krxlv	30	let us do it recursively.please correct me if I am wrong a[0...n-1] now add a[n].then let A(n-1) be the number of valid interpretations.then A(n)=A(n-1)+A(n-2) if a[n-1]<3 else A(n-1)+1.Hence we can do it by dynamic programming	2014-12-10 11:50:01		
3034	vanul	30		2014-12-10 11:50:01		
3035	dkebi	30		2014-12-10 11:50:01		
3036	huiqq	30	I think the problem can be solved recursively as stated previously and also iteratively. Iterative version is presumably tough to do.  Full implementation of recursive method in java is given below.	2014-12-10 11:50:01		
3037	admin	30		2014-12-10 11:50:01		
3038	ufdxg	30		2014-12-10 11:50:02		
3039	dkebi	30	Below is the code using Iterative approach.  1. Find all combinations sum to string length using 1's & 2's 2. Find possible words for each combination	2014-12-10 11:50:02		
3040	cfzie	30		2014-12-10 11:50:02		
3041	dkebi	30		2014-12-10 11:50:02		
3042	huiqq	30		2014-12-10 11:50:02		
3043	wbqzu	30		2014-12-10 11:50:02		
3044	azmjc	30		2014-12-10 11:50:02		
3045	cfzie	30		2014-12-10 11:50:02		
3046	fowai	30	o/p = 1> ['aabc', 'kbc', 'alc', 'aaw', 'kw'] 2> ['jaebc', 'jobc', 'jaew', 'jow'] 3> ['jt']	2014-12-10 11:50:02		
3047	wbqzu	30		2014-12-10 11:50:02		
3048	eucmc	30		2014-12-10 11:50:02		
3049	rrmeu	30		2014-12-10 11:50:02		
3050	cfzie	30		2014-12-10 11:50:02		
3051	gilit	30	there is no need to use hashmap we can simply use recursion by taking one and two char if possible and print it.	2014-12-10 11:50:02		
3052	vanul	30		2014-12-10 11:50:02		
3053	bexbp	30		2014-12-10 11:50:02		
3054	admin	30	For any query mail me at sahilkb23@gmail.com This code was compiled using Dev-Cpp	2014-12-10 11:50:02		
3055	xhgls	30		2014-12-10 11:50:02		
3056	admin	30		2014-12-10 11:50:02		
3057	bjsiw	30	#include <iostream>  using namespace std;  void print(int n[],char s[],int nn,int ns,int num) { if(nn==num) { s[ns]='\0'; cout<<"\n"<<s; return; } if(n[nn]==0) { print(n,s,nn+1,ns,num); return; } s[ns]=(char)(n[nn]+64); print(n,s,nn+1,ns+1,num); if(ns<num-1) { int a=n[nn]*10+n[nn+1]; if(a<=26) { s[ns]=(char)(a+64); print(n,s,nn+2,ns+1,num); } } } int main() { int n[]={1,1,0,2,0,3}; int size=sizeof(n)/sizeof(int); char *s=new char[size+5]; print(n,s,0,0,size); return 0; }	2014-12-10 11:50:02		
3058	cfzie	30	good one works for all case	2014-12-10 11:50:02		
3059	krxlv	30	Javascript Solution  {{ function getLetterRankWords(str) { var letterRanks = {}; var alphabet = 'abcdefghijklmnopqrstuvwxyz'; for (var i = 0; i < alphabet.length; i++) { letterRanks[ i+1 ] = alphabet[i]; }  var results = {};  var gobbleString = function(str, remainingStr, posToConsider) { if (remainingStr === "") { results[str] = true; return; }  if (posToConsider === 2 && remainingStr.length >= 2) { // Consider the next two numbers var nextTwoNum = parseInt( remainingStr[0] + remainingStr[1], 10 ); var letter = letterRanks[ nextTwoNum ]; if (letter) { gobbleString(str + letter, remainingStr.substring(2), 1); if (remainingStr.length >= 2) { gobbleString(str + letter, remainingStr.substring(2), 2); } } } else { var letter = letterRanks[ parseInt(remainingStr[0], 10) ]; if (letter) { gobbleString(str + letter, remainingStr.substring(1), 1); if (remainingStr.length >= 2) { gobbleString(str + letter, remainingStr.substring(1), 2); } } } }  gobbleString("", str, 1); if (str.length >= 2) { gobbleString("", str, 2); }  return Object.keys(results); } getLetterRankWords('1123'); }}	2014-12-10 11:50:02		
3060	ethan	30		2014-12-10 11:50:03		
3061	dkebi	30		2014-12-10 11:50:03		
3062	admin	30	f (n) = f(n-1) {if a[n] is not zero} + f(n-2) {if a[n-1]*10+a[n] <= 26} [f denotes no of ways] 1. Take two vectors v1 , v2 2. append a[0] to v1 3. i = 1 4. if a[i] is not zero, append a[i] to v1, else clear vector v1 5. if (b = a[i-1]*10+a[i]) <= 26 && >= 10, append b to v2; else clear vector v2 6. swap v1 & v2 7. i++, repeat step 4 till end 8. return v1 union v2	2014-12-10 11:50:03		
3063	vanul	30	my solution. Maybe is a duplicate of other people's solution.	2014-12-10 11:50:03		
3064	sqzqo	30		2014-12-10 11:50:03		
3065	wbqzu	30		2014-12-10 11:50:03		
3066	nwkeg	30	Solution using backtracking:  #include <stdio.h>  void print(int N, char *s, int i) { int j; if (N == 0) { for(j=(i-1);j>=0;j--) { printf("%c",s[j]); } printf("\n"); } else { s[i] = 96 + N % 10; i++; print(N/10, s, i); i--;  if ((N % 100 > 9) && (N % 100 <= 26)) { s[i] = 96 + N % 100; i++; print(N/100, s, i); } } }  int main() { int N; char s[100]; scanf("%d",&N); print(N,s,0); return 0; }	2014-12-10 11:50:03		
3067	xhgls	30		2014-12-10 11:50:03		
3068	admin	30		2014-12-10 11:50:03		
3069	sgiwy	30	The solution is based on the creation of a binary tree, left branch values smaller than the node, right branch values greater than the node and smaller than 26. A visitor then will visit the tree and create all the strings based on the path.	2014-12-10 11:50:03		
3070	bexbp	30		2014-12-10 11:50:03		
3071	eucmc	30		2014-12-10 11:50:03		
3072	eucmc	30		2014-12-10 11:50:03		
3073	ethan	30		2014-12-10 11:50:03		
3074	sgiwy	30	Visitor that print all the possible strings:	2014-12-10 11:50:03		
3075	krxlv	30		2014-12-10 11:50:03		
3076	vanul	30		2014-12-10 11:50:03		
3077	ufdxg	30	Here is another visitor that print the tree structure:	2014-12-10 11:50:03		
3078	admin	30		2014-12-10 11:50:03		
3079	gilit	30		2014-12-10 11:50:03		
3080	bjsiw	30	Output:	2014-12-10 11:50:03		
3081	mrjku	30		2014-12-10 11:50:03		
3082	wbqzu	30		2014-12-10 11:50:04		
3083	sqzqo	30	using System; using System.Collections.Generic; using System.Linq; using System.Text;  namespace printAllCombo { class Program { static void printCombo(string input,int index,string stringToPrint,int tempIndex) { if (tempIndex == input.Length-1) { Console.WriteLine("String:"+stringToPrint); return; } for (int i = index; i < input.Length; i++) {  int temp=int.Parse(input.Substring(index, i-index+1)); if (i + 1 < input.Length && input[i + 1] == '0') {if((temp*10)>=1 && (temp*10)<=26) { i++; printCombo(input, i + 1, stringToPrint + (char)((temp*10) + 'a' - 1), i); } } else { if (temp >= 1 && temp <= 26) { printCombo(input, i + 1, stringToPrint + (char)(temp + 'a' - 1), i); } } } } static void Main(string[] args) {  printCombo("110203", 0, "", 0); Console.Read(); } } }	2014-12-10 11:50:04		
3084	nwkeg	30		2014-12-10 11:50:04		
3085	sqzqo	30		2014-12-10 11:50:04		
3086	azmjc	30	/// Just another recursive solution. Who know iterative solution? Plz show me.	2014-12-10 11:50:04		
3087	dkebi	30		2014-12-10 11:50:04		
3088	rrmeu	30		2014-12-10 11:50:04		
3089	ethan	30		2014-12-10 11:50:04		
3090	ftfck	30		2014-12-10 11:50:04		
3091	huiqq	30	{{using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks;  namespace Puzzle2 { class Program { /*If a=1, b=2, c=3,....z=26. Given a string, find all possible codes that string can generate. Give a count as well as print the strings.  For example: Input: "1123". You need to general all valid alphabet codes from this string.  Output List aabc //a = 1, a = 1, b = 2, c = 3 kbc // since k is 11, b = 2, c= 3 alc // a = 1, l = 12, c = 3 aaw // a= 1, a =1, w= 23 kw // k = 11, w = 23*/ public static Dictionary<int, char> map = new Dictionary<int,char>(); static void Main(string[] args) { for (int i = 1; i <= 26; i++) { map[i] = (char)('a' + (i - 1)); } PrintCodes(string.Empty, "1123"); Console.ReadKey(); }  public static void PrintCodes(string codePrefix, string subString) { if(subString.Length==0) Console.WriteLine(codePrefix);  for (int i = 1; i <= 2; i++) { if (i > subString.Length) break; else if (i == subString.Length) Console.WriteLine(codePrefix + map[int.Parse(subString)].ToString()); else { string subSubString = subString.Substring(0, i); string codePre = map[int.Parse(subSubString)].ToString(); PrintCodes(codePrefix + codePre, subString.Substring(i)); }  } } } } }}	2014-12-10 11:50:04		
3092	rdfeo	30		2014-12-10 11:50:04		
3093	eucmc	30		2014-12-10 11:50:04		
3094	tenuw	30		2014-12-10 11:50:04		
3095	xhgls	30		2014-12-10 11:50:04		
3096	jippy	30		2014-12-10 11:50:04		
3097	jippy	30		2014-12-10 11:50:04		
3098	vanul	30	Its a simple backtracking question...here is my c++ code for it...	2014-12-10 11:50:04		
3099	nwkeg	30		2014-12-10 11:50:04		
3100	fowai	30		2014-12-10 11:50:04		
3101	jippy	30		2014-12-10 11:50:04		
3102	qywrh	30		2014-12-10 11:50:04		
3103	dkebi	30	My implementation in ruby	2014-12-10 11:50:04		
3104	gilit	30		2014-12-10 11:50:05		
3105	fowai	30		2014-12-10 11:50:05		
3106	huiqq	30		2014-12-10 11:50:05		
3107	ftfck	30		2014-12-10 11:50:05		
3108	fmzze	30	Sorry !it should be dfs(s,0,x) instead of dfs(s,0,0) and x should be an empty string initialized in main()	2014-12-10 11:50:05		
3109	fowai	30	A simple dfs implementation	2014-12-10 11:50:05		
3110	gilit	30		2014-12-10 11:50:05		
3111	zeice	30		2014-12-10 11:50:05		
3112	rdfeo	30	DP, O(n), with python	2014-12-10 11:50:05		
3113	sqzqo	30		2014-12-10 11:50:05		
3114	vanul	30		2014-12-10 11:50:05		
3115	zeice	30	A really simple recursive code in python:  str_list = []  def str_map(str1, f_str, i): if i == len(str1): str_list.append(f_str)  if i < len(str1): t_str = list(f_str) t_str.append(chr(96+int(str1[i])))  str_map(str1, t_str, i+1)  if i+1 < len(str1): t1_str = list(f_str) t1_str.append(chr(96+int(str1[i:i+2]))) str_map(str1, t1_str, i+2)   def test(): str1 = "1123" str_map(str1, [], 0) print str_list  test()	2014-12-10 11:50:05		
3116	ewigy	30	Following code works on all inputs, even corner cases which include 0 in the input string. I have assumed that if more than two consecutive 0's occur in the input string, there is no valid interpretation of the given string since we do not have any character which maps to 0.	2014-12-10 11:50:05		
3117	rdfeo	30		2014-12-10 11:50:05		
3118	jippy	30		2014-12-10 11:50:05		
3119	vanul	30		2014-12-10 11:50:05		
3120	jippy	30		2014-12-10 11:50:05		
3121	zeice	30		2014-12-10 11:50:05		
3122	admin	30		2014-12-10 11:50:05		
3123	rdfeo	30	Here's a python implementation	2014-12-10 11:50:05		
3124	dkebi	30		2014-12-10 11:50:05		
3125	plapd	30		2014-12-10 11:50:05		
3126	qywrh	30	Here's my dynamic approach in python (repost after signing in)	2014-12-10 11:50:05		
3127	krxlv	30		2014-12-10 11:50:05		
3128	nwkeg	30		2014-12-10 11:50:05		
3129	ewigy	30		2014-12-10 11:50:05		
3130	gilit	30		2014-12-10 11:50:05		
3131	rrmeu	30		2014-12-10 11:50:05		
3132	gilit	30		2014-12-10 11:50:06		
3133	krxlv	30	somebody please explain the algorithm to solve this problem rather than source code.	2014-12-10 11:50:06		
3134	xhgls	30	somebody please explain the algorithm to solve it rather than the code	2014-12-10 11:50:06		
3135	wbqzu	30	look up Depth First Search and watch some youtube videos about it. They will be a lot better than whatever i would write.	2014-12-10 11:50:06		
3136	huiqq	30		2014-12-10 11:50:06		
3137	ewigy	30		2014-12-10 11:50:06		
3138	admin	30	Recursion + DP	2014-12-10 11:50:06		
3139	rrmeu	30	here my C++ solution:	2014-12-10 11:50:06		
3140	admin	30		2014-12-10 11:50:06		
3141	ftfck	30		2014-12-10 11:50:06		
3142	dkebi	30	The following is my solution in Objective-C	2014-12-10 11:50:06		
3143	nhibd	30		2014-12-10 11:50:06		
3144	mrjku	30		2014-12-10 11:50:06		
3145	jippy	30	Test case:	2014-12-10 11:50:06		
3146	vanul	30		2014-12-10 11:50:06		
3147	mrjku	30		2014-12-10 11:50:06		
3148	xhgls	30	I modified my code, to fix error when "0" is in the codes	2014-12-10 11:50:06		
3149	dgjji	30		2014-12-10 11:50:06		
3150	ewigy	30		2014-12-10 11:50:06		
3151	admin	30	The correct code in C++. Enjoy!	2014-12-10 11:50:06		
3152	cfzie	30		2014-12-10 11:50:06		
3153	sgiwy	30		2014-12-10 11:50:06		
3154	ethan	30	PHP version:	2014-12-10 11:50:06		
3155	admin	30		2014-12-10 11:50:06		
3156	rrmeu	30		2014-12-10 11:50:07		
3157	nhibd	30	Here's a recursive solution in Objective-C, composed of two classes:  1. `NSString (CCPCharacterCode)` is a category on `NSString` that converts a string between `@"1"` and `@"26"` to a string containing an letter between `@"a"` and `@"z"`. 2. `CCPCodeParser` parses a code and stores the results in a `results` property.  I believe the complexity is `O(n^2)`, but I'm not 100% sure.	2014-12-10 11:50:07		
3158	nhibd	30		2014-12-10 11:50:07		
3159	ewigy	30		2014-12-10 11:50:07		
3160	vanul	30		2014-12-10 11:50:07		
3161	vanul	30		2014-12-10 11:50:07		
3162	mrjku	30		2014-12-10 11:50:07		
3163	ufdxg	30		2014-12-10 11:50:07		
3164	vanul	30		2014-12-10 11:50:07		
3165	tenuw	30		2014-12-10 11:50:07		
3166	rrmeu	30	I forgot to include the test file:	2014-12-10 11:50:07		
3167	sgiwy	30		2014-12-10 11:50:07		
3168	jippy	30		2014-12-10 11:50:07		
3169	fmzze	30	There's two steps (assuming you only have digits 1-9)  1. Create a partition of the numbers: for example, 6121371 is partitioned into (6,1213,7,1). This is straightforward by walking through two digits at a time, and splitting in the middle if the number is greater than 26.  In Python this takes two lines:	2014-12-10 11:50:07		
3170	rrmeu	30		2014-12-10 11:50:07		
3171	nwkeg	30		2014-12-10 11:50:07		
3172	plapd	30		2014-12-10 11:50:07		
3173	mrjku	30		2014-12-10 11:50:07		
3174	dgjji	30	2. At this point you only have to get the possible combinations on each partition; this can be done (for example) with DP or just walking through it in O(K^2) time, where K is the size of the partition. If max(K) << N (length of the full string), e.g. for randomly-chosen digits, the walkthrough in Step 1 of O(N) dominates. Worst-case scenario the digits aren't randomly chosen (e.g. there's lots of 1's and 2's) and you're dealing with O(N^2)	2014-12-10 11:50:07		
3175	sgiwy	30	The simplest solution	2014-12-10 11:50:07		
3176	nhibd	30		2014-12-10 11:50:07		
3177	admin	30		2014-12-10 11:50:07		
3178	bjsiw	30		2014-12-10 11:50:07		
3179	ufdxg	30		2014-12-10 11:50:07		
3180	krxlv	30	By using recursion: From each position we move by 1 and then by 2 positions:	2014-12-10 11:50:08		
3181	gilit	30		2014-12-10 11:50:08		
3182	ftfck	30		2014-12-10 11:50:08		
3183	fmzze	30	Thank you	2014-12-10 11:50:08		
3184	zeice	30		2014-12-10 11:50:08		
3185	rdfeo	30		2014-12-10 11:50:08		
3186	rdfeo	30	Why was this down voted ? Seems to be working fine...	2014-12-10 11:50:08		
3187	plapd	30	May be if the input contains 0 you need to check for the same	2014-12-10 11:50:08		
3188	tenuw	30		2014-12-10 11:50:08		
3189	jippy	30		2014-12-10 11:50:08		
3190	wbqzu	31	DFS	2014-12-10 11:50:21		
3191	plapd	31		2014-12-10 11:50:21		
3192	azmjc	31		2014-12-10 11:50:21		
3193	krxlv	31	}	2014-12-10 11:50:21		
3194	bjsiw	31	I think this is a reasonable solution. Brilliant!	2014-12-10 11:50:21		
3195	mrjku	31	What if sort the server and tasks first to reduce the run time?	2014-12-10 11:50:21		
3196	gilit	31	Yep sorting is good idea to omit dfs checks on the same sized tasks (and servers)	2014-12-10 11:50:21		
3197	admin	31	There are two loops for each level of recursion, which means O(n^2 * (n-1)^2 * (n-2)^2 ....), which means O(n ^ n)? Am I wrong?	2014-12-10 11:50:21		
3198	krxlv	31	Recursive solution is not preferred, they are rarely used in production code.  Greedy soln: 1. Use two max heaps, one for storing all remaining capacities of servers and one for storing tasks. 2. Pop max. task from tasks' heap and subtract max. task length from the max. server. If remaining capacity of server becomes zero, delete the element. Max heapify both heaps. 3. Do this untill the tasks heap is finished or max. task length is greater than max. server capacity.  Ofcourse, you have to prove this greedy algo. is optimal.  Complexity: O(nlogn + mlogm)	2014-12-10 11:50:21		
3199	jippy	31	Server capacity limits: 1, 3 Task capacity needs: 4  In this case, the above code returns 'true' that is not expected behavior.  servers[j] >= tasks[i] needs be changed into '>'?	2014-12-10 11:50:21		
3200	huiqq	31	The greedy solution proposed above fails for e.g: Servers: 8,24 Tasks: 6,6,6,6,8. It would assign 8 to 24,then assign two more sixes to 24. It would then be left with two tasks of size 6 and a server of cap 8, so it would return false. Obviously you can solve the above problem by assigning all 6s to server 24, and 8 to server 8.	2014-12-10 11:50:21		
3201	tenuw	31	Just adding a minor comment that this problem is NP-complete, i.e, let's assume you have a general case with N servers and M tasks and let the capacity of all servers be the same. Then, the question whether or not you can fit all tasks inside servers is equivalent to packing M stones in N bins, i.e., you are answering a general instance of the bin-packing problem. If you can make it work with N, then you keep reducing N until you find the smallest number of servers.  That being said, the recursive DFS, i.e., backtracking is the best bet as far as I can tell.	2014-12-10 11:50:21		
3202	tenuw	31	Looks like a Max-Flow problem to me. Let J be the group of jobs and W be the list of work servers.  1. Create a graph so that each job is a node and each worker is a node. 2. Create an Edge between each job node and each server node iff that worker's capacity is less than or equal to the task's requirements, set the value of each edge to be the job requirements. 3. Add a node S, and an edge from S to each task node in T and set the value to infinity (or Integer.MAX_VALUE).. 4. Add a node T, and an edge from each worker in W to T. set the value of each edge to be the capacity of the worker. 5. Run a max flow algorithm (e.g. Ford Fulkerson) and return "True" iff the max flow of the graph equals the sum of all the jobs in J.	2014-12-10 11:50:21		
3203	krxlv	31	This will not work because in max-flow problem you could divide the flow from a job node to multiple worker nodes, but this is not allowed in the problem. You cannot have half the job running on one server and other half on other server.	2014-12-10 11:50:21		
3204	zeice	31	Flow network is really a great idea though your solution actually doesn't suits for the problem as gimli said above. I think flow network could work for this problem with some modify on your method	2014-12-10 11:50:21		
3205	zeice	31		2014-12-10 11:50:21		
3206	fmzze	31		2014-12-10 11:50:21		
3207	ethan	31	I think this is the correct solution, but can you also explain this. I am not very familiar with this programming language, but seems like you are filling the server with tasks going in descending order of capacity. If you fail to fit a task at any stage, you back track and try next server until you either find a solution or run out of all servers to try.	2014-12-10 11:50:21		
3208	fowai	31	@Solomon Yang In point of view giving a code directly for a problem is not going to be so much worthy , please give your algorithm and let the other code it. It will also give a better understanding of solution in quick time . Btw thanx for solution.	2014-12-10 11:50:21		
3209	ftfck	31	This is a basic recursive algorithm. It will definitely work. What the code does is 1. Assigns the largest job to a server(i) 2. Recurse on the remaining set of jobs and new server capacities(modified server capacity i) 3. If the recursive problem can be solved, we get a solution for the problem else assigns the ith job to another server  Complexity Each job can be assigned to any of the servers So it looks like O(#servers^#jobs)	2014-12-10 11:50:21		
3210	fmzze	31	first sort the task capacity needs in descending order and try to find best fit for each task capacity needs. where best fit is min of capacity greater than equal to the task capacity need eg- capacity limits- 8,16,8,32 after sorting task capacity needs - 18,8,8,8,6,6,4,4 1)best fit for 18 is min no in capacity limit array which is greater than equal to 18, which is 32 after this pass capacity needs - 8,8,8,6,6,4,4 capacity limits-8,16,8,14  2) best fit for 8 is 8 after this pass capacity needs -8,8,6,6,4,4 capacity limits-0,16,8,14  3)best fit for 8 is 8 capacity needs -8,6,6,4,4 capacity limits-0,16,0,14  4)best fit for 8 is 14 capacity needs -6,6,4,4 capacity limits-0,16,0,6  5)best fit for 6 is 6 capacity needs -6,4,4 capacity limits-0,16,0,0  6)best fit for 6 is 16 capacity needs -4,4 capacity limits-0,10,0,0  7)best fit for 4 is 10 capacity needs -4 capacity limits-0,6,0,0  8)best fit for 4 is 6 capacity needs - capacity limits-0,2,0,0	2014-12-10 11:50:21		
3211	rdfeo	31	Unfortunately this doesn't work. Consider needs = (5, 3, 3, 2) and limits = (7, 6). A solution is 7 = 5 + 2 and 6 = 3 + 3. However, running your algo on this data yields  1) Best fit for 5 is 6: needs = (3, 3, 2) limits = (7, 1)  2) Best fit for 3 is 7: needs = (3, 2) limits = (4, 1)  3) Best fit for 3 is 4: needs = (2) limits = (1, 1)  and then it stops failling to allocate a server for task 2.	2014-12-10 11:50:21		
3212	dkebi	31	Mode the problem as a giftbox problem, i.e., put several gifts in different sizes into boxes in different sizes. The strategy is try to put the largest gift into the lagest box and repeat the process until all gifts are boxed. If at a certain point the process fails, try the second largest box, then the third largest and so forth.  Implemented in scala is a brute force solution (NP complete, worst case O(n^3), n be the number of gifts), but since it can return early, the algorithm is quite efficient (best case O(n)). Note sorting the boxes can be further optimized with a simple insertion at the right place (linear).	2014-12-10 11:50:21		
3213	nhibd	31		2014-12-10 11:50:21		
3214	qywrh	31		2014-12-10 11:50:21		
3215	ftfck	31	The three test cases gives true, true, false	2014-12-10 11:50:21		
3216	zeice	31		2014-12-10 11:50:21		
3217	nwkeg	31		2014-12-10 11:50:21		
3218	krxlv	31	I'm not familir with scala but you said that "The strategy is try to put the largest gift into the lagest box...". If this is what your code is doing, then it doesn't work. Consider servers/boxes = (6, 5) and tasks/gifts = (5, 3, 3). Unless I'm missing something, your strategy puts gift 5 into box 6, gift 3 into box 5 and there's no room for the other gift 3. However, we could put gift 5 into box 5 and the two gifts 3 into box 6.	2014-12-10 11:50:21		
3219	sgiwy	31	Cassio, The algo also says "If at a certain point the process fails, try the second largest box, then the third largest and so forth". This is an essential part of the algorithm that handles your case. Though you are not familiar with scala, you can read the trace of the program execution to find the following case: Checking List(0, 2, 6, 8) for List(4, 4, 6) Checking List(0, 2, 2, 6) for List(4, 4) Checking List(0, 2, 2, 2) for List(4) Checking List(0, 0, 2, 8) for List(4, 4) which first tried to put 6 into 8 and after failure put 6 into 6 leading to a success.  Would you think twice before you vote the solution down?	2014-12-10 11:50:21		
3220	ufdxg	31	So, I was indeed missing something. I might be wrong again but it seems to me that your solution is similar to Shankar's (which I like very much) with added heuristics (trying to put big gifts in big giftbox first) that may speed up the algo.  I don't remember having voted your solution down. I normally don't vote down a solution that I don't understand (and I didn't understand yours). But, if I did, then I apologise. I have voted it up now (I think the heuristics is a good idea).	2014-12-10 11:50:21		
3221	fowai	31		2014-12-10 11:50:21		
3222	bexbp	31		2014-12-10 11:50:21		
3223	plapd	31	Very nice solution. Similar to driv3r's but doesn't need the auxiliary array to keep track of tasks that have been already allocated. In addition, it doesn't loop through the tasks, instead, each recursive call gets one task less to handle. This reduces the total number of calls tremendously.	2014-12-10 11:50:21		
3224	rdfeo	31	I can think of the following algorithm at high level, correct me if i am wrong  1.Check if we have exact fit available for a task 2.If not find the possible fit for that task 3.Get the best possible fit if we have multiple possible fits available 4.Best possible fit can be defined as the exact fit of 2 or more available tasks combined	2014-12-10 11:50:21		
3225	huiqq	31	Basically, one way is to solve using recursive backtracking with no memoization. Given a list of jobs L1 with service times S_i, and a list of servers L2 with with capacities C_i, we try each job on all servers one by one until the list L1 is traversed. Its like Depth First Search with backtracking (in case we don't find the solution along the path). An improvization would/could be memoization instead of backtracking. Say, we order the list L1 in descending order of service rates. The state I would memoize is. S[Sorted List of remaining capacities in L2, i] => The current state of List L2 after processing the 1st i elements of L1 S[Sorted List of remaining capacities in L2, i] = {-1, 0, 1} -1 means not yet memoized 0 means not possible 1 means possible  ------------------------------------------------------------------------------------------------ The important part is that i am storing List L2 after sorting it, because all servers are identical. (so that we don't have to recompute for the same list in different order)	2014-12-10 11:50:21		
3226	jippy	31	This question is form of bin-packing algorithm. Will post the solution soon.	2014-12-10 11:50:21		
3227	plapd	31	yes, this is a bin sort problem. First, sort the tasks in the descending order. Then assign the tasks to each bin as long as it can fit it.  here is the solution: bool bin_packing(int* tasks, int nt, int* workers, int nw) { quick_sort_kernel(tasks, 0, nt-1); bool setted_tasks[nt]; for(int i = 0; i < nt; i++) { int cur_task = tasks[i]; setted_tasks[i] = false; printf("task:%d ", cur_task); for(int j = 0; j < nw; j++) printf("%d ", workers[j]); printf("\n"); for(int j = 0; j < nw; j++) { if(workers[j]-cur_task >= 0) { workers[j] = workers[j]-cur_task; setted_tasks[i] = true; break; } } } for(int i = 0; i < nt; i++) { if(!setted_tasks[i]) return false; } return true; }	2014-12-10 11:50:21		
3228	huiqq	31		2014-12-10 11:50:21		
3229	eucmc	31		2014-12-10 11:50:22		
3230	rdfeo	31	What if sort the server and task first and assign the largest task to largest server, then add the smaller task to that server. The following code is the implementation of the algorithm above	2014-12-10 11:50:22		
3231	plapd	31		2014-12-10 11:50:22		
3232	wbqzu	31		2014-12-10 11:50:22		
3233	rdfeo	31	isn't this problem the Bin Packing problem, and therefore NP-Hard?	2014-12-10 11:50:22		
3234	krxlv	31	1) Let L be an array of tasks in some order. 2) The first server takes as many adjacent tasks as it can from the start of L. From what is left, the second server takes as many adjacent tasks as it can, and so on. If all tasks are taken then we're done and return true. 3) Otherwise, change L to another permutation of tasks and go back to step 2, unless all permutations have been tried, in which case, return false.  Here is C++ code. Notice that can_allocate uses 'std::next_permutation' which generates permutations in lexicographical order. To ensure that all permutations are generated, 'tasks' must be initialized in increasing order.	2014-12-10 11:50:22		
3235	zeice	31		2014-12-10 11:50:22		
3236	xhgls	31		2014-12-10 11:50:22		
3237	dgjji	31	Let n be the number of tasks and m be the number of servers. We have:  a) 'std::next permutation' has O(n) complexity; b) 'can_allocate_in_order' is ran at most n! times; c) 'can_allocate_in_order' has complexity O(n + m).  Since n = 8, 'can_allocate_in_order' can be called up to 8! = 40,320 times. This is arguably a big number however:  a) 'std::next_permutation' takes into consideration repetitions less calls are made. For instance, for tasks = {4, 4, 6, 6, 8, 8, 8, 18}, 4 is repeated 2 times, 6 is repeated 2 times and 8 is repeated 3 times. The number of calls is reduced to, at most, 8! / (2!*2!*3!) = 1,680.  b) Even when this maximum is achieved (e.g., when tasks = {1, 2, 3, 4, 5, 6, 7, 33}) the C++ code above takes a fraction of a second to run in my computer.  c) In contrast, driv3r's algorithm (ported to C++), for tasks = {1, 2, 3, 4, 5, 6, 7, 33} calls 'canArrangeRecursive' 37,369,133 times and takes a few of seconds to run.  The implementation can be easily modified to use Heap's algorithm (which has nothing to do with the homonymous data structure) to generate each permutation in O(1) and it doesn't make any assumption on 'tasks' initial order. The price to pay is that Heap's algorithm doesn't take profit of repetitions.	2014-12-10 11:50:22		
3238	wbqzu	31	Please, don't +1 this solution (mine). Consider, Shankar's instead.	2014-12-10 11:50:22		
3239	zeice	31	The algo also saids "If at a certain point the process fails, try the second largest box, then the third largest and so forth". In your example the code will roll back to try gift 5 in box 5.	2014-12-10 11:50:22		
3240	jippy	31	The algo also saids "If at a certain point the process fails, try the second largest box, then the third largest and so forth". In your example the code will roll back to try gift 5 in box 5.	2014-12-10 11:50:22		
3241	vanul	31		2014-12-10 11:50:22		
3242	bjsiw	31		2014-12-10 11:50:22		
3243	gilit	31	This is incorrect. You do not break up the jobs 'nicely.' The first example does not work. Consider a better way to break up the jobs. Also sorting so many times is not very efficient for larger numbers.	2014-12-10 11:50:22		
3244	fowai	31	{{def isSchedulable(limits,requires): if len(requires)==0: return True if len(limits)==0: return False limits.sort() limits=limits[::-1] requires.sort() requires=requires[::-1] if requires[0]>limits[0]: return False else: limits[0]=limits[0]-requires[0] while requires[-1]<=limits[0]: limits[0]=limits[0]-requires[-1] requires.pop() if limits[0]==0: limits.pop(0) requires.pop(0) return isSchedulable(limits,requires)}}	2014-12-10 11:50:22		
3245	rrmeu	31	No need of DP, greedy algorithm works:	2014-12-10 11:50:22		
3246	cfzie	31		2014-12-10 11:50:22		
3247	rdfeo	31		2014-12-10 11:50:22		
3248	vanul	31	I have got a solution. Correct me if I am wrong conceptually. Pick the boxes one by one. For each of the boxes, apply the 0/1 knapsack with the slight modification that if there are multiple ways to fill the box, then choose the way where the weight of the heaviest box is maximum at each step.	2014-12-10 11:50:22		
3249	fowai	31	This is what I was thinking. The key thing to realise is that if we 'stuff' each server independently as efficiently as possible (i.e. as little unused cap as possible), we can reduce the problem by 1 server and an arbitrary number of tasks. We can continue from there as before. Now, 'stuffing' each server as effectively as possible is done by the 0/1 knapsack problem as you said. This solution seems correct at least for two servers, and might be generalised to arbitrarily many servers. It's certainly a nice thing to mention in an interview, even if it turns out to not be correct in the end, you'd get kudos for trying a non-brute-force solution.	2014-12-10 11:50:22		
3250	sgiwy	31		2014-12-10 11:50:22		
3251	dgjji	31		2014-12-10 11:50:22		
3252	ethan	31	1. Read the input 2. Put both ServerCapacity and Tasks in separate Integer ArrayList s. 3. Sort both ArraList s in Desc order. 4. For the Biggest task, Try to fit in biggest server. 5. If Task is Bigger Than Capacity then there is no point in moving ahead.	2014-12-10 11:50:22		
3253	vanul	31		2014-12-10 11:50:22		
3254	qywrh	31		2014-12-10 11:50:22		
3255	plapd	31	1. Get input Capacity and tasks in separate ArrayList s 2. Sort both ArrayList s in Desc order. 3. For the Highest task check the Highest available Server capacity. 3. If the task is bigger than any server capacity then there is no point in moving ahead. 4. If the same capacity as task is found then remove both task and capacity from respective ArrayList s. 5. If the Task is smalled than the Capacity then deduct from capacity 6. Reiterate till you find servers for all Tasks.	2014-12-10 11:50:22		
3256	plapd	31	1. Get input Capacity and tasks in separate ArrayList s 2. Sort both ArrayList s in Desc order. 3. For the Highest task check the Highest available Server capacity. 3. If the task is bigger than any server capacity then there is no point in moving ahead. 4. If the same capacity as task is found then remove both task and capacity from respective ArrayList s. 5. If the Task is smalled than the Capacity then deduct from capacity 6. Reiterate till you find servers for all Tasks.	2014-12-10 11:50:22		
3257	krxlv	31		2014-12-10 11:50:22		
3258	rdfeo	31		2014-12-10 11:50:22		
3259	ufdxg	31	1. Get input Capacity and tasks in separate ArrayList s 2. Sort both ArrayList s in Desc order. 3. For the Highest task check the Highest available Server capacity. 3. If the task is bigger than any server capacity then there is no point in moving ahead. 4. If the same capacity as task is found then remove both task and capacity from respective ArrayList s. 5. If the Task is smalled than the Capacity then deduct from capacity 6. Reiterate till you find servers for all Tasks.	2014-12-10 11:50:22		
3260	nwkeg	31		2014-12-10 11:50:22		
3261	rdfeo	31		2014-12-10 11:50:22		
3262	rdfeo	31	1. Get input Capacity and tasks in separate ArrayList s 2. Sort both ArrayList s in Desc order. 3. For the Highest task check the Highest available Server capacity. 3. If the task is bigger than any server capacity then there is no point in moving ahead. 4. If the same capacity as task is found then remove both task and capacity from respective ArrayList s. 5. If the Task is smalled than the Capacity then deduct from capacity 6. Reiterate till you find servers for all Tasks.	2014-12-10 11:50:22		
3263	admin	31		2014-12-10 11:50:22		
3264	gilit	31		2014-12-10 11:50:22		
3265	huiqq	31	1. Get input Capacity and tasks in separate ArrayList s 2. Sort both ArrayList s in Desc order. 3. For the Highest task check the Highest available Server capacity. 3. If the task is bigger than any server capacity then there is no point in moving ahead. 4. If the same capacity as task is found then remove both task and capacity from respective ArrayList s. 5. If the Task is smalled than the Capacity then deduct from capacity 6. Reiterate till you find servers for all Tasks.	2014-12-10 11:50:22		
3266	zeice	31		2014-12-10 11:50:22		
3267	ethan	31		2014-12-10 11:50:22		
3268	wbqzu	31		2014-12-10 11:50:22		
3269	dgjji	31		2014-12-10 11:50:22		
3270	huiqq	31		2014-12-10 11:50:22		
3271	azmjc	31		2014-12-10 11:50:22		
3272	sgiwy	31		2014-12-10 11:50:22		
3273	azmjc	31		2014-12-10 11:50:22		
3274	tenuw	31		2014-12-10 11:50:22		
3275	vanul	31		2014-12-10 11:50:22		
3276	xhgls	31		2014-12-10 11:50:22		
3277	ftfck	31		2014-12-10 11:50:22		
3278	ewigy	31	For each task, check if it can fit into any server. DFS as long as tasks fit	2014-12-10 11:50:22		
3279	huiqq	31		2014-12-10 11:50:22		
3280	bexbp	31		2014-12-10 11:50:22		
3281	vanul	31		2014-12-10 11:50:22		
3282	krxlv	31		2014-12-10 11:50:22		
3283	nhibd	31	Find more about the sub-problem description and test here: cpluspluslearning-petert.blogspot.co.uk/2014/11/dynamic-programming-task-schedulling.html	2014-12-10 11:50:22		
3284	ftfck	31	I think its a best fit algorithm problem in which a number of processes are given and some memory blocks are given and we have to find the best fit memory block for a problem.  There might a more efficient way to slove this problem but i would like to solve this problem with the help of linked list and a array.  Lets suppose we have a linked list whose each node representing the memory space of each data center. Take your first example . Servers capacity limits: 8, 16, 8, 32 Tasks capacity needs: 18, 4, 8, 4, 6, 6, 8, 8  Linked list : 32->16->8->8 array : 18,4,8,4,6,6,8,8 Now i will search best fit memory space (which is wasting minimum memory space after acqureing required space)of each process .  18 : 14->16->8->8 16->14->8->8  4: 16->14->4->8 16->14->8->4  8: 16->14->4  4: 16->14  6: 16->8  6: 16->2  8: 8->2  8: 2	2014-12-10 11:50:22		
3285	vanul	31	I thought the same way, but in each process we are re-sorting the linked list after the "best-fit" step. Is there a more optimized way to do this?	2014-12-10 11:50:22		
3286	ethan	31	I think minor quicken the algo ? 1. We can use min heap for storing the server memory spaces. Search will be faster and insertion, deletion is easier to do. 2. You can sort task list as well in descending order and traverse through that order. This will help quicken the search process and you can remove the heap root, if it doesnt fit the task capacity.	2014-12-10 11:50:22		
3287	rdfeo	31	@R so you are saying we should create min heap for each process ?	2014-12-10 11:50:22		
3288	bjsiw	31	Best fit will not work for following case server capacity : 12 8 Task capacity need: 5 3 7 5	2014-12-10 11:50:22		
3289	ewigy	31	I may be mistaken, but isn't this problem as simple as determining whether the highest server capacity is higher than the highest task capacity?  If so, all you have to do is make one pass through the server capacities, find the max. Make another pass through the task capacities, find the max. The comparison between the two determines if they can be scheduled.	2014-12-10 11:50:22		
3290	fowai	31	This is one of the case. Just comparing max capacities will not work. See below example: Server: 4, 8 Tasks: 5, 7	2014-12-10 11:50:22		
3291	rdfeo	31	If your alogrithm is just to decrease the max job from the server with max capacity, it doesn't work for this  [8,6,2] [5,4,3,2,1]	2014-12-10 11:50:22		
3292	krxlv	31	This is more closely related to the "Bin Filling" problem	2014-12-10 11:50:22		
3293	fmzze	31	@Solomon Yang, greedy algorithm still works here, [8,6,2] , 5->8, 4->6, 3->3(8), 2->2(6), 1->2, right?  It will fail with following case, [8,6,2] [5,4,4,2,1]	2014-12-10 11:50:22		
3294	ufdxg	31	Is there a hidden constraint in the problem that says we can't use sorting, because if we can use sorting then this problem can be solved easily, the following are the steps to do that -:  1) sort the servers by their capacity/memory limits, so for instance in the example shown above we will have our servers in the following order after sorting - 8,8,16,32  2) Perform the same step as above for the tasks that you want to allocate on these servers, so the sequence of jobs now becomes the following - 4,4,6,6,8,8,8,18  3) now for each job scan through the list of server's sorted by their memory limits and if a task can fit in the server decrease the capacity of the server by the size of the job in each step, so the final list becomes the following - 0,2,2,6 and hence you can return true when you have exhausted finding a best fit for all the jobs, else if you failed finding a best fit for a specific task you can return false immediately	2014-12-10 11:50:22		
3295	jippy	31	If your alogrithm is just to decrease the max job from the server with max capacity, it doesn't work for this  [8,6,2] [5,4,3,2,1]	2014-12-10 11:50:22		
3296	ethan	31	I understand what you are saying, got the problem working on it	2014-12-10 11:50:22		
3297	plapd	31	[8,6,2] [5,4,3,2,1]  the above algorithm still works for this test case as: [8,6,2] [5,4,3,2,1]   [3,2,2] [3,2,1]  [0,0,1]  so it works	2014-12-10 11:50:22		
3298	rdfeo	31	Sorry, my previous version has a bug. Here is working one.	2014-12-10 11:50:22		
3299	eucmc	31		2014-12-10 11:50:22		
3300	dgjji	31		2014-12-10 11:50:22		
3301	eucmc	31	could you please explain your algorithm than just writing lines of code.	2014-12-10 11:50:22		
3302	nwkeg	31	Sames to be the same algorithm as mine.	2014-12-10 11:50:22		
3303	bjsiw	31	Not sure we need dynamic programming for this,  if n servers are there and m number of tasks are there, first make max heap out of n servers, a second max heap of m taks, pseudo code: while(second max heap of m tasks is empty) { if(first server heap is empty) return false;  mmax = get max task element out of second task heap smax = get max server element of first server heap;  if(smax < mmax) return false;  if(smax-mmax > 0) insertintofirstserverheapandheapify(smax-mmax) }  return true;  timecomplexity (mtaskitems log(servers) + mtaskitems log(mtaskitems ))	2014-12-10 11:50:22		
3304	rrmeu	31	Clearly, this is not a correct solution. Let me take an example, Server Limits: 8, 6 Task Limits: 6, 4, 4 The heap will be represented in similar order, since the nos. are sorted. Your solution will map, Task 1 (6) to Server 1(8), with remainder 2. Task 2 will be mapped to Server 2(6). There will be no solution.  However, if we map Task 1(6) to Server 2(6) in the first case, then there is a solution possible as the other two tasks will be mapped to Server 1.	2014-12-10 11:50:22		
3305	rrmeu	31	Try converting your max heap to a min heap for server capacity	2014-12-10 11:50:22		
3306	tenuw	31	@anaon, yeah I was wrong thanks for the example, @ghost, may be I am wrong min heap solution will not work either server: 12, 4 tasks, 2,4, 10 dynamic programming is the way to go, like an assembly line scheduler	2014-12-10 11:50:22		
3307	jippy	31		2014-12-10 11:50:23		
3308	fmzze	31		2014-12-10 11:50:23		
3309	fmzze	31	This works with all the examples I tried so far.	2014-12-10 11:50:23		
3310	ftfck	31	s = [12, 8] l = [5, 3, 7, 5]	2014-12-10 11:50:23		
3311	ufdxg	31	Here's my 2 cents, correct me if I'm wrong.  1) Sort the server and task according to capacity/memory from large to small; return false if the some tasks are larger than the largest server; 2) Starting from large server, try to pack tasks in sequence into server, if some task can't fit in current server, go to smaller server and do the same thing; 3) Repeat until all task are filled. return false if there's left-over tasks	2014-12-10 11:50:23		
3312	nwkeg	31	It doesn't work. Consider servers = (6, 5) and tasks = (5, 3, 3). A solution is 6 = 3 + 3 and 5 = 5. Your algorithm would send task 5 to server 6 and task 3 to server 5 and there would be no server for the other task 3.	2014-12-10 11:50:23		
3313	rrmeu	31	What if you push back on a question like this since by the time any algorithm solves it, it would have been faster to just "randomly" assign the tasks to the servers and let them finish. There is no fast optimal solution to this. See "The Maximum Resource Bin Packing Problem", Boyar et al  I would just take the shortest job dump it on the server with the least capacity for which it fits and move forward. This greedy algorithm isn't optimal, but is a hell of a lot faster than getting the absolute correct answer and since the load balancer (ie your solution to this problem) is what is getting pounded the hardest in this system, it has to be fast to dish out the tasks. It's google, if they can't handle the load on their work servers perfectly, screw it, they'll buy another million machines ;-)	2014-12-10 11:50:23		
3314	ftfck	31	Can we just simply get sums of two arrays? Then, sum of server capacity is greater than sum of tasks, it will be true. Am I missing anything?	2014-12-10 11:50:23		
3315	zeice	31	Consider servers = (5, 5) and tasks = (6, 1). Although 5 + 5 = 10 > 7 = 6 + 1, so your algorithm returns true, no server can take the task 6. Notice that a task cannot be broken into smaller pieces.	2014-12-10 11:50:23		
3316	tenuw	31	Here is one more solution:	2014-12-10 11:50:23		
3317	dkebi	31		2014-12-10 11:50:23		
3318	krxlv	31		2014-12-10 11:50:23		
3319	ethan	31	Output:	2014-12-10 11:50:23		
3320	ftfck	31		2014-12-10 11:50:23		
3321	eucmc	31		2014-12-10 11:50:23		
3322	plapd	31	class Program { static void Main(string[] args) { List<int> servers = new List<int>() { 8, 6, 2 }; List<int> tasks = new List<int>() { 6,5,3,2,1 };  bool result = BinFilling(servers, tasks); }  //Servers: 8, 16, 8, 32 //Tasks: 18, 4, 8,4,6,6,8,8 //Servers: 8,6,2 //Tasks: 5,4,3,2,1  public static bool BinFilling(List<int> servers, List<int> tasks) { if (tasks.Count == 0) return true;   for (int i = 0; i < servers.Count; i++) { for(int j=0; j< tasks.Count; j++) { if (tasks[j] != 0 && tasks[j] <= servers[i]) { List<int> cloneServers = new List<int>(servers); List<int> cloneTasks = new List<int>(tasks); cloneServers[i] -= cloneTasks[j]; cloneTasks.RemoveAt(j); if (BinFilling(cloneServers, cloneTasks)) { return true; } } } } return false; } }	2014-12-10 11:50:23		
3323	sgiwy	31	O(m*n) in worst case. Enjoy.	2014-12-10 11:50:23		
3324	ufdxg	31		2014-12-10 11:50:23		
3325	dgjji	31		2014-12-10 11:50:23		
3326	ewigy	31	@zprogd, Hi, Could you explain why this is time complexity = O(m * n)? I think this is O(m^n), m is the number of servers and n is the number of tasks. Think about this: Since there is n tasks, so the max depth of the recursion is n, and each level of recursion we have a for-loop, that means each level is O(m), so the totally time complexity = O(m^n), I am not sure my analysis, any wrong, pleas point out.	2014-12-10 11:50:23		
3327	nhibd	32	Lets say the array has M numbers. For the purpose of this problem, negative values and 0s are irrelevant. Also, numbers larger than M can be treated as M because the answer is never larger than M.  So, we can count the number of existing values between 1 and M. Then, process the values backwards (M to 1) to find the answer, adding the counts of the values processed so far.  This yields an O(M) algorithm with extra O(M) memory.	2014-12-10 11:50:24		
3328	ftfck	32		2014-12-10 11:50:24		
3329	wbqzu	32		2014-12-10 11:50:24		
3330	nwkeg	32	This one is good too.	2014-12-10 11:50:24		
3331	rrmeu	32	Not just good, actually. This is the best solution so far (in fact, probably even beyond the interviewer's expectations).  The second best is the one with the selection algorithm + binary search (has -1 votes unfortunately, but not surprising as people seem to find it difficult to understand)	2014-12-10 11:50:24		
3332	qywrh	32	Wouldn't it be simpler to modify quick select for very obvious change of partition choosing and terminal condition. No extra space.	2014-12-10 11:50:24		
3333	bexbp	32	Like quicksort, quickselect has O(N^2) worst case time complexity	2014-12-10 11:50:24		
3334	tenuw	32	But average case is linear, which is better than quick sort.	2014-12-10 11:50:24		
3335	wbqzu	32	The time is O(N+M).	2014-12-10 11:50:24		
3336	sqzqo	32	This is a neat solution. But please correct me if I am wrong here. Wouldn't this algorithm fail in a case where no such n exists that there are n values that are greater than or equal to n, in the array.  Say the array is [900, 902, 901, 903, 1000]. My understanding is that there is no n satisfying the given condition. But this algorithm would give you '5' as the answer.	2014-12-10 11:50:24		
3337	fmzze	32	The 'n' in the question refers to the number of values. In that input, there are 5 values >= than 5. The fact that the values are >= 900 is not an issue.  Adriana, my M is the number of values. In the worst case, all M values are processed. So it's just O(M).	2014-12-10 11:50:24		
3338	admin	32	You are assuming that it is a "sorted array" and not an "unsorted array" in this case.	2014-12-10 11:50:24		
3339	xhgls	32	how so? don't see such an assumption in my algorithm	2014-12-10 11:50:24		
3340	fowai	32	What is the correct answer supposed to be with this input {1,4,2,1}  When I try this code in converted into java I get 2, should the answer be 1?	2014-12-10 11:50:24		
3341	wbqzu	32	In that input, there are 2 numbers (2 and 4) larger or equal than 2. So the answer is 2	2014-12-10 11:50:24		
3342	nhibd	32	Got it thanks!	2014-12-10 11:50:24		
3343	dgjji	32	If we sort the numbers and pair together with the count of elements greater or equal than the elementin the sorted array, which is essentially the total count minus its index , we can easily determine where the answer is. For (1,2,3,4) the array of pairs is (1,4), (2,3), (3, 2) and (4,1). Compare the first number in the pair and the second number in the pair, there is an element after which the first number becomes greater than the second number in the pair. The second number in the pair is our answer.  To find the figures in the pairs, we need to count occurrences of the numbers in the array, hence the solution given by Miguel. Bellow is the same algorithm implemented in scala.	2014-12-10 11:50:24		
3344	dgjji	32		2014-12-10 11:50:24		
3345	krxlv	32		2014-12-10 11:50:24		
3346	bjsiw	32	There is a problem with the input {900, 2, 901, 3, 1000}; Th O/p is : 3,2,1 cz it is going by index.  Slight change fixes it, cz you need to compare by value not index.  int am = count[n]; for (int i = n-1; i >= 0; i--) { am += count[i]; // amount of numbers >= i if (am >= values[i]) { cout<<values[i]<<endl; } }	2014-12-10 11:50:24		
3347	rdfeo	32	@Khush, I don't see any issue. The code gives output 3 for that example as expected.	2014-12-10 11:50:24		
3348	qywrh	32	Isnt it just easier, to start with n, then iterate through and if a number is smaller then n then reduce n with one?	2014-12-10 11:50:24		
3349	nwkeg	32		2014-12-10 11:50:24		
3350	sgiwy	32		2014-12-10 11:50:24		
3351	admin	32	M elements, want to find n.  Binary search on n, using selection algorithm.  Guess n = n'. Find the n' largest element K using linear time selection algorithm. Check if K >= n'.  We can ignore half the elements already considered, so O(M) time algorithm.	2014-12-10 11:50:24		
3352	fmzze	32	A question: Binary search should be on a sorted array, right? Even selection algorithm can take O(M) time, so your method may not be a linear time in total.	2014-12-10 11:50:24		
3353	ewigy	32	@zhang.  "We can ignore half the elements already considered, so O(M) time algorithm." is accurate statement.  Binary search here implies you first guess n = M/2 and keep refining that guess.  You don't need the array sorted.	2014-12-10 11:50:24		
3354	huiqq	32	This answer is right. If you don't understand, ask. Downvoting only shows how ignorant you are.	2014-12-10 11:50:24		
3355	cfzie	32	Once again, the answer to this question is VERY SMALL modification of quick select algorithm. THe pivot is known to be how many from end, see if its value corresponds condition, choosing left or right partition is trivial. Quick select has just tiny bi simpler choosing conditions.	2014-12-10 11:50:24		
3356	ethan	32	@CT: Once again. The above solution is guaranteed linear, even with the selection algorithm running multiple times.  Replacing the guaranteed O(M) selection algorithm with expected O(M) quickselect might be the practical thing to do, but you do need to consider the multiple calls to quickselect involved.  The solution by Miguel Oliviera is going to be the most practical and best performing, beating your quickselect.  Not sure what you are harping about.	2014-12-10 11:50:24		
3357	qywrh	32	Could you be a bit more detailed on "We can ignore half the elements already considered, so O(M) time algorithm"?  Did you mean that when do selection, we can shrink the search range? I don't understand this. Since the array is not sorted, the n-th element can occur in any place of the array, which means the "selection" algorithm will always have to search the entire array.  Am I missing anything here?	2014-12-10 11:50:24		
3358	cfzie	32	@xiaoxipan:  Finding the 7th largest allows you to partition the array into elements greater and lesser.  This is similar to how quickselect works, in fact.	2014-12-10 11:50:24		
3359	eucmc	32	To clarify a little.  Say you found the 7th largest, and now want to find the 15th largest.  You partition based on 7th largest (part of selection algo) and then find the 8th largest in partition which has the smaller elements.	2014-12-10 11:50:24		
3360	dgjji	32	Got it. Thank you anonymous. Actually std::nth_element does exactly what you expected. Your solution is the best in the sense that its time complexity is O(M) and space complexity is O(1).	2014-12-10 11:50:24		
3361	vanul	32	This algorithm works well with time complexity O(M)+O(M/2)+...+O(1)=O(M), and space complexity O(1). It is the best solution till now. Please up vote Anonymous' answer. The code and the test case:	2014-12-10 11:50:24		
3362	wbqzu	32		2014-12-10 11:50:24		
3363	ewigy	32		2014-12-10 11:50:24		
3364	admin	32	Sort the array in descending order. Loop over it from the beginning till you find A[i] where i > A[i]. This would be nlog(n).	2014-12-10 11:50:24		
3365	qywrh	32	Sounds right !	2014-12-10 11:50:24		
3366	mrjku	32	sort in mlog(m) then binary search log(m)	2014-12-10 11:50:24		
3367	wbqzu	32	Hi Neeraj Can you pls explain how can you use binary search to find the element. You wouldnt know what element to search for right.  Here is an example for my query for the Array = {900, 2, 901, 1, 3, 4,902,903,1000} Sorted array = {1,2,3,4,900,901,902,903,1000}  Iteration1: Min = 0, max = array length The middle element (pivot) = 900. Comparison: 900<=number of elements to his right? --> No  Iteration2: So min = 0, max = (index of 900)-1; pivot value = 2 Comparison: 2<=number of elements to his right --> yes  Now the problem is you got the answer but thats not the correct one so you will still have to keep running iterations and would not be able to stop.  So how is binary search would really be useful?	2014-12-10 11:50:24		
3368	dgjji	32	^^ Modify your condition to find the value. Check both the constraints 1> N should have N greater values than it 2> N should be largest for the upgiven property. For #2 check N+1 fails the #1 test.  Here are your conditions for moving left/right.  if(arr[mid] > (hi-mid) && arr[mid+1] <= (hi-mid+1)) return arr[mid] if(arr[mid] > (hi-mid) ) go to right else go to left  ** Not handled edge cases, hope you get the drift.	2014-12-10 11:50:24		
3369	wbqzu	32	Saurabh, you were almost there. You just ended your binary search prematurely. we have the sorted array={1,2,3,4,900,901,902,903,1000} after 2nd iteration we have min=1(index of 2) max=3  3rd iteration: pivot value=3 no of elements on right side of 3>3 so we move right  4th iteration: min=2 max=3 pivot=4 (since we already know 3 satisfies the property) now for 4 we have >=4 values which are>4  now min=max=3 This is our final answer -> 4	2014-12-10 11:50:24		
3370	qywrh	32	Sort the array in descending order. Loop over it from the beginning till you find A[i] where i > A[i]. This would be nlog(n).	2014-12-10 11:50:24		
3371	qywrh	32		2014-12-10 11:50:24		
3372	fowai	32		2014-12-10 11:50:24		
3373	nhibd	32	I dont know what to return when no such element found so returning -1000.	2014-12-10 11:50:24		
3374	ewigy	32	Idea: inside the quick sort algorithm iteration process only one "half" of array depending on "pivotValue", length of left and right sub-array. Pros: in avarage case should be still O(nlogn) but with smaller koefficient Cons: worst case is still O(n^2)	2014-12-10 11:50:24		
3375	gilit	32	Agree. Have the same idea, would suggest to use 3-way partition in order to count repeated values.	2014-12-10 11:50:24		
3376	bjsiw	32	This algorithm is called quick select, the solution is nearly identical to quick select. Running time is O(n) believe it or not.	2014-12-10 11:50:24		
3377	bexbp	32	1. sort the array in ascending order 2. then look for i where n-i+1>=a[i]; if no such element exists, then return 0 3. time complexity o(nlogn)	2014-12-10 11:50:24		
3378	qywrh	32	Wouldn't it be simpler to modify quick select for very obvious change of partition choosing and terminal condition. No extra space.	2014-12-10 11:50:24		
3379	huiqq	32	// Java code	2014-12-10 11:50:24		
3380	fmzze	32		2014-12-10 11:50:24		
3381	mrjku	32		2014-12-10 11:50:24		
3382	dgjji	32		2014-12-10 11:50:24		
3383	bjsiw	32		2014-12-10 11:50:25		
3384	tenuw	32		2014-12-10 11:50:25		
3385	qywrh	32		2014-12-10 11:50:25		
3386	wbqzu	32	/// import java.util.Arrays;  public class MaxN {  public static int arrayReturn(int[] arr){ Arrays.sort(arr); int length = arr.length; int i = length/2-1; //for identifying the position int howmany = length - i ; while( i>0 && arr[i] > howmany ) i--;  return arr[i]; }  public static void main(String args[]){ int[] array = {900, 2, 901 , 3, 1000}; int i = arrayReturn(array); System.out.println(i); }  } \\\	2014-12-10 11:50:25		
3387	nhibd	32	This would be my answer : 1. Let the input array be A[] of size M. 2. Sort the array A in ascending order 3. Var N = -1 ( Assuming all elements are positive ) 4. for each element A[i] starting from A[M-1] to A[0] do the following: __4.a. if A[i] <= (M-i-1) : N = A[i] ; Break 5. if N == -1 then " No Results found" else "Answer is "+ N  Analysis : Sorting : Time :O(M) Counting Sort ( Space Complexity depends on Input range O(A[M-1]) or Time : O(nlogn) and Space : O(1) for heap Sort  Finding the element : Time O(M) Total : O(M) + O(M) = O(M)  Correct me if i am wrong	2014-12-10 11:50:25		
3388	zeice	32	Linear time: very simple and obvios modification of quick select	2014-12-10 11:50:25		
3389	bexbp	32	1. Build a TreeMap (Map with sorted keys) and count the frequency of each number 2. Traverse in descending order and sum the frequency of the numbers 3. Stop when sum >= n O(n log(n)) time O(n) space	2014-12-10 11:50:25		
3390	sqzqo	32		2014-12-10 11:50:25		
3391	sqzqo	32		2014-12-10 11:50:25		
3392	nhibd	32	N: size of array. O(N) time (amortized), O(1) space. A modification of quicksort like many others pointed out.  (semi rigorous) proof for complexity: At any stage, T(n) = T(a n) + O(n); a<1 at subproblem size n (i.e., we are depending on a smaller problem of size a N). In reality we will have different values of	2014-12-10 11:50:25		
3393	sgiwy	32		2014-12-10 11:50:25		
3394	azmjc	32		2014-12-10 11:50:25		
3395	wbqzu	32	at every stage but lets say its the average value. on summing up starting from problem size N, we have N + a N + a^2 N + .... + 1 and termination is upon reaching 1 or 0. so, we have: T(N) = (1-a^(N+1)/(1-a))*N. when N-<inf, T(N) -> N.  O(1) space because it is in place.	2014-12-10 11:50:25		
3396	plapd	32		2014-12-10 11:50:25		
3397	rdfeo	32		2014-12-10 11:50:25		
3398	rdfeo	32	You are the only smart guy in this forum filled with idiots	2014-12-10 11:50:25		
3399	fmzze	32	Just a correction: O(N) average time, not amortized	2014-12-10 11:50:25		
3400	fmzze	32		2014-12-10 11:50:25		
3401	nwkeg	32		2014-12-10 11:50:25		
3402	rdfeo	32	How about this? I can solve without extra storage.  1. First, I will do quick select for the median position. 2. See the left side of median to find maximum candidate.  1 will take 2n on the vatage, 2 will take n, so total 3n, leading O(n).	2014-12-10 11:50:25		
3403	nhibd	32		2014-12-10 11:50:25		
3404	rdfeo	32		2014-12-10 11:50:25		
3405	ftfck	32	1. use linear select to find the middle element. 2. check if middle element X <= N - m. here m is the absolute postion of the original array but middle position of the subarray. if true search on right. else search on left	2014-12-10 11:50:25		
3406	huiqq	32	binary search and linear select 1. use linear select to find the middle element. 2. check if the middle element value is less then or equal to the number of elements on the right side of the original array not in the subarray.	2014-12-10 11:50:25		
3407	rrmeu	32	static public int findnum(int [] a){ int l = a.length; int t = a[1]; for(int i=0; i<l; i++){ if(a[i]<l){ if(t<a[i]) t = a[i]; } } return t; }	2014-12-10 11:50:25		
3408	vanul	32	public class Test {  public static int getNumber(int[] A) throws Exception { int result = helper(A, 0, A.length - 1, 0); if (result == 0) throw new Exception("Number does not exist!"); return A[A.length - result]; }  // return the num of elements which is greater to equal to the pivot public static int helper(int[] A, int start, int end, int tailSize) { if (start > end) return 0;  // choose the starting number of this range as pivot int left = start, mid = start + 1, right = end; while (mid <= right) { if (A[mid] < A[left]) { swap(A, left, mid); mid++; left++; } else if (A[mid] == A[left]) mid++; else { swap(A, mid, right); right--; } }  int greaterOrEqualToPivot = end - left + 1 + tailSize; if (greaterOrEqualToPivot >= A[left]) { int subResult = helper(A, right + 1, end, tailSize); if (subResult != 0) return subResult; else return greaterOrEqualToPivot; } else return helper(A, start, left - 1, greaterOrEqualToPivot); }  public static void swap(int[] A, int left, int right) { int temp = A[left]; A[left] = A[right]; A[right] = temp; }  public static void main(String[] args) throws Exception { System.out.println(getNumber(new int[] { 900, 2, 901, 3, 1000 })); }  }	2014-12-10 11:50:25		
3409	tenuw	32		2014-12-10 11:50:25		
3410	krxlv	32		2014-12-10 11:50:25		
3411	zeice	32	Best method:  1.Sort the array in descending order. 2.Find n @A[i] 3.If i<(m-n+1) 4. Output values A[i] toA[m-n+1] 5.Else no output  Complexity would still be O(nlogn)	2014-12-10 11:50:25		
3412	cfzie	32	Huh?	2014-12-10 11:50:25		
3413	mrjku	32	Seems like the h-index calculation. Can be done in O(logn) on sorted array	2014-12-10 11:50:25		
3414	tenuw	32	Why downvote? h-index is the right term for this. The answer is reasonable too.	2014-12-10 11:50:25		
3415	cfzie	32		2014-12-10 11:50:25		
3416	nwkeg	32		2014-12-10 11:50:25		
3417	jippy	32	this fails {2, 3, 0} for example.  it might work with an extra pass over the array though	2014-12-10 11:50:25		
3418	nwkeg	33	Maintain two arrays - front [ ] and rear [ ] front maintains the product before the current index rear maintains the product after the current index then the product of current index i = front[i]*rear[i]	2014-12-10 11:50:27		
3419	cfzie	33		2014-12-10 11:50:27		
3420	ftfck	33		2014-12-10 11:50:27		
3421	xhgls	33	Nice	2014-12-10 11:50:27		
3422	bexbp	33	You can do this using one array and save some space:	2014-12-10 11:50:27		
3423	fmzze	33		2014-12-10 11:50:27		
3424	vanul	33		2014-12-10 11:50:27		
3425	gilit	33	To make things even more interesting we can do this recursively:	2014-12-10 11:50:28		
3426	admin	33		2014-12-10 11:50:28		
3427	nwkeg	33		2014-12-10 11:50:28		
3428	krxlv	33	Can anyone explain math background of this solution, please?	2014-12-10 11:50:28		
3429	azmjc	33	I would like to explain it with example instead of code. Because code would be really easy:	2014-12-10 11:50:28		
3430	rdfeo	33		2014-12-10 11:50:28		
3431	qywrh	33		2014-12-10 11:50:28		
3432	plapd	33	Thank you for explaining it	2014-12-10 11:50:28		
3433	jippy	33	thanks for the explanation	2014-12-10 11:50:28		
3434	fmzze	33	cheers	2014-12-10 11:50:28		
3435	azmjc	33	Does division as repeated subtraction also doesn't count?	2014-12-10 11:50:28		
3436	plapd	33	Repeated subtraction is not an O(n) operation, depending on your implementation.	2014-12-10 11:50:28		
3437	bexbp	33	Just use modular arithmetic with a large prime. Instead of divide, multiply by the inverse mod(p). 1. Calculate tp = the total product mod p 2. For each x: x = tp * x^(p - 2) mod p note: p must be picked larger than the largest result	2014-12-10 11:50:28		
3438	vanul	33	What is p here...?	2014-12-10 11:50:28		
3439	jippy	33	that makes you code work in O(n * log(p)), which doesn't fit into given constraints	2014-12-10 11:50:28		
3440	jippy	33		2014-12-10 11:50:28		
3441	nhibd	33		2014-12-10 11:50:28		
3442	xhgls	33	The GetQuotient method does not add complexity because its a formulated mathematical calculation.  So the complexity of the program is still O(n).	2014-12-10 11:50:28		
3443	plapd	33	Can you please explain on the concept behind this?	2014-12-10 11:50:28		
3444	huiqq	33	he's trying to use the fact that  (x/y) = e^log(x/y) = e^{logx - logy}  but he should test his code, especially with y==0 (log 0 == infinity?)	2014-12-10 11:50:28		
3445	tenuw	33	This is an elegant solution. And in fact way "out-of-the-box thinking" than any other solution.  It doesn't require more storage space also. And computation cycles are never counted as part of complexity  Also, even if there is a single 0 in the array, the output array will be ALL zero  So I guess he can add a line in the main program like so	2014-12-10 11:50:28		
3446	ewigy	33		2014-12-10 11:50:28		
3447	vanul	33		2014-12-10 11:50:28		
3448	ufdxg	33	Actually Samtg, your solution is not quite correct.  They're right. I should add the case to check for zero because here's what I missed  1. If there are no zeros in the array, then this program functions correctly  2. If there's 1 zero in the array, then all the elements are zero EXCEPT the element that was originally zero since it will be replaced with the product of all other numbers except zero  3. If there are more than 1 zero's in the array, then ALL the elements will be zero	2014-12-10 11:50:28		
3449	admin	33	#include <stdio.h> int main() { int a[4],b[4],i,n; for(i=0;i<4;i++) { scanf("%d",&a[i]); } for(i=0;i<4;i++) { if(i==0) { b[i]=a[i+1]*a[i+2]*a[i+3]; } else if(i==1) { b[i]=a[i-1]*a[i+1]*a[i+2]; } else if(i==2) { b[i]=a[i-2]*a[i-1]*a[i+1]; } else { b[i]=a[i-3]*a[i-2]*a[i-1]; } } for(i=0;i<4;i++) { printf("%d ",b[i]); } return 0; }	2014-12-10 11:50:28		
3450	nhibd	33	this will work only for array with 4 elements, if the inout array is dynamic it will fail	2014-12-10 11:50:28		
3451	qywrh	33	what if you have array of 50 size. Will you use 50 if-else ladder.	2014-12-10 11:50:28		
3452	azmjc	33		2014-12-10 11:50:28		
3453	sgiwy	33		2014-12-10 11:50:28		
3454	sgiwy	33	time:O(n), space:O(n)	2014-12-10 11:50:28		
3455	krxlv	33	Nice solution but think the operations in the first loop are reversed. I mean, they should be arr[i] = productSoFar; productSoFar *= arr[i];	2014-12-10 11:50:28		
3456	plapd	33		2014-12-10 11:50:28		
3457	fmzze	33		2014-12-10 11:50:28		
3458	cfzie	33	Shouldn't it be so simple... 1. Multiple all element in first go 2. Divide the result by current element to get result at that position.	2014-12-10 11:50:28		
3459	admin	33	Division not allowed. Constraint!!	2014-12-10 11:50:28		
3460	ftfck	33	multiply all the array elements and then divide the product with present element.	2014-12-10 11:50:28		
3461	plapd	33	division not allowed, l2r	2014-12-10 11:50:28		
3462	eucmc	33	Multiplying anagram values	2014-12-10 11:50:28		
3463	vanul	33	Multiplying anagram values	2014-12-10 11:50:28		
3464	bjsiw	33		2014-12-10 11:50:28		
3465	eucmc	33		2014-12-10 11:50:28		
3466	azmjc	33	Here is my code  1. Identify the current index and set the value of that element as 1 2. Multiple the elements in the array , that will be product of 3 numbers	2014-12-10 11:50:28		
3467	bexbp	33		2014-12-10 11:50:28		
3468	mrjku	33		2014-12-10 11:50:28		
3469	krxlv	33	n^2.	2014-12-10 11:50:28		
3470	fmzze	33		2014-12-10 11:50:28		
3471	mrjku	33		2014-12-10 11:50:28		
3472	fowai	33	public class FaceBookProblem1 {  public static void main(String[] args) { int input[] = { 2, 3, 1, 4 }; fillArray(input, 0, input.length, 1); for (int i = 0; i < input.length; i++) { System.out.println(input[i]); } }  private static int fillArray(int[] array, int index, int length, int value) { if (index == (length - 1)) { int val = array[index]; array[index] = value; return val; } else { int val = fillArray(array, index + 1, length, value * array[index]); int retVal = val * array[index]; array[index] = value * val; return retVal; } } }	2014-12-10 11:50:28		
3473	rrmeu	33	python	2014-12-10 11:50:28		
3474	wbqzu	33		2014-12-10 11:50:28		
3475	krxlv	33		2014-12-10 11:50:28		
3476	rrmeu	33	{ public static void main(String[] args) { int[] input = {2, 3, 1, 4}; int[] output = new int[input.length];  int index; for (index = 0; index < input.length; index ++) { output[index] = 1; }  int m = 1; for (index = 0; index < input.length; index ++) { output[index] = m; m = m * input[index]; }  m = 1; for (index = input.length - 1; index >= 0; index --) { output[index] = output[index] * m; m = m * input[index]; }  for (index = 0; index < output.length; index ++) { System.out.println(output[index]); } }    }	2014-12-10 11:50:28		
3477	ewigy	33		2014-12-10 11:50:28		
3478	huiqq	33		2014-12-10 11:50:28		
3479	admin	33	public static void main(String[] args){ int[] a={2,3,1,4}; solve(a,0); }   static void solve(int[] a,int index){ //result array int[] r = new int[a.length]; int t=1;  //multiple from left for(int i=0;i<a.length;i++){ r[i]=t; t=t*a[i]; }  t=1;  //multiple from right for(int i=(a.length-1);i>=0;i--){ r[i]=t*r[i]; t=t*a[i]; }  //complete for(int i=0;i<a.length;i++){ System.out.println(r[i]); }	2014-12-10 11:50:28		
3480	nwkeg	33	private static int[] multiplyOthers(int [] a) { int [] p = new int[a.length];  for (int i = 0; i < a.length; i ++) { int multiplior = 1; for(int j=0; j<a.length; j++) { if(i != j) { multiplior = multiplior * a[j]; } } p[i] = multiplior; } return p; }	2014-12-10 11:50:28		
3481	dgjji	33	1. long product = a[0]*a[1]*..*a[n] 2. return [product/a[0], product/a[1].. product/a[n]]	2014-12-10 11:50:28		
3482	qywrh	33		2014-12-10 11:50:28		
3483	rrmeu	33		2014-12-10 11:50:28		
3484	admin	33	Or you could just implement the division function with a while-loop. It's sneaky but it fulfills the requirements.	2014-12-10 11:50:29		
3485	bexbp	33		2014-12-10 11:50:29		
3486	admin	33		2014-12-10 11:50:29		
3487	qywrh	33	function mul(a, b) { return a * b; }  function genArray(a) { var res = [];  a.map(function(item, i) { res.push(a.filter(function( ai) { return ai !== item; }).reduce(mul)); }); return res; }  console.log(genArray(a));	2014-12-10 11:50:29		
3488	xhgls	34	This problem is the same as LRU cache design, using double linked list and hash table.	2014-12-10 11:50:29		
3489	ftfck	34	for a history of size 5?	2014-12-10 11:50:29		
3490	ufdxg	34	read the problem carefully, "no duplicates allowed, and 5 can be any N later"	2014-12-10 11:50:29		
3491	dkebi	34	ha ha yeah it's hidden in there (real problem definition is hidden in an example  in that case your answer should be upvoted highest because you had it before Ajeet	2014-12-10 11:50:29		
3492	admin	34	good solution	2014-12-10 11:50:29		
3493	huiqq	34	Why do you need the list to be double linked?	2014-12-10 11:50:29		
3494	huiqq	34	To be able to delete node from list for O(1)	2014-12-10 11:50:29		
3495	vanul	34	O(1) insert and O(1) history retrieve:	2014-12-10 11:50:30		
3496	ftfck	34		2014-12-10 11:50:30		
3497	eucmc	34		2014-12-10 11:50:30		
3498	admin	34		2014-12-10 11:50:30		
3499	jippy	34		2014-12-10 11:50:30		
3500	bexbp	34	I think it should be	2014-12-10 11:50:30		
3501	krxlv	34		2014-12-10 11:50:30		
3502	vanul	34		2014-12-10 11:50:30		
3503	eucmc	34	Implementation and unit tests:	2014-12-10 11:50:30		
3504	gilit	34		2014-12-10 11:50:30		
3505	dkebi	34		2014-12-10 11:50:30		
3506	dkebi	34	------------------------------------------------------------------------  Tests:	2014-12-10 11:50:30		
3507	bjsiw	34		2014-12-10 11:50:30		
3508	ftfck	34		2014-12-10 11:50:30		
3509	rrmeu	34	I took a similar approach by using a Map and Linked List. In the map, I store a pointer to the linked list object corresponding to the URL. If the same page is visited twice, the address is used to find the object in the list, remove it, and re-insert it at the head.  Also, you can always obtain the last "N" pages by traversing through the list from the head down.  Here is the C++ code:	2014-12-10 11:50:30		
3510	dkebi	34		2014-12-10 11:50:30		
3511	zeice	34		2014-12-10 11:50:30		
3512	jippy	34	And a sample usage:	2014-12-10 11:50:30		
3513	nwkeg	34		2014-12-10 11:50:30		
3514	dkebi	34		2014-12-10 11:50:30		
3515	eucmc	34	Output:	2014-12-10 11:50:30		
3516	nhibd	34		2014-12-10 11:50:30		
3517	ftfck	34		2014-12-10 11:50:30		
3518	nwkeg	34	What is wrong in the code above? Let's leave some feedback after up/down voting.	2014-12-10 11:50:30		
3519	huiqq	34	Anonymous and multiple personality is angered other win this question before one of his namea can win the upvote. So of course downvote all over like a mess and make this question useless so the win become diminished.  Today you notice that anonymous did not use Subbu name but use the / name He use Subbu name for post good solution usual these days and other names to mess the questions for others Have names for both construction and destruction.	2014-12-10 11:50:30		
3520	nwkeg	34	I did not register. So cannot vote. But thank you for saying that I post good solutions.  I have to say though, you must have a strange mind to come to such conclusions. Hope you get over it soon.	2014-12-10 11:50:30		
3521	ewigy	34	I am surprised to be "winner" of this thread. If you were suggesting that I downvote all other answers, sorry, you are not a good detective. Otherwise, forget this post, I am not interested in discussing non-technical issues.	2014-12-10 11:50:30		
3522	admin	34	Two upvotes to this idiotic comment by algos at the same instant. Hmm... talking about multiple personalities...  (upvoted by: Oxana.Sidenko and Luri Covalisin).	2014-12-10 11:50:30		
3523	rrmeu	34	Its like a LRU cache. It can be solved using Queue,Doubly Linked List, . For each address he enters create a hash key and store it in queue. This browser address and hash key store it in a doubly linked list. Once user again visits same address break the node and bring it to first.	2014-12-10 11:50:30		
3524	azmjc	34	Is it true love, or self love? Not sure :(	2014-12-10 11:50:30		
3525	wbqzu	34	Is it true love, or self love? Not sure :(	2014-12-10 11:50:30		
3526	dkebi	34	Since the number of elements to keep in the history was 5, I assumed than an array search would be fast enough to prevent any loss of performance.	2014-12-10 11:50:30		
3527	nwkeg	34		2014-12-10 11:50:30		
3528	nwkeg	34		2014-12-10 11:50:30		
3529	vanul	34	C version	2014-12-10 11:50:30		
3530	bexbp	34		2014-12-10 11:50:30		
3531	dgjji	34		2014-12-10 11:50:30		
3532	dkebi	34		2014-12-10 11:50:30		
3533	rrmeu	34		2014-12-10 11:50:30		
3534	ewigy	34	I have a question:Does it require dynamically generating the answer,can't we do it when we need to check the top N history? If we do it when we need the answer, it'll be quite a different algorithm!	2014-12-10 11:50:30		
3535	cfzie	34		2014-12-10 11:50:30		
3536	dkebi	34		2014-12-10 11:50:30		
3537	azmjc	34	HashMap & list both will be of size N, in given scenario N = 5.	2014-12-10 11:50:30		
3538	zeice	34	Doing all this for size 5 is major overkill	2014-12-10 11:50:30		
3539	bexbp	34	You posted this several hours after Jason's exact answer. Waste of space.	2014-12-10 11:50:30		
3540	fowai	34	Strange logic behind downvote ...:(  I have already replied it around a month back ..for similar kind of scenario (question?id=5112274943475712). So it does not matter, when are you replying. It should be only for optimal and perfect solution.	2014-12-10 11:50:30		
3541	wbqzu	34	With Java LinkedHashSet, O(1) solution is	2014-12-10 11:50:30		
3542	vanul	34		2014-12-10 11:50:31		
3543	ufdxg	34		2014-12-10 11:50:31		
3544	ewigy	34	Here is an example of the O(1) hashtable implementation. The idea is that the linked list has an ordering of the last n websites, and the hashtable maps website to iterators into the list for O(1) find time (for removal when needed).  /// class History { public: History(unsigned sz) : sz(sz) {} void add_website(string const &website); list<string> const &get_history(){ return recentlyVisited;} private: unsigned sz;  unordered_map<string, list<string>>::iterator> iterators; list<string> recentlyVisited; }  add_website(string const &website) { // If the website is already in there, just erase it and put it on the front. auto hashLookup = iterators.find(website); if(hashLookup != end(iterators)) { recentlyVisited.erase(hashLookup->second); recentlyVisisted.push_front(website); hashLookup->second = begin(recentlyVisited); return; }   // Otherwise, add it. If space is used, remove the one that has been unused longest. if(recentlyVisisted.size() == sz) { iterators.erase(recentlyVisited.back()); recentlyVisited.pop_back(); } recentlyVisited.push_front(website); iterators.insert(make_pair(website, begin(recentlyVisited))); } \\\  But let's do a little bit of real talk. How many websites could there be stored in a website browser? Maybe 4,000. Maybe 6,000. These are all incredibly tiny numbers, and even an O(n) complexity solution will be just fine. In fact, such a solution will outperform a hashtable implementation for n = 5 due to avoiding the overhead. The O(n) complexity is as follows:  Have a list [doubly linked list with stored size] of top n most recently used. called list<string> recentlyVisited. No need for hashtable this time. Find elements in it with a linear search. add function: /// add_website(string const &website) { // If the website is already in there, just erase it and put it on the front. auto itr = find(begin(recentlyVisited), end(recentlyVisited), website); if(itr != end(recentlyVisited)) { recentlyVisited.erase(itr); recentlyVisited.push_front(website); return; }  // Otherwise, add it. If space is used, remove the one that has been unused longest. if(recentlyVisited.size() == sz) { recentlyVisited.pop_back(); } recentlyVisited.push_front(website); } \\\	2014-12-10 11:50:31		
3545	nhibd	34	You haven't considered multi-threading issues.	2014-12-10 11:50:31		
3546	sgiwy	34	And is this a problem from Google or Bloomberg LP?	2014-12-10 11:50:31		
3547	qywrh	34	priority queue, implemented as a 'max-heap' on access-time. most recently visited page will be available on the top of team (its time will be greater than all others).  if heap is full, replace the end element and move up the heap readjusting it.	2014-12-10 11:50:31		
3548	gilit	34	instead of 'max-heap', a 'max-treap' can be employed. key will be URL for tree operation (search), and key for heap operation (insert, update) will be access time	2014-12-10 11:50:31		
3549	jippy	34	circular buffer of size 5	2014-12-10 11:50:31		
3550	fowai	34	You missed the part where no duplicates are allowed	2014-12-10 11:50:31		
3551	vanul	34	no I did not it's size 5, slide along 5 elements each time before inserting into the circular buffer  anyone who uses fancy stuff for a history of 5 is kidding themselves	2014-12-10 11:50:31		
3552	admin	34	Anyone who thinks browser history would be restricted to showing just the last 5 entries is smoking something.	2014-12-10 11:50:31		
3553	admin	34		2014-12-10 11:50:31		
3554	rdfeo	34	for size 5?  Let's think about the actual use case. Would a company do anything other than a simple 5 element array/buffer/circularbuffer for this problem?	2014-12-10 11:50:31		
3555	ufdxg	34	@/: Will a company hardcode 5 and have such a narrow scope of the browser history? Get real.  All these LRU caches and 'fancy data structure; etc are well known and production versions of those are usually available (either open source etc or within large companies themselves).  Multithreading/multi-process could be a consideration as you will have multiple tabs etc and these days browsers use the multi-process model.  Another aspect that is left is the actual storage on the hard disk, for persisting history and the in-memory structure representing that. Add in other features with history usage (like wordwheel) and your answer changes. This talk about company is nonsense. There will be much more to history than just showing that last 5 visited.  I am glad this has -2. This answer now stands out and is not buried in the noise! Thank you downvoters.	2014-12-10 11:50:31		
3556	sqzqo	35		2014-12-10 11:50:32		
3557	bjsiw	35		2014-12-10 11:50:32		
3558	bexbp	35	good handling of not generating similar combinations  How about just finding the total number of ways possible. Can we lower the complexity?	2014-12-10 11:50:32		
3559	bjsiw	35	Same solution in JavaScript:	2014-12-10 11:50:32		
3560	rdfeo	35		2014-12-10 11:50:32		
3561	rdfeo	35		2014-12-10 11:50:32		
3562	gilit	35	That's very similar to what I had, except it took me forever and some help from the interviewer to get there!	2014-12-10 11:50:32		
3563	krxlv	35		2014-12-10 11:50:32		
3564	eucmc	35		2014-12-10 11:50:32		
3565	fmzze	35	Can you comment on the complexity of this algo?	2014-12-10 11:50:32		
3566	plapd	35	What about this one?  But I am still struggled with the complexity. It seems to be O ( n ^ 3 ) What do you guys think ?	2014-12-10 11:50:32		
3567	jippy	35		2014-12-10 11:50:32		
3568	ethan	35		2014-12-10 11:50:32		
3569	ewigy	35		2014-12-10 11:50:32		
3570	rrmeu	35		2014-12-10 11:50:32		
3571	ufdxg	35		2014-12-10 11:50:32		
3572	jippy	35		2014-12-10 11:50:32		
3573	nhibd	35	Use this recursion:  makeSum(n, n-1), returns sets such that sum of its elements is n and the elements in the set are less than or equal to n-1.  makeSum(n, n-1) = CreateSet(n-1, n-1...i times) U ForEach set in (makeSum(n-i(n-1), n-2)), where 0 <= i <= n/(n-1)  makeSum(n, 1) = CreateSet(1,1,...n times)	2014-12-10 11:50:32		
3574	zeice	35	you start with 4 as {1,3} and recurse down with 3 next. you save the history of 1 so that you can reconstruct results as {1,1,2} in the next iteration . the code is below	2014-12-10 11:50:32		
3575	ufdxg	35		2014-12-10 11:50:32		
3576	ftfck	35		2014-12-10 11:50:32		
3577	zeice	35	ODOMETER! WOO HOO!	2014-12-10 11:50:32		
3578	ewigy	35	if N=4 return {{1,1,1,1},{1,1,2},{1,3}} why no {2,2}?	2014-12-10 11:50:32		
3579	ewigy	35	Because I forgot :p	2014-12-10 11:50:32		
3580	fowai	35	my previous answer is wrong. it missed (2,2). but here is the correct and elegant solution. you start the recursion with target = 4, solutionSpace = [1,2,3] and result = []  at each step of recursion you make a decision whether you want to include the first digit in the solution space in the result or not. if you don't include the digit in result, remove it from solution space. if you include the first digit in the solution space, save the digit in the result and adjust the target. the recursion ends if target is zero or target is less than first digit in solution space or solution space is empty.. a thing of beauty !!!	2014-12-10 11:50:32		
3581	ftfck	35		2014-12-10 11:50:32		
3582	sgiwy	35		2014-12-10 11:50:32		
3583	rrmeu	35	Get all possible sets of 2 elements and store them as a list [the list is sorted as each element is greater than its predecessor] Enqueue all the lists in a a queue Store them as a List in Queue Dequeue the elements from the queue [and print a possible set] and expand the last element if it is 2 time or more than its previous one and store the resulting list back to queue, and loop until the queue is empty.  Here is the code in C#  static void printAllPossibleSum(int n) { Queue<List<int>> q = new Queue<List<int>>();  for (int i = 1; i <= n/2; i ++) { List<int> l = new List<int>(); l.Add(i); l.Add(n - i); q.Enqueue(l); }  while(q.Count > 0) { List<int> l = q.Dequeue(); printList(l); for (int i = l[l.Count - 2]; i <= l[l.Count -1]/2; i++) { List<int> a = new List<int>(); for (int j = 0; j < l.Count -1; j ++) { a.Add(l[j]); } a.Add(i); a.Add(l[l.Count -1] - i); q.Enqueue(a); } } }	2014-12-10 11:50:32		
3584	ethan	35	Great answer! How did you decide to 'expand the last element if it is 2 time or more than its previous one'?	2014-12-10 11:50:32		
3585	mrjku	35	Java based on Umer Javaid answer.	2014-12-10 11:50:32		
3586	bexbp	35		2014-12-10 11:50:32		
3587	xhgls	35		2014-12-10 11:50:32		
3588	krxlv	35	Objective-C, iOS solution:	2014-12-10 11:50:32		
3589	nwkeg	35		2014-12-10 11:50:32		
3590	sqzqo	35		2014-12-10 11:50:32		
3591	ethan	35	This is the partition problem (wikipedia.org/wiki/Partition_(number_theory)).  Does the following help someone? 1111111 (n=1) ======= 111112 (n=2) ====== 11113 (n=3) ===== 11122 1114 (n=4) ==== 1123 115 (n=5) === 1222 124 133 16 (n=6) == 223 25 34 7 (n=7)  The number of lines is the number of possible partitions and the list of partitions for each n. So the algorithm is recursive, computing the partitions for n-1, running over them and adding 1 to the left of the of each partition. In addition, we add all partitions that have incremental values starting with 2. I'm stuck with calculation the incremental final part :(  BTW, my email is kilaka at gmail.com :)	2014-12-10 11:50:32		
3592	zeice	35		2014-12-10 11:50:32		
3593	nhibd	35		2014-12-10 11:50:32		
3594	dgjji	35	An other solution	2014-12-10 11:50:32		
3595	sqzqo	35		2014-12-10 11:50:32		
3596	cfzie	35		2014-12-10 11:50:33		
3597	bexbp	35	define m = max {m1, m2, m3, ...mi} n = m1 + m2 + m3 ...mi  if n == 1 || m == 1 then f(n, m) = 1 if n == m then f(n, m) = 1 + f(n, m-1) if n > m then f(n, m) = f(n -m, m) + f(n, m-1)  recursive itself.	2014-12-10 11:50:33		
3598	huiqq	35	Algorithm from page 392 of The Art of Computer Programming, Volume 4A.	2014-12-10 11:50:33		
3599	xhgls	35		2014-12-10 11:50:33		
3600	eucmc	35		2014-12-10 11:50:33		
3601	admin	35	Python code	2014-12-10 11:50:33		
3602	rdfeo	35		2014-12-10 11:50:33		
3603	eucmc	35		2014-12-10 11:50:33		
3604	admin	35		2014-12-10 11:50:33		
3605	nwkeg	35		2014-12-10 11:50:33		
3606	xhgls	35		2014-12-10 11:50:33		
3607	gilit	35		2014-12-10 11:50:33		
3608	ftfck	35	Ruby 2.0.0 implementation	2014-12-10 11:50:33		
3609	plapd	35		2014-12-10 11:50:33		
3610	jippy	35		2014-12-10 11:50:33		
3611	wbqzu	35	Ruby 2.0.0 implementation updated with non exponential time.	2014-12-10 11:50:33		
3612	nwkeg	35		2014-12-10 11:50:33		
3613	dgjji	35		2014-12-10 11:50:33		
3614	fmzze	35		2014-12-10 11:50:33		
3615	ftfck	35		2014-12-10 11:50:33		
3616	tenuw	35	Here is my code in Objective-C	2014-12-10 11:50:33		
3617	qywrh	35		2014-12-10 11:50:33		
3618	sgiwy	35		2014-12-10 11:50:33		
3619	eucmc	35	Here is my code in Objective-C	2014-12-10 11:50:33		
3620	cfzie	35		2014-12-10 11:50:33		
3621	rdfeo	35		2014-12-10 11:50:33		
3622	tenuw	35	C++	2014-12-10 11:50:33		
3623	fowai	35		2014-12-10 11:50:33		
3624	rrmeu	35		2014-12-10 11:50:33		
3625	tenuw	35	#include <stdio.h> #include <stdlib.h> #include <vector>  using namespace std; //10:24  vector<vector<int> >& all_combinations(int N,int prev,vector<int> v,vector<vector<int> > &v_prime) { if(N < 0) return v_prime; if(N == 0) { //Print and return v_prime.push_back(v); return v_prime; } v.push_back(0);//dummy element for(int i=prev;i>0;i--) { v.pop_back(); v.push_back(i); all_combinations(N-i,i,v,v_prime); } }  //10:33 void print_vect(vector<int> &v) { int i=0,size = v.size(); for(i =0 ;i < size;i++) printf("%d ", v[i]); printf("\n"); } void print_vects(vector<vector<int> > &v) { int i,size=v.size(); for(i=0;i<size;i++) print_vect(v[i]); }  int main(int argc, char const *argv[]) { vector<vector<int> > u;//empty vector of vector vector<int> v;//empty vector; all_combinations(8,8-1,v,u); print_vects(u); return 0; }	2014-12-10 11:50:33		
3626	krxlv	35		2014-12-10 11:50:33		
3627	rrmeu	35		2014-12-10 11:50:33		
3628	rdfeo	35		2014-12-10 11:50:33		
3629	nwkeg	35		2014-12-10 11:50:33		
3630	fowai	35	codepad.org/Q9pcHDPj	2014-12-10 11:50:33		
3631	huiqq	35	Here's a recursive solution in Objective-C. I believe the complexity is `O(n^2)`, but I'm not sure.	2014-12-10 11:50:33		
3632	plapd	35		2014-12-10 11:50:33		
3633	rrmeu	35		2014-12-10 11:50:33		
3634	sgiwy	35		2014-12-10 11:50:33		
3635	ufdxg	35		2014-12-10 11:50:33		
3636	plapd	35		2014-12-10 11:50:33		
3637	nhibd	35		2014-12-10 11:50:33		
3638	dgjji	35	Use simple recursion. There are two cases: 1) Include the given number in the sum 2) Exclude the number from the sum and proceed to next number Code:	2014-12-10 11:50:33		
3639	bexbp	35		2014-12-10 11:50:33		
3640	zeice	35		2014-12-10 11:50:33		
3641	sqzqo	35	Very elegant....  Can add one extra condition in if (n == 0) loop print result only if(result.size() != 1), which would discard the output with one digit in it	2014-12-10 11:50:33		
3642	xhgls	36	In Python:	2014-12-10 11:50:35		
3643	fmzze	36		2014-12-10 11:50:35		
3644	admin	36		2014-12-10 11:50:35		
3645	ftfck	36		2014-12-10 11:50:35		
3646	krxlv	36		2014-12-10 11:50:35		
3647	nwkeg	36	good i like your approach without recursion.	2014-12-10 11:50:35		
3648	sgiwy	36	outputstr=""; if(number<26) print number else while(number!=0) { x=number%26 //0 is A ,1 is B and so on outputstr=outputstr+"x" //string append number=number/26 }  from string to number: example: xyz z*26^0+y*26^1+x*26^2	2014-12-10 11:50:35		
3649	mrjku	36	I see 2 problems in this solution: 1. In most programming languages this is close to an infinite loop because number/26 takes a long time to become 0, i.e. starts at x.yyy... x.zzz... and so on until 0. I would use floor(number/26) 2. you need to append the "x" before the outputstr because converting it back to number with outputstr+"x" will not give you the same answer.	2014-12-10 11:50:35		
3650	ufdxg	36	any how we are using int type man so it will not be a problem  And it just an algo and i think it will work fine	2014-12-10 11:50:35		
3651	xhgls	36	Basically converting base-10 input to base-26 on symbols {A, B, ..., Z}  C++:	2014-12-10 11:50:35		
3652	azmjc	36		2014-12-10 11:50:35		
3653	krxlv	36		2014-12-10 11:50:36		
3654	wbqzu	36	This does not work for int representations big enough (such as for AAZ)	2014-12-10 11:50:36		
3655	ftfck	36	explain?	2014-12-10 11:50:36		
3656	mrjku	36	It actually does work, but I'm not sure why. The thing is that in Hexadecimal for example 16^3 is F000 but here 26^3 is more like YYZ, it doesn't even have 4 digits... what's going on?  In 26-base the digits should go form 0 to 25 but here they go from 1 to 26, and the regular transformation algorithm still works, that's confusing.	2014-12-10 11:50:36		
3657	vanul	36	The program gives wrong result!!! input : 52 Expected output: AZ Actual Output : B@	2014-12-10 11:50:36		
3658	rdfeo	36	char* charToInt(unsigned int p) { char output[1024]; memset(output,0, 1024); int i = 0; while(p) { int x = p % 26; char c = (char)((int('A') - 1 + x)); output[i] = c; i++; p = p / 26; } return strrev(output); }	2014-12-10 11:50:36		
3659	ftfck	36		2014-12-10 11:50:36		
3660	bjsiw	36		2014-12-10 11:50:36		
3661	rdfeo	36		2014-12-10 11:50:36		
3662	ufdxg	36		2014-12-10 11:50:36		
3663	dkebi	36	if (number <= 26) print(number) String tempString = "AA" int temp = 27; while (temp + 27 < number) { tempString += "A" temp += 27 } int remainder = temp + 27 - number; if (remainder == 1) print tempString+"A" etc	2014-12-10 11:50:36		
3664	vanul	36		2014-12-10 11:50:36		
3665	bjsiw	36		2014-12-10 11:50:36		
3666	eucmc	36		2014-12-10 11:50:36		
3667	ethan	36		2014-12-10 11:50:36		
3668	jippy	36	I think this returns BA (instead of AA) for 27	2014-12-10 11:50:36		
3669	eucmc	36	num = num -1 already takes care of that. I did test it.	2014-12-10 11:50:36		
3670	plapd	36	Sunny you are right I see the problem. here's the correct function.	2014-12-10 11:50:36		
3671	rrmeu	36		2014-12-10 11:50:36		
3672	plapd	36		2014-12-10 11:50:36		
3673	gilit	36		2014-12-10 11:50:36		
3674	huiqq	36		2014-12-10 11:50:36		
3675	fowai	36		2014-12-10 11:50:36		
3676	rrmeu	36		2014-12-10 11:50:36		
3677	rrmeu	36		2014-12-10 11:50:36		
3678	nwkeg	36		2014-12-10 11:50:36		
3679	nwkeg	36	Java Code:	2014-12-10 11:50:36		
3680	krxlv	36		2014-12-10 11:50:36		
3681	xhgls	36		2014-12-10 11:50:36		
3682	admin	36	public class Practice93 { public static void main(String[] args){ System.out.println(GetExcelColumnName(26*26+1)); System.out.println(getColumnNumber("ZA")); }	2014-12-10 11:50:36		
3683	azmjc	36		2014-12-10 11:50:36		
3684	admin	36		2014-12-10 11:50:36		
3685	sqzqo	36		2014-12-10 11:50:36		
3686	dkebi	36		2014-12-10 11:50:36		
3687	rrmeu	36	Please test the code and reply if there are any mistakes	2014-12-10 11:50:36		
3688	ufdxg	36		2014-12-10 11:50:36		
3689	ufdxg	36		2014-12-10 11:50:36		
3690	fowai	36	public String getExcelStr(int n) { return n==0?"":getExcelStr(n/26) + Character.toString((char)((int)'A'+n%26-1)); }	2014-12-10 11:50:36		
3691	ethan	36	public int getNumber(String str) { return str.length()==0?0:(int)((str.charAt(0)-'A'+1) * Math.pow(26,str.length()-1) + getNumber(str.substring(1))); }	2014-12-10 11:50:36		
3692	gilit	36		2014-12-10 11:50:36		
3693	eucmc	36		2014-12-10 11:50:36		
3694	ftfck	36	A = []  def convertDigit2Letter (d): return chr(ord('A') + d)  def convertNumber2Letters (x): x = x - 1 while x > 0: r = x % 26 x = x / 26 A.append(r) l = len(A) s = "" while (l > 0): digit = A.pop() print str(digit) if (l == 1): c = convertDigit2Letter(digit) print str(c) s += str(c) else: c = convertDigit2Letter(digit - 1) print str(c) s += str(c) l = l - 1 return s  letters = convertNumber2Letters(27) print str (letters)	2014-12-10 11:50:36		
3695	fmzze	36		2014-12-10 11:50:36		
3696	bexbp	36		2014-12-10 11:50:36		
3697	eucmc	36	In Python:	2014-12-10 11:50:36		
3698	mrjku	36		2014-12-10 11:50:36		
3699	jippy	36		2014-12-10 11:50:36		
3700	dkebi	36	In Javascript	2014-12-10 11:50:36		
3701	krxlv	36		2014-12-10 11:50:36		
3702	fowai	36		2014-12-10 11:50:36		
3703	nhibd	36	Fix typo :	2014-12-10 11:50:36		
3704	krxlv	36		2014-12-10 11:50:36		
3705	ethan	36		2014-12-10 11:50:36		
3706	sgiwy	37	Here's a dynamic programming solution which does this in O(n).	2014-12-10 11:50:44		
3707	nhibd	37		2014-12-10 11:50:44		
3708	qywrh	37		2014-12-10 11:50:44		
3709	qywrh	37	This should work as a simple solution, does anyone have a more effecient one? (call it with -1 for the parent value to start it)	2014-12-10 11:50:44		
3710	bexbp	37		2014-12-10 11:50:44		
3711	bexbp	37		2014-12-10 11:50:44		
3712	ftfck	37		2014-12-10 11:50:44		
3713	sqzqo	37		2014-12-10 11:50:44		
3714	admin	37	the above code should visit each edge of the tree only once O (n) while the worst case complexity for donnell code is around O(n^2)	2014-12-10 11:50:44		
3715	azmjc	37	We can do this problem in O(n) time using O(n) space. 1) As each element of the given array(except the root) will be in the range [0,n), so we can create an array of Linked Lists. 2) Now traverse the given array. Insert the index of the element to the respective parent. Also mark out the root in this process. So now the array becomes:	2014-12-10 11:50:44		
3716	ewigy	37		2014-12-10 11:50:44		
3717	rrmeu	37		2014-12-10 11:50:44		
3718	rrmeu	37	3) Now create a Queue. Insert the root index into it. And also insert a special symbol say $, to mark the end of the current level. Each time you pop out a element from the queue, push all its children into the queue. A bit of pseudocode to help.	2014-12-10 11:50:44		
3719	vanul	37		2014-12-10 11:50:44		
3720	rrmeu	37		2014-12-10 11:50:44		
3721	admin	37	Because each node is pushed and popped in the queue at most once, the complexity is O(n).	2014-12-10 11:50:44		
3722	rdfeo	37	This is exactly what I thought. +1 !	2014-12-10 11:50:44		
3723	ftfck	37	I think following should work	2014-12-10 11:50:44		
3724	sgiwy	37		2014-12-10 11:50:45		
3725	fowai	37		2014-12-10 11:50:45		
3726	dkebi	37	why u find the max value from l and cov[] .....in my opinion we will count the value which is greater then 0 will b desired result::	2014-12-10 11:50:45		
3727	huiqq	37	if the input is as input[]={5,5,5,5,,5,-1} then the content of cov[]={0,0,0,0,5,0} so from your side answer should b 5 but the height will b 1 can u explain more..(am i wrong or..?)	2014-12-10 11:50:45		
3728	qywrh	37	@G25 for every node, cov would store depth of the of that node, the test case which you are referring is below 5 / / \ \ \ 0 1 2 3 4 for which cov array at the end is (after executing this same code) cov = {0,0,0,0,0,1} so answer in end is 2 (the height, 1 more than maximum value in array) kindly check it on your machine, and let me know if still you find some bug in it.	2014-12-10 11:50:45		
3729	cfzie	37		2014-12-10 11:50:45		
3730	krxlv	37		2014-12-10 11:50:45		
3731	bexbp	37		2014-12-10 11:50:45		
3732	tenuw	37		2014-12-10 11:50:45		
3733	qywrh	37	Nagendra, above code looks incorrect as you are assuming level[parentnode] which are not yet traversed as 0.	2014-12-10 11:50:45		
3734	dkebi	37	The code is generated for .net, which defaults all int values to 0.	2014-12-10 11:50:45		
3735	qywrh	37	Hi KP, thanks for that. As .net sets all values to 0, I did not explicitly initialize the level array values. For other programming languages which do not initialize to 0, it is needed to explicitly set the value to 0 for all level array items.	2014-12-10 11:50:45		
3736	bexbp	37	1. Create an array of n elements, lets call it level[ ] 2. Find the root element index with value -1from node [ ], search(O(n)) 3. Set the value of that index in level [ ] to 0 4. Traverse through the node [ ], for each index(lets say index 0), find its parent index value(parent index is 3, index 3's value in level[ ] is 0 and set the value in level[ ] to parent index value (here 0 ) + 1 = 1 This is also O(n) e.g node[ ] = { 3, 3, 3, 3, -1, 2, 1, 0} level[ ] = {1, 1, 1, 0, 2, 2, 2} max value in level [ ] will be the height of the tree. find max is also o(n)	2014-12-10 11:50:45		
3737	jippy	37	same logic is implemented in my code above	2014-12-10 11:50:45		
3738	jippy	37	there is simple soln to this by just making the index the element as follows. h-height eg-int a[ ]={2,6,3,6,3,6,-1}  int h=0,i=0; while(i!=-1) { i=a[i]; ++h; } cout>>h;  it gives 4 for the above eg.	2014-12-10 11:50:45		
3739	azmjc	37	{{ class Program { static int[] parent = { 3, 4, 3, -1, 2 }; static int[] nodes = { 0, 1, 2, 3, 4 }; static int[] heigths = { 0, 0, 0, 0, 0 }; static int root = -1; static int max = -1; static int FindHeigth(int i) { var h = heigths[parent[i]]; if (h == 0) { return 1 + FindHeigth(parent[i]); } else { return h + 1; } } static void Main(string[] args) { for (var i = 0; i < nodes.Length; i++) { if (parent[i] == -1) { heigths[i] = 1; root = nodes[i]; } }  for (var i = 0; i < nodes.Length; i++) { if (i != root) { heigths[i] = FindHeigth(i); if(max < heigths[i]){ max = heigths[i]; } } }  System.Console.WriteLine("Depth " + max); System.Console.Read(); } } }}	2014-12-10 11:50:45		
3740	fowai	37		2014-12-10 11:50:45		
3741	ewigy	37		2014-12-10 11:50:45		
3742	bexbp	37	javascript solution:	2014-12-10 11:50:45		
3743	dgjji	37		2014-12-10 11:50:45		
3744	huiqq	37		2014-12-10 11:50:45		
3745	sqzqo	37	The maximum number in the array is the height of the tree ;) Isn't it ?	2014-12-10 11:50:45		
3746	nhibd	37	Not necessarily, 4,4,4,4,-1 has height 1 Not 4	2014-12-10 11:50:45		
3747	azmjc	37	How tree constructs for this array?	2014-12-10 11:50:45		
3748	xhgls	37	OK, Sorry! So unique set of Numbers, is height. ooops!	2014-12-10 11:50:45		
3749	mrjku	37	The set's size solution will only work for the above example.	2014-12-10 11:50:45		
3750	ethan	37	It is simply to check number of distinct elements in the array since each distinct element in the array denotes a parent hence introduces a new level. So find out the number of distinct elements in the array. This can be done in O(n) time	2014-12-10 11:50:45		
3751	wbqzu	37	Not correct, check with {3,3,3,-1,2,1,0}. According to your solution the answer should be 4 but the correct answer is 2.	2014-12-10 11:50:45		
3752	krxlv	37	You are right, my mistake!  Here`s a working version:	2014-12-10 11:50:45		
3753	bexbp	37		2014-12-10 11:50:45		
3754	ufdxg	37		2014-12-10 11:50:45		
3755	huiqq	37	create a hash table with <parent,list of children> pairs from the array the number of keys in the array gives the size of the tree.	2014-12-10 11:50:45		
3756	fmzze	38	Interesting, this was one of the questions of my second interview. This was my answer: - Suppose we know the size of the left subtree for each node. - We want the number of values in the interval [A, B]. This is the same as the number of values up to B minus the number of values less than A. - So we can reduce this question to finding the number of values up to X. 1) Start at the root 2a) If the value we search is less or equal to current node value. Then this node and all values to the right are larger or equal to this value and we can ignore them. Recurse on the left subtree 2b) The value we search is larger than the current node value. Then this node and all values in the left subtree are less than this value. Recurse on the right subtree.  On a balanced BST, this algorithm takes O(log N) time.	2014-12-10 11:50:46		
3757	fowai	38		2014-12-10 11:50:46		
3758	gilit	38		2014-12-10 11:50:46		
3759	gilit	38	An elegant solution..;)	2014-12-10 11:50:46		
3760	admin	38	@Miguel Do you mind posting the other questions from your interview?	2014-12-10 11:50:46		
3761	tenuw	38	this was the only question that I haven't seen online already. just notice that actual interview questions are not this precisely defined. My interviewer didn't mention "You can assume that you already have some extra information at each node", the questions are open to discussion and I asked if I could use extra information. The point is to discuss different approaches and their trade-offs.	2014-12-10 11:50:46		
3762	fowai	38	1. I don't think there is any sub-linear algorithms to solve this. In the worst case you have to visit the entire tree. Your algorithms is also O(n) not O(log N) 2. You don't need to keep any extra information. (e.g., size of the left subtree)  This is a BST after all and you can use a modified inorder traversal to print the range. Solution from Geek4Geeks:	2014-12-10 11:50:46		
3763	admin	38		2014-12-10 11:50:46		
3764	ewigy	38		2014-12-10 11:50:46		
3765	fowai	38	Can you also shoot me an email, I'd like to learn more about your interview experience? My email is ozslatersd @ gmail. Thank you, @Miguel Oliveira	2014-12-10 11:50:46		
3766	plapd	38	What part of my explanation you didn't understand?  In my approach, we only recurse in one child thanks to having the size of the left subtree, so the time complexity is O(depth) which is O(log n) in a balanced tree.  Your approach just traverses the whole tree in the worst case. It's quite different.	2014-12-10 11:50:46		
3767	sgiwy	38	Sorry, you're right. The question says return the number of nodes, not the nodes themself. My implementation print the keys, between the given range.	2014-12-10 11:50:47		
3768	gilit	38	Miguel, for the worst case for your algorithm the runtime is O(n). In the worst case every node is in the interval - to get that answer you would have to traverse every node.	2014-12-10 11:50:47		
3769	ethan	38	@Aleksey you're right, but he made the assumption that the BST is balanced in his notes.	2014-12-10 11:50:47		
3770	tenuw	38	And I've made the same mistake. The question is asking "the number of nodes", not the nodes themselves.	2014-12-10 11:50:47		
3771	dgjji	38	Alexey, the worst case is not when all numbers belong to the interval because we're only counting them. It is if the tree is actually a line. If you prefer, treat the complexity as O(depth), which is O(log n) if the tree is balanced.	2014-12-10 11:50:47		
3772	ewigy	38	Ahhhh....I see where I messed up.	2014-12-10 11:50:47		
3773	ewigy	38	Really enjoyed this solution. Thank you for sharing.	2014-12-10 11:50:47		
3774	tenuw	38	I think we can avoid some redundant calls for example when we found the if (v == node->val) - just return left size	2014-12-10 11:50:47		
3775	rdfeo	38	C++ code	2014-12-10 11:50:47		
3776	bjsiw	38		2014-12-10 11:50:47		
3777	fowai	38		2014-12-10 11:50:47		
3778	admin	38	}	2014-12-10 11:50:47		
3779	qywrh	38	Hi Neeraj,  In your program, what are the initial values of low and high .?  Suppose my root value is 15 and the min and max are given as 2 and 30 respectively, control will go into else part of the findCount() function., could you please explain what will the condition if(lbound>=low && rbound<=right) evaluate to.!	2014-12-10 11:50:47		
3780	wbqzu	38	There can be 2 ways to get the number of nodes.  Approach 1: With extra space: Step1: While inserting elements in BST, keep count of left and right children at every node including root. Step2: search(min, max) At the search time, total nodes between the min and max will be left child count of root + right child count of root - left child count of min node - right child count of max nodes + 1 for root himself  Explanation:  For BST -- search(3,20)	2014-12-10 11:50:47		
3781	dgjji	38		2014-12-10 11:50:47		
3782	gilit	38		2014-12-10 11:50:47		
3783	nwkeg	38	Search for min element in BST. Get the left and right child counts. For 3: left count = 1 and right count = 0  Search for max element BST. Get the left and right child counts. For 20: left count = 2 and right count = 1  Get the left and right child count of the root. For root: left count = 4 and right count = 4  So the total number of elements between min and max would be left child count of root + right child count of root - left child count of min node - right child count of max nodes + 1 for root himself  4 + 4 - 1 - 1 + 1 = 7 nodes  Time taken for finding nodes between min and max: Search for min element: Worst case: O(N) Search for max element: Worst Case O(N) Calculation: O (1)  Total Time taken: O(N) + O(N) + O(1) = O(N)   Approach 2: Second approach would be not to store any additional information at the node level. Once the BST is built, perform in-order traversal of the BST and start counting the elements between min and max elements given in the BST.  Total Time taken : For in order traversal O(N) For counting elements: O(1)  Total time: O(N)  I will post the code for 2 approaches in short time.	2014-12-10 11:50:47		
3784	vanul	38	Hi Saurabh,  I think your first approach will not work. Consider the same tree you given and search(7, 20).  Search for min element in BST. Get the left and right child counts. For 7: left count = 0 and right count = 0  Search for max element BST. Get the left and right child counts. For 20: left count = 2 and right count = 1  Get the left and right child count of the root. For root: left count = 4 and right count = 4  So the total number of elements between min and max would be left child count of root + right child count of root - left child count of min node - right child count of max nodes + 1 for root himself  4 + 4 - 0 - 1 + 1 = 8 nodes which is wrong. It should return 3.  Please correct me if I'm wrong.	2014-12-10 11:50:47		
3785	wbqzu	38	Correction to the above comment. In the given tree, search (7, 20) should return 5.(ot 3 as mentioned in previous comment)	2014-12-10 11:50:47		
3786	bjsiw	38	Yes, you got a point. My approach 1 wont work with the current logic. Thanks for pointing it out :)	2014-12-10 11:50:47		
3787	tenuw	38	Here's a simple solution in Python. Runs in O(n) time, which is asymptotically optimal.	2014-12-10 11:50:47		
3788	tenuw	38		2014-12-10 11:50:47		
3789	dkebi	38		2014-12-10 11:50:47		
3790	zeice	38	it is not asymptotically optimal, as I showed in my answer	2014-12-10 11:50:47		
3791	qywrh	38	You're right; I forgot that we knew the size of the left and right subtrees. Without that information, my solution is optimal :)	2014-12-10 11:50:47		
3792	wbqzu	38	Forgot to mention in the question., interviewer expected an algorithm whose worst case complexity is also less than O(N) where N is number of nodes in the tree.	2014-12-10 11:50:47		
3793	xhgls	38		2014-12-10 11:50:47		
3794	sgiwy	38		2014-12-10 11:50:47		
3795	ftfck	38	public int countNode (Tree node, int min, int max){  if(node == null){ return 0; } else if (node.data< min || node.data > max) { return 0; }  else {  if (node.data > min && node.data < max) { return (1+ countNode(node.left,min,max) + countNode(node.right,min,max));  } else { return 0; }   } }	2014-12-10 11:50:47		
3796	dgjji	38		2014-12-10 11:50:47		
3797	nhibd	38		2014-12-10 11:50:47		
3798	rrmeu	38		2014-12-10 11:50:47		
3799	nhibd	38		2014-12-10 11:50:47		
3800	vanul	38	Assume i < j	2014-12-10 11:50:47		
3801	nhibd	39	This can be done in 3 steps: 1. covert the BSTs to sorted linked list (this can be done in place with O(m+n) time) 2. Merge this two sorted linked lists to a single list (this can be done in place with O(m+n) time) 3. Convert sorted linked list to balanced BST (this can be done in place with O(m+n) time)	2014-12-10 11:50:49		
3802	eucmc	39	The condition of having constant space is not met in step 2.	2014-12-10 11:50:49		
3803	ewigy	39	@Learner - step 2 can be done in constant space. Please check the merge procedure of linked list merge sort.	2014-12-10 11:50:49		
3804	tenuw	39	How can the 3rd step be done in place with O(m+n) time?	2014-12-10 11:50:49		
3805	rrmeu	39	we have to convert BST into doubly linked list(instead of single) then merge and then convert back into balabced BST( DLL to balanced BST can be done inplace)	2014-12-10 11:50:49		
3806	nwkeg	39	step 1 take log n space stack space	2014-12-10 11:50:49		
3807	ewigy	39	Method 3 (In-Place Merge using DLL) geeksforgeeks.org/merge-two-balanced-binary-search-trees/	2014-12-10 11:50:49		
3808	wbqzu	39	. convert bst to linkedlist merge 2 sorted lists convert list to bst  // use morris trasversal. and in-place.. and but won't be O(m+n).	2014-12-10 11:50:49		
3809	gilit	39		2014-12-10 11:50:49		
3810	gilit	39		2014-12-10 11:50:49		
3811	rdfeo	39	sorry , output tree is not clear in que due to error in que box.	2014-12-10 11:50:49		
3812	bjsiw	39	The output here is missing 110. The output should be: 90 (60 (5)(70)) (110 () (800)).  Looks like a tree rotation problem to handle balancing, just as in AVL trees.	2014-12-10 11:50:49		
3813	sqzqo	39		2014-12-10 11:50:49		
3814	bexbp	39		2014-12-10 11:50:49		
3815	bexbp	39	This is a solution with time complexity of O((m + n)*log min(n,m)) and constant space complexity. If min(m,n) << m+n, we might say that this is O(m+n). If someone can optimize this to get an O(m+n) solution (without the log min(n,m)) with constant space, I would be curious to hear the solution. The assumption here is that since the question requires using no extra space, we need to modify the existing trees to derive our merged tree. We use the algorithm in a recursive fashion to arrive at our final merged tree :- 1. First traverse all the elements to find the center element of the m+n elements. So, if this were an m+n sized array, we would be looking for the (m+n/2)th element if m+n is odd OR the ((m+n)/2 + 1)th element if m+n is even. This is because if there are even number of elements, the balance binary trees right subtree would have one element less than the left subtree. This is our first (m+n)th traversal while tracking time complexity and thus far we have not used any extra space. 2. Next choose the bst which contains the the element that we found in step 1, and modify it so that this element becomes the root. Again, we use no extra space, and this is an O(n) or O(m) time complexity operation. 3. Now add a node to the other tree with the same value as the root of the other tree, and modify this tree to make this node the root node. Again an O(m) or O(n) operation in terms of time complexity, and one node extra in terms of space complexity. 4. Now choose the tree with fewer nodes, and free the root node, after holding pointers/references to the left and right subtrees - Let us call the resultant trees from this operation the left main bst and right main bst. 5. (recursion) a. final_root = root b. merge left main bst with the left subtee of the other tree c. merge right main bst with the right subtree of the other tree 6. if (final_root != null) a. final_root->left = root of left merge b. final_root->right = root of right merge else return final_root	2014-12-10 11:50:49		
3816	gilit	39	1)Get a sorted linked list out of the two trees. a) Create first sorted list by Inorder traversal on first tree b) Create Second sorted list by Inorder traversal on first tree c) Merge two sorted list. Or a) Inorder traversal of both trees together to create single sorted merged list.(Do inorder on first and second, stop first till the time second is smaller and viceversa) Complexity: O(m+n) 2)Build balanced binary tree out of sorted linked list. Complexity: O(m+n) Hint: Middle element is root of balanced btree	2014-12-10 11:50:49		
3817	eucmc	39	Convert two trees in DoubleyLinkedlist using inorder traversal then merge them thus you will have a sorted list now make a tree out of it using recursive procedure using divide and conquer will result in a balanced binary search tree.	2014-12-10 11:50:49		
3818	zeice	39	Find min in left subtree(call this modified subtree T1), Find max in right subtree(T2) Make T1 the left child of T2  Note: since the input trees are already balanced, the generated tree should also be balanced, similar trick is used in splay trees	2014-12-10 11:50:49		
3819	azmjc	39	* find i meant => splay : rotate and bring to the top (root) * left subtree => BST1 (question) * right subtree => BST2	2014-12-10 11:50:49		
3820	tenuw	39	Balance Tree 1 using rotations. I believe this is O(log n) if doing log n rotations and each rotation is constant time. Insert nodes of Tree 2 in a preorder fashion into Tree 1. O(m) to traverse + O(log n) to insert.	2014-12-10 11:50:49		
3821	eucmc	39	1) Remove each element from BST-2 and add it to BST-1. So the space which was being used for BST-2 is free now. 2) Remove each element from BST-1 and make a balanced tree (Red-Black/AVL) out of it.  In this way extra space won't be utilized. The space will be utilized only after making that space free from the other tree.  Time Complexity = O(log(m+n))  Please give suggestions.	2014-12-10 11:50:49		
3822	krxlv	39	Adding every element from BST 2 to BST1 will take mlogn time.	2014-12-10 11:50:49		
3823	plapd	39	/** Tree1: 90 / \ 70 110  Tree2: 60 / \ 5 800  Balanced Tree3: 70 / \ 5 110 \ / \ 60 90 800 */ Java language solution of this problem is given below:	2014-12-10 11:50:49		
3824	ufdxg	39		2014-12-10 11:50:49		
3825	azmjc	39		2014-12-10 11:50:49		
3826	ufdxg	39	From the amount of "new" statement you have, it is obvious that the statement "in constant space" in question cannot be achieved. Maybe it is only possible either to have time O(m+n) and space O(m+n), or time((m+n)log(m+n)), space O(1)	2014-12-10 11:50:49		
3827	ewigy	40	Why maitaining a MinHeap instead of a MaxHeap?	2014-12-10 11:50:51		
3828	eucmc	40	Because at any time I need to change/throw 1 company out of the heap, I would like the one which has been traded the minimum. If I keep maximum heap, every time a company is traded, I have to check that company's number of share, with the current heap's minimum, because that's the only 1 which will be thrown out of the heap	2014-12-10 11:50:51		
3829	ftfck	40	Thanks Aditya for explaining. Sorry, I didn't quite follow you. Can you explain by giving an example.	2014-12-10 11:50:51		
3830	ewigy	40	Everyday u create a new heap and hasmap. 1st 10 companies traded automatically enter and create the heap, as they are the most (and only) traded company till then. Then, as and when more trades happen, every time there is a live update, you check the updated record with the min heap only, so only, a constant number of 10 checks. If the company is in the Heap already, you update the number of shares, and rebalance the heap if required. If the company is not in the heap, you just see if the total trade of this new company is more than the trade of the root company. If yes, you replace the root with the new company, and rebalance if required.	2014-12-10 11:50:51		
3831	ethan	40	How can we find the ten most traded companies from the HashMap that is maintained? Do we need to scan the entire hashmap to find the top 10 every time a live update comes in?	2014-12-10 11:50:51		
3832	sqzqo	40	Nope, never said you find top 10 from HashMap. For the top 10, you maintain a min heap, and everytime there is a live update, you check the updated record with the min heap only, so only, a constant number of 10 checks. If the company is in the Heap already, you update the number of shares, and rebalance the heap if required. If the company is not in the heap, you just see if the total trade of this new company is more than the trade of the root company. If yes, you replace the root with the new company, and rebalance if required.	2014-12-10 11:50:51		
3833	xhgls	40	ok got it thanks...  I was thinking of a TreeSet(maintains sorted set of objects) which sorts objects by number of votes. But again , this might involve an implicit sort after every update which might take complexity to n^2lgn . I find your solution is nlg10 which is O(n) correct?	2014-12-10 11:50:51		
3834	bjsiw	40	I was wondering why a simple sorted array is not the solution. It provides O(1) modification and search and max.	2014-12-10 11:50:51		
3835	nwkeg	40	Exactly how do you get O(1) modification, search or max in a sorted array? None of these operations are possible in O(1), except maybe Modification, that also, ONLY if you know the index you want to modify	2014-12-10 11:50:51		
3836	eucmc	40	You are right. Search and max-10 are O(1) since it is sorted. But the sorting after modifying one company is O(n) which is not good.  But a combination of sorted array and heap might help. If we assume "N = the number of companies" and N >> 10, then you could imagine a sorted array of length 9 and a heap of length N - 9 with "extract-max".  Now if the load for a company changes, if it already belongs to the top 9, then it is at most "9" swaps to re-sort. If it belongs to 10'th company, then we compare the max of heap with the min of array. Then if necessary, in one swap, we could change the "max" of heap with min of array and in at most 9 swaps re-order array. If the company is already in the heap, then it is O(log(N - 9)). So the time complexity is max(10, c log(N)) swaps.	2014-12-10 11:50:51		
3837	wbqzu	40	1) In your original approach, even searching isn't O(1), since the array was sorted by number of trades, and not some company index.  2) In your current approach, if the company is in the heap, and the number of trades isn't sufficient for it to qualify as top 10, you still end up re-balancing the heap in O(log(N)) time, which isn't good. You will end up re-balancing the heap at every trade, not just when you need the top 10.	2014-12-10 11:50:51		
3838	sgiwy	40	1) Searching is O(1). You can assume you keep a separate array to keep the company index and apply any modification on the trade load array on the index array as well. Then the i-th position of the trade-load is the i-th largest, and the i-th position of the index array, is the company index.  2) True. But each new modification (if arbitrary) requires O(log(n)) comparisons to determine the position.  3) <<<On a separate note>>> I guess we don't even need to have a heap for this application. Divide the companies into two sets: Set(1) = {top 9}, Set(2)={Other companies}. Keep a pointer to the company in Set(2) with maximum trade load at this time.  Event: A company "X" changes in trade load: Let: Y = max{Set(2)}, Z = arg min{Set(1)} A) X is in Set(2):  A-1) X < Y ==> Do nothing. A-2) (X > Y) & (X < Z) ==> max{S(2)} = X. A-3) X > Z ==> Add X to array of top 10. Drop Z from the array. Let max{Set(2)} = Z.  B) The X = Y (also in Set(2)) B-1) Y > Z ==> Set max{S(2)} = &Z. Add to position of Z. Reorder top 9. B-2) Y < Z ==> Do nothing.  C) X is in Set(1) C-1) A simple reorder under 9 swaps. No change to Set(2).  Then, the time complexity of each modification would be O(1). This approach works if trade load change at each instance is a non-negative number.	2014-12-10 11:50:51		
3839	eucmc	40	1) Still not sure how you will get O(1) search. Can you please give an example? (Also, you are now using 2 arrays, twice d space).  2) In your approach, each modification requires O(log(N)) comparisons to determine the position. That will not be the case in a 10 element min heap and a HashTable, the solution I proposed after the hint from the interviewer.  3) Not sure how you intend to implement the Set Interface. That will dictate how much time it will take for you to find and update the trade load value of companies in both the sets. If that's taken care of, this look good, at least to me. The only thing, though outside the scale of this specific problem is, what if the query of top 10 changes, say, to a 100, or a 1000. Maintaining a min heap still scales better, as a new entry in the heap will require a operation of logN time, while sorting a set (or array, whatever you are using) will need more time.	2014-12-10 11:50:51		
3840	ewigy	40	3) This is a crude implementation:	2014-12-10 11:50:51		
3841	vanul	40		2014-12-10 11:50:51		
3842	fowai	40		2014-12-10 11:50:51		
3843	nwkeg	40	As I look again, the pointer to maximum is not necessary. All we care is the top 10. When a company changes in load, we just need to compare it with top 10.  As you said, it scales badly with number of top companies. Maybe for large enough such number, a balanced binary tree is a solution.  2) You are right. At first I was thinking of sorted array implementation and I did not notice you solution.  1) What I meant was something like this:	2014-12-10 11:50:51		
3844	wbqzu	40		2014-12-10 11:50:51		
3845	zeice	40		2014-12-10 11:50:52		
3846	ufdxg	40	if load for some company changes, e.g., company "3", then	2014-12-10 11:50:52		
3847	plapd	40		2014-12-10 11:50:52		
3848	dgjji	40		2014-12-10 11:50:52		
3849	zeice	40	After sort we swap load[2] and load[0]. Do the same for order.	2014-12-10 11:50:52		
3850	jippy	40		2014-12-10 11:50:52		
3851	jippy	40		2014-12-10 11:50:52		
3852	plapd	40	Now order[0] refers to the company with maximum load.  However, this is useless since we could define an array of Company objects already including all the information.	2014-12-10 11:50:52		
3853	fmzze	40	Do you intend the use of priority queue here ?	2014-12-10 11:50:52		
3854	cfzie	40	Hi Aditya, Totally unrelated to your question, I just wanted to know if the interview process in Bloomberg specifies any language like C or C++ or Java, or is it open to us to use anything.	2014-12-10 11:50:52		
3855	vanul	40	I think bloomberg has bigger focus on c++, because their work is mainly in that, except a couple of team who work in JAVA. That said, if u are strong in JAVA and not C++, dnt say to d interviewer that you will give the interview in C++. To them it doesn't matter that much I believe, as long as you can show that you understand the approach to the problem sufficiently well.	2014-12-10 11:50:52		
3856	fowai	40	Thanks for the reply. Does the phone interview cover Algorithms, Data Structures, OOD and puzzles or does it have anything more?	2014-12-10 11:50:52		
3857	jippy	41	It is missing some condition, for example consists of english words. Because: aaaaaaaaaaabaaaa will not tell what position b is located in any of the aba, aab, baa return.	2014-12-10 11:50:53		
3858	nhibd	41	Well, may be if you do hige amount of runs and compare amount of aab vs baa occurence, you will know b position, provided perfect random distribution	2014-12-10 11:50:53		
3859	ufdxg	41	In the above example, huge amount of runs won't only tell whether letter b is not the first, second, last, or second last letter in the sequence, by checking the distribution. It won't tell where letter b is in the middle.	2014-12-10 11:50:53		
3860	plapd	41	Total combination of unique triplets is total=n!/6(n-3)!. From them starting from the first charachter of string is (n-1)(n-2)/2, second (n-2)(n-3)/2 and so on So, we know the percintile of triplets that has to have first string character as first triplet char, second, and so on, it is getting less and less. For ever character of the alphabet, count how many times it was first in the triplet on many calls. Take most frequent. It will be the first char. Substract percentile based on the postion by the above formula for this char. Repeat untill build half a string. The other half build in similar way going backwords and counting last tripplet char.	2014-12-10 11:50:53		
3861	fmzze	41	in the case of baaaaaaacaaaaab, the most common first and last char would be a instead of b.	2014-12-10 11:50:53		
3862	mrjku	41	I guess you should run the code for 1 000 000 time and after this you look at the percentage of each letter to appear.... in fact if a letter has higher probability => this means that it appears more than one time	2014-12-10 11:50:53		
3863	wbqzu	41	Consider for every string returned , each character as a node of the graph. Then on final output, perform Topological Sort to give the original string	2014-12-10 11:50:53		
3864	sqzqo	41	Nice idea, but in the the case of "helloworld", what if you get "low" and "wol"? How do you deal with duplicate characters?	2014-12-10 11:50:53		
3865	cfzie	41	This code works for most strings. If in the secret string there is not too much duplicating then this algo will work fine and in most cases it will be able to recover secret string as it is.	2014-12-10 11:50:53		
3866	ufdxg	41		2014-12-10 11:50:53		
3867	bjsiw	41		2014-12-10 11:50:53		
3868	fowai	41	Create a N tree using the combination, and having a dictionary function to return true or false for verification the words. Now go down to the n tree with the depth of the words. Do a complete traversal to find the valid word in the dictionary.	2014-12-10 11:50:53		
3869	bjsiw	41	My idea is to call getTripplet() many times and for each tripplet, represent it as a directed path in a graph. Say for string "abcd", we could have abc, abd, acd, bcd. So we create a graph based on all those tripplets. If a path already exists, just ignore it (in this case, b->c->d path already exists before reach this tripplet).  After the graph is constructed, find a full path that visits all the nodes.  The tricky part is how many times you should call getTripplet(). My random guess is until you have called it 10 times and you found all the paths already exist.	2014-12-10 11:50:53		
3870	rrmeu	41	My solution. This returns correct guess in most cases. But there might be a set whose element generate exact same set of triplets, in which case the guessed string might not be the same to the secret string but still a correct guess.	2014-12-10 11:50:53		
3871	rdfeo	41		2014-12-10 11:50:53		
3872	ewigy	41		2014-12-10 11:50:53		
3873	wbqzu	41	Did anyone find the solution?	2014-12-10 11:50:53		
3874	krxlv	41	topo sort	2014-12-10 11:50:53		
3875	rrmeu	41	You may have duplicate elements in the string. How do your determine which is which?	2014-12-10 11:50:53		
3876	mrjku	41	Here is my first try:	2014-12-10 11:50:53		
3877	fowai	41		2014-12-10 11:50:53		
3878	tenuw	41		2014-12-10 11:50:53		
3879	tenuw	41	I dont think you can write this length code within an interview....	2014-12-10 11:50:53		
3880	gilit	41	Most of the times your program's guess is wrong.	2014-12-10 11:50:53		
3881	wbqzu	41	import java.util.Random;  public class RandomTripplet {  private static Random random = new Random();  private static int randomInteger(int min, int max) { return min + random.nextInt((max - min) + 1); }  public static String getRandomTripplet(String str) {  if (str.length()<=3) return str;  char[] array = str.toCharArray(); int lastIndex = str.length() - 1; int firstIndex = randomInteger(0, lastIndex - 2); int secondIndex = randomInteger(firstIndex+1, lastIndex - 1); int thirdIndex = randomInteger(secondIndex+1, lastIndex);  return String.valueOf(array[firstIndex]) + String.valueOf(array[secondIndex]) + String.valueOf(array[thirdIndex]);  }  public static void main(String[] args) { for (int i=0; i<5; i++) System.out.println(getRandomTripplet("helloworld")); }  }	2014-12-10 11:50:53		
3882	bexbp	41	Its simple . Get all possible triplets using getrandtriplets multiple times. Sort all these triplet. For the string by 1st letter all the sorted list.	2014-12-10 11:50:53		
3883	ftfck	41	Let's assume the length of the given string as N. Therefore, index range for each character in the string is: [0,N-1]  Lets's assume the desired random triplet is represented as XYZ. Also, let's assume Ix,Iy, and Iz denote randomly chosen indices for characters X, Y, and Z respectively. As per the given condition: Ix = [0, N-3] Iy = [ Ix+1, N-2] Iz = [ Iy+1, N-1]  The psuedo code is:	2014-12-10 11:50:53		
3884	bjsiw	41		2014-12-10 11:50:53		
3885	tenuw	41		2014-12-10 11:50:53		
3886	dgjji	41	We want to guess the string not to implement getRandomTripplet() method. It is given to you.	2014-12-10 11:50:53		
3887	ethan	41		2014-12-10 11:50:53		
3888	cfzie	41		2014-12-10 11:50:53		
3889	admin	41		2014-12-10 11:50:53		
3890	ethan	41		2014-12-10 11:50:53		
3891	sqzqo	41	It works, but with O(N3);	2014-12-10 11:50:54		
3892	rrmeu	41	This question needs a tedius program. So I just list the steps for solving it.  1. Maintain a list of possible strings at all time. If the list has only one string with the required length, that is the answer.  2. If list has multiple strings, call getRandomTriplet() again. Combine the triplet with each of the strings in the list. If length overflow, delete it. A new list is formed.  3. In combining two strings (one from the list, one is a triplet). We could simply merge the two. Say 'abc' and 'def'. It can generate 'abcdef', 'dabcef', 'dabecf', 'dabefc', 'adbcef', 'adbecf', 'adbefc', 'deabcf', 'deabfc', 'deafbc', 'abdcef', 'abdecf', 'abdefc', 'daebcf', 'daebfc', 'daefbc', 'adecef', 'adefbc', 'defabc'.  If the two strings share some letters, we could use shared letters and generate shorter strings. Say 'abc' and 'dbf', we could generate 5 letter strings, 'adbcf', 'dabcf', 'adbfc', 'dabfc'.	2014-12-10 11:50:54		
3893	sgiwy	41	// this is a working code in JAVA for Nplets, that is duplex, triplex, quadruplets etc are provided by the function argument	2014-12-10 11:50:54		
3894	ewigy	41		2014-12-10 11:50:54		
3895	huiqq	41		2014-12-10 11:50:54		
3896	ftfck	41	1. Generate a random string 2. Generate 3 random numbers, the first between 0 and string length, the second between 1st number and string length and 3rd between 2nd number and string length. 3. Concatenate string indices to get the random triplet.	2014-12-10 11:50:54		
3897	vanul	41		2014-12-10 11:50:54		
3898	mrjku	41		2014-12-10 11:50:54		
3899	vanul	41		2014-12-10 11:50:54		
3900	jippy	41		2014-12-10 11:50:54		
3901	fowai	41		2014-12-10 11:50:54		
3902	plapd	41		2014-12-10 11:50:54		
3903	jippy	41		2014-12-10 11:50:54		
3904	ufdxg	41		2014-12-10 11:50:54		
3905	sgiwy	41	It doesn't compile.	2014-12-10 11:50:54		
3906	qywrh	41	I was able to compile it by including <cstring>. However, I tried to execute it with strings other than "wanderlayindustries" and I got segmentation fault all the time.	2014-12-10 11:50:54		
3907	ethan	41		2014-12-10 11:50:54		
3908	sqzqo	41		2014-12-10 11:50:54		
3909	dgjji	41		2014-12-10 11:50:54		
3910	sqzqo	41		2014-12-10 11:50:54		
3911	ufdxg	41		2014-12-10 11:50:54		
3912	sgiwy	41		2014-12-10 11:50:54		
3913	bjsiw	41		2014-12-10 11:50:54		
3914	plapd	41		2014-12-10 11:50:54		
3915	wbqzu	41	You have the length of the string. After a certain number of attempts all coming up "aaa", you really could conclude that, with high probability, the string is "aaaaaaaaaaaaaaa". I'm guessing the question only requires you to return an answer that is correct with high probability, because clearly there is always some chance that you will never even learn about the existence of a character. That chance can become vanishingly small with enough uses of the random triplet method, however.	2014-12-10 11:50:54		
3916	sgiwy	41	Agree with this comment (which has -3 votes). This is a ridiculous question for an interview.	2014-12-10 11:50:54		
3917	huiqq	41		2014-12-10 11:50:54		
3918	plapd	41		2014-12-10 11:50:54		
3919	dgjji	41	Why it this code voted as negative? is there any problem with that ?	2014-12-10 11:50:54		
3920	vanul	42		2014-12-10 11:50:56		
3921	ethan	42		2014-12-10 11:50:56		
3922	jippy	42	Hi,  Can you tell me how this works?  Thanks	2014-12-10 11:50:56		
3923	sgiwy	42	Do we really need (arr[arr[i]] % size) why cant we directly put the arr[arr[i]] which i guess will yield the same result.since the values of array cannot be more than the size...	2014-12-10 11:50:56		
3924	cfzie	42	@/  I think what he's doing is effectively magnifying the final result so that the current value doesn't matter anymore. When he multiplies the arr[arr[i]] by size and add the current value to it, you get a new value. This new value can use division to get the final result or modulo to obtain the current value. When he does the division, the current value(remainder) just falls off and you get the final value.	2014-12-10 11:50:56		
3925	azmjc	42	@ Royal  I think you need the %size because you can potentially retrieve the new final value from arr[arr[i]]. And that would mess up the calculation. You can try it with the input from the question: {2,3,1,0} will become: {1,0,3,6}  Btw, Ganesh Ram Sundaram, this solution is ingenious.	2014-12-10 11:50:56		
3926	sgiwy	42	It is simple maths:	2014-12-10 11:50:56		
3927	eucmc	42		2014-12-10 11:50:56		
3928	nhibd	42		2014-12-10 11:50:56		
3929	fmzze	42	Good solution.	2014-12-10 11:50:56		
3930	tenuw	42	Thanks for all your comments! The logic I used is exactly as pointed out by aka. In the first loop, I add (size * "OLD arr[arr[i]]") to arr[i] so that, when doing integer division by size, I get old arr[arr[i]], when doing %size, I get old arr[i]. However I add arr[arr[i]]%size to get old arr[arr[i]], in case it was already modified in the loop. The second loop simply replaces each arr[i] with old arr[arr[i]], as mentioned above.	2014-12-10 11:50:56		
3931	nwkeg	42	Very nice idea. I just wanted to point out one bug (one modulo operator is missing). Here's the correction I made:	2014-12-10 11:50:56		
3932	eucmc	42		2014-12-10 11:50:56		
3933	nhibd	42		2014-12-10 11:50:57		
3934	fowai	42	One problem of this approach is that when size of the array is big (N >= 2^31) there will be overflow.  My approach in another solves this problem.	2014-12-10 11:50:57		
3935	ewigy	42	I don't get it - if you are modifying elemants as per @zelox991 example, why not just:  a[i]=i	2014-12-10 11:50:57		
3936	azmjc	42	for size greater than long long int ?	2014-12-10 11:50:57		
3937	rdfeo	42	Good idea. It's a mix and filter solution. Same algo in scala:	2014-12-10 11:50:57		
3938	plapd	42		2014-12-10 11:50:57		
3939	dkebi	42		2014-12-10 11:50:57		
3940	rrmeu	42	If I were right, the question is to modify matrix so that for any 0 <= i < n, i=a[a[i]]. Why the proposed algorithm is correct? Suppose we change the matrix to {2,0,1,3}, then the output will be {1,2,0,3}, am I right? Several observations are, 1) after modification is applied, if a[i] = j, then a[j] = i; 2) it is impossible that a[i] = j and a[i'] = j (i != i'). If such case exists, then what's the value for a[j]? If we assume that for all a[i] = j, 0 <= j < n (no value goes out of the range 0 ~ n-1), then for any i, we could pick i' (i' != i || i' == i), let a[i] = i' and a[i'] = i.	2014-12-10 11:50:57		
3941	fmzze	42	public static void modIndex(int[] array){ int pre = array[0]; int idx = 0; array[0] = -array[pre]; while (true){ int i = 0; for(; i < array.length;i++){ if(array[i] == idx) break; } if(i == array.length) break; int t = array[i]; array[i] = - pre; pre = t; idx = i;  }  for(int i = 0 ; i < array.length; i++) array[i] *= -1; }	2014-12-10 11:50:57		
3942	admin	42		2014-12-10 11:50:57		
3943	jippy	42		2014-12-10 11:50:57		
3944	xhgls	42	:_(	2014-12-10 11:50:57		
3945	bjsiw	42	@BigKdotAtTdot	2014-12-10 11:50:57		
3946	sqzqo	42		2014-12-10 11:50:57		
3947	jippy	42		2014-12-10 11:50:57		
3948	bjsiw	42	indicates that all elements are relocated. Then it can jump out of the loop.	2014-12-10 11:50:57		
3949	rrmeu	42	Hi, What is point of making the array elements into negative.	2014-12-10 11:50:57		
3950	zeice	42	Please can you explain your algorithm? Or comment your code? Or both :)	2014-12-10 11:50:57		
3951	azmjc	42	Deducing from the example, I think what we really want here is I = arr[arr[I]], which can be done in many ways while one of them is simply let arr[k] = k.	2014-12-10 11:50:57		
3952	dkebi	42	No look at the example properly. Its not moving the indices , its moving the value present at the indices. One information I missed in the question is , the array contains 0 to n-1 integers.	2014-12-10 11:50:57		
3953	ethan	42	Your example doesn't make sense. The condition is 'arr[I] = arr[arr[I]]'. In your example for l = 0 arr[0] = 1 arr[1] = 0 so arr[I] != arr[arr[I]]	2014-12-10 11:50:57		
3954	vanul	42	I agree the question is i = arr[arr[i]] and the solution proposed arr[k] = k is correct. But as mentioned there are other solutions also and I could not think of any way to do it. Is it NP complete?	2014-12-10 11:50:57		
3955	cfzie	42		2014-12-10 11:50:57		
3956	jippy	42		2014-12-10 11:50:57		
3957	nwkeg	42	Can u plz explain ur logic ?	2014-12-10 11:50:57		
3958	fowai	42	1. Number up to n can be held in log(n) ceiling bits, say m. 2. The first loop puts target value into the bits offset by m bit from right, so the right most m bits still hold the original value. 3. The second loop purges the original value, which is index to the cell holding target value, and move the m bits holding the target value, to right most positions.  It is possible to use to implement a similar solution using mod division and multiplication, instead of using bit wise operations.	2014-12-10 11:50:57		
3959	rrmeu	42	Ok this works for smaller numbers may be, how about larger numbers. Lets say we want to do this using 'byte' data type and there are numbers from 0 to 127. Would this still work ? nevertheless a vry nice approach.	2014-12-10 11:50:57		
3960	krxlv	42	This method assuming the length is smaller enough to put into integer (8/16/32 bits?) right?	2014-12-10 11:50:57		
3961	zeice	42	in line : arr[i] += (arr[arr[i] & mask] & mask) << shift; can't it just be arr[i] += arr[arr[i]]<<shift; as integers are guaranteed to be between 0 and n-1. What is the point in masking anyways.	2014-12-10 11:50:57		
3962	huiqq	42	@coder, the mask is used to clear set bits beyond the m right most bits. When an element points back to an element with smaller index, the targeted value is no longer the original value.	2014-12-10 11:50:57		
3963	azmjc	42	Actually using mod division and multiplication results shorter, and easy to understood code:	2014-12-10 11:50:57		
3964	wbqzu	42		2014-12-10 11:50:57		
3965	ethan	42		2014-12-10 11:50:57		
3966	mrjku	42		2014-12-10 11:50:57		
3967	admin	42		2014-12-10 11:50:57		
3968	rdfeo	42	You need to do it without using additional memory, your solution implicitly uses stack for recursion.	2014-12-10 11:50:57		
3969	azmjc	42		2014-12-10 11:50:57		
3970	qywrh	42		2014-12-10 11:50:57		
3971	ufdxg	42	this only works if 0 is the last element	2014-12-10 11:50:57		
3972	huiqq	42	Yes, you are right, thanks for pointing that, and I modify code based on my previous thought.	2014-12-10 11:50:57		
3973	bexbp	42		2014-12-10 11:50:57		
3974	dkebi	42		2014-12-10 11:50:57		
3975	jippy	42	Here we have a loop. a[0] becomes a[2] and a[2] becomes a[1]... a[0]->a[2]->a[1]->a[3]->a[0]. If we change any one value we will break the cycle. So, until we change all the values, we need to retain both the old and new values. Normally we could save them in a temporary vector b. But here we are not allowed to do that. But the hint is that the number are between 0...n-1. So, assuming n^2 < max(int) we can keep the old and the new values simultaneously with just a single number. Here is what we can do:  First change each of a[i] to n*(newval+1)+oldval. Given a[i], we can get its old value by a[i]%n and get the new value by (a[i]/n -1). Here is my code:	2014-12-10 11:50:57		
3976	ufdxg	42		2014-12-10 11:50:57		
3977	mrjku	42		2014-12-10 11:50:57		
3978	vanul	42	it won't work with {4,3,1,2} where you should get {0,2,3,1} as output	2014-12-10 11:50:57		
3979	ethan	42	It is working for {0,3,1,2}(assuming you typed 4 for 0 by error). I get {0,2,3,1}.	2014-12-10 11:50:57		
3980	rdfeo	42		2014-12-10 11:50:57		
3981	ufdxg	42		2014-12-10 11:50:57		
3982	rrmeu	42	O(n) solution:	2014-12-10 11:50:58		
3983	vanul	42		2014-12-10 11:50:58		
3984	vanul	42		2014-12-10 11:50:58		
3985	eucmc	42		2014-12-10 11:50:58		
3986	eucmc	42		2014-12-10 11:50:58		
3987	fmzze	42		2014-12-10 11:50:58		
3988	gilit	42		2014-12-10 11:50:58		
3989	rrmeu	42		2014-12-10 11:50:58		
3990	fmzze	42		2014-12-10 11:50:58		
3991	bjsiw	42		2014-12-10 11:50:58		
3992	fowai	42		2014-12-10 11:50:58		
3993	huiqq	42	You can even do number splitting based on bits, given all the integer, you can store arr[arr[i]] on other half (16 bits) and arr[i] on first 16 bits.	2014-12-10 11:50:58		
3994	nwkeg	42		2014-12-10 11:50:58		
3995	sgiwy	42		2014-12-10 11:50:58		
3996	dgjji	42	Good answer, just iterate with	2014-12-10 11:50:58		
3997	huiqq	42		2014-12-10 11:50:58		
3998	mrjku	42		2014-12-10 11:50:58		
3999	mrjku	42	I would like to correct my previously posted algorithm, here is the one that compiles, written in Java:  import java.util.Arrays;	2014-12-10 11:50:58		
4000	azmjc	42		2014-12-10 11:50:58		
4001	qywrh	42		2014-12-10 11:50:58		
4002	wbqzu	42	Could we keep rotating the array say i times and check if the terminating condition for all elements in the array. a[i] == a[a[i]] . The rotating process could be done by log(n) and the worst case would be n log(n)	2014-12-10 11:50:58		
4003	huiqq	42	solution inspired by cycle leader iteration algorithm	2014-12-10 11:50:58		
4004	gilit	42		2014-12-10 11:50:58		
4005	ethan	42		2014-12-10 11:50:58		
4006	sqzqo	42	call using f(0, False)	2014-12-10 11:50:58		
4007	fowai	42	For each element, trace it down until a loop is formed.  e.g. [2, 3, 1, 0]  1. all add one ==> [3, 4, 2, 1] 2. at position 0 arr[0] = arr[arr[0] - 1] = arr[3 - 1] = arr[2]  so, we swap position 0 and 2, and maintain a integer "value" to remember what arr[2] is originally Here we get: - new arr: [-2, 4, 3, 1] (-2 is to mark it's in right place) - value: 2 (what arr[2] is originally)  then we at the position 2, arr[2] = arr[arr[2] - 1] = arr[value - 1] = arr[1] then we swap position 2 and 1, and update "value" to arr[1] new arr: [-2, 3, -4, 1] value: 4  then we at position 1 as before, we get new arr: [-2, -1, -4, 3] value: 1  then we at position 3 arr[3] = arr[arr[3] - 1] = arr[value - 1] = arr[0] since arr[0] now is negative, we've finished this loop, set current position to its opposite and move to next position. Now arr = [-2, -1, -4, -3]  3. since all values are negative, they're in right places. Restore value, we get: [-2, -1, -4, -3] ==> [2, 1, 4, 3] ==> [1, 0, 3, 2]  4. done	2014-12-10 11:50:58		
4008	plapd	42		2014-12-10 11:50:58		
4009	bexbp	42		2014-12-10 11:50:58		
4010	krxlv	42	onestopinterviewprep.blogspot.com/2014/03/arri-arrarri-in-place.html	2014-12-10 11:50:58		
4011	fmzze	42	O(n*log(n))	2014-12-10 11:50:58		
4012	gilit	42		2014-12-10 11:50:58		
4013	fmzze	42		2014-12-10 11:50:58		
4014	rrmeu	42	Recursive solution is very simple. It sounded like they were looking for something along those lines. I can paste the code I wrote whn on my laptop. Typing on the phone is too much hassle.	2014-12-10 11:50:58		
4015	eucmc	42	curious!  would [0, 1, 2, 3] be considered as a valid answer?	2014-12-10 11:50:58		
4016	ewigy	42	The largest value is n-1, if this value can fit into the lower 16 bits of the integer, we can use the higher 16 bits as a buffer to swap numbers in place. So if n <= 2^17, we can shift the lower 16 bits to higher 16 bits for A[i], making spaces for A[A[i]], then add the original A[A[i]] back (now it's shifted left 16 bits, so shift it back before adding it to A[i]), finally clear out the higher 16 bits.	2014-12-10 11:50:58		
4017	sqzqo	42		2014-12-10 11:50:58		
4018	nwkeg	42		2014-12-10 11:50:58		
4019	rrmeu	42	Not sure why there is ; appended to the end of shift operator, but anyway, you got the idea.	2014-12-10 11:50:58		
4020	huiqq	42	Correction: to get the original value, do not shift the current value back because its lower 16 bits might already been set, so shift to right to get the original value will lose the lower 16 bits. So we write another function that returns a value copy of the higher 16 bits of a number to get its original value.	2014-12-10 11:50:58		
4021	fmzze	42		2014-12-10 11:50:58		
4022	wbqzu	42		2014-12-10 11:50:58		
4023	sgiwy	42	can anyone just explain me the question..how is the modification working..?	2014-12-10 11:50:58		
4024	vanul	42		2014-12-10 11:50:58		
4025	ethan	42		2014-12-10 11:50:58		
4026	ethan	42	I solved this with recursion and looking up the index from the last in the array and then go from there.  1. check wether this is the first round and store the first item (temp) 2. put new item=a into first item 3. lookup (index of a) - in the array 4. now put temp in the found place and so on	2014-12-10 11:50:58		
4027	sqzqo	42		2014-12-10 11:50:58		
4028	huiqq	42		2014-12-10 11:50:58		
4029	nhibd	42	You just need to store the next index before it is overwritten. I am doing this using the nextIndex variable. Java code:	2014-12-10 11:50:58		
4030	xhgls	42		2014-12-10 11:50:58		
4031	eucmc	42		2014-12-10 11:50:59		
4032	sqzqo	42	This can be accomplished the same way you would do it with memory allocation, but instead using pointers.	2014-12-10 11:50:59		
4033	zeice	42		2014-12-10 11:50:59		
4034	ethan	42		2014-12-10 11:50:59		
4035	krxlv	42	}	2014-12-10 11:50:59		
4036	azmjc	42	Reverse function can be work in this use case: example : if a = {2,3,1,0} ----> Reverse(0,4)--> 0,1,3,2----> reverse (0,1)---> 1 ,0 ,3,2	2014-12-10 11:50:59		
4037	ufdxg	43	- Get digits of N in positional order - Find first digit M that is not in ascending order (searching from right to left) - If all digits are in ascending order from right to left, then return N - Find the smallest digit P that is to the right of M and is also larger than M - Swap positions of M and P - Sort digits after original position of M in ascending order from left to right - Build and return from digits	2014-12-10 11:51:01		
4038	nhibd	43		2014-12-10 11:51:01		
4039	bexbp	43		2014-12-10 11:51:01		
4040	bjsiw	43	Array.sort is O(nLogN). To keep the total time complexity linear, just reverse the remaining digits as they are already sorted in descending manner from left to right.	2014-12-10 11:51:01		
4041	sgiwy	43	And we don't have to search for minimum value on the right side of our found first_not_in_ascending_order digit. It would allways be rightmost digit. Because they are actually arranged in ascending order from right to left:)	2014-12-10 11:51:01		
4042	dgjji	43	I think the time complexity is O(log N)  Proof: For Integer N , there are max of logN+1 digits , let K= log N so, 1. For traversing over digits : O(K) 2. We know the digits range only from 0-9 , so we'll use bucket sort, radix sort algos instead of heap -r quick sort , hence for sorting O(K)  over all : O(K) => O(log N)	2014-12-10 11:51:01		
4043	qywrh	43	very similar to leetcode Next Permutation	2014-12-10 11:51:01		
4044	huiqq	43		2014-12-10 11:51:01		
4045	huiqq	43		2014-12-10 11:51:01		
4046	cfzie	43		2014-12-10 11:51:01		
4047	jippy	43		2014-12-10 11:51:01		
4048	ethan	43		2014-12-10 11:51:01		
4049	tenuw	43		2014-12-10 11:51:01		
4050	rrmeu	43	Come on, dude. 1. you use additional space; 2, the complexity is log linear, because no need to sort for every descending order!	2014-12-10 11:51:01		
4051	ewigy	43	integer to array, then scan from the last digit, if a[i] < a[i + 1] continue, until you find a pos to stop, if not found, then return the original number (cannot swap), else do:  let the number to be swapped is x = a[i + 1] (which is smaller than a[i]) find the position that a[p] > x (p is from 0 to i - 1, use binary search) swap the a[p + 1] and x; reverse the order of elements from 0 to i; convert the array to integer and return it.	2014-12-10 11:51:01		
4052	sgiwy	43		2014-12-10 11:51:01		
4053	fmzze	43		2014-12-10 11:51:01		
4054	nhibd	43	#include<stdio.h> #include<conio.h>   int main() { int n,i,j,k,ar[5],num,key,p; printf("Enter no.: "); scanf("%d",&n); i=0; p=n; while(n>0) //seperating each digit { //and storing it in array. ar[i]=n%10; n=n/10; i++; } num=ar[i-1]; //using last digit in num bcz num must be started with same digit i.e. for(j=1;j<i-1;j++) //if number is 21567 then higher will be started from 2 and will be 25167 { key=ar[j]; //appplying insertion sort on digits stored in array except last digit k=j-1; while((k>=0)&&ar[k]>key) { ar[k+1]=ar[k]; k=k-1; ar[k+1]=key; } } for(k=0;k<i-1;k++) //finding the smallest larger number from last digit { //i.e larger no than 2 in our example is 5 which is smallest if(ar[k]>num) //of all larger no's. { j=k; key=ar[k]; break; } } num=num*10+key; //converting digits in number k=0; while(k<i-1) { if(k==j) //we need not to take that digit which is already has been used { //so if that location comes, just increment in k location k++; } num=num*10+ar[k]; k++; } printf("\nThe next higher number of %d is %d",p,num); getch(); return 0; }	2014-12-10 11:51:01		
4055	nwkeg	43		2014-12-10 11:51:01		
4056	admin	43		2014-12-10 11:51:01		
4057	cfzie	43		2014-12-10 11:51:01		
4058	xhgls	43		2014-12-10 11:51:01		
4059	dkebi	43		2014-12-10 11:51:01		
4060	fmzze	43		2014-12-10 11:51:01		
4061	fowai	43	}	2014-12-10 11:51:01		
4062	bjsiw	43	Pretty sure some simple thing like this in Ruby would work.	2014-12-10 11:51:01		
4063	xhgls	43		2014-12-10 11:51:01		
4064	azmjc	43		2014-12-10 11:51:01		
4065	rrmeu	43	And a slightly longer version in Python	2014-12-10 11:51:01		
4066	fmzze	43		2014-12-10 11:51:01		
4067	ftfck	43		2014-12-10 11:51:01		
4068	wbqzu	43	And finally a kind of ridiculous one line ruby script with no semi-colons	2014-12-10 11:51:01		
4069	bjsiw	43		2014-12-10 11:51:01		
4070	azmjc	43		2014-12-10 11:51:01		
4071	xhgls	43		2014-12-10 11:51:02		
4072	bjsiw	43		2014-12-10 11:51:02		
4073	ufdxg	43		2014-12-10 11:51:02		
4074	dgjji	43		2014-12-10 11:51:02		
4075	huiqq	43		2014-12-10 11:51:02		
4076	cfzie	43		2014-12-10 11:51:02		
4077	vanul	43	That ought to do it:	2014-12-10 11:51:02		
4078	sgiwy	43		2014-12-10 11:51:02		
4079	qywrh	43		2014-12-10 11:51:02		
4080	fowai	43	Oops.. I made a mistake!  You can fix it with (at most) one line extra... I'll leave that as an exercise ;)	2014-12-10 11:51:02		
4081	ethan	43	Should this compile? Breaks on second for() in Xcode 5.1.	2014-12-10 11:51:02		
4082	gilit	43	My solution in python:	2014-12-10 11:51:02		
4083	ethan	43		2014-12-10 11:51:02		
4084	xhgls	43		2014-12-10 11:51:02		
4085	bjsiw	43	import java.util.Scanner;  public class NextHighestNumberWithSameDigits {  public static void main(final String[] args) { // TODO Auto-generated method stub final Scanner sc = new Scanner(System.in); System.out.println("Enter a number:"); final String digit = sc.next(); final char[] ch = digit.toCharArray(); final int j = digit.length() - 1; int k = -1; for (int i = j - 1; i >= 0; i--) { if (ch[i] < ch[j]) { final char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp; k = i; break; } } if (k == -1) { System.out.println(digit); } else { for (int i = k + 1; i < j; i++) { if (ch[i] > ch[j]) { final char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp; } } System.out.println("next biggest digit:" + String.valueOf(ch)); } } }	2014-12-10 11:51:02		
4086	dgjji	43	1. We scan the no from the Least significant digit and store it 2. The scan continues unitl we find a digit lesser than the previous digit 3. If the order is in ascending from least significant digit to the most then return the same number 4. Else the found digit is swapped with the least significant digit and the rest digits are sorted in ascending order and the final number is made   #include<iostream> #include<math.h> //#include<algorithm>  using namespace std; int get_length(int n) { int temp=0; while(n) { n=n/10; temp++; } cout<<"in get_length ="<<temp<<endl; return temp; } void sortRest(int arr[],int i) { int j,k,temp; for(j=0;j<=i-1;j++) { for(k=j+1;k<=i;k++) { if(arr[j]>arr[k]) { temp=arr[k]; arr[k]=arr[j]; arr[j]=temp; }  }  } cout<<"after sorting\n"; for(j=0;j<=i;j++) cout<<arr[j]; cout<<endl; } double swap(int arr[], int i, double n) { int j=i; //int temp = arr[0]; //arr[0] = arr[i]; //arr[i]= temp; cout<<"0,i= "<<arr[0]<<arr[i]<<endl; sortRest(arr+1, i-1); cout<<"0,i= "<<arr[0]<<arr[i]<<endl; while(j>=0) { cout<<"in swap n="<<n<<" i="<<i<<endl; n=n*10+arr[i-j]; j--; } return n; } int main() { int n,num,len,i=0,ans=-1; cout<<"enter n\n"; cin>>n;num=n; len=get_length(n); int arr[len]; while(n) { arr[i]=n%10;cout<<"arr["<<i<<"]="<<arr[i]<<endl; n=n/10;cout<<"n="<<n<<endl; if(i!=0) { if(arr[i]<arr[i-1]) { ans=swap(arr, i, n); break; } } i++; } if(ans!=-1) cout<<ans<<endl; else cout<<num<<endl; return ans; }	2014-12-10 11:51:02		
4087	ewigy	43	Goal is to swap 2 digits such that it results in bigger number, i.e before swap left digit should be greater than right digit. If we swap the 2 right most digits where this is possible, we will get next biggest number.	2014-12-10 11:51:02		
4088	bexbp	43	Hey everyone. My solution is the same as the majority of you. Here is my implementation in C++, using priority_queue class in STL. Note that, we should push (-1 * value) in the pqueue, because we want to have a min-heap but the priority_queue class implements a max-heap.	2014-12-10 11:51:02		
4089	sqzqo	43		2014-12-10 11:51:02		
4090	plapd	43		2014-12-10 11:51:02		
4091	xhgls	43	The running time of the algorithm is proportional to running time of the sorting algorithm used. Note that we have only digits here, so we can use counting sort to have a linear running time.	2014-12-10 11:51:02		
4092	eucmc	43		2014-12-10 11:51:02		
4093	gilit	43		2014-12-10 11:51:02		
4094	fmzze	43	package com.test.util;  public class NextHigherNumber { static int numArr[]; public static void main(String[] arg) { int n=123456789; int num=n; int numLen=0; while(n!=0) { n=n/10; numLen++; } numArr=new int[numLen]; n=num; for(int i=numLen-1;i>=0;i--) { numArr[i]=n%10; n=n/10; } for(int i : numArr) System.out.println("i : "+i);  outer : for(int i=numLen-2;i>=0;i--) { inner : for(int j=i+1;j<numLen;j++) { if(numArr[i]>=numArr[j]) { System.out.println("1st cond>>>>>i : "+i+" j : "+j+" numArr[i]="+numArr[i]+" numArr[j]="+numArr[j]); continue inner; }  else { System.out.println("2nd cond>>>>>i : "+i+" j : "+j+" numArr[i]="+numArr[i]+" numArr[j]="+numArr[j]); int temp=numArr[numLen-1]; numArr[numLen-1]=numArr[i]; numArr[i]=temp; System.out.println("Swapping>>>>>i : "+i+" numLen-1 : "+(numLen-1)+" numArr[i]="+numArr[i]+" numArr[numLen-1]="+numArr[numLen-1]); sort(i+1,numLen-1); break outer; } } } int newNum=0; for(int i=numLen-1;i>=0;i--) { newNum=newNum+(int) (Math.pow(10, i)*numArr[numLen-1-i]); } System.out.println("New Number : "+newNum); }  public static void sort(int frmIndex,int toIndex) { for(int i=frmIndex;i<=toIndex;i++) System.out.println(i+" Before : "+numArr[i]); for(int i=frmIndex;i<=toIndex;i++) { for(int j=i+1;j<=toIndex;j++) { if(numArr[i]>numArr[j]) { int temp=numArr[i]; numArr[i]=numArr[j]; numArr[j]=temp; } } } for(int i=0;i<=toIndex;i++) System.out.println(i+" After : "+numArr[i]); } }	2014-12-10 11:51:02		
4095	ethan	43		2014-12-10 11:51:02		
4096	fmzze	43		2014-12-10 11:51:02		
4097	ftfck	43	/* * find the next higher number with the same digits */  public static int findNextHigerNum(int num){  int[] arr = num2arr(num); if(arr.length<=1) return num; if(num<0) return -1 * findNextLower(arr); return findNextHiger(arr);   } private static int[] num2arr(int num){ if(num<0) num *= -1; int count = 0; int temp = num; while(temp>0){ temp /= 10; count++; } //use an array to store the num digit by digit int[] arr = new int[count]; for(int i=0; i<count; i++){ arr[i] = num%10; num /= 10; } return arr; } private static int findNextHiger(int[] arr){  int i = 0, j = 0; while(arr[i]<=arr[i+1]&&i<arr.length-1){ i++; if(i==arr.length-1) return arr2num(arr);//meaning this number is the largest possible }  int value = arr[i+1]; while(arr[j]<=value) j++; swap(arr, i+1, j); //now place the the remaining part in descending order, this just need a reverse operation reverse(arr, 0, i); return arr2num(arr); }  private static int findNextLower(int[] arr){  int i = 0, j = 0; while(arr[i]>=arr[i+1]&&i<arr.length-1){ i++; if(i==arr.length-1) return arr2num(arr); }  int value = arr[i+1]; while(arr[j]>=value) j++; swap(arr, i+1, j); reverse(arr, 0, i); return arr2num(arr); }  private static int arr2num(int[] arr){ int poly = 1; int value = 0; for(int i=0; i<arr.length; i++){ value += arr[i] * poly; poly *= 10; } return value; } private static void reverse(int[] arr, int start, int end){ while(start<end){ int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--; } }	2014-12-10 11:51:02		
4098	rdfeo	43	c++ solution	2014-12-10 11:51:02		
4099	sqzqo	43		2014-12-10 11:51:02		
4100	vanul	43		2014-12-10 11:51:02		
4101	gilit	43		2014-12-10 11:51:02		
4102	ewigy	43		2014-12-10 11:51:02		
4103	bjsiw	43	similar to leetcode nextPermutation	2014-12-10 11:51:02		
4104	azmjc	43		2014-12-10 11:51:02		
4105	eucmc	43		2014-12-10 11:51:02		
4106	nhibd	43		2014-12-10 11:51:02		
4107	fmzze	43		2014-12-10 11:51:02		
4108	krxlv	43	pseudo code:	2014-12-10 11:51:02		
4109	vanul	43		2014-12-10 11:51:02		
4110	ftfck	43		2014-12-10 11:51:02		
4111	mrjku	43	//O(n) time complexity	2014-12-10 11:51:02		
4112	azmjc	43		2014-12-10 11:51:02		
4113	sqzqo	43		2014-12-10 11:51:02		
4114	tenuw	43		2014-12-10 11:51:02		
4115	sqzqo	43		2014-12-10 11:51:03		
4116	bjsiw	43		2014-12-10 11:51:03		
4117	cfzie	43		2014-12-10 11:51:03		
4118	vanul	43		2014-12-10 11:51:03		
4119	dgjji	43		2014-12-10 11:51:03		
4120	nhibd	43		2014-12-10 11:51:03		
4121	rdfeo	43		2014-12-10 11:51:03		
4122	krxlv	43		2014-12-10 11:51:03		
4123	rrmeu	43		2014-12-10 11:51:03		
4124	fmzze	43		2014-12-10 11:51:03		
4125	wbqzu	43	FUCK YOU.	2014-12-10 11:51:03		
4126	dgjji	43	THIS GUY IS USING SOCK PUPPETS TO UPVOTE HIS QUESTIONS AND ANSWERS. FUCK THIS GUY.	2014-12-10 11:51:03		
4127	fowai	43	FUCK YOU RAMESH.	2014-12-10 11:51:03		
4128	bexbp	43	Guys even if he is publicizing his blog, atleast the question he posts are good. When the question quality is down then we can criticize him.	2014-12-10 11:51:03		
4129	plapd	43	No, don't encourage people to make this their own advertising space. Broken windows theory (see wikipedia) applies here. Plus, the questions are not necessarily first-hand interview questions, even though they might be interesting/good. I can give you plenty of interesting questions which will only lower your chances of getting a job.  He can post to the forum all he wants. Is it really hard for folks to understand that? GAWD. The IQ level on this site is sickening.	2014-12-10 11:51:03		
4130	ufdxg	44	The question does not require the minimum swap number. So, an easy way to do is, find the index of first does not match (except ZERO), then swap ZERO with it, then swap ZERO with the tgt value of that index. Just loop for all positions. Then, it is done. eg. {0, 1, 2} -> {0, 2, 1} first does not match index is 1, and tgt value is 2. So, {0, 1, 2}-> {1, 0, 2}->{1, 2, 0}  If it require the minimum swap number, then, shortest path algorithm will resolve it. Every permutation is one node, and all possible links are just a swap of ZERO. For performance improvement, A* can be used. So, never swap ZERO with any value that matched already. And it is better to generate nodes in run time.	2014-12-10 11:51:04		
4131	ethan	44	This is a great answer. But here's a possible optimization. In the suggested implementation, you are checking for the next index that doesn't match in each iteration, swapping ZERO in that position, then swapping the correct element for ZERO. So there are 2 swaps per mismatch. I believe 2 swaps are not always necessary.  Instead, you could find ZERO in src and swap the tgt value there. Do this in each iteration. In this case, you are just moving the correct value for ZERO's current position, one swap per incorrectly placed item.  The special case for this is when you swap ZERO into its correct position. In this case, you can't swap the correct number in, because it is already there -- it just happens to be ZERO. Instead, you can swap some other incorrect number into ZERO's position. (just move misplaced number into a different misplaced position -- ZERO's position) In the next iteration after doing this fix, it is guaranteed that you will swap some number into its correct place. So even when this special case occurs, it will still only take 2 swaps to move 1 misplaced number.  I still think your solution is more suitable for answering this question as it is more simple to understand. However, I just wanted to point out that 2 swaps are not necessarily required :)	2014-12-10 11:51:04		
4132	sgiwy	44	simply great solution... :)	2014-12-10 11:51:04		
4133	bexbp	44	Could you please clarify on the shortest path. I understand the algorithm, but isn't the size of the problem too large? Can we implement it without extra memory? If we have N numbers, then N! is the total number of permutations and in this case, vertices.	2014-12-10 11:51:04		
4134	ewigy	44	I think he meant BFS instead of shortest path first	2014-12-10 11:51:04		
4135	wbqzu	44	Good solution. You can use an extra O(n) space to get a solution with O(n) time complexity.  1. In a pre-processing step, go through the "source" array, compute the position of each of the 0 to n elements and store in the auxiliary 'position' array. 2. Start at the heads of both source and target array and compare the elements 3. If the elements are the same or the value of the target array ==0 proceed to the next elements. Otherwise go to step 4 4. Find position of 0 using the 'position' array and swap it with the current element 'e' in the source array and update the positions of 0 and 'e' in the position array. Now swap 0 with the target element(found again using the position array) and after the swap, update their positions in the position array. Advance the pointers of both source and target arrays. 5. Repeat steps 3 & 4 until all the elements are processed.	2014-12-10 11:51:04		
4136	huiqq	44	this can be reduced more with two cases. 1. 0 is in its own position. 2. 0 is not in its own position.  case 1: do as above. case 2: keep on swapping with correct target until 0 is in its position.	2014-12-10 11:51:04		
4137	zeice	44		2014-12-10 11:51:04		
4138	sgiwy	44		2014-12-10 11:51:04		
4139	tenuw	44		2014-12-10 11:51:04		
4140	nwkeg	44		2014-12-10 11:51:04		
4141	bjsiw	44	1)Make for loop of tgt 2)if ith element of tgt is 0 then contine (skip current iteration) with loop 3)Now find the position of ith element of tgt in src array and store it in say p variable. 4)check if postion found in 3rd step is equal to i? 5)if position is not equal to i than store p found in 3rd step to other variable say p2. 6)do while loop till p2!=i 7)in this while loop check if p2 is equal to p. this will be true for first iteration of while loop 8) if p2==p then replace zero in src array with p th element in src, then store new postion of pth element in p2. 9)if condition checked in step 7 is not true then 10) initialize temp=0; 11) And replace zero in src array with temp th element in src 12) Now replace zero with p2 in src array. 13) after while loop increment temp;   Below is pseudocode	2014-12-10 11:51:04		
4142	fmzze	44		2014-12-10 11:51:04		
4143	bexbp	44		2014-12-10 11:51:04		
4144	ufdxg	44	Using interim variables like p2 kind of defies the conditions of the test. It's supposed to be analogous to the parking lot where you only have one free space. If you didn't have to work with that restraint, you could just memcpy() from tgt to src.	2014-12-10 11:51:04		
4145	sgiwy	44		2014-12-10 11:51:04		
4146	nhibd	44		2014-12-10 11:51:04		
4147	zeice	44	@Avinash Sight modification is your code to avoid findPoistion of zero in each iteration. Correct me if I am wrong...	2014-12-10 11:51:04		
4148	rdfeo	44		2014-12-10 11:51:04		
4149	gilit	44		2014-12-10 11:51:04		
4150	qywrh	44	My thoughts:  1) As any number can be swapped only with '0' -> The relative position of most of the numbers should be same, except the case of 1st position.  2) Zero always bubbles up to the first position, its like every new car gets to park on the top of the stack, so which means either (here zero travelling is nothing but swapping) - Zero travels all the way to right-most and get swapped with left-most element. - Zero travels all the way to the left-most  So if we consider target possibility of given src={1,0,2,3} would be either  Case 1: tgt={0,2,3,1} - Which is zero travels right-most and gets swapped with left-most element. or Case 2: tgt={0,1,2,3} - Which is zero travels left-most  I mean we compare src[0] with tgt[0] and decide whether to take zero to travel in which direction.  I might be assuming lot of things like  If we assume tgt[0] is always zero then tgt possibilities would be (n-1)!, so by assuming relative position I am ruling out all tgt possibilities except two.  So for {X, , , } => 1, 2, 3 can be arranged in 3! = 6 ways, but I am ruling out {0, 2, 1, 3}, {0, 3, 1, 2}, {0, 3, 2, 1} and {0, 1, 3, 2}  Sai	2014-12-10 11:51:04		
4151	sqzqo	44		2014-12-10 11:51:04		
4152	huiqq	44		2014-12-10 11:51:04		
4153	tenuw	44	A slight problem with the above code. There will still be instances where the 0 in the src and tgt ends up being in the same index before everything is finished swapping. Back to the drawing board.	2014-12-10 11:51:04		
4154	qywrh	44	OK. Second attempt.  public class SwapWith0 { static int lastKnownDifference = 0;  public static void main(String[] args) { // int[] src = new int[] {1,0,2,3}; // int[] tgt = new int[] {0,2,3,1}; int[] src = new int[] {0,1,2,3,4,5,6,7,8,9,10}; int[] tgt = new int[] {1,0,3,2,6,5,4,10,9,8,7};  int srcEmptyIndex = -1; int tgtEmptyIndex = -1; int[] indexTable = new int[src.length];  for(int i=0;i<src.length;i++) { if(src[i]==0) { srcEmptyIndex = i; } else { if(src[i]!=tgt[i]) { indexTable[src[i]] = i | 0x80000000; // MSB set means need to visit lastKnownDifference = i; } else indexTable[src[i]] = i; }  if(tgt[i]==0) { tgtEmptyIndex = i; } }  // If empty slots are the same, need to make it different to get things moving. if(srcEmptyIndex==tgtEmptyIndex) { int a = srcEmptyIndex; int b = srcEmptyIndex; if(srcEmptyIndex==0) { // first element // Swap with next element b = srcEmptyIndex+1; } else { // Swap with previous element. takes care of last element as well. b = srcEmptyIndex-1; } indexTable[src[b]] = srcEmptyIndex | 0x80000000; // element src[b] swapped with 0 srcEmptyIndex=b; System.out.println("Swap " + src[b] + " with 0");  /* No need to change the src array. src[a] = src[a] ^ src[b]; src[b] = src[a] ^ src[b]; src[a] = src[a] ^ src[b]; */ }  // while(srcEmptyIndex!=tgtEmptyIndex) { while( srcEmptyIndex!=tgtEmptyIndex || ((srcEmptyIndex=getNextSwapPosition(indexTable,srcEmptyIndex))!=-1) ) { System.out.println("Swap " + tgt[srcEmptyIndex] + " with 0"); indexTable[tgt[srcEmptyIndex]] &= 0x7FFFFFFF; srcEmptyIndex = indexTable[tgt[srcEmptyIndex]]; } }  public static int getNextSwapPosition(int[] indexTable, int srcEmptyIndex) { for(int i=lastKnownDifference;i>-1;i--) { if(indexTable[i]<0) { // Need to visit lastKnownDifference = i; System.out.println("Swap " + i + " with 0"); indexTable[i] = srcEmptyIndex | 0x80000000; return i; } }  return -1; } }	2014-12-10 11:51:04		
4155	ethan	44	Just have to iterate through the cyclic transposition, only trick is that the graph may not be connected.	2014-12-10 11:51:05		
4156	wbqzu	44		2014-12-10 11:51:05		
4157	bexbp	44		2014-12-10 11:51:05		
4158	cfzie	44	The visited counter is not quite right.. it is trivial to fix though.	2014-12-10 11:51:05		
4159	nwkeg	44		2014-12-10 11:51:05		
4160	fowai	44		2014-12-10 11:51:05		
4161	eucmc	44		2014-12-10 11:51:05		
4162	rdfeo	44		2014-12-10 11:51:05		
4163	krxlv	44		2014-12-10 11:51:05		
4164	sgiwy	44		2014-12-10 11:51:05		
4165	bexbp	44		2014-12-10 11:51:05		
4166	ewigy	44		2014-12-10 11:51:05		
4167	eucmc	44	}	2014-12-10 11:51:05		
4168	eucmc	44	Simply modify answer of edlai	2014-12-10 11:51:05		
4169	admin	44		2014-12-10 11:51:05		
4170	krxlv	44		2014-12-10 11:51:05		
4171	ethan	44		2014-12-10 11:51:05		
4172	nwkeg	44		2014-12-10 11:51:05		
4173	zeice	44		2014-12-10 11:51:05		
4174	plapd	44		2014-12-10 11:51:05		
4175	plapd	44	I find an algorithm could achieve the goal in O(n) time, and here is the procedure: 1) scan the tgt array to find out the target position of i( i is an element in src ), and store it as an array tgt_index, so tgt[2] means where 2 should be in the tgt array; 2) scan the src array to find out the position of zero, denoted as zero_pos; 3) for each element src[i], let its target position in tgt be ti = tgt_index[src[i]] 3.1) if src[i] == 0, just swap src[i] and src[ti], and change zero_pos to ti; 3.2) if src[i] == 0, first swap src[ti] with src[zero_pos]( src[ti]has zero now ), then swap src[i] with src[ti]( src[i] has zero now ), and at last swap src[zero_pos] with src[i]( src[zero_pos] has zero new ).  Here is my code in C++:	2014-12-10 11:51:05		
4176	jippy	44		2014-12-10 11:51:05		
4177	fmzze	44		2014-12-10 11:51:05		
4178	dkebi	44	Algo 1: O(n^2)	2014-12-10 11:51:05		
4179	tenuw	44		2014-12-10 11:51:05		
4180	rdfeo	44		2014-12-10 11:51:05		
4181	nwkeg	44	Algo 2: O(NlogN) ------------------------ 1) Sort the first set of numbers 2) Perform a binary Search (Handle when middle index points to zero .... no need to move the numbers)	2014-12-10 11:51:05		
4182	rrmeu	44		2014-12-10 11:51:05		
4183	plapd	44		2014-12-10 11:51:05		
4184	rdfeo	44	Algo O(N) : -------------- 1) Use hash map 2) Store the indexes and swap by traversing the target array	2014-12-10 11:51:05		
4185	nwkeg	44		2014-12-10 11:51:05		
4186	ftfck	44		2014-12-10 11:51:05		
4187	dgjji	44		2014-12-10 11:51:05		
4188	bexbp	44		2014-12-10 11:51:05		
4189	huiqq	44	an improvement maybe to cache zero position in src to avoid an lookup.	2014-12-10 11:51:05		
4190	xhgls	44	// My idea is based on regular permutation implementation, and it is easy to understand. By iteratively swap 0 with others element in the array, we can get desired permutation(target). Also, swapping two non-zero values require some trick.  say src={1,0,2,3}, dest={3,2,0,1}  By swapping forward, we get: {1}+0+perb(2,3),{1,2}+perb(0,3), {1,3}+perb(2,0); by swapping backward, we get: 0+perb(1,2,3)  src={...., 0, ...}, the first part contains i elements before 0 and the second part contains j elements after 0, and i+1+j=n  //swap forward and permutation for(int k=i+1;k<n;k++){ // 0 is at the pos of i+1 swap(0,src[k]); int first[]=src[0...k-1]; int second[]=perb(src,k+1,n,k); int result[]=first+second; }   //swap backward ...  // note we are unable to do swap(a[i],a[j]) directly, and use swap_ex to replace swap void swap_ex(int a[], int i, int j, int h){// h is the position of 0 swap(&a[i],&a[h]); swap(&a[h],a[j]) }  void perb(int src[], int k, int n, const int h){ // h is the pos of 0 { if (k==n){ // we have a chance here to find if src matches target return; } else{ for(int j=k;j<n;j++){ swap_ex(src[k],src[k+1],h); perb(src,k+1,n); swap_ex(src[k],src[k+1],h); } } }  Time and space complexity is ok(if the input is a huge string, it might be a problem!)	2014-12-10 11:51:05		
4191	mrjku	44	I felt confused about swap with 0. Does it mean swap(&a[i], &[j]) when a[i] or a[j] has value 0?	2014-12-10 11:51:05		
4192	cfzie	44		2014-12-10 11:51:05		
4193	zeice	44		2014-12-10 11:51:05		
4194	bjsiw	44		2014-12-10 11:51:05		
4195	ewigy	44		2014-12-10 11:51:05		
4196	nhibd	44		2014-12-10 11:51:05		
4197	azmjc	44		2014-12-10 11:51:05		
4198	krxlv	44	A simple recursion should be suffice: 1) Find the 0's index (pos_0) in src[] 2) If tgt[pos_0] == 0, stop recursion, otherwise swap 0 with tgt[pos_0], then recursion. Time complexity is O(N^2), space is O(1).	2014-12-10 11:51:06		
4199	dkebi	44		2014-12-10 11:51:06		
4200	gilit	44		2014-12-10 11:51:06		
4201	rdfeo	44	if tgt and src have zero in same position, but other numbers are not in same position, whether it work.............?	2014-12-10 11:51:06		
4202	mrjku	44	Nice catch. Thanks. Still recursion;	2014-12-10 11:51:06		
4203	xhgls	44		2014-12-10 11:51:06		
4204	fowai	44		2014-12-10 11:51:06		
4205	eucmc	44	Space complexity isn't technically O(1) as recursing n times is equivalent to O(n)	2014-12-10 11:51:06		
4206	vanul	44	#include <stdio.h> #include <string.h> #include <stdlib.h> int a[100],b[100],n,s[100]; int posb(int i) { int j,l; for(j=0;j<n;j++) { if(b[j]==i) return j; } } swap(int i,int j) { int t; t=b[i]; b[i]=b[j]; b[j]=t; } rea(int l,int p) { int i,j,k,m; if(l!=0) { k=a[p]; if(k!=0) { m=posb(k); l--; swap(p,m); s[p]=1; printf("\npositin %d <--> %d",p+1,m+1); for(i=0;i<n;i++) { if(b[i]==0) { m=i; break; } } } else { i=p+1; while(s[i]==1) { if(i==n-1) { i=0; } else i++; } m=i; } rea(l,m); } } main() { FILE *fp; fp=fopen("input.txt","r"); int i,d,k; fscanf(fp,"%d",&n); printf("%d\n",n); for(i=0;i<n;i++) { fscanf(fp,"%d",&a[i]); } for(i=0;i<n;i++) { fscanf(fp,"%d",&b[i]); } for(i=0;i<n;i++) { printf("%d ",a[i]); } printf("\n"); for(i=0;i<n;i++) { printf("%d ",b[i]); } for(i=0;i<n;i++) { s[i]=0; } for(i=0;i<n;i++) { if(b[i]==0) { k=i; break; } } rea(n-1,k); printf("\n"); for(i=0;i<n;i++) { printf("%d ",a[i]); } printf("\n"); for(i=0;i<n;i++) { printf("%d ",b[i]); } }	2014-12-10 11:51:06		
4207	ethan	44		2014-12-10 11:51:06		
4208	ufdxg	44		2014-12-10 11:51:06		
4209	cfzie	44		2014-12-10 11:51:06		
4210	bjsiw	44		2014-12-10 11:51:06		
4211	rrmeu	44		2014-12-10 11:51:06		
4212	dkebi	44		2014-12-10 11:51:06		
4213	admin	44		2014-12-10 11:51:06		
4214	ewigy	44		2014-12-10 11:51:06		
4215	gilit	44		2014-12-10 11:51:06		
4216	ewigy	44		2014-12-10 11:51:06		
4217	huiqq	44		2014-12-10 11:51:06		
4218	eucmc	44		2014-12-10 11:51:06		
4219	xhgls	44		2014-12-10 11:51:06		
4220	cfzie	44		2014-12-10 11:51:06		
4221	ethan	44		2014-12-10 11:51:06		
4222	ftfck	44		2014-12-10 11:51:06		
4223	rdfeo	44		2014-12-10 11:51:06		
4224	fmzze	44		2014-12-10 11:51:06		
4225	eucmc	44		2014-12-10 11:51:06		
4226	zeice	44		2014-12-10 11:51:06		
4227	fmzze	44		2014-12-10 11:51:06		
4228	zeice	44		2014-12-10 11:51:06		
4229	dkebi	44		2014-12-10 11:51:06		
4230	qywrh	44		2014-12-10 11:51:06		
4231	tenuw	44		2014-12-10 11:51:06		
4232	sgiwy	44		2014-12-10 11:51:06		
4233	krxlv	44		2014-12-10 11:51:06		
4234	bjsiw	44		2014-12-10 11:51:06		
4235	nwkeg	44		2014-12-10 11:51:06		
4236	rrmeu	44		2014-12-10 11:51:06		
4237	eucmc	44		2014-12-10 11:51:06		
4238	mrjku	44		2014-12-10 11:51:06		
4239	sqzqo	44		2014-12-10 11:51:06		
4240	dkebi	44		2014-12-10 11:51:06		
4241	eucmc	44		2014-12-10 11:51:06		
4242	tenuw	44		2014-12-10 11:51:07		
4243	bjsiw	44		2014-12-10 11:51:07		
4244	ethan	44		2014-12-10 11:51:07		
4245	rrmeu	44		2014-12-10 11:51:07		
4246	tenuw	44		2014-12-10 11:51:07		
4247	gilit	44		2014-12-10 11:51:07		
4248	ewigy	44		2014-12-10 11:51:07		
4249	nwkeg	44		2014-12-10 11:51:07		
4250	sqzqo	44		2014-12-10 11:51:07		
4251	cfzie	44		2014-12-10 11:51:07		
4252	nhibd	44		2014-12-10 11:51:07		
4253	eucmc	44		2014-12-10 11:51:07		
4254	nwkeg	44		2014-12-10 11:51:07		
4255	ethan	44		2014-12-10 11:51:07		
4256	fmzze	44		2014-12-10 11:51:07		
4257	sqzqo	44	Javascript version without recursion Less memory because it doesn't need to keep a stack of calls Count and logs for easier understanding	2014-12-10 11:51:07		
4258	nwkeg	44		2014-12-10 11:51:07		
4259	azmjc	44		2014-12-10 11:51:07		
4260	ewigy	45	you can solve this in O(n) using a combination of trie and linked list. The leaf node of a trie maintains a flag to record duplicate urls and pointer to a node in a link list. If you encounter a new url, add a node to the head of the linked list and set the pointer in the trie. Whenever you encounter a url that is already in the trie, if the flag is not set, then set the flag, delete the node from the linked list and set pointer to null. If the flag is already set, then ignore and read the next url. After processing all the urls, the link list should only contain the unique urls and the node at the tail is the first unique url from the list. For n urls, inserting urls into the trie in O(n) and link list operations are all constant time. The node could just keep the index of the url in the list so that we don't have to store urls in the link list as well.	2014-12-10 11:51:08		
4261	azmjc	45	i thought tries have insertion time o(nlogn) for n elements. are you sure its o(n), its a tree structure...	2014-12-10 11:51:08		
4262	ufdxg	45	The trie insertion time is k, where k is the length of the string being inserted. So the total time is O(nk). Since the length of the URL's doesn't depend on n, though, and can be expected to be relatively constant, this is O(n).	2014-12-10 11:51:08		
4263	cfzie	45	Why not just use a hashtable if your storage is going to be O(n) anyway though?	2014-12-10 11:51:08		
4264	krxlv	45	Storage is going to be O(n) -- but a hash table is not as space efficient as it has to store the entire string in case of collision, but in all partial matches are collapsed together, no?	2014-12-10 11:51:08		
4265	sgiwy	45	Incorrect soln will not be O(n) as you would be deleting nodes from link list...parsing till node will be extra time.	2014-12-10 11:51:08		
4266	sgiwy	45	To answer the question of above user: There is no extra time needed to "parse till the node to be deleted". The following code is my implementation of the same idea as that of the original poster, the linked list is combined with the trie, once you have finished travelling to end of an url in the trie, you would have the node in the linked list to be deleted.	2014-12-10 11:51:08		
4267	rdfeo	45		2014-12-10 11:51:08		
4268	fmzze	45		2014-12-10 11:51:08		
4269	plapd	45	I believe you used hash(or trie or something similar) to store the counts of each URL. To make it one traversal, you need only to use a doubly linked list to link all the unique ones (either link the items in the hash table or do it separately) so far as you traverse through. Remove the URL from the list if its count goes over 1; and of course connects its predecessor and successor (which is actually implied when I say "remove") So after one traversal, the first one of your linked list is the desired one. Extra spaces for two pointers for each URL are required for this solution.	2014-12-10 11:51:08		
4270	vanul	45	suppose you are in the middle of traversing thru the list, u have a half prepared link list, now u get another url, so what u do?? u traverse thru the link list untill u find the match. But how u r going to do this "traverse thru" for each element on "overall O(n) complexity"??	2014-12-10 11:51:08		
4271	ftfck	45	The doubly linked list is in addition to the hash table. To remove or to insert a node to this list is up to the count of the URL in the hash table.	2014-12-10 11:51:08		
4272	ufdxg	45	If we have a hash table then why do we require a linked list. Can't we just traverse the array and keep on checking the count for each one??	2014-12-10 11:51:08		
4273	qywrh	45	You may consider an array is a special type of hashtable which integrates (partly) the doubly linked list. But in practice, I believe a real hast table is required and each of its item is pointing to a doubly linked list.You can tell the difference between these two different models	2014-12-10 11:51:08		
4274	fowai	45	What does unique mean? appearing exactly once?  Hash the url and use the hash to check for dupes, should be faster than plain old string matching.	2014-12-10 11:51:08		
4275	nwkeg	45	millions of url i dont think hash is a good idea	2014-12-10 11:51:08		
4276	azmjc	45	Use min heap with url as data of heap and url_frequency as the heap comparator. Top of the heap would give u an unique url if its frequency is exactly 1.  O(nlogn) time complexity, O(n) space complexity.	2014-12-10 11:51:08		
4277	gilit	45	Sorry, this doesnt work in O(nlogn). When we see a duplicated url, to find the url and increase its url_frequency count is O(n) (Searching in heap is O(n))  Hence, the overall time complexity is O(n^2).	2014-12-10 11:51:08		
4278	huiqq	45	I think this might work in linear time. Assign a prime number for each character (letters, digits and special characters). Eg: 'a'--> 2, 'b'-->3, '1'-->17, '#'--> 29. Compute the hash code of the url based on the character's prime number and its position in the url. After computing the hashcode, insert the hashcode in HashSet (in Java). Do this for every URL. Incase the hashcode of URL mathces the hashcode of some previous url inserted in HashSet, then its the first duplicate.	2014-12-10 11:51:08		
4279	nwkeg	45	If urls are stored in xml file, then a quick way would be to use Muench's grouping technique to retrieve unique url.	2014-12-10 11:51:08		
4280	plapd	45	bedalrocks,  Using prime numbers is usually a very bad idea, practically speaking.	2014-12-10 11:51:08		
4281	nhibd	45	Sort the url list using quick sort in O(nlogn). Scan through the array to find the unique URL in O(n) time. Total time: O(nlogn).  PS: Here sorting and scnaning involves string comparision. Say if each string is length K, we can treat n*k = N as another constant.	2014-12-10 11:51:08		
4282	jippy	45	The list of url's is very big, and hence sorting does not seem to be a valid option here.	2014-12-10 11:51:09		
4283	gilit	45	what abt md5 checksum	2014-12-10 11:51:09		
4284	tenuw	45	Seems list quite a few here have missed a part of the question. The question is to find the first unique URL. Not any unique url or the first duplicate.  A solution would be * go through the URLs, store in hash table, for key=url, a boolean value that represents if the URL has been seen once or more than once. That is first pass. * go through the URLs again, and for each URL, check in the hash table, for how many times it has occured. If it has occured only once, that's the URL you want.  Now, there are some space constraints that I haven't considered. Millions of URLs. Let's say 10 million URLs. Each URL has let's say 50 characters on average. That's 500 million characters. That takes up a lot of space even though it is doable. However if I am using a hash table, I am not storing the entire URL, but just the hash code and a boolean. That would be let's say 4 bytes for hash code and a bit for boolean. ~40 MB for hash table. That's not bad at all.  One way to optimize the second pass would be .. if I could create another array that contains the URLs in the order in which they appear in the original list, however without any duplicates. I can construct this during the first pass. So during the second pass, I could go through this array, that way reducing the number of URLs I am processing. However this needs additional memory.  Now if I could make this more challenging, what if the number of URLs is not millions but billions. In that case the hash table cannot be stored in memory. It would be in the order of 40GB. How would we solve the problem then?  One solution I can think of is to use distributed computing. Have multiple server machines store the hash table pieces in their local memory. Since network communication could be faster than disk reads, this could work well. Otherwise the hash table could be stored on disk. This would be slow because you don't know where the hash code of next URL will be in the hash table memory.	2014-12-10 11:51:09		
4285	gilit	45	How will you check for duplicates if you don't store the entire url? After all, if the hash is just 4 bytes, there is a non-zero chance of a collision.  Also, you have perhaps missed an important step: Canonicalize the URLS. There could be multiple versions of the same url, which might hash differently but are actually the same.  Also, your comment about hashtable and hard disk access is incorrect, if you use chained linear hashing. In fact the original intent behind inventing the hash table was to have a fast disk access. An array -> quick access, followed by a linked list access, which would be fast if the size of the linked list (# of collisions for that hash) is small.  And you could just store the least index of the url, (whether it was first, second, nth etc) in the hash table itself and just walk the hash table ignoring dupes. For this just a bit array would be sufficient as a supporting structure to figure out the first unique.   Also, if the urls are valid, about using IP addresses? With a trie (patricia) of IP address + a lookup structure (say hash/tree) for each IP adress, you could perhap cut down on space and make the lookups faster.	2014-12-10 11:51:09		
4286	fowai	45	The linked list/trie combo approach above successfully captures the first unique URL.	2014-12-10 11:51:09		
4287	ufdxg	45	One way would be to maintain a Bloom filter for the URL's that you have seen before. They are great for negative membership queries.	2014-12-10 11:51:09		
4288	ewigy	45	the question is to find the 1st unique url. If u make the hash of all the url's and then traverse each hash to check the frequency you may be able to get all the unique url's but certainly not the one that comes first. One way to come up with the 1st unique url is to go thourgh the list order in which the url's are presented to us and then look at the set of unique url's (found by Rajesh's method) to determine which is the 1st unique.	2014-12-10 11:51:09		
4289	ewigy	45	I like the bloom filter idea indeed. Now, since the list is very long but finite (ie. not a stream), we can iterate it backwards, keeping track of the last URL that we don't find in the bloom filter.	2014-12-10 11:51:09		
4290	rrmeu	45		2014-12-10 11:51:09		
4291	jippy	45		2014-12-10 11:51:09		
4292	fmzze	45	you can have a trie sort of structure O(n) time complexity, each node can have a flag which says whether a word finishes there or not and a count stating number of occurrences.	2014-12-10 11:51:09		
4293	sqzqo	45	How about using linkedHashMap?  HashMap  md5(url) | reference to node in doubly linked list  while( lines ){ if( md5(url) exists ) delete node in in doubly linkedlist else{ add to linkedlist queue end set value to the node ( queue end). } }  return the first node of the queue.  I think this can be done in O(n)	2014-12-10 11:51:09		
4294	ewigy	45	Trie would be better. But instead of having count of urls we should have the index of the string in the list. Whenever we encounter the url again make the index = -1. So now the trie will give indexes in each node of trie as Null(never got set) or -1(set more than once) or +ve index value of the url in the list(set only once). now getting all the non null and +ve indexes find the min index you will get first unique URL.	2014-12-10 11:51:09		
4295	mrjku	45	uniq filename.txt > f2.txt  using unix commands? not sure about the time complexity tho :|	2014-12-10 11:51:09		
4296	jippy	45	Or we can use std::sort + std::unique for a C++ position if unix command is allowed.	2014-12-10 11:51:09		
4297	eucmc	45	uniq requires that its input be sorted, and sort takes O(n log(n))	2014-12-10 11:51:09		
4298	rrmeu	45	This is well explained in CC book	2014-12-10 11:51:09		
4299	admin	45	what is the CC book?	2014-12-10 11:51:09		
4300	mrjku	45	Cracking the coding interview. You'l find it on the home page of this site.	2014-12-10 11:51:09		
4301	eucmc	45	As fentoyal says, put them into a hash table. Add to each actual bucket entry an iterator into a doubly-linked list of those items that have been seen once. When you walk down the original list of urls, if you don't find it in the hash table, add it, and add its entry (hash table iterator, or raw url, either way) to the back of the linked list. If you do find the entry in the hash table, look at the iterator stored there. If it's null, you've seen it 2+ times already, do nothing. If the iterator there is non-null, use it to pull the item out of the linked list (O(1) time), and then set the iterator in the hash table to null.  When you've gone through the list of urls, pick the front-most (which is the first added, that was not subsequently removed) url from the linked list.	2014-12-10 11:51:09		
4302	ethan	45	I dont think this will give time O(n).  Look at the case when an element was previously considered unique and now as we iterate through the sequence we find that it has a double. In this case we have to remove from hash which is fine as it can be done in O(1) but removing the item from the linked list takes O(n)  doesnt this push the overall running time to O(n^2)	2014-12-10 11:51:09		
4303	bjsiw	45	No, no - you never remove the url from the hash table (otherwise if you see it again, you'd think it was the first time). There are 3 states - 1) it's a new url (add to hash table and to back of list, add that list iterator to the url's hashtable entry), 2) you've seen the url and the hash table still has a valid iterator to the list (you've seen it once - so we remove the url from the list, and remove the iterator from the url's entry in the hashtable) 3) you've seen the url, and its hash table entry no longer has the iterator -> you've seen the url 2+ times. It's not in the list, so it's in no danger of being thought unique - do nothing).	2014-12-10 11:51:09		
4304	gilit	45	... to answer your objection more specifically, you're talking about case 2). We don't have to iterate through the doubly-linked list to find our candidate, because removing an element from a linked list is O(1), if you know exactly where it is. (I don't know how it is in Java, I'm sure it's the same, but in C++ you can have an iterator (acts like a pointer) to a list element. Being doubly-linked, removal is constant-time, and you don't mess up any other iterators.) And, again, you never take the url's entry out of the hash table.	2014-12-10 11:51:09		
4305	xhgls	45	I think space complexity here is way too high. 1. Keeping LONG list of URL as a DLL. 2. Maintaining a HashMap.  Slightly better solution is to use 2 hashmaps.  1. unqiue_url 2. all_url  Traverse through URLS if URL is present in all_url remove url from unique_url else add url to unique_url add url to all_url end  Items left in unique_url will be unique	2014-12-10 11:51:09		
4306	plapd	45	> Items left in unique_url will be unique  ... but how will you know which was first? And, my doubly-linked list contains only unique items, it should take less space than another hash table.	2014-12-10 11:51:09		
4307	cfzie	45	unqiue_url you can store url as key and value as the order of occurence 1, 2, 3, 4. or use a Map which keeps track of insertion order, but I guess that uses a DLL internally.  I did not see that you only store unique items in DLL.  Both solutions have same complexity, guess choice would be between what is easier to read and maintain	2014-12-10 11:51:09		
4308	fowai	45	if you change the unique map to a vector (C++) or arraylist (Java), you could have the position in the unique_url list as the value of the all_url map and just remove it from the list right away. This solves the knowing which was first problem since lists preserve order.	2014-12-10 11:51:09		
4309	sqzqo	45	I guess you can first create a hashmap of all the url whose key contains i) no of occurrences of the url ii) corresponding linked list node containing the url.  So whenever a new url is met, it is determined whether the url is contained in the hashmap. i) If it is contained and the no of occurences is 1, then we increase the number of occurences by 1 and delete the corresponding linked list node. ii)If it is not contained in the hash map, then we create a new node and connect it to the tail of the linked list. Then we update the hash map accordingly. iii) If it is contained in the hash map, and the number of occurrences is more than 1, it means that the corresponding node has already been deleted, and we do not need to do anything.  The head of the linked list is gives the answer.	2014-12-10 11:51:09		
4310	ftfck	45	This should work but you need to use a doubly linked list and you need to remember a pointer to the node in the doubly linked list in the hash map as well. Once an url is found to be duplicate you increment the counter, delete the node and also make the pointer in the hash map null. Rest should work as you mentioned.	2014-12-10 11:51:09		
4311	cfzie	45	You use mixed combination of trie and hashing on the reversed URL. Basically by reversing the URL and treating the domains in it as complex keys you reduce the number of collisions (host.dom1.dom2 -> dom2(trie).dom1(trie).host(hash))	2014-12-10 11:51:09		
4312	jippy	45	<pre lang="" line="1" title="CodeMonkey48234" class="run-this">Dictionary<string, int> urlCount = new Dictionary<string, int>(); Queue<string> uniqueUrls = new Queue<string>();  foreach(string url in File.ReadLine()) { if(!urlCount.Contains(url)) { urlCount.Add(url, 1); uniqueUrls.Enqueue(url); } else { //count > 1 urlCount[url]++; if(uniqueUrls.Peek() == url) { uniqueUrls.Dequeue(); } } }  return uniqueUrls.Dequeue();</pre><pre title="CodeMonkey48234" input="yes"> </pre>	2014-12-10 11:51:09		
4313	bexbp	45	<pre lang="" line="1" title="CodeMonkey11335" class="run-this">package career.cup.google;  import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.NoSuchElementException; import java.util.Random;  /** * @author Given a very long list of URLs, find the first URL which is * unique ( occurred exactly once ). I gave a O(n) extra space and O(2n) * time solution, but he was expecting O(n) time, one traversal. */ public class G94FirstUniqueURL {  /** * @param url * @returns 1st non duplicate URL, otherwise throws NoSuchElementFind exception... * * traverse the List check if the URL was find delete his * correspondent index from the LinkedHashSet index keep that URL as duplicate.... * Will use a hash map to register the list traversal * status, key = URL, Value = A list of indexes in the list, * Will use A LinkedHashSet for the indexes which assume are not duplicates, and remove those which are... * Used this data structure because will contain the first element which is unique at the end of the algorithm.. * If this hash set is empty throw No Such Element Find... */ public static String findFirstUniqueURL(ArrayList<String> url) {  HashMap<String, HashSet<Integer>> hm = new HashMap<String, HashSet<Integer>>(); LinkedHashSet<Integer> fIndex = new LinkedHashSet<Integer>(); Iterator<String> it = url.iterator(); int listIndex = -1; while (it.hasNext()) { String u = it.next(); listIndex++; if (!hm.containsKey(u)) { HashSet<Integer> idx = new HashSet<Integer>(); idx.add(listIndex); hm.put(u, idx); fIndex.add(listIndex); } else { hm.get(u).add(listIndex); deleteDuplicateIndexes(hm.get(u), fIndex); hm.put(u, new HashSet<Integer>()); } } if (fIndex.isEmpty()) throw new NoSuchElementException("No Unique URL"); return url.get(fIndex.iterator().next()); }  /** * @param idx - duplicate indexes list * @param in - indexes processed */ private static void deleteDuplicateIndexes(HashSet<Integer> idx, LinkedHashSet<Integer> in) { for (Integer i : idx) { in.remove(i); } }  public static void main(String[] args) { Random r = new Random(); ArrayList<String> url = new ArrayList<String>(); for (int i = 0; i < 50; i++) { Integer v = r.nextInt(37); url.add(v.toString()); System.out.printf("%d ", v); } System.out.println(); System.out.println(findFirstUniqueURL(url));  } }  </pre><pre title="CodeMonkey11335" input="yes"> </pre>	2014-12-10 11:51:09		
4314	huiqq	45	you can solve this in O(n) using a combination of trie and linked list. The leaf node of a trie maintains a flag to record duplicate urls and pointer to a node in a link list. If you encounter a new url, add a node to the head of the linked list and set the pointer in the trie. Whenever you encounter a url that is already in the trie, if the flag is not set, then set the flag, delete the node from the linked list and set pointer to null. If the flag is already set, then ignore and read the next url. After processing all the urls, the link list should only contain the unique urls and the node at the tail is the first unique url from the list. For n urls, inserting urls into the trie in O(n) and link list operations are all constant time. The node could just keep the index of the url in the list so that we don't have to store urls in the link list as well.	2014-12-10 11:51:09		
4315	gilit	45	Wouldnt the algo below work ?	2014-12-10 11:51:09		
4316	ftfck	45		2014-12-10 11:51:09		
4317	plapd	45		2014-12-10 11:51:09		
4318	nwkeg	45		2014-12-10 11:51:09		
4319	huiqq	45		2014-12-10 11:51:09		
4320	rdfeo	45		2014-12-10 11:51:09		
4321	sqzqo	45		2014-12-10 11:51:09		
4322	sqzqo	45		2014-12-10 11:51:09		
4323	sgiwy	45		2014-12-10 11:51:09		
4324	zeice	45	This is the answer: \w*?foo\w*?\s(?!foo+)	2014-12-10 11:51:09		
4325	dkebi	45	I think you are on to something. This can all be done with Linux/Unix commands.  if the master list of urls are in a text file (master.txt) then  sort master.txt | uniq -c > occurances.txt  will give you a file of the occurances for each url.  Obviously, the url(s) with associated occurance of one is what you want.  If for some reason the urls are scattered in different files you can use grep  to pipe them into one file with something like  grep -r "http:*" *.* > master.txt  I don't know what the run time of unix sort is but why would anyone write  a C++ program when Unix/Linux can tell you with no effort.	2014-12-10 11:51:10		
4326	cfzie	45	You can traverse the list from the end to the begining, then the last unique one in this method is the first one and the problem will be easier.	2014-12-10 11:51:10		
4327	xhgls	45	ok. so create two has tables. One will store dup urls. Other will store unique urls.  1. Read url. create hash. 2. Try to insert hash into dup url hash. If success remove it. else go to step 1. Ignore insertion failures in dup url hash table. 3. Insert into unique url hash. If hash exists error will be generated. Remove that key from uniqu url hash and insert it into dup url hash. Ignore insert failures for dup url hash table. go to step 1 3. The unique url hash table contains all the urls that are unique.	2014-12-10 11:51:10		
4328	rdfeo	45	I think all of you missed that the guy wanted a real string algo... pretty hard core:	2014-12-10 11:51:10		
4329	fowai	45		2014-12-10 11:51:10		
4330	dkebi	45		2014-12-10 11:51:10		
4331	ewigy	45	This does the job in cleaner, shorter, faster and least memory possible	2014-12-10 11:51:10		
4332	mrjku	45		2014-12-10 11:51:10		
4333	plapd	45		2014-12-10 11:51:10		
4334	cfzie	45	Can try 1) adding all values in hash table O(n) 2)Perform linear search on hash table O(n)	2014-12-10 11:51:10		
4335	wbqzu	45	Are you serious?? Interviewer explicitly mentioned tht its a long list. Hashtable is rejected in the question itslf indirectly	2014-12-10 11:51:10		
4336	tenuw	45	i think following code will work.  package psan; import java.io.*; import java.util.*;  public class UniqueUrlSearch  { public static void main(String...s) throws Exception { BufferedReader b=new BufferedReader(new InputStreamReader(System.in)); LinkedList<String> ans=new LinkedList<String>(); System.out.println("Enter the list"); String list[]=b.readLine().split(" "); int len=list.length,itr=-1; int old=1,current=1,v=0; String tmp="",yy=""; HashMap<String,String> hs=new HashMap<String,String>(); for(int i=0;i< len;i++) {  if(!hs.containsKey(list[i])) { try{++itr; yy=yy+itr; tmp=tmp+yy+" "+"1"; System.out.println("in if tmp="+tmp); hs.put(list[i],tmp); ans.add(list[i]); }catch(Exception e){e.printStackTrace();} } else { try{  System.out.println("in else:"); String ss=hs.get(list[i]); String x[]=ss.split(" "); //for(int j=0;j<x.length;j++) System.out.print(" "+x[j]); int key=new Integer(x[1]); int index=new Integer(x[0]); key+=old; tmp=""; tmp=tmp+index+" "+key; hs.put(list[i],tmp); //System.out.println("index="+index+" "+"key="+key); if((index-v) >= 0) ans.remove(index-v); //System.out.println("size of linked list="+ans.size()); ++v; }catch(Exception e1){e1.printStackTrace();}  } yy=""; tmp="";  } System.out.println("ans="+ans); }   }	2014-12-10 11:51:10		
4337	sqzqo	45	package psan; import java.io.*; import java.util.*;  public class UniqueUrlSearch  { public static void main(String...s) throws Exception { BufferedReader b=new BufferedReader(new InputStreamReader(System.in)); LinkedList<String> ans=new LinkedList<String>(); System.out.println("Enter the list"); String list[]=b.readLine().split(" "); int len=list.length,itr=-1; int old=1,current=1,v=0; String tmp="",yy=""; HashMap<String,String> hs=new HashMap<String,String>(); for(int i=0;i< len;i++) {  if(!hs.containsKey(list[i])) { try{++itr; yy=yy+itr; tmp=tmp+yy+" "+"1"; System.out.println("in if tmp="+tmp); hs.put(list[i],tmp); ans.add(list[i]); }catch(Exception e){e.printStackTrace();} } else { try{  System.out.println("in else:"); String ss=hs.get(list[i]); String x[]=ss.split(" "); //for(int j=0;j<x.length;j++) System.out.print(" "+x[j]); int key=new Integer(x[1]); int index=new Integer(x[0]); key+=old; tmp=""; tmp=tmp+index+" "+key; hs.put(list[i],tmp); //System.out.println("index="+index+" "+"key="+key); if((index-v) >= 0) ans.remove(index-v); //System.out.println("size of linked list="+ans.size()); ++v; }catch(Exception e1){e1.printStackTrace();}  } yy=""; tmp="";  } System.out.println("ans="+ans); }   }	2014-12-10 11:51:10		
4338	wbqzu	45	I was asked this question by an interviewer. I felt that no algorithm can be faster than O(n^2). But, I saw the methods using the hash table. Though I get the idea to use the hash table, the question simply shifts from finding the first unique URL to finding the optimal hashing function. There can still be collisions and that can end up increasing the search in the unique list from O(1).	2014-12-10 11:51:10		
4339	sgiwy	45	I was asked this question by an interviewer. I felt that no algorithm can be faster than O(n^2). But, I saw the methods using the hash table. Though I get the idea to use the hash table, the question simply shifts from finding the first unique URL to finding the optimal hashing function. There can still be collisions and that can end up increasing the search in the unique list from O(1).	2014-12-10 11:51:10		
4340	ewigy	46	Here's a very simple way to do it. Make an array of booleans (or bits) of size N^2, where arr[i-1] indicates whether i+1 is adjacent to i. Then, iterate over the matrix, checking for each cell the four neighbors and populating the relevant entry in the boolean array. Then just look for the longest run of "true" values in the boolean array, which can be done with one pass.  This approach is linear in time and space with the size of the input. The space needed is only 1 bit per element, so the constant factor is really low for space. The constant factor for time should be reasonably good as well because we only do a few array accesses and comparisons for each element in the input.	2014-12-10 11:51:11		
4341	cfzie	46	I don' t think this takes into encounter whether it forms an increasing sequence It just ensures hat the values taken are consequent. Ex: 5 6 7 4 1 7 6 2 will probably give 6 7 6 7 as ans, if I am interpreting your algorithm correctly. Kindly correct me if I am wrong.	2014-12-10 11:51:11		
4342	nhibd	46	First, the question tells us to assume that we have all numbers from 1 to n*n EXACTLY once, so your situation cannot happen.  Also, if you're not guaranteed distinct integers, the algorithm does not make any sense. What do you store in arr[5] if one of the 6s is adjacent to 7 but the other one isn't?  I hope that clears up some confusion.	2014-12-10 11:51:11		
4343	eucmc	46	Yes, the algorithm is only valid if all the integers are distinct. We can still solve in linear time and space with respect to the size of the input if they're not distinct, but you would need a different algorithm. You could do it using dynamic programming. Let F(x,y) be the longest sequence starting from coordinates (x, y). Then F(x, y) = 1 if there are no neighbors with value arr[x][y]+1, or 1 + max over all such neighbors if any exist.	2014-12-10 11:51:11		
4344	krxlv	46	The problem statement says " NxN matrix which contains all distinct 1 to n^2 numbers" and this is an elegant solution. It's probably the answer the interviewer expecting too. +1.  @Eugene says it's linear time, but it's actually O(N^2) time and space, because input size is N^2.	2014-12-10 11:51:11		
4345	mrjku	46	Note that I said the algorithm is "linear in time and space with the size of the input", not linear in terms of N. The input size is N^2, so the time and space complexities are O(N^2). I chose to talk about the performance relative to the size of the input because that makes it clear that this algorithm is asymptotically optimal, since any algorithm must look at all or most of the input.	2014-12-10 11:51:11		
4346	plapd	46	can you explain how will you modify the entry in the boolean array when you traverse the matrix? I might be missing something. The solution is a bit unclear to me.	2014-12-10 11:51:11		
4347	ethan	46	got it. never mind.	2014-12-10 11:51:11		
4348	qywrh	46	time O(n^2) space O(n^2) solution. we will need a 2D array visited[n][n] and two global vars->start and max=0. Now we will traverse the matrix row by row. for each 'not visited' element k start a recursive dfs such that next element is k+1. Mark all traversed elements as visited so that you do not start a traversal from them again the dfs() will return you the depth value till which it could go. e.g. for 6 it will return 4 (6-7-8-9). for 7 it will return 3 (7-8-9). if this value is greater than max, then update max and start value.  At last print max no. of consecutive characters from start value.	2014-12-10 11:51:11		
4349	eucmc	46	@neerajlakhotia08: based on your idea	2014-12-10 11:51:11		
4350	dkebi	46		2014-12-10 11:51:11		
4351	ewigy	46		2014-12-10 11:51:11		
4352	ethan	46	Your sample data ignores the constraints of the question: that the array is rectangular (that is, X == Y, so why not use only one constant?) and that the array is populated with the numbers 1...N^2. With X == Y == 4, you shouldn't have any number larger than 16 or less than 1.	2014-12-10 11:51:11		
4353	cfzie	46	1. In an array, store the position of every integer from 1 to n^2 by simply reading every entry of the matrix.  2. Iterate through the array. At every step, check if the next position is adjacent to the current position. If so, your current sequence's size increases by 1. If not, your current sequence is over. Every time a sequence terminates, if its length is greater than the longest sequence seen so far, remember its length and where it ends.  3. Knowing the size of the longest sequence and on which number it ends, you can easily print the sequence by printing the numbers from "end - length + 1" to "end".  Running the algorithm on the given example looks like this:	2014-12-10 11:51:11		
4354	wbqzu	46		2014-12-10 11:51:11		
4355	sqzqo	46		2014-12-10 11:51:11		
4356	sgiwy	46	1. Produce the following array: [(0,0), (0,1), (1,1), (0,2), (1,0), (1,2), (2,2), (2,1), (2,0)]  2. Set length counter to 1. (0,0) is adjacent to (0,1): +1; (0,1) is adjacent to (1,1): +1; (1,1) is not adjacent to (0,2): sequence length is 3, our current best, so lets remember the length and that it ended on the 3rd entry. Reset length counter to 1. (0,2) is not adjacent to (1, 0): sequence length is 1, not our best. Simply reset counter to 1. (1,0) is not adjacent to (1, 2): sequence length is 1, not our best. Simply reset counter to 1. (1,2) is adjacent to (2,2): +1; (2,2) is adjacent to (2,1): +1; (2,1) is adjacent to (2,0): +1; (2,0) is the end of the array, so the sequence ends: sequence length is 4, our current best, so lets remember the length and that it ended on the 9th entry.  3. Our longest sequence has length 4 and ends at 9. So it starts at 9 - 4 + 1 = 6. So we output 6 7 8 9.  This algorithm has O(n^2) time and space complexity. O(n^2) is optimal for time complexity because you have to at least look at all of the entries, but O(n^2) is not optimal for space complexity. I can't seem to reduce the space complexity without increasing the time complexity however...  In Java:	2014-12-10 11:51:11		
4357	nhibd	46		2014-12-10 11:51:12		
4358	nhibd	46		2014-12-10 11:51:12		
4359	dkebi	46	where Coordinate is the following simple class (you could just use an array of size 2 instead of making a class if you want to be more efficient, but then, you shouldn't be using Java lol)	2014-12-10 11:51:12		
4360	fmzze	46		2014-12-10 11:51:12		
4361	admin	46		2014-12-10 11:51:12		
4362	mrjku	46	I assumed that you want to print the *longest* sequence of of consecutive numbers that are adjacent in the array. If not could you please clarify your question please, thanks.	2014-12-10 11:51:12		
4363	bexbp	46		2014-12-10 11:51:12		
4364	qywrh	46		2014-12-10 11:51:12		
4365	eucmc	46	Could you please explain how is it an increasing sequence from the matrix? not when i read thru row or cols, so how should i read the matrix? if through the edge of the matrix, then 1246789 seems to be also the sequence	2014-12-10 11:51:12		
4366	wbqzu	46	Please explain the increasing sequence here as there are others that might be possible of the same sequence.	2014-12-10 11:51:12		
4367	ufdxg	46	I updated the question guys. its the adjacent sequential numbers like 6 7 8 but not 1 2 4	2014-12-10 11:51:12		
4368	jippy	46	We can implement using below graph by getting the adjacent value then check for increasing order needs extra effort.  1 2 3 4 5 6 7 8 9  1 0 1 0 0 1 0 0 0 0  2 1 0 1 1 1 0 0 0 0  3 0 1 0 0 1 1 0 1 0  4 0 1 0 0 0 1 0 0 0  5 1 0 1 0 0 0 0 0 1  6 0 0 1 1 0 0 1 0 0  7 0 0 0 0 0 1 0 1 0  8 0 0 1 0 0 0 1 0 1  9 0 0 0 0 1 0 0 1 0  the sequence can be pushed into the stack for the result.  Suggest if the above solution is wrong.	2014-12-10 11:51:12		
4369	sgiwy	46	might not be super efficient; but would work	2014-12-10 11:51:12		
4370	fmzze	46		2014-12-10 11:51:12		
4371	eucmc	46		2014-12-10 11:51:12		
4372	krxlv	46	The question says the array is square and NxN in size; and that it is populated with numbers 1...n^2. Why does your 4x4 array have numbers like 29 and 28 in it?	2014-12-10 11:51:12		
4373	ufdxg	46	Right or wrong, remember that this is an interview question. Code clarity, time to write, avoiding unnecessary structures and dependencies are measured as well. I believe the expectation for such question is that one can write the full code within 20-25 minutes...	2014-12-10 11:51:12		
4374	huiqq	46		2014-12-10 11:51:12		
4375	ufdxg	46		2014-12-10 11:51:12		
4376	gilit	46	public static void search(int cur, ArrayList<Node> mat,String result, ArrayList<String> results){ int left = cur%3 -1; int right = cur%3 +1; int up = cur/3 -1; int down = cur/3 +1; mat.get(cur).visit = true; result += mat.get(cur).num+""; boolean haha = false; if(left >=0 && left < 3){ if(mat.get(cur-1).num-mat.get(cur).num == 1 && !mat.get(cur-1).visit){ search(cur-1, mat,result, results); haha = true; } } if(right >=0 && right < 3){ if(mat.get(cur+1).num-mat.get(cur).num == 1 && !mat.get(cur+1).visit){ search(cur+1, mat,result, results); haha = true; } } if(up >=0 && up < 3){ if(mat.get(cur-3).num-mat.get(cur).num == 1 && !mat.get(cur-3).visit){ search(cur-3, mat,result, results); haha = true; } } if(down >=0 && down < 3){ if(mat.get(cur+3).num-mat.get(cur).num == 1 && !mat.get(cur+3).visit){ search(cur+3, mat,result, results); haha=true; } }  if(!haha){ results.add(result); }  }	2014-12-10 11:51:12		
4377	krxlv	46		2014-12-10 11:51:12		
4378	krxlv	46		2014-12-10 11:51:12		
4379	vanul	46	This is O(n)	2014-12-10 11:51:12		
4380	eucmc	46		2014-12-10 11:51:12		
4381	fowai	46		2014-12-10 11:51:12		
4382	rdfeo	46		2014-12-10 11:51:12		
4383	sgiwy	46		2014-12-10 11:51:12		
4384	nhibd	46	Anyone else thinks that the Union-Find data structure would be perfect for this problem? O(2n) space requirements, O(log n) time to "connect" the numbers, constant time to check if 2 numbers are connected. O(n) time to find the largest set.  Th only problem with this and the above solutions is that their next question will probably be something along the lines of: "Well, what if the matrix is so big that it doesn't fit into memory?" :)	2014-12-10 11:51:12		
4385	sgiwy	46	Union-find and tree traverse have similar space and time requirements.  Tree traverse by DFS may need recursive call.	2014-12-10 11:51:12		
4386	dkebi	46	Fairly brute force, O(n) scan with recursion on adjacent cells that are one value higher. Then sort of all possible answers to find longest (with largest sum, if more than one of same length):  python n_by_n_sequence.py matrix.in [6, 7, 8, 9]	2014-12-10 11:51:12		
4387	fmzze	46		2014-12-10 11:51:12		
4388	zeice	46		2014-12-10 11:51:12		
4389	fowai	46		2014-12-10 11:51:12		
4390	jippy	46		2014-12-10 11:51:12		
4391	azmjc	46	Since all the content is exactly 1..N*N, create a map from these to the right cell (i,j). Iterate, say with i, from 1 to N^2-1 - if the map.get(i) has distance of exactly 1 from map.get(i+1), augment this pair (say in List), when the above is false, if the List is not empty, print it out and empty.  (O(NXN)) memory and time	2014-12-10 11:51:12		
4392	ethan	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:12		
4393	plapd	46		2014-12-10 11:51:12		
4394	ufdxg	46		2014-12-10 11:51:12		
4395	krxlv	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:12		
4396	bexbp	46		2014-12-10 11:51:12		
4397	plapd	46		2014-12-10 11:51:12		
4398	jippy	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:12		
4399	eucmc	46		2014-12-10 11:51:13		
4400	gilit	46		2014-12-10 11:51:13		
4401	xhgls	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4402	azmjc	46		2014-12-10 11:51:13		
4403	fowai	46		2014-12-10 11:51:13		
4404	dkebi	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4405	ethan	46		2014-12-10 11:51:13		
4406	rdfeo	46		2014-12-10 11:51:13		
4407	nwkeg	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4408	ufdxg	46		2014-12-10 11:51:13		
4409	xhgls	46		2014-12-10 11:51:13		
4410	rrmeu	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4411	eucmc	46		2014-12-10 11:51:13		
4412	qywrh	46		2014-12-10 11:51:13		
4413	ethan	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4414	bjsiw	46		2014-12-10 11:51:13		
4415	nhibd	46		2014-12-10 11:51:13		
4416	zeice	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4417	fowai	46		2014-12-10 11:51:13		
4418	dkebi	46		2014-12-10 11:51:13		
4419	rdfeo	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4420	jippy	46		2014-12-10 11:51:13		
4421	ewigy	46		2014-12-10 11:51:13		
4422	ftfck	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4423	ftfck	46		2014-12-10 11:51:13		
4424	huiqq	46		2014-12-10 11:51:13		
4425	mrjku	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4426	fmzze	46		2014-12-10 11:51:13		
4427	rdfeo	46		2014-12-10 11:51:13		
4428	gilit	46	I can only find a way to calculate the length of the substring, can anyone help me to print out the string?	2014-12-10 11:51:13		
4429	bjsiw	46		2014-12-10 11:51:13		
4430	nhibd	46		2014-12-10 11:51:13		
4431	wbqzu	46	simple my version	2014-12-10 11:51:13		
4432	sgiwy	46		2014-12-10 11:51:13		
4433	dkebi	46		2014-12-10 11:51:13		
4434	zeice	46	Could anyone please explain the question a bit in detail? My confusion stems from the concept that matrices are usually read 1 row at a time - top down. I am unable to see 6 7 8 9 as adjacent numbers, unless seen visually. matrix [row] [column] is the general declaration i have seen till now. A lot of folks are attempting the question means I am missing something here. Appreciate any help. Thanks!	2014-12-10 11:51:13		
4435	ewigy	46	Here is another solution.  First we construct a graph, one node for each element in the matrix. Then we add directed edges for every pair of adjacent nodes (a-->b) where b-1 == a. Finally, we re-loop over all nodes checking the maximum length run by following the edges of each child node until no more exist. When this final loop finishes we've noted the maximum length run and we return it.  We are looping over the input 3 times, but I belive the running time is O(n) where n is the size of the matrix.	2014-12-10 11:51:13		
4436	eucmc	46		2014-12-10 11:51:13		
4437	jippy	46		2014-12-10 11:51:13		
4438	rdfeo	46		2014-12-10 11:51:13		
4439	huiqq	46		2014-12-10 11:51:14		
4440	wbqzu	46	I am not sure I get the question - should the sample answer to the question not have printed out {1 2 3} and {6,7,8,9}, assuming that adjacency is just above, below, left and right?	2014-12-10 11:51:14		
4441	admin	46	#include <stdio.h> #include <iostream>  using namespace std;  bool** check; int searchLongestAdjaSeq(int**, int*, int); int searchLongestAdjaSeqInv(int**, int*, int, int, int);  int main() { int i, j, N, len; int **matrix, *seq;  cout << "size of matrix: "; cin >> N;  matrix = new int *[N]; check = new bool *[N]; for(i=0; i<N; i++) { matrix[i] = new int [N]; check[i] = new bool [N]; }  cout << "fill NXN matrix: "; for(i=0; i<N; i++) { for(j=0; j<N; j++) { cin >> matrix[i][j]; check[i][j] = false; } }  seq = new int [N*N]; len = searchLongestAdjaSeq(matrix, seq, N);  cout << "seq: "; for(i=0; i<len; i++) printf("%d ", seq[i]);  return 0; }   int searchLongestAdjaSeq(int** matrix, int* seq, int N) { int i, j, k, ret, len; int *tmpseq;  ret = 0; for(i=0; i<N; i++) { for(j=0; j<N; j++) { if(check[i][j]) continue;  tmpseq = new int [N*N]; len = searchLongestAdjaSeqInv(matrix, tmpseq, N, i, j);  if(len > ret) { for(k=0; k<len; k++) seq[k] = tmpseq[k];  ret = len; }  delete [] tmpseq; } }  return ret; }  int searchLongestAdjaSeqInv(int** matrix, int* seq, int N, int i, int j) { int ret, k; int *tmpseq;  ret = 0; check[i][j] = true; tmpseq = new int [N*N]; if (i!=0 && matrix[i][j]+1 == matrix[i-1][j]) ret = searchLongestAdjaSeqInv(matrix, tmpseq, N, i-1, j); else if (i!=N-1 && matrix[i][j]+1 == matrix[i+1][j]) ret = searchLongestAdjaSeqInv(matrix, tmpseq, N, i+1, j); else if (j!=0 && matrix[i][j]+1 == matrix[i][j-1]) ret = searchLongestAdjaSeqInv(matrix, tmpseq, N, i, j-1); else if (j!=N-1 && matrix[i][j]+1 == matrix[i][j+1]) ret = searchLongestAdjaSeqInv(matrix, tmpseq, N, i, j+1);  ret++; seq[0] = matrix[i][j]; for(k=1; k<ret; k++) seq[k] = tmpseq[k-1];  return ret; }	2014-12-10 11:51:14		
4442	bjsiw	46		2014-12-10 11:51:14		
4443	cfzie	46		2014-12-10 11:51:14		
4444	fmzze	46		2014-12-10 11:51:14		
4445	azmjc	46		2014-12-10 11:51:14		
4446	huiqq	46	To explain my code above, I'm using the backtracking techniques to recursively find the adjacent numbers. Precisely, I'm looking for the number which is 1 bigger than current stand in the up, down, left, right spots. If there exists such number than go that direction.  This algorithm will not work well since it only consider the increasing scenario. For example, the worst case should be: {1,2,3, 6,5,4, 7,8,9} it will traverse all the previous numbers at each step. To improve the algorithm, we need additional space to trade off time which I have not gave a through thought yet.	2014-12-10 11:51:14		
4447	bexbp	46		2014-12-10 11:51:14		
4448	nhibd	46		2014-12-10 11:51:14		
4449	azmjc	46	Fully testable code	2014-12-10 11:51:14		
4450	vanul	46	Recursive JavaScript solution - returns an array of the longest sequence:	2014-12-10 11:51:14		
4451	rrmeu	46		2014-12-10 11:51:14		
4452	huiqq	46		2014-12-10 11:51:14		
4453	jippy	46	O(n)	2014-12-10 11:51:14		
4454	mrjku	46		2014-12-10 11:51:14		
4455	ftfck	46		2014-12-10 11:51:14		
4456	eucmc	47	this one is simple you will need two array of same size solution as example: {a,b,c,d,e,f} generate {1,a,ab,abc,abcd,abcde} and {bcdef,cdef,def,ef,f,1} now do a dot product of the above two array you are done.. complexity O(3n)= O(n) the above array are easily calculable as they can be generated the first from the front of array and other from back with 1 multiplcation for each element.	2014-12-10 11:51:15		
4457	eucmc	47	@kkr.ashish : the solution is correct however you can do it in two iterations rather than 3n C++ code below for O(2n)	2014-12-10 11:51:15		
4458	admin	47		2014-12-10 11:51:15		
4459	nhibd	47		2014-12-10 11:51:15		
4460	mrjku	47	How you can say O(n) ? Because you are generating array {1,a,ab,abc,abcd,abcde} which will take multiple iterations.	2014-12-10 11:51:15		
4461	jippy	47	@Rahul generating the array is as simple as newArr[i]=newArr[i-1]*arr[i]; So yes, it is O(n).	2014-12-10 11:51:15		
4462	mrjku	47	Construct 2 arrays F(forward) and B(backward). F[i] = a[0]*a[1]*a[i-1] B[i]=a[i+1]*...a[n-1] F[0]=1; B[n-1]=1; Use dynamic programming to construct F and B b[i]=F[i]*B[i].	2014-12-10 11:51:15		
4463	dkebi	47		2014-12-10 11:51:15		
4464	bexbp	47	a = {1,2,3,6,2,8} {{ F[2] = 1 * 2 }} You made a mistake at this step. B[2] = 6 * 2 * 8 b[2] = 1 * 2 * 6 * 2 * 8  192 = 192	2014-12-10 11:51:15		
4465	ftfck	47	{a[0]*a[1]*a[2]*...a[n-1] - (a[1]*a[2]...a[n-1] (a[0]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[2]...a[n-1] (a[1]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[1]*a[3]...a[n-1] (a[2]-1)), ...} Complexity O(n)	2014-12-10 11:51:15		
4466	krxlv	47	input 1,2,3,6,2,8  1*2*3*6*2*8 = 576  576/1 = 576 576/2 = 288 576/3 = 192 576/6 = 82 576/2 = 288  a[0]*a[1]*a[2]*...a[n-1] - (a[1]*a[2]...a[n-1] (a[0]-1)) = 576 - 2*3*6*2*8 (1-1) = 576 a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[2]...a[n-1] (a[1]-1)) = 576 - 1*3*6*2*8 (2-1) = 288 a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[1]*a[3]...a[n-1] (a[2]-1)) = 576 - 1*2*6*2*8 (3-1) = 192  Verified. Excellent work. Thumps up	2014-12-10 11:51:15		
4467	bexbp	47	nice one ....   a[0]*a[1]*...*a[n-1] ( a[r] - a[r]+1) = a[0]*a[1]*.......*a[r-1]*a[r+1].............*a[n-1]	2014-12-10 11:51:15		
4468	mrjku	47		2014-12-10 11:51:15		
4469	eucmc	47		2014-12-10 11:51:15		
4470	xhgls	47	O(2n) no additional buffer (only output array)	2014-12-10 11:51:15		
4471	bexbp	47		2014-12-10 11:51:15		
4472	mrjku	47		2014-12-10 11:51:15		
4473	wbqzu	47	Calculate suffix product array, for input array A: B[i] = Product of A[i+1], ..., A[n-1]  Do this by linear sweep from right:	2014-12-10 11:51:15		
4474	cfzie	47		2014-12-10 11:51:15		
4475	ethan	47		2014-12-10 11:51:15		
4476	wbqzu	47	Now go forwards and calculate prefix products on the fly, and place result in array R: R[i] = prefix_product_at_i * B[i]:	2014-12-10 11:51:15		
4477	ethan	47		2014-12-10 11:51:15		
4478	fmzze	47		2014-12-10 11:51:15		
4479	jippy	47	~2n runtime ~n space	2014-12-10 11:51:15		
4480	sqzqo	47	This is laziest solution I am going to explain with an example: {a,b,c,d,e,f} then find this value====> abcdef and then find { abcdef *(a^-1), abcdef* (b^-1), abcdef * (c^-1),abcdef * (d^-1), abcdef * (e^-1), abcdef * (f^-1) }  Conclusion: Time complexity: O(2n)=O(n). Space complexity=O(1).  Note: i am not using division operator.	2014-12-10 11:51:15		
4481	tenuw	47	Really Great Solution Sir.	2014-12-10 11:51:15		
4482	rrmeu	47	To have a complete solution, you would need to mention an algorithm for finding a^(-1) without using division. After all, a^(-1) is sometimes *defined* as 1/a.  It looks like what you mean to say is that you will find a way to do something equivalent to division without dividing directly...which might be OK, but you'd need to give an algorithm for that.	2014-12-10 11:51:16		
4483	dgjji	47	It is very difficult to digest out of box solutions. :-p  a^(-1), Here ^(power) is inbuilt operator like *(multiplication). If ur asking power algorithm. why ur not asking multiplication algorithm.  Everyone knows About it	2014-12-10 11:51:16		
4484	tenuw	47	Guys I have solved this simple approach.  {a[0]*a[1]*a[2]*...a[n-1] - (a[1]*a[2]...a[n-1] (a[0]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[2]...a[n-1] (a[1]-1)), a[0]*a[1]*a[2]*...a[n-1] - (a[0]*a[1]*a[3]...a[n-1] (a[2]-1)), ...} Complexity O(n)  P/A = P - BCDEF (A-1) P/B = P - ACDEF (B-1) P/C = P - ABDEF (C-1) P/D = P- ABCEF (D-1)  etc  where A = a[0] B = a[1].... P= ABCDEF...  Vote it if you understood it.	2014-12-10 11:51:16		
4485	wbqzu	47	How is the product 22? Can you clarify the question further?	2014-12-10 11:51:16		
4486	vanul	47	I think he meant sum.	2014-12-10 11:51:16		
4487	eucmc	47	sorry product is 576	2014-12-10 11:51:16		
4488	fowai	47	sorry product is 576	2014-12-10 11:51:16		
4489	fowai	47	kkr.ashish's approach is correct!  Here is my code:	2014-12-10 11:51:16		
4490	dkebi	47		2014-12-10 11:51:16		
4491	dkebi	47		2014-12-10 11:51:16		
4492	dkebi	47	O1 stores {1, A[0], A[0]A[1], ...., A[0]A[1]..A[N-2]} O2 stores {A[1]A[2]..A[N-1], A[2]A[3]..A[N-1], ...., 1}	2014-12-10 11:51:16		
4493	admin	47	it will take n^2	2014-12-10 11:51:16		
4494	dgjji	47	How about below approach.  arr[] = { a,b,c,d,e}; create another array res in such a way that res [] = {abcd,acde,abde,abce,abcd };  let me know if i am correct?	2014-12-10 11:51:16		
4495	jippy	47	sorry for mistake this is correct res [] = {abcde,acde,abde,abce,abcd };	2014-12-10 11:51:16		
4496	dkebi	47	what you are doing is correct but look at the complexity part.. you are accessing n-1 elements for every 1 element in output array Complexity = O(n(n-1))= O(n2) the question asked is to reduce the complexity also your updated res[] is not correct the first elemeny should be bcde and abcde	2014-12-10 11:51:16		
4497	bjsiw	47	yes thanks Ashish for pointing	2014-12-10 11:51:16		
4498	bjsiw	47	int main() { int arr[]={1,2,3,4}; int size=sizeof(arr)/sizeof(arr[0]); int *B=(int *)malloc(sizeof(int)*(size-1)); memset(B,0,sizeof(int)*(size-1)); int x=1; for(int i=0;i<size;i++) { B[i]=x; x=x*arr[i]; } x=1; for(int i=size-1;i>=0;i--) { B[i]=x*B[i]; x=x*arr[i]; } for(int i=0;i<size;i++) cout<<B[i]<<" "; getchar(); return 0; }	2014-12-10 11:51:16		
4499	krxlv	47	This can be done in O(nlogn) using divide and conquer The basic idea of the algorithm is as follows: 1. We recursively solve two smaller arrays of size n/2 to get F and B 2. Compute f= a[0]*a[1]*...*a[n/2-1]; b = a[n/2]*a[n/2+1]*...*a[n-1] 3. Multiply each element in F by b, and multiply each element in B by f. Time complexity analysis: T(n) = 2T(n/2) + O(n) = O(nlogn)	2014-12-10 11:51:16		
4500	cfzie	47	o(n) solution is already given :)	2014-12-10 11:51:16		
4501	dgjji	47	how does it works? i didn't get this	2014-12-10 11:51:16		
4502	sqzqo	47		2014-12-10 11:51:16		
4503	tenuw	47		2014-12-10 11:51:16		
4504	admin	47	And one more thing, you should think about the size of this kind of multiplication. It may not work for even a little large number. For example, array with size of 20 and full of 20s.	2014-12-10 11:51:16		
4505	dgjji	47	//Time Complexity O(nlogn) #include<stdio.h> int f(int *a,int i,int j){ int p=1,leftp=1,rightp=1; int l; for(l=i;l<=j;l++) p*=a[l]; if(j==i){ a[i]=1; return p; } int mid=i+(j-i)/2; leftp=f(a,i,mid); rightp=f(a,mid+1,j); for(l=i;l<=mid;l++) a[l]*=rightp; for(l=mid+1;l<=j;l++) a[l]*=leftp; return p; } int main(){ int a[]={1,2,3,4,5,6,7,8}; int n=sizeof(a)/sizeof(a[0]),i; int p=f(a,0,n-1); printf("Product--%d\n",p); for(i=0;i<n;i++) printf("%d ",a[i]); }	2014-12-10 11:51:16		
4506	fowai	47		2014-12-10 11:51:16		
4507	fmzze	47		2014-12-10 11:51:16		
4508	sgiwy	47		2014-12-10 11:51:16		
4509	jippy	47		2014-12-10 11:51:16		
4510	huiqq	48	Consider the resultant string to be S1...E1 S2... E2 ................ Sn... En where Si is the starting character of String i and Ei is the ending character of String i. Here, E1 must be equal to S2 and E2 must be equal to S3 and En-1 must be equal to Sn. But S1 and En donot have any relation with any other character. So consider that the Set of starting characters S = {S1, S2, ...., Sn} and the set of ending characters E = {E1, E2, ..... , En}. We need these sets to differ only by at most one element. This element will be the start of the first String and the end of the last string). But for every other value in Set S, other than the value that differs, there must be a corrsponding value in set E. A way to implement this is to have an array of integers with a cell for each character. First, for every character in set S, we increment its position in the array by one. Then for every character in Set E we decrement its place in the array by one. Afterwards if the array is all zeros (every charcater in the set S had a matching character in set E) or if the array consists of zeros except for one cell having value one and one cell having value negative one (in that case only one character differs between set S and set E) then all strings can be adhered together and there's a solution.	2014-12-10 11:51:18		
4511	rrmeu	48	this alone is not enough, assume a set (a,b), (b,d), (c,b), (b,c). to find the chain (and print it), you have to find the correct order as well. if ab->bd is chosen we stuck at that point, we have to follow as ab->bc->cb->bd.	2014-12-10 11:51:18		
4512	sgiwy	48	You are checking for necessary condition. A sufficient condition and solution thereafter is an NP complete problem.	2014-12-10 11:51:18		
4513	bexbp	48	public static boolean chaintermed(String[] strings){ NodePP[] arr=new NodePP[26]; int count=0; for(int i=0;i<strings.length;i++){ int pre=strings[i].charAt(0)-'a'; int pro=strings[i].charAt(strings[i].length()-1)-'a'; if(arr[pre]==null){ NodePP nPre=new NodePP(); arr[pre]=nPre; } if(arr[pro]==null){ NodePP nPro=new NodePP(); arr[pro]=nPro; } arr[pre].pre++; arr[pro].pro++; } for(int j=0;j<strings.length;j++){ int pre=arr[strings[j].charAt(0)-'a'].pro; int pro=arr[strings[j].charAt(strings[j].length()-1)-'a'].pre; if(((pre==0)&&(pro==0))){return false;} if((pre!=pro)){ count++; } } return count==2?true:false; }	2014-12-10 11:51:18		
4514	huiqq	48	use ruler path. Return true when there are exact two odd number of vertices.	2014-12-10 11:51:18		
4515	admin	48		2014-12-10 11:51:18		
4516	zeice	48		2014-12-10 11:51:18		
4517	tenuw	48	here is my solution which (I believe) works correctly and also prints the sequence	2014-12-10 11:51:18		
4518	mrjku	48		2014-12-10 11:51:18		
4519	ufdxg	48		2014-12-10 11:51:18		
4520	gilit	48	1) Consider all ending and initial character as vertices of graph. 2)string as edge. 3) Form a directed graph 4) find "Euler path" i) if path found concatenation all string in path. ii) else no chain possible  eg: 1) a...d 2) q...b 3) n...f 4) a...q 5) f...a 6) d....n  Nodes will be: a b d n f q  Edged will be: 1) a->d 2) q->b 3) n->f 4)a->q 5)f->a 6)d->n  One possible path will be: a->d->n->f->a->q->b  so chain will be: a...d...n...f...a...q...b	2014-12-10 11:51:18		
4521	azmjc	48	who is giving -1 to all ans?? if you hv any better sol give it..	2014-12-10 11:51:18		
4522	fowai	48	+1. Euler tour is right idea.  And Yeah. If you pick a random visitor of this site, you will likely get a f***g idiot.	2014-12-10 11:51:18		
4523	dgjji	48	You want the Hamiltonian path, not the Eulerian path. Every transition (path) need not be visited, only every vertex, in other words, every word.	2014-12-10 11:51:18		
4524	mrjku	48	Euler path will not work , if there are duplicate pair's.	2014-12-10 11:51:18		
4525	ethan	48	With duplicate pairs , we add another edge.  example: cab chb.. should produce a graph with 2 edges from c->b .. in such a graph there is no euler path	2014-12-10 11:51:18		
4526	qywrh	48	@memo you are right - this is Hamiltonian path problem, not Eulerian, because last allows same vertex to be visited twice, which is not acceptable solution. This is NP-Complete problem and seems all combinations have to be verified in worst case.  I wonder if this problem can be converted to another, not NP-Complete so we'll have better complexity.	2014-12-10 11:51:18		
4527	eucmc	48	7 positive votes for an incorrect solution? At least people should have the ability to judge the correctness of given solution.	2014-12-10 11:51:18		
4528	mrjku	48	Hi please let me know if the following is failing for any test case:  #include <stdio.h> #include <stdlib.h>  struct list{ int v; int indegree; struct list *next; };  struct Graph{ int V; struct list **Adj; };  struct Graph *createG(int n){ int i=0,j=0; struct Graph *G=(struct Graph*)malloc(sizeof(struct Graph));  G->V=n;  G->Adj=(struct list**)malloc(sizeof(struct list*)*n*2);  for(j=0;j<n;j++){ G->Adj[i]=(struct list*)malloc(sizeof(struct list));  G->Adj[i]->v=i; G->Adj[i]->indegree=0;    G->Adj[i+1]=(struct list*)malloc(sizeof(struct list)); G->Adj[i+1]->v=i+1;  G->Adj[i+1]->indegree=0;    struct list *temp=(struct list*)malloc(sizeof(struct list)); temp->v=i+1; temp->next=NULL; G->Adj[i]->next=temp;  struct list *temp2=(struct list*)malloc(sizeof(struct list)); temp2->v=i; temp2->next=NULL; G->Adj[i+1]->next=temp2;    i+=2; }    return G;  }  void createEdge(struct Graph *G,struct list *u,struct list *v){ int p,q;  p=u->v; q=v->v;  struct list *temp=(struct list*)malloc(sizeof(struct list)); temp->v=q; temp->next=G->Adj[p]->next; G->Adj[p]->next=temp; G->Adj[p]->indegree+=1;  struct list *temp2=(struct list*)malloc(sizeof(struct list)); temp2->v=p; temp2->next=G->Adj[q]->next; G->Adj[q]->next=temp2; G->Adj[q]->indegree+=1;  return;    }  struct list_t{ char key; struct list *val; struct list_t *next; };   struct hash_table{ int size; struct list_t **table; };  struct hash_table *createH(int size){ int i; struct hash_table *t=(struct hash_table*)malloc(sizeof(struct hash_table));  t->size=size;  t->table=(struct list_t**)malloc(sizeof(struct list_t)*size);  for(i=0;i<size;i++) t->table[i]=NULL;  return t; }   int hash(struct hash_table *t,char key){ unsigned int hashval=0;  hashval=((int)key)<<5 -(int)key;  return hashval%t->size;  }   struct node{ struct list *v; struct node *next;  };  void Insert(struct node **head,struct list *v){ struct node *temp=(struct node*)malloc(sizeof(struct node));  temp->v=v;  temp->next=*head; *head=temp;  }   struct list *lookupH(struct hash_table *t,char key){  int hashval=hash(t,key);  struct list_t *list_val=NULL;  struct node *head=NULL;  for(list_val=t->table[hashval];list_val;list_val=list_val->next){ if(list_val->key==key) Insert(&head,list_val->val); }  return head; }  void InsertH(struct hash_table *t,char key,struct list *val){   int hashval=hash(t,key);  struct list_t *list_val=(struct list_t*)malloc(sizeof(struct list_t));  list_val->key=key; list_val->val=val;  list_val->next=t->table[hashval];  t->table[hashval]=list_val;   }   int main() {  int i,j=0,n; printf("Enter # of strings\n");  scanf("%d",&n);  char **A=(char**)malloc(sizeof(char*)*n);  for(i=0;i<n;i++){ printf("Enter string # %d\n",i+1); A[i]=(char*)malloc(sizeof(char)*20); scanf("%s",A[i]); }  struct Graph *G=createG(n);   struct hash_table *t1=createH(n); struct hash_table *t2=createH(n);  j=0;    for(i=0;i<n;i++){ int len=strlen(A[i]);  InsertH(t1,*(A[i]),G->Adj[j]);  struct node *head=lookupH(t2,*(A[i]));  while(head){ createEdge(G,G->Adj[j],head->v); head=head->next; }   InsertH(t2,*(A[i]+len-1),G->Adj[j+1]);   head=lookupH(t1,*(A[i]+len-1));   while(head){ createEdge(G,G->Adj[j+1],head->v); head=head->next; }    j+=2;  }  j=0; int count1=0,count2=0;   for(i=0;i<n;i++){ if(G->Adj[j]->indegree==0) count1++; if(G->Adj[j+1]->indegree==0) count2++; j+=2; }    if(count1>1 || count2>1) printf("NO"); else printf("YES");  return 0; }	2014-12-10 11:51:18		
4529	nhibd	48	Consider the resultant string to be S1...E1 S2... E2 ................ Sn... En where Si is the starting character of String i and Ei is the ending character of String i. Here, E1 must be equal to S2 and E2 must be equal to S3 and En-1 must be equal to Sn. But S1 and En donot have any relation with any other character. So consider that the Set of starting characters S = {S1, S2, ...., Sn} and the set of ending characters E = {E1, E2, ..... , En}. We need these sets to differ only by at most one element. This element will be the start of the first String and the end of the last string). But for every other value in Set S, other than the value that differs, there must be a corrsponding value in set E. A way to implement this is to have an array of integers with a cell for each character. First, for every character in set S, we increment its position in the array by one. Then for every character in Set E we decrement its place in the array by one. Afterwards if the array is all zeros (every charcater in the set S had a matching character in set E) or if the array consists of zeros except for one cell having value one and one cell having value negative one (in that case only one character differs between set S and set E) then all strings can be adhered together and there's a solution.	2014-12-10 11:51:18		
4530	ethan	48	Can I use bucket sort? Create 1 array each with 26 entries. All strings will first character a in the 0th entry, b in 1st entry and so on. It takes O(n) to create such an array. Now we traverse the array once, pop the just word we encounter in the array, read its last character, pop the first string with that character in corresponding entry of the array. Keep doing it until there are no more string in the array. This procedure also takes O(n) times. Total run time is O(n).	2014-12-10 11:51:19		
4531	sgiwy	48	We can also use a hash table:	2014-12-10 11:51:19		
4532	wbqzu	48		2014-12-10 11:51:19		
4533	ftfck	48		2014-12-10 11:51:19		
4534	bjsiw	48	in C++ code	2014-12-10 11:51:19		
4535	dkebi	48		2014-12-10 11:51:19		
4536	sgiwy	48		2014-12-10 11:51:19		
4537	rdfeo	48	The basic idea is keep two list, src and dest. - when you need to check whether to put current Scr in srcList, check if previous any one of destinations is same as that of curSrc then remove that from destList and don't put current scr into srcList. - Similarly for current dest.  At the end you should have only one source.	2014-12-10 11:51:19		
4538	xhgls	48		2014-12-10 11:51:19		
4539	sqzqo	48		2014-12-10 11:51:19		
4540	krxlv	48	In the perfect case the posed problem would be resolved with a graph and searching for Hamiltonian path, which is NP-complete, so I avoided graph and did a brute-force solution: build all combinations of strings recursively and return false if it fails to build the combination at any level, here's working code:	2014-12-10 11:51:19		
4541	rdfeo	48		2014-12-10 11:51:19		
4542	rdfeo	48		2014-12-10 11:51:19		
4543	rdfeo	48	Can we create an array of 26 length? Initialize all elements to null. Then iterate through each string, setting the array as follows: first look at string[0]. Compare to string[len(string)-1]. They can be equal or not equal. 1. If equal: set array[f(string[0])]=MAXINT but only if array[f(string[0])]==NULL, otherwise skip this string. f(X)=numeric place of X in the alphabet e.g.A=1,B=2, etc. 2. If not equal: a. If array[f(string[0])==NULL or MAXINT, set it to 1. b. Otherwise, increment it. c. Perform same test on array[f(string[len(string)-1])] but decrement instead of increment. When we are done we iterate through the 26-element array. -If we see any element with value >1 or <-1, return false. -Else if we count more than one element with 1 or -1, also return false. -Else return true. This should be O(N) complexity, no?	2014-12-10 11:51:19		
4544	dkebi	48	To solve this problem, you need to know SCC(strongly connected components) at first. Just build the directed graph as many guys said before, then combinate every circles(SCC) into a node one by one, then check whether the final graph is a single link. Time: O(N) Space: O(N)	2014-12-10 11:51:19		
4545	rrmeu	48	THis problem can be solved by using topological sorting. We need to build a directed graph, where each node corresponds to either 1st or last char of string.  Assume 1st char of a string is directed to last char of same string, And in the beginning graph does not have any nodes.  Traverse from 1st string. 1. Take 1st string. Build a graph where 1st and last char will represent two nodes, pointing from 1st to last char. 2. Take 2nd string. If 1st char of this string exists in a graph, then add last char of this string as a node in the graph. Else, build one more graph, the way we built in step 1. Here we have two disconnected graphs. 3. Take 3rd string. If 1st char of this string exists in graphs, then check if last char exists. If it exists, then connect these two nodes. Else, add last char of this string as a node in the graph, else build one more disconnected graph.  Say, we have, first string=sdfg second string=ydfgfx third string=dfgs fourth string=nertty fifth string=ghjhn  from 1st string = [s]-->[g] (1st graph) from 2nd string = [y]-->[x] (2nd graph) from 3rd string = [d]-->[s]-->g ( Since, 's' is already in 1st graph, connect 3rd string to 1st string) from 4th string = [n]-->[y]-->x ( Since, 'y' is already in 2nd graph, connect 4th string to 2nd string) from 5th string = d-->s-->[g]-->[n]-->y-->x (Since, 1st char 'g' is in 1st graph, and last char 'n' is in 2nd graph, so connect these two graphs)  Now, we can check if there is more than one connected graphs using DFS. A chain can be formed if there is only one graph. In above scenario, a chain can be formed.	2014-12-10 11:51:19		
4546	plapd	48	wtf. why -1 ? reply if u have any concern with my answer.	2014-12-10 11:51:19		
4547	fmzze	48	what if it has cycles? topological sort assumes you always find an element that has no incoming edges, and little modification of original example breaks the topological sort possibility ("S  Set of all nodes with no incoming edges" will not do anything):	2014-12-10 11:51:19		
4548	nhibd	48		2014-12-10 11:51:19		
4549	ufdxg	48		2014-12-10 11:51:19		
4550	jippy	48	Form a Bipartite graph having the starting characters of the strings in one group and ending characters in the other group. Create two hash maps one will contain starting characters and other will contain ending characters. while inserting a starting character or ending character of a string in the hashmap check whether the character is already in the other hashmap. If yes then connect an edge between the corresponding nodes in the Graph. In the graph each source node is connected to its corresponding end node. Now if the graph contains more than one node with in degree 0 then Its NOT POSSIBLE to form the chain. If the graph contains only one node with in degree 0 and if it has only one component then its possible to form a chain.	2014-12-10 11:51:19		
4551	plapd	48	1. Create directed graph from strings. dfgs -> sdfg -> ghjhk This graph could be complex with cycles. 2. Check if directed graph has Euler path/cycle.  2.1. A directed graph has an eulerian circuit if and only if it is connected and each vertex has the same in-degree as out-degree. 2.2. A directed graph has an eulerian path if and only if it is connected and each vertex except 2 have the same in-degree as out-degree, and one of those 2 vertices has out-degree with one greater than in-degree (this is the start vertex), and the other vertex has in-degree with one greater than out-degree (this is the end vertex).	2014-12-10 11:51:19		
4552	admin	48	Euler path is a trail in a graph which visits every edge exactly once. you want to visit each node! not edge! You probably mean Hamiltonian path	2014-12-10 11:51:19		
4553	nwkeg	48	public static boolean canChain(String[] strs) { HashMap<Character, Integer> map = new HashMap<Character, Integer>(); for (int i = 0; i < strs.length; i++) { if (strs[i].length() < 2 || strs[i].charAt(0) == strs[i].charAt(strs[i] .length() - 1)) continue; if (map.containsKey(strs[i].charAt(0))) { map.remove(strs[i].charAt(0)); } else { map.put(strs[i].charAt(0), i); } if (map.containsKey(strs[i].charAt(strs[i].length() - 1))) { map.remove(strs[i].charAt(strs[i].length() - 1)); } else { map.put(strs[i].charAt(strs[i].length() - 1), i); } }  if (map.size() == 0 || map.size() == 2) return true; return false; }	2014-12-10 11:51:19		
4554	plapd	48	In this program i am populating map and array of strings manually. And considering all N no of strings are unique.   public class Chain {   public static void main(String a[]) {  Map<String,String> map=new HashMap<String,String>(); map.put("a","abc"); map.put("d","def"); map.put("c","cod"); map.put("g","geb"); map.put("b","bea");  String[] arr=new String[5]; arr[0]="abc"; arr[1]="def"; arr[2]="cod"; arr[3]="geb"; arr[4]="bea";  int i=0; String temp; int count=0; while((arr.length)!=i) { StringBuilder sb=new StringBuilder(); temp=arr[i]; sb.append(temp); count=0; while(true) { if(map.get(temp.substring(temp.length()-1))!=null) { temp=map.get(temp.substring(temp.length()-1)); sb.append(temp); count++; } else { if(count!=(arr.length-1)) { break; } else { System.out.println("Chain Found: "+sb.toString()); break; } } }  if(count==(arr.length-1)) { break; } i++;  if((arr.length)==i) { System.out.println("Chain not Found"); } }  } }	2014-12-10 11:51:19		
4555	ftfck	48		2014-12-10 11:51:19		
4556	ethan	48		2014-12-10 11:51:19		
4557	admin	48	the way i understand the question is that you need to only compare the neighboring strings. so i will compare the last character in first string and first character in next string and so on will moving along the list and that will be O(n). if we are only interested in the answer to the question can a chain be formed then returning a boolean seems sufficient.	2014-12-10 11:51:19		
4558	bjsiw	48		2014-12-10 11:51:19		
4559	rrmeu	48		2014-12-10 11:51:19		
4560	vanul	48		2014-12-10 11:51:19		
4561	ftfck	48		2014-12-10 11:51:19		
4562	vanul	48		2014-12-10 11:51:19		
4563	jippy	49		2014-12-10 11:51:20		
4564	mrjku	49		2014-12-10 11:51:20		
4565	ewigy	49		2014-12-10 11:51:20		
4566	ewigy	49		2014-12-10 11:51:20		
4567	jippy	49	It is (n2)(logn) We can get n2	2014-12-10 11:51:20		
4568	rrmeu	49	Amazing ... how did you calculate it .. ? ...this algo required two for loops.. one to pre process hashMap and it will be done in O(str2.length) In second we required only O(str1.length)..  How is it ..(n2)(logn) or n2 .. ?	2014-12-10 11:51:20		
4569	vanul	49	The remove operation from LinkedList is O(n). As it's in the loop then the complexity is O(|string1| * |string2|). But as he suggests to use the doubly linked list we can keep in the hash table directly the nodes of it. So then the remove would be O(1) what gives linear complexity.	2014-12-10 11:51:20		
4570	nwkeg	49	Ok yes double LL helping Thannk	2014-12-10 11:51:20		
4571	gilit	49	Hi Ajeet, I am not sure if I have missed some concept in your algo. But I think the piece of code :	2014-12-10 11:51:21		
4572	gilit	49		2014-12-10 11:51:21		
4573	sgiwy	49		2014-12-10 11:51:21		
4574	mrjku	49	should also be placed outside the second for loop, just to ensure that we are not missing the case where map and LL is updated during the last iteration. For an example: S = "ADOBECODEBANC" T = "ABC"  The minimum window if I have understood correctly should be "BANC" (last four character in S), which will be obtained if we check ((window[1] - window[0]) > (orderedList.getLast().index - orderedList.getFirst().index)) one last time after the foor loop. Correct me if I am wrong. Thanks.	2014-12-10 11:51:21		
4575	bjsiw	49	Yup... thanks	2014-12-10 11:51:21		
4576	eucmc	49	Do a breadth wise traversal. Break stri1 into 2 parts removing the first and last character. Check for all the char of str2 in both the parts if all the chars present in both the parts. Then continue to divide them into respective parts. Else ignore the part which does not have all the characters. The part u obtain at the depest level will have the minimum window. For example: str1 : KAMALESH str2: ASH Break str1 into : KAMALES & AMALESH Now if use the first part doesn not have H char so ignore that part and break the second part further. into AMALES & MALESH. Continue this to the depeest level where all the char of str2 are present.	2014-12-10 11:51:21		
4577	nhibd	49	This is hard to explain in words. Let me explain with an example: str1= cPagQRjhfPQaRhgPanRbRc str2= PQR	2014-12-10 11:51:21		
4578	nhibd	49		2014-12-10 11:51:21		
4579	gilit	49		2014-12-10 11:51:21		
4580	ethan	49	Worst case time complexity is O(|str1|+|str2|).	2014-12-10 11:51:21		
4581	eucmc	49		2014-12-10 11:51:21		
4582	wbqzu	49		2014-12-10 11:51:21		
4583	admin	49	Hi, Please review your code. Suppose if str1=cPagQRjhfPQaRhgPanRbRc and str2=PQR. It returns PagQR instead of PQaR.	2014-12-10 11:51:21		
4584	nwkeg	49	#include<iostream> #include<algorithm> #include<unordered_map> #include<vector> #include<string> #include<list> using namespace std; int main() { string S, T; cin >> S >> T; unordered_map<char, int> map; for (size_t i = 0; i < T.length(); i++) map.insert(make_pair(T[i], -1)); //list<pair<char, int*>> List; int count = 0; int min=std::numeric_limits<int>::max(); int low, high; for (size_t i = 0; i < S.length(); i++) { if (map.find(S[i])!=map.end() && map[S[i]]==-1) { if (count==1) { low = i; } map[S[i]] = i; count++; if (count==T.length()) { high = i; min = high - low + 1; continue; } } if (count == T.length() && map.find(S[i])!=map.end()) { high = i; map[S[i]] = i; low = numeric_limits<int>::max(); for (auto i = map.begin(); i != map.end(); i++) { if (i->second<low) { low = i->second; } } int temp = high - low + 1; if (min > temp) min = temp; } } return 0; }	2014-12-10 11:51:21		
4585	ufdxg	49	tech-queries.blogspot.in/2010/12/finding-minimum-window-in-array-which.html	2014-12-10 11:51:21		
4586	cfzie	50	stackoverflow.com/questions/17562089/how-to-count-number-of-requests-in-last-second-minute-and-hour	2014-12-10 11:51:22		
4587	ewigy	50	(Poster here.)  Another point of clarification: "in the last X" is measured relative to the current nanosecond, i.e., it refers to the time interval [time() - X, time()]. This is a continuously updating and moving window of time.	2014-12-10 11:51:22		
4588	bjsiw	50	The queue implementation described in the link above will be able to cater to that.	2014-12-10 11:51:22		
4589	wbqzu	50	If the timer is at nano scale, then a queue will not be ideal solution: Assuming 32 bytes/ message, holding a day's worth of timestamp in a queue would require 3600 * 24 * 10^9 * 32 bytes which would be in peta bytes.	2014-12-10 11:51:22		
4590	sqzqo	50	Why do you have 10^9 as the multiplication factor? You are over thinking the problem ...	2014-12-10 11:51:22		
4591	qywrh	50		2014-12-10 11:51:22		
4592	xhgls	50		2014-12-10 11:51:22		
4593	huiqq	50	Read the question carefully. "timer time() with nanosecond precision". You are using precision at millisecond level. Also they havent mentioned that your "get" requests have to return values at second/minute boundaries. They could be rolling window. For Ex: If current time is 10 PM 48 min 56 sec 77777777 ns, then the getRequestsInLastSec request should return the num requests between 10 PM 47 min 77777777 ns to 10 PM 48 min 56 sec 77777777 ns.  You also made a wild assumption that you could cron a timer to purge the request queue. Such assumptions are invalid.	2014-12-10 11:51:22		
4594	dgjji	50	I am not sure if you read the code carefully, so let me put things in clear perspective for you:  1) The timer object is of type "java.util.Timer" and not the timer time() class which the author mentions in the question. So they are two separate entities. java.util.Timer is a class under the java.lang package. [See: docs.oracle.com/javase/1.5.0/docs/api/java/util/Timer.html].  2) My assumption of using the milli sec doesn't make any difference in the output required / expected. If there were say 1,000 ticks happening in 100 nano seconds then from my logic they would appear to happen in 0 millisec ( they actually happened in 0.000100 millisec). Since we are only concerned with the number of ticks (or number of times increment was called) so the code would still return 1000 ticks. which is the response expected here.  3) The problem also states that the space usage shouldn't grow depending on the number of call backs to increment(), since the API has methods defined only till the getCountInLastDay() so I am clearing any timers or calls which happened more than 24 hours ago will not only put a cap on the storage but also remove any data which is stored but never used or read anymore.  4) You still haven't explained why you have used 10^9 multiplication factor here. The question says "timer time()" has nano second precision so that "just" means if there were say 10,000 ticks happened in 100 nano seconds then you will be able to differentiate the difference in the timings of the individual ticks to the nano second level. It has nothing to do with the address space or how much memory will be consumed. (fyi : the default precision level is till microseconds so nano second isn't that far either :P )  5) Assuming you took some basic programming course :P at some level in your life, let me ask you on what basis do you have your "wild" assumption of using 32 "bytes" per message, what programming language uses that much memory to store information for primitive or non primitive variables. Please enlighten me. :) I may have still let you go if you had used "32 bits" NOT "32 bytes" to store information. With these two corrections I am sure your claim of using petabytes of memory will come down.	2014-12-10 11:51:22		
4595	azmjc	50	Dude.. First off control your arrogance. I am a MS from a top univ and currently Sr Soft Dev at Amazon in Seattle working on several big data/distributed systems. So I know my CS concepts well enough. From having interviewed several SDEs both on phone and in house, I can certainly say with confidence that your answer would most certainly be rejected.  1. I do know that you used java.util.Timer and not the timer mentioned by the question. I pointed out that no big tech companies will appreciate this kind of hacky way of clearing a queue at a specified time. These are not the way real systems are built.  2. The 10^9 comes from a fact that the timer gives ticks at nanosecond precision. So if you were to store each and every timestamp, you would need a queue of 10^9 * 3600 * 24.  3. In the minimum you need to store the request UUID, timestamp in the queue. If you have a clock at nanosecond precision and it gives you the number of nanoseconds passed since the epoch of 1st January 1970 (which is what most of timers do), calculate the number of bytes required to store such a number.	2014-12-10 11:51:22		
4596	bexbp	50	The above reply by Anonymous is mine.  In the above reply, hope you understood why the queue size has a factor of 10^9. It is because if you have a highly available service and at worst case a request happens every nanosecond, you will end up adding that to the ArrayList.  Let me tell you some things that interviewers look for when they ask such questions, based on my experience:  It is but obvious that the service is a distributed service (especially these questions are asked in Google/Amazon). In a real world system, a loadbalancer fans out requests to app servers/web server. A web request hits one machine in your fleet. How do we maintain a count of an entity (like webrequests) over several machines? How do we ensure consistency of data? What happens if a get Request is made (say by another consumer) along with many put requests (In your case "increment" method) i.e. do you have synchronization issues? What happens if a host fails before a count is incremented? There are many things that you need to consider/clarify when you are asked such question, before jumping into a solution and claiming to be alan turing.	2014-12-10 11:51:22		
4597	azmjc	51	I'll try to present a Segment Tree based approach, which takes O(n^2) time and space to pre-process, and answers each query in O(r * log(c)) time. r and c are the number of rows and columns in the query.  For each row A[i] in the matrix A, we build a segment tree, such that each node remembers GCD(A[i][a..b]) for some range [a,b). The root node remembers GCD(A[i][0..n]), its children remembers GCD(A[i][0..n/2]) and GCD(A[i][n/2..n]), and so on. The tree allows us to query GCD(A[i][a..b]) in O(log n) time for some row i and an arbitrary range [a,b). The memory complexity of each segment tree is O(n), which gives us O(n^2) total memory complexity.  To answer a query, we just query GCD(A[y1][x1..x2]), GCD(A[y1+1][x1..x2]), ... GCD(A[y2][x1..x2]) and take a GCD on all these numbers.  We can further improve the query time to O(logn * logn) by building one 2-d segment tree for the entire matrix, but I doubt whether it's feasible to implement a 2-d segment tree within the timespan of an interview.	2014-12-10 11:51:23		
4598	gilit	51	Check out the least voted answer on this page.	2014-12-10 11:51:23		
4599	zeice	51	I doubt if this is the correct answer	2014-12-10 11:51:23		
4600	rdfeo	51	1) compute GCD for every 2 adjacent point, then we need a matrix with size N*N/2 2) compute GCD for every 4 adjacent point, then we need a matrix with size N*N/4 .... the total space N^2(1/2+1/4+....) <= n^2 each step we can reuse the previous result. so the time complexity is also the same n^2   To compute GCD for every submatrix, first we divide the big matrix into the small submatrixs that we prepossessed. And then we compute the GCD of them.	2014-12-10 11:51:23		
4601	cfzie	51	This is probably the simplest correct algorithm based on GCD properties.  From Wikipedia: "The gcd of three numbers can be computed as gcd(a, b, c) = gcd(gcd(a, b), c), or in some different way by applying commutativity and associativity. This can be extended to any number of numbers."	2014-12-10 11:51:23		
4602	dkebi	51	Well, but isn't that still O(N^2)? It may be N/2 ^ 2 if you divide into grids of 2x2, but that's still O(N^2).  I'm thinking about running sums (here, products), somehow.  The query rectangle has to completely enclose any pre-computed GCD squares for it to use it - all I can think of is to make some constant number of levels, top-down rather than bottom-up, as bottom up makes it dependent on N - just pick a number - and make a quadtree of pre-computed GCD squares down to that level. Not the answer, I'm sure.  Nah, top-down doesn't make any difference, any regular grid of cells will be N^2 one way or another.	2014-12-10 11:51:23		
4603	mrjku	51	Lawrence, in your solution, let's say n = 10, which element remembers GCD for	2014-12-10 11:51:23		
4604	bjsiw	51		2014-12-10 11:51:23		
4605	dkebi	51		2014-12-10 11:51:23		
4606	tenuw	51	? To cover all the combinations within i, shouldn't we keep n * (n - 1) / 2 values per each row? Also, calculating multiple GCD values on runtime seems not easy...  Here is how I thought. My problem is it requires a little more than n^2, but not in n-polynomial way:  Prep: 1. Create an array of n^2, call it	2014-12-10 11:51:23		
4607	huiqq	51		2014-12-10 11:51:23		
4608	nhibd	51		2014-12-10 11:51:23		
4609	xhgls	51	.	2014-12-10 11:51:24		
4610	vanul	51		2014-12-10 11:51:24		
4611	fmzze	51		2014-12-10 11:51:24		
4612	dgjji	51	will have multiplied value of prime numbers for the original array	2014-12-10 11:51:24		
4613	plapd	51		2014-12-10 11:51:24		
4614	bjsiw	51		2014-12-10 11:51:24		
4615	ewigy	51	. For example, A's value 9 (3^2) will be stored as PrimesOnly value 3. 16 (2^4) will be 2. 24(2^3 * 3) will be 6 (2*3). 2. Create a dictionary<int, int[]>	2014-12-10 11:51:24		
4616	fowai	51		2014-12-10 11:51:24		
4617	sqzqo	51		2014-12-10 11:51:24		
4618	wbqzu	51	, to keep 2 => {2}, 3 => {3}, 6 => {2, 3}, etc. (Again, this is a small array but I am violating the rule here.)  Query: 1. For the given range values, get PrimesOnly values, and then get the list of PrimeList value arrays. 2. Get common prime set among those arrays found in step #1. If your A values were {24, 36}, PrimeOnly will be {6, 6} and common prime set will be {2, 3}. If your A values were {16, 24, 36}, common prime set should be {2} only. 3. For each elements in common prime set found in step #2, get the power number by dividing each A values in the range, starting from ^1, ^2, ^3, etc. If we get remainder on any of them, we have identified maximum value for the element. 4. Multiply all the elements and power numbers identified in step #3.	2014-12-10 11:51:24		
4619	tenuw	51	Check out the least voted answer on this page.	2014-12-10 11:51:24		
4620	ufdxg	52		2014-12-10 11:51:27		
4621	gilit	52		2014-12-10 11:51:27		
4622	xhgls	52	what is the need of count in isBST ?? Also, count argument is missing in return statement of isBST	2014-12-10 11:51:27		
4623	cfzie	52	I think you're on the right path, but there might a small thing you missed  In the LargestBST Method,	2014-12-10 11:51:27		
4624	qywrh	52		2014-12-10 11:51:27		
4625	xhgls	52		2014-12-10 11:51:27		
4626	wbqzu	52	you return node but, you never actually compare the result of these two recursive calls. It should be something like	2014-12-10 11:51:27		
4627	wbqzu	52		2014-12-10 11:51:27		
4628	qywrh	52		2014-12-10 11:51:27		
4629	sgiwy	52	A subtree is one that goes all the way till the leaves... a simple non-decreasing sequence for an inorder traversal need not necessarily point out the actual largest subtree.	2014-12-10 11:51:27		
4630	azmjc	52	using a recursive call: which get number of node, min, max for BST and return bool if this tree is a BST. Always rembmer the max number of node sub bst tree and root. Anyway, this is a good question.	2014-12-10 11:51:27		
4631	krxlv	52	I think your way will work.	2014-12-10 11:51:27		
4632	dgjji	52	yes this is d right way.....Starting from root (and then left and right subtrees) we have to check whether the subtree is a BST or not (with the help of min and max values for the corresponding subtree......min=left-extreme-value & max=right-extreme-value)  At the same time if a BST subtree is found,we have to store no of nodes in this subtree and its root pointer in an array/linkedlist ......finally if we get more than 1 BST subtree,return the root pointer with maxm no of nodes..... hope it helps.....a gud question indeeed!! :)	2014-12-10 11:51:27		
4633	nwkeg	52	Use BFS technique and make a function which validate the BST property and return the MAX no of nodes in that BST	2014-12-10 11:51:27		
4634	plapd	52	int LBST(node* n) { if( (n->left<n) && (n < n->right) && (LBST(n->left) != -1) && (LBST(n->right) != -1) ) return LBST(n->right) + LBST(n->left);  if(n->left==NULL && n->right ==NULL) return 1;  else return -1;  }       int maxNodes=0; node* maxNode;  node* returnMaxBST(node* n) {   int i=0;  if(n->left==NULL && n->right==NULL) { if(maxNodes==0) { maxNodes=1; maxNode=n; }  return n; }   if(LBST(n) > maxNodes ) { maxNodes=LBST(n); maxNode = m; }  returnMaxBST(n->left); returnMaxBST(n->right);   return maxNode;;  }	2014-12-10 11:51:27		
4635	mrjku	52	int LBST(node* n) { if( (n->left<n) && (n < n->right) && (LBST(n->left) != -1) && (LBST(n->right) != -1) ) return LBST(n->right) + LBST(n->left);  if(n->left==NULL && n->right ==NULL) return 1;  else return -1;  }     -----------------------------------------------------------------------------------------------------  int maxNodes=0; node* maxNode;   -----------------------------------------------------------------------------------------------------  node* returnMaxBST(node* n) {   int i=0;  if(n->left==NULL && n->right==NULL) { if(maxNodes==0) { maxNodes=1; maxNode=n; }  return n; }   if(LBST(n) > maxNodes ) { maxNodes=LBST(n); maxNode = m; }  returnMaxBST(n->left); returnMaxBST(n->right);   return maxNode;;  }	2014-12-10 11:51:27		
4636	fowai	52	int LBST(node* n) { if( (n->left<n) && (n < n->right) && (LBST(n->left) != -1) && (LBST(n->right) != -1) ) return LBST(n->right) + LBST(n->left);  if(n->left==NULL && n->right ==NULL) return 1;  else return -1;  }  -----------------------------------------------------------------------------------------------------  int maxNodes=0; node* maxNode;  -----------------------------------------------------------------------------------------------------  node* returnMaxBST(node* n) {  int i=0;  if(n->left==NULL && n->right==NULL) { if(maxNodes==0) { maxNodes=1; maxNode=n; }  }  if(LBST(n) > maxNodes ) { maxNodes=LBST(n); maxNode = m; }  maxNode= returnMaxBST(n->left); maxNode= returnMaxBST(n->right);  return maxNode;  }	2014-12-10 11:51:27		
4637	sgiwy	52	@giri none of the 3 solutions you posted is working. post a proper solution.	2014-12-10 11:51:27		
4638	ethan	52	I think the first answer itself gives a proper direction on solving this problem. People should read the responses before blindly providing crappy solutions.	2014-12-10 11:51:27		
4639	dkebi	52	Abe Dhakkan  If you think the first answer, as you said, "gives a proper direction on solving the problem," then you must have a solid understanding of the problem.  If that is true, then you should be able to provide an example data set plus the resulting data set from an algorithm.	2014-12-10 11:51:28		
4640	plapd	52	Loda le!	2014-12-10 11:51:28		
4641	rrmeu	52	Ok the first solution is partially right.change must be to find longest increasing sub string.Will longest increasing subseq work out???	2014-12-10 11:51:28		
4642	wbqzu	52	Ragavenderan  I think the first solution is complete nonsense, it is not logically coherent and it is vacuous, but that may be just me.  You also seem to have a pretty good understanding of the problem.  Maybe youre up to the challenge and you can provide an example data set plus the resulting data from an algorithm. If you understand this problem, that should be straight forward.	2014-12-10 11:51:28		
4643	vanul	52	Michael, I agree that the solutions might be bullshit.  That does not mean the question is wrong.  Assume we need to implement the following method:	2014-12-10 11:51:28		
4644	plapd	52		2014-12-10 11:51:28		
4645	mrjku	52		2014-12-10 11:51:28		
4646	mrjku	52	Can you think of a recursive method with this signature which will help you solve the problem?  Note a sub-tree is just a subset of connected nodes of the original tree.	2014-12-10 11:51:28		
4647	sgiwy	52	Err.. make that	2014-12-10 11:51:28		
4648	dkebi	52		2014-12-10 11:51:28		
4649	ftfck	52		2014-12-10 11:51:28		
4650	sqzqo	52		2014-12-10 11:51:28		
4651	eucmc	52		2014-12-10 11:51:28		
4652	ftfck	52	Don't know why, but you can't read half of my response so I'm reposting it.  LOLer,  I strenuously disagree. The question is just plain and simply wrong, because it is not logically coherent, it just doesnt make any sense. Its conceivable that it could be clarified, but no one has volunteered to do that.  Your comment, at best, just further confuses the issue. Further your comment isnt even complete.  This class that you reference, Tree, which you conveniently did not define, is the heart of the problem. What is it? What are its data members? What kind of member functions does it have?  What no one seems to recognize is that not all Binary Trees are BSTs, but all BSTs are Binary Trees. They are two distinct classes of objects.  Ill repeat the definition of a BST that I posted earlier.  A BST is a finite set of nodes that is either empty or consists of a root and two disjoint Binary Search Trees called the left subtree and the right subtree. With the following properties:  1. The left subtree of a node contains only nodes with keys less than or equal to the nodes key. 2. The right subtree of a node contains only nodes with keys greater than the nodes key. 3. Both the left and right subtrees must also be Binary Search Trees.  This definition is why the problem statement, given a binary tree, find the largest sub-tree which is a BST, is nonsensical.  Ill give you the same challenge that I have others. Please provide an example problem with the resulting BST that the algorithm would find. If the problem makes sense and you understand it, this should be trivial.  I patiently await you or anyone else who is up to this task.	2014-12-10 11:51:28		
4653	azmjc	52	Huh?  Consider the following tree:	2014-12-10 11:51:28		
4654	ufdxg	52		2014-12-10 11:51:28		
4655	rdfeo	52		2014-12-10 11:51:28		
4656	qywrh	52	Frankly, I think your objections are nonsensical...	2014-12-10 11:51:28		
4657	vanul	52	LOLer,  Excellent, but the tree youve presented is a BST! Yes it is a Binary Tree, which is a Binary Search Tree, but any subtree is also going to be a BST.  You dont have to test or further determine if any subtrees are BSTs, they are BSTs by definition.  Lets look at the original problem statement.  given a binary tree ,find the largest sub-tree which is a BST...(largest means subtree having largest no of nodes in it)  So if we are working with BSTs and the problem is to find the largest subtree where largest means the largest no of nodes in it. Then the answer is trivial! It is either the left subtree of the root or the right subtree of the root. The solution only requires you to count the number of nodes in the left and right subtrees and compare which is greater.  The following function will count the number of nodes in a BST.	2014-12-10 11:51:28		
4658	eucmc	52		2014-12-10 11:51:28		
4659	ethan	52		2014-12-10 11:51:28		
4660	gilit	52	In the example youve given, we have a tie, because the left subtree and the right subtree have the same number of nodes, 2.  From the problem statement your answer is incorrect, because it is not a subtree of the original tree.	2014-12-10 11:51:28		
4661	azmjc	52	Michael,  What are you talking about? Where did you get the statement "it must be either left sub-tree of right subtree" from? Perhaps that is where the confusion lies.  I interpret sub-tree as a sub-graph in the proper graph theoretical sense. Even if we mean sub-tree to include a node and all it's descendants (and other possible meaning), the question still makes sense. As any sub-tree of the left sub-tree (or right) is still a sub-tree...  The statement that a sub-tree is either the left one or the right is incorrect.   And, the tree i gave is not a BST, 7 isn't in the right place.  If we go by the second definition (including descendants of a node), the subtree	2014-12-10 11:51:28		
4662	fmzze	52		2014-12-10 11:51:28		
4663	fowai	52		2014-12-10 11:51:28		
4664	fmzze	52	would be the answer in the example I gave.	2014-12-10 11:51:28		
4665	qywrh	52	Too many typos in my response, sorry. But I hope you get what I was trying to say.	2014-12-10 11:51:28		
4666	jippy	52	Michael,  the question makes perfect sense.. LOLers example is not a BST. it is a BT.	2014-12-10 11:51:28		
4667	dgjji	52	LOLer,  Thanks for making the effort to explain your answer. Youre right, I missed that the 7 node was in the wrong place. This tree is a BST that has nodes that do not follow the properties of a BST and some nodes that do. I guess you could describe this as a BST that has errors?  At least with the example youve given, that makes some sense, like I said Im probably just a bit dense and I dont get it, fundamentally the question to me is just wacky. I've been looking at it with a black and white perspective, it either is a BST or it isnt and why would you ever have anything else? Doesnt really matter, because if the interviewer does think its valid then youre left with justifying why it isnt valid or doing your best to answer the question. The most reasonable thing to do is to give your best answer.  Still if the original poster had given an example like yours that would have made the intention of the problem clearer.  Regarding the issue of what a subtree means, (A subtree of a tree T is a tree comprised of a node in T and all of its descendants in T).  As you noted in your response, if you use that definition, the answer would then be:  2 \ \ 4  But, exactly which definition of a sub-tree you would use could be clarified by the interviewer. Thanks again for your posting; this is finally making some sense to me.	2014-12-10 11:51:28		
4668	krxlv	52	LOLer,  So I have a candidate solution that appears to work correctly and returns the 2,4 sub-tree from your example and appears to return the correct result with other sample data. I dont think this is the best solution, but I finally understand the problem and have a point to work from. Its been fun!	2014-12-10 11:51:28		
4669	nwkeg	52		2014-12-10 11:51:28		
4670	krxlv	52		2014-12-10 11:51:28		
4671	krxlv	52	@LOLer	2014-12-10 11:51:28		
4672	mrjku	52		2014-12-10 11:51:29		
4673	cfzie	52		2014-12-10 11:51:29		
4674	fowai	52	In the above example	2014-12-10 11:51:29		
4675	rdfeo	52		2014-12-10 11:51:29		
4676	zeice	52		2014-12-10 11:51:29		
4677	bexbp	52	is not a subtree, since subtree is said to be rooted at some node and everything till leaves are considered. If u say subtree rooted at 10, then that will include all the nodes as its the root of the tree. If we say subtree rooted 2 then that will be as below:	2014-12-10 11:51:29		
4678	wbqzu	52		2014-12-10 11:51:29		
4679	wbqzu	52		2014-12-10 11:51:29		
4680	eucmc	52	So this example is wrong. But if we take the correct definition of subtree, then we have to go at each node and check if the subtree is BST or not. Amazon asks non sense questions, sometimes they ask some dummy design questions which have no meaning. I attended the interview once then decided that never join such a junk company. I think this question explains why Amazon interviewers are such junk guys with low IQ and knowledge. Basically a company where no one (atleast in India) knows to code in C++ is bound to contain mediocre java programmers and the result is these junk questions.	2014-12-10 11:51:29		
4681	xhgls	52	Is this qsn asking for subgraph or subtree..  If subtree, then we can do a dynamic algorithm solution. We can write a recursive isBST function, which takes a node and returns true or false  Pseudo Code:  Init count to 0s  Null Case.  if(!node->left && !node->right) return true; isBST(node->left, 2*i) and isBST(node->right, 2*i+1) and node->left->data < node->data <= node->right count[i] = count[2*i] + count[2*i+1]	2014-12-10 11:51:29		
4682	rrmeu	52	Anonymous,  I think you may be on the right track, but since youve only shown a fragment of the code, Im not sure.  The term 2*i is the term you can use to find the left-child in a heap that is a complete binary tree and stored in an array where i is the array index. This makes me skeptical that you have a correct solution.  Maybe you can expand on your explanation?	2014-12-10 11:51:29		
4683	krxlv	52	I repeat the first approach does make sense. Have a look and make things clear to yourself @Michael Jackson. Your argument is completely vacuous/illogical. First get your basics right. You seem to be loosing the basic definition/meaning of basic tree data structures. Brush up your basics and then come back here. FYI: http://en.wikipedia.org/wiki/Binary_search_tree  HTH, Thank you. I'm a big FAN of LOLer !	2014-12-10 11:51:29		
4684	sqzqo	52	@Michael  The question is 100% correct,please do not argue pointlessly	2014-12-10 11:51:29		
4685	azmjc	52	Traverse the entire tree (using any traversal method) and pass each node (rather the binary subtree) to the following function isBST().	2014-12-10 11:51:29		
4686	rrmeu	52		2014-12-10 11:51:29		
4687	nhibd	52		2014-12-10 11:51:29		
4688	bjsiw	52	If the above function returns true, pass the same node to the following function count() to calculate the size (or the number of nodes) of this node (or the binary subtree).	2014-12-10 11:51:29		
4689	sqzqo	52		2014-12-10 11:51:29		
4690	dkebi	52		2014-12-10 11:51:29		
4691	xhgls	52	Now, store each node and its size in a data structure like a hashmap or an associative array. Then, the row in the hashmap with the highest size is the LARGEST SUBTREE WHICH IS A BST.  Complexity: ----------- Traversal - O(n) for the given binary tree Size calculation of each subtree - O(n) for each node(subtree). Hashmap size - worst case space is O(n) if every subtree is a BST. Scanning the hashmap for the highest size = O(1).  So, overall, this comes to O(n) complexity.	2014-12-10 11:51:29		
4692	gilit	52	Traverse the entire tree (using any traversal method) and pass each node (rather the binary subtree) to the following function isBST().	2014-12-10 11:51:29		
4693	mrjku	52		2014-12-10 11:51:29		
4694	mrjku	52		2014-12-10 11:51:29		
4695	rrmeu	52	If the above function returns true, pass the same node to the following function count() to calculate the size (or the number of nodes) of this node (or the binary subtree).	2014-12-10 11:51:29		
4696	dkebi	52		2014-12-10 11:51:29		
4697	vanul	52		2014-12-10 11:51:29		
4698	plapd	52	Now, store each node and its size in a data structure like a hashmap or an associative array. Then, the row in the hashmap with the highest size is the LARGEST SUBTREE WHICH IS A BST.  Complexity: ----------- Traversal - O(n) for the given binary tree Size calculation of each subtree - O(n) for each node(subtree). Hashmap size - worst case space is O(n) if every subtree is a BST. Scanning the hashmap for the highest size = O(1).  So, overall, this comes to O(n) complexity.	2014-12-10 11:51:29		
4699	ethan	52	i think this is a valid solution, basically a combination of two problems: verifyBST + tree size	2014-12-10 11:51:29		
4700	sgiwy	52	Sounds like it should work, but I think part of the challenge is how you can combine the BST verification and the counting into a single function so that you won't have to traverse a subtree twice.	2014-12-10 11:51:29		
4701	mrjku	52	here is what i think mostly will work. Not well tested but i am sure can be achieved with something like this -  take 2 buckets to store temp and max BST and 1 stack 1. start with current  if(start == null) return  push start to temp if(start->left != null) if start->left < start push to temp bucket go to step 1 with start = start->left else push start->left to stack  if(start->right != null) if start->right > start, push to temp bucket go to step 1 with start = start->right else push start->right to stack  compare temp with max and if required, update max assign start to stack.pop and start from beginning  //idea is to store captured BST from current node and compare it with Max if you find BST from current node and its broken somewhere down the road, you can't find bigger BST from one of its child EXCEPT that BST starts from or sub tree of broken node. so dont visit all child of start but only visit broken nodes so store them on stack.  -------15---- | | ------16------ 14 | | 8 32 -------- ----- | | | 5 4 30  so here 16 and 14 both goes to stack on first run. Max = 15 pop 16, and you will end up with temp = 16,8,5,32,30 and 4 going on stack. update max. pop 14. temp = 14. no need to update max. pop 4. temp = 4. no need to update max.  Comments/working code welcome :)	2014-12-10 11:51:29		
4702	dkebi	52	Example graph did not go through well.	2014-12-10 11:51:29		
4703	krxlv	52		2014-12-10 11:51:29		
4704	ewigy	52		2014-12-10 11:51:29		
4705	rrmeu	52	{ }	2014-12-10 11:51:29		
4706	nhibd	52	In-order traversal of binary tree, and then find largest non-decreasing sequence, start index of this sub-sequence is the root of BST.	2014-12-10 11:51:30		
4707	ftfck	52	Call below method recursively for each left & right subtree of original tree. Return as soon as isBST returns true with root at the iteration  /* Returns true if the given tree is a BST and its values are >= min and <= max. */ int isBSTUtil(struct node* node, int min, int max) { if (node==NULL) return(true);  // false if this node violates the min/max constraint if (node->data<min || node->data>max) return(false);  // otherwise check the subtrees recursively, // tightening the min or max constraint return isBSTUtil(node->left, min, node->data) && isBSTUtil(node->right, node->data+1, max) ); }	2014-12-10 11:51:30		
4708	bjsiw	52	I don't really see any size comparisons here. What if there's a BST somewhere below the left child and another BST somewhere below the right child. How will you determine which one is bigger?	2014-12-10 11:51:30		
4709	sqzqo	52	Please comment on my solution...  As the first solution did half the work.  Do in order traversal of the tree .(Store the result we need it again) Find the longest non-decreasing sequence . Now the starting element is the root. Now do inorder traversal on that tree if it again becomes non decreasing (i.e check isBST )then we arrived at the answer else go to next longest non-decresing substring and repeat the check for isBST?	2014-12-10 11:51:30		
4710	tenuw	52		2014-12-10 11:51:30		
4711	huiqq	52		2014-12-10 11:51:30		
4712	admin	52	We can do it by keeping track if every node in the tree is a valid BST root, and the number of children it has. We can do this by doing a Depth First Traversal in O(v) time and updating all of the counts and keeping track of a global max variable.  Assuming a nice node class,	2014-12-10 11:51:30		
4713	jippy	52		2014-12-10 11:51:30		
4714	krxlv	52		2014-12-10 11:51:30		
4715	eucmc	52	And a couple of global variables (can be done without them, but this makes it easy),	2014-12-10 11:51:30		
4716	ftfck	52		2014-12-10 11:51:30		
4717	azmjc	52		2014-12-10 11:51:30		
4718	huiqq	52	The code that actually figures out the answer,	2014-12-10 11:51:30		
4719	ufdxg	52		2014-12-10 11:51:30		
4720	eucmc	52		2014-12-10 11:51:30		
4721	ethan	52	@LOLer	2014-12-10 11:51:30		
4722	nhibd	52		2014-12-10 11:51:30		
4723	plapd	52		2014-12-10 11:51:30		
4724	cfzie	52	In the above example	2014-12-10 11:51:30		
4725	bjsiw	52		2014-12-10 11:51:30		
4726	ftfck	52		2014-12-10 11:51:30		
4727	sgiwy	52	is not a subtree, since subtree is said to be rooted at some node and everything till leaves are considered. If u say subtree rooted at 10, then that will include all the nodes as its the root of the tree. If we say subtree rooted 2 then that will be as below:	2014-12-10 11:51:30		
4728	gilit	52		2014-12-10 11:51:30		
4729	qywrh	52		2014-12-10 11:51:30		
4730	rdfeo	52	So this example is wrong. But if we take the correct definition of subtree, then we have to go at each node and check if the subtree is BST or not. Amazon asks non sense questions, sometimes they ask some dummy design questions which have no meaning. I attended the interview once then decided that never join such a junk company. I think this question explains why Amazon interviewers are such junk guys with low IQ and knowledge. Basically a company where no one (atleast in India) knows to code in C++ is bound to contain mediocre java programmers and the result is these junk questions.	2014-12-10 11:51:30		
4731	azmjc	52	Lets divide this to sub problems. 1. Given a binary tree find out if its a BST. -- isTreeBST() 2. Given a tree find total number of nodes -- getTotalObjects() 3. Finally find larget BST using recusrion - getLargestBST().  Code :	2014-12-10 11:51:30		
4732	nhibd	52		2014-12-10 11:51:30		
4733	nwkeg	52		2014-12-10 11:51:30		
4734	rrmeu	52	In-order traversal of binary tree, and then find largest non-decreasing sequence, start index of this sub-sequence is the root of BST.	2014-12-10 11:51:30		
4735	jippy	52	find start index of longest non-decreasing sequence obtained by in-order  use this index to find the root of BST in preorder traversal of tree	2014-12-10 11:51:30		
4736	bexbp	52	This question is nonsensical to me. Ill parse it out and explain what I find confusing.  "Given a binary tree"  Ok got that. My understanding is a binary tree is a finite set of nodes that is either empty or consists of a root and two disjoint binary trees called the left subtree and the right subtree.  "Find the largest subtree which is a BST...(largest means subtree having largest no of nodes in it)"  By definition any subtree is going to be a binary tree, so WTF does this questioner mean by a subtree which is a BST?  Lets look at a definition for a Binary Search Tree (BST). A BST is a finite set of nodes that is either empty or consists of a root and two disjoint Binary Search Trees called the left subtree and the right subtree. With the following properties:  (1. The left subtree of a node contains only nodes with keys less than or equal to the nodes key.) (2. The right subtree of a node contains only nodes with keys greater than the nodes key.) (3. Both the left and right subtrees must also be Binary Search Trees.)  So the root cause of my confusion with this question is the discordance between starting apparently with a Binary Tree and then referring to its subtrees as Binary Search Trees. Its either a Binary Search Tree or a Binary Tree. It doesnt make any sense that it is both, or this is a data structure that Im not familiar with. If that is the case the questioner should have explained in detail what they meant.  Some of the proposed answers are the following:  Use BFS technique and make a function which validate the BST property and return the MAX no of nodes in that BST  using a recursive call: which get number of node, min, max for BST and return bool if this tree is a BST. Always rembmer the max number of node sub bst tree and root. Anyway, this is a good question.  WTF does it mean to validate the BST property or return bool if this tree is a BST, thats inherent in the very definition of the data structure itself. Again, it either has it or it doesnt. Its not something you have to validate.  So apparently Im not the only one confused by this question.  I dont believe any of the proposed answers make any sense, and I dont think any of the responders understand the simple definition of a Binary Search Tree, or the distinction between a Binary Tree and Binary Search Tree. I dont know it all and I could be wrong, so if some enlightened soul feels they have parsed this question correctly, please speak up.	2014-12-10 11:51:30		
4737	vanul	52	It is a perfect valid question.  Binary tree: a tree where each node at at most 2 children.  Binary search tree: A Binary tree with keys attached to nodes, satisfying the property you state.  So given a binary tree with keys attached to node, find the largest subtree, whose keys from a binary search tree.	2014-12-10 11:51:30		
4738	tenuw	52	Abe Dhakkan,  After reading your response and thinking about this question some more I must say that what I find even more confusing than the question itself is the confusing answers that are given which for the better majority make no freaking sense at all.  So if you understand the question and it is perfectly valid to you, then what would be most useful is if you provided an algorithm or code that resolves the question.	2014-12-10 11:51:30		
4739	dgjji	52	The question is perfectly valid.. He is not asking if the entire is a BST or not. Hes asking if any subtree is.  Every BST is a binary tree, but every Binary tree isnt a BST.   Think of it recursively..  Each node has a tree rooted at its left child and right child.  The question asks if such a tree is a binary search tree..	2014-12-10 11:51:30		
4740	tenuw	52	use dynamic programming...	2014-12-10 11:51:31		
4741	plapd	53	Could you clarify the question a bit more? Do the number of black pixels and white pixels have to be equal? Also, are subsquared filled with one color only?	2014-12-10 11:51:32		
4742	bexbp	53	I am thinking; consider we have the nxn in an array a[][], assume a[i][j].color gives us the color. 1. Max spiral size ms = 0; 1. For each element starting from a[0,0], until last; 2. Assume a funtiona Spiral which does the followig: The moment we hit a white color cell we will try to go as far(distance d) to the right and go down d and go up distance d in a spiral fashion. We continue until the spiral hits the smallest possible spiral updating localms, in the process if we hit a black cell we set localms =0 and quit,else return localms. 3. If localms > ms then ms = localms 3. If Go to step 1 with the next element. 4. return ms  If the actual sub square is required in terms of the array indices (left top/right bottom pair), we need to store that too in function spiral.	2014-12-10 11:51:32		
4743	gilit	53	I guess the spiral has an issue.. The above method will help u in finding squares within squares... But what about a sub-square on left/right corner?  ______________ | | | | | | |____| | | | | | |_____________|  ______________ | | | _______ | | | | | | | | | | |______| | ====> Your Spiral model will generate this. |_____________|	2014-12-10 11:51:32		
4744	wbqzu	53	use dynamic programming. keep two values right and down that tells how many consecutive black pixles are in that direction including the current pixel. Compute this using bottom up approach. Then, use these values to compute the maximum square length at each pixel. Should run in O(n*n) time and memory. What do u guys think?	2014-12-10 11:51:32		
4745	admin	53	Good idea, Raghu ! I guess you need left and up values as well, It would be when your algo is crunching in the middle of the matrix. but ya .. it would work in O(n^2) space and time ... but thats acceptable .. n^2 time is definitely needed to read every pixel... its linear in terms of the number of cells.	2014-12-10 11:51:32		
4746	rdfeo	53	The idea of using Dynamic programming is good but I think it is still O(n^3) time complexity, because you have to check if the right line exists, if not decrease the size.... so it gets O(n) for each top left corner	2014-12-10 11:51:32		
4747	fowai	53	Assume the matrix to be a binary tree, where each cell is a node connected to 2 other nodes (down & right). Do a DFS based on this tree structure and determine borders. 1. keep a count of consecutive black pixels along one direction(if its less than the max found so far, then forget it).. else its a potential candidate, so explore other borders 2. still dont know how to avoid redundancy in checking .. 3. one spl case would be that if you find a square of side n/2 .. u can stop ..! :D .. pretty obvious !  ... i know its kinda vague .. but seems like the right direction.	2014-12-10 11:51:32		
4748	huiqq	53	using a devide and counter method could yield between O(n*lgn) and O(n^2); FindMaxSquare(matrix,1,n){ sqr1=FindMaxSquare(matrix,1,n/2); sqr2=FindMaxSquare(matrix,n/2+1,n); borderLength=max(sqr1.borderLength,sqr2.borderLength); sqr3=FindMaxSqaureAlongAxis(n/2,borderLength+1); if(sqr3!=null)return sqr3; else return max(sqr1,sqr2); } master theorem T(n)=2T(n/2)+f(n); here f(n) is the complexity of FindMaxSqaureAlongAxis, so if we could prove that complexity of FindMaxSqaureAlongAxis is between O(n) and O(n^2), then the total time we need is between O(n*lgn) and O(n^2). Complexity of FindMaxSqaureAlongAxis is O(borderLength*n), since borderLength could be a constant, or could be proportional to n, so O(n)=<O(borderLength*n)=<O(n^2). done	2014-12-10 11:51:32		
4749	zeice	53	I think we will use dynamic programming here.I agree with raghu.  let the size of square be N. pseudocode:  for each cell { calculate the black cell along its right.Let it ne Nr. Calculate the white cells along downside. Let it be Nd length = Min(Nr,Nd) for i =1 to length { check the subcell i*i has blackborder if yes. max=cell id and i } } return Max  It will have complexity of order N^N.	2014-12-10 11:51:32		
4750	ftfck	53	why is this O{n^2}?  for each cell // n { calculate the black cell along its right.Let it ne Nr. //n Calculate the white cells along downside. Let it be Nd //n length = Min(Nr,Nd) // 1 for i =1 to length //n { check the subcell i*i has blackborder //n^2 if yes. max=cell id and i } } return Max  It should be O(n*(n+n+1+n*n^2)) = O(n^4)???	2014-12-10 11:51:32		
4751	sgiwy	53	also check max..at every loop  if i < max do not store else max = new max	2014-12-10 11:51:32		
4752	rrmeu	53	Apply dynamic programming to compute Max length for row & columns 1) Initialize maxRowLen[ k ] [ n-1 ] = (arr[ k ][ n -1 ] == 0 ?1:0) maxColLen[ n-1 ] [ k ] = (arr[ n-1 ][ k ] == 0 ?1:0)  For each element in arr[k][j] (k = n-2 to 0) (j = n-2 to 0)  2) if arr[ k ] [ j ] == 1 maxRowLen[ k ] [ j ] = 0 3) else // i.e arr[ k ] [ j ] == 0 maxRowLen[ k ][ j ] = maxRowLen[k][j+1] + 1  Compute Max length for Column 4) if arr[ k ] [ j ] == 1 maxLen[ k ][ j ] = 0 5) else // i.e arr[j] == 0 maxColLen[ k ][ j ] = maxColLen[k+1][j] + 1  6) maxSqLen = 0  Now iterate either of max length row or max length col & for each (either of) maxRowLen or maxColLen --- Lets take maxRowLen 7) lenOfSquare = Minimum( maxRowLen[k][j], maxColLen[k][j] ) 8) if lenOfSquare > maxSqLen 9) Now, check if a square is formed if( maxColLen[ k ][ j+ lenOfSquare ] == lenOfSquare && maxRowLen[ k + lenOfSquare ][ j ] == lenOfSquare ) { maxSqRowStart = k; maxSqColStart = j; maxSqLen = lenOfSquare ; }  Space - 2 dimension array for maxRolLen & maxColLen i.e O(2 * N square ) Time - O( 2 * N square ) 1) Compute maxRowLen & maxColLen for each element of arr[n * n] + 2) Compute if square with max len is formed for each element (either of) maxRowElem or maxColLen	2014-12-10 11:51:32		
4753	admin	53	For subsquare, N^2 is enough. What if it is not subsquare?	2014-12-10 11:51:32		
4754	mrjku	53	The output should be a subsquare surrounded by all black pixels. This can be done by keeping a list of all white squares and running BFS from each white square. The white squares can not be from first row or column and last row or column. When running BFS pick up any one node and travel level by level eliminating branches that cannot satisfy the constraints. Also eliminate these nodes from the list of white squares. If you are able to find an enclosed boundary then just check if the enclosed boundary has k*k dimensions.This can be done by keeping track how much we have moved in y direction and x direction.	2014-12-10 11:51:32		
4755	nwkeg	53	at least n^3	2014-12-10 11:51:32		
4756	vanul	53	Using Dynamic programming, can it be done like... for each cell n = calculate size of square it's forming using black border SquareSize = (n-2); if(maxSquareSize < SquareSize) maxSquareSize = SquareSize;  print "maxSquareSize"	2014-12-10 11:51:32		
4757	nhibd	53	Using Dynamic programming, can it be done like... for each cell n = calculate size of square it's forming using black border (for this need to check all 4 sides of square so that they have equal nos. of black pixels) O->->->->-> | | | | here n = 5; | | squareSize = 3 | | | | ->->->->->  SquareSize = (n-2); if(maxSquareSize < SquareSize) maxSquareSize = SquareSize;  print "maxSquareSize"	2014-12-10 11:51:32		
4758	ethan	53	formatting has ruined the square I am trying to display. Consider right vertical edge such that width = height = 5	2014-12-10 11:51:32		
4759	dkebi	53	_ _ _ _ | /\ | | / \ | | / \ | |/ \| |\ /| | \ / | | \ / | |_ _\/_ _|	2014-12-10 11:51:32		
4760	azmjc	53	_ _ _ _ | /\ | | / \ | | / \ | |/ \| |\ /| | \ / | | \ / | | \/ | - - - -	2014-12-10 11:51:32		
4761	mrjku	53	The easiest and O(n~n*n)way is: Look for pure white subsqures instead of black frames. ------------------------------ Initialization:MaxLength=0; ------------------------------ step 1: for every cell, if cell=white go to step 2 ------------------------------ step 2: take the current cell as the leftup corner of the subsqure, and length=1+MaxLength, is the subsqure pure white? If yes, go to step 3, else go to step 1; ------------------------------ step 3: is the squre surrounded by black frame? If yes,MaxLength++, and go back to step2; If no, go back to step 1.	2014-12-10 11:51:32		
4762	nwkeg	53	so the size of possible white subsqures should be 0, 4=2*2, 9=3*3, 16=4*4.	2014-12-10 11:51:32		
4763	sqzqo	53	I can think of 2 methods. One is a simple to implement brutish method, while the other is more efficient but harder to implement.  Method 1: Simply test for sub-squares starting with S (length of side) = N, and continue till S = 2 i.e. S = N -> 2. For each S test each pixel in the matrix as the top corner of S. This is O(n^3), but it is simple to understand and gauranteed to work for complex configurations.  Method 2: As some have already mentioned, one can go through the matrix keeping a list of horizontal black lines (only need to store to coords - the start and end of the line). Then do similar to get a list of verticle lines. Note that one has to keep every single line and not just the max length lines because there are various combinations of lines that can form a square - Note: horizontal lines and verticle lines may intersect each other to form a square that is smaller then the length of each individual line. So from here I am not sure how to easily look at intersection points to identify the larger square.  I like my method 1 because it is simple and given be visually animated to show that it is scanning correctly.	2014-12-10 11:51:32		
4764	rrmeu	53	there is an O(n^2) algo with O(n^2) space.	2014-12-10 11:51:32		
4765	xhgls	53	The answer is here: http://discuss.joelonsoftware.com/default.asp?interview.11.445656.19	2014-12-10 11:51:32		
4766	fowai	53	white = 0 black = 1  1. construct a row and a col matrix to record the # of consecutive "1" from current node to left, and up, respectively.  e.g.:  Original (A): 11111 11101 10111 01011  row: 12345 12301 10123 01012  col: 11111 22202 30313 01024	2014-12-10 11:51:33		
4767	tenuw	53		2014-12-10 11:51:33		
4768	sgiwy	53		2014-12-10 11:51:33		
4769	ethan	53	still O(n^3) though	2014-12-10 11:51:33		
4770	qywrh	53	<a href="http://khmyzszs.com">yuuyu</a> http://khmyzszs.com [url=http://khmyzszs.com]yuuyu[/url]	2014-12-10 11:51:33		
4771	gilit	53	<a href="http://khmnhrzs.com">hgryu</a> http://khmnhrzs.com [url=http://khmnhrzs.com]hgryu[/url]	2014-12-10 11:51:33		
4772	eucmc	53	<a href="http://khmnhrzs.com">hgryu</a> http://khmnhrzs.com [url=http://khmnhrzs.com]hgryu[/url]	2014-12-10 11:51:33		
4773	ethan	53	<a href="http://khmnhrzs.com">hgryu</a> http://khmnhrzs.com [url=http://khmnhrzs.com]hgryu[/url]	2014-12-10 11:51:33		
4774	qywrh	53	doors.txt;5	2014-12-10 11:51:33		
4775	ufdxg	53	doors.txt;5	2014-12-10 11:51:33		
4776	zeice	53	doors.txt;5	2014-12-10 11:51:33		
4777	tenuw	53	doors.txt;5	2014-12-10 11:51:33		
4778	mrjku	53	doors.txt;10	2014-12-10 11:51:33		
4779	ewigy	53	Read Matrix and store all black in sorted order in an array. After that it is just finding consecutive blacks..... e.g. a 3*3 matrix like this  www bbw bbw  can be stored as 10,11,20,21 Now foreach element 1. count consecutive number e.g. for 10 it is {10,11} = 2( lets call it len) 2.now we know that for this entry we can at max a square of length 2(len). 3.now go downwards. for first and last number in above set and keep going for len-1 entries. so try to find 20(y) in above array and then 21(k). As it is sorted array, binary search will do 4. if above test is successful, travel from y -> k with y++ in each step and try to find it(y). if we have success we located a square of length len for first entry. 5. Now feel free to skip len-1 entries and proceed  Time complexity should be less than n^3. in worst case(all blacks) should be around nLog(n)	2014-12-10 11:51:33		
4780	jippy	53	public static int findLargestSquare(int[][]test) { int largest = 0; printMatrix(test); for (int y = test[0].length-1; y>=0; y--) { for (int x = test.length-1; x >=0; x--) { if (x != test.length-1 && y != test[0].length -1 && test[x][y] !=0) { int bottom = test[x][y+1]; int right = test[x+1][y]; int bottomRight = test[x+1][y+1]; test[x][y] = Math.min(bottom, Math.min(right, bottomRight))+1; }  } } for (int i = test.length - 1; i >=0; i--) { for (int j = test[0].length-1; j >=0; j--) { if (test[i][j] > largest) { largest = test[i][j]; } } } return largest; }	2014-12-10 11:51:33		
4781	mrjku	53	O(n^2) solution is available for the problem in "cracking the code interview" book. chapter : 20 (problem 20.11)	2014-12-10 11:51:33		
4782	eucmc	53	That solution is not actually O(n^2). If you analyze it a little bit more it is O(n^4) worst case. there are 3 loops in which there is a call to a method which also has a loop. All of these depend on n.	2014-12-10 11:51:33		
4783	admin	53	(n-1) x (n-1) will be the sub square	2014-12-10 11:51:33		
4784	fowai	53		2014-12-10 11:51:33		
4785	qywrh	53	Worked for me. could solve the problem in O(1) time.	2014-12-10 11:51:33		
4786	gilit	53	yea awesome solution man...	2014-12-10 11:51:33		
4787	plapd	54	Just do a loop from 0 to 2^n-1 with the following.  unsigned int binaryToGray(unsigned int num) { return (num >> 1) ^ num; }	2014-12-10 11:51:35		
4788	admin	54	Really most wonderful one, i guess i need to refresh my math memory now, :(. Just spend some time proving its correctness: (x>>1)^x=(y>>1)^y <==> (x==y) (x>>1)^x and ((x+1)>>1)^(x+1) only has one bit change. binary representation of x and y could easily give out the result.	2014-12-10 11:51:35		
4789	qywrh	54	nice!	2014-12-10 11:51:35		
4790	zeice	54	I love this one. It does in one line of code what my recursive algorithm does in 9.	2014-12-10 11:51:35		
4791	huiqq	54	I think you need one more step. Compute a list of gray-code values and then turn those into numbers (not their equivalent), because the problem asks for the bits of the actual numbers to be at a distance of 1, not their gray-code equivalents (i.e. 00001 and 00010, differ in 2 bits and not by 1 bit, as the problem asks, although their graycode equivalent differs in only 1 bit). So I believe one more step is required, once the gray-codes are generates is to transform them into numbers	2014-12-10 11:51:35		
4792	fowai	54	Gray code.	2014-12-10 11:51:35		
4793	eucmc	54	program to print numbers in gray code:	2014-12-10 11:51:35		
4794	qywrh	54		2014-12-10 11:51:35		
4795	admin	54		2014-12-10 11:51:35		
4796	xhgls	54	Here is a code which can achieve this (I think); some optimizations and cleaning are possible.	2014-12-10 11:51:35		
4797	ufdxg	54		2014-12-10 11:51:35		
4798	mrjku	54		2014-12-10 11:51:35		
4799	mrjku	54	some typos in there; haven't tried running it.	2014-12-10 11:51:36		
4800	sqzqo	54	How about this.	2014-12-10 11:51:36		
4801	ufdxg	54		2014-12-10 11:51:36		
4802	krxlv	54		2014-12-10 11:51:36		
4803	krxlv	54	}	2014-12-10 11:51:36		
4804	bjsiw	54	Here is an iterative version, (also added recursive version just for comparison) So, that is as optimal as it gets! in space and time	2014-12-10 11:51:36		
4805	admin	54		2014-12-10 11:51:36		
4806	bjsiw	54		2014-12-10 11:51:36		
4807	rdfeo	54	code did not format correct: please refer here pastebin.com/jFwEgqX8	2014-12-10 11:51:36		
4808	huiqq	54		2014-12-10 11:51:36		
4809	ftfck	54		2014-12-10 11:51:36		
4810	bjsiw	54	I could have just looked up standard algorithm for Gray codes, but that would have ruined the challenge.	2014-12-10 11:51:36		
4811	dkebi	54		2014-12-10 11:51:36		
4812	dgjji	54		2014-12-10 11:51:36		
4813	nhibd	54	My code:	2014-12-10 11:51:36		
4814	jippy	54		2014-12-10 11:51:36		
4815	sgiwy	54		2014-12-10 11:51:37		
4816	azmjc	54	Test result for n=4: 0 0 0 0 0 0 0 1 0 0 1 1 0 0 1 0 0 1 1 0 0 1 1 1 0 1 0 1 0 1 0 0 1 1 0 0 1 1 0 1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 1 1 0 0 1 1 0 0 0	2014-12-10 11:51:37		
4817	nhibd	54	Recursive solution in python	2014-12-10 11:51:37		
4818	sgiwy	54		2014-12-10 11:51:37		
4819	zeice	54		2014-12-10 11:51:37		
4820	sgiwy	54	vector<int> grayCode(int n) { vector<int> seq; seq.push_back(0); if (n == 0) return seq; seq.push_back(1);  for (int i = 1; i < n; i++) { int size = seq.size(); for (int k = size-1; k >= 0; k--) { seq.push_back(seq[k] | (1 << i)); } }  return seq; }	2014-12-10 11:51:37		
4821	rdfeo	54	Something very interesting i came across:  wisc-online.com/ Objects/ ViewObject.aspx? ID=IAU8307	2014-12-10 11:51:37		
4822	dkebi	54	interesting read;  introcs.cs.princeton.edu / java/ 23recursion/ GrayCode.java.html	2014-12-10 11:51:37		
4823	azmjc	54	Here is the C# implementation of Gray Code	2014-12-10 11:51:37		
4824	xhgls	54		2014-12-10 11:51:37		
4825	azmjc	54		2014-12-10 11:51:37		
4826	dgjji	54		2014-12-10 11:51:37		
4827	nhibd	54		2014-12-10 11:51:37		
4828	mrjku	54		2014-12-10 11:51:37		
4829	huiqq	54		2014-12-10 11:51:37		
4830	huiqq	54	public class GrayCode {  static char charArray[] = {'0','0','0','0'};  public static void main(String[] args) { grayCode(4); }  static void grayCode(int i){ if (i == 1){ System.out.println(charArray); charArray[0] = (charArray[0] == '0'?'1':'0'); System.out.println(charArray); return; } grayCode(i-1); charArray[i-1] = (charArray[i-1] == '0'?'1':'0'); grayCode(i-1); } }	2014-12-10 11:51:37		
4831	sgiwy	54		2014-12-10 11:51:37		
4832	gilit	54		2014-12-10 11:51:37		
4833	ewigy	54		2014-12-10 11:51:37		
4834	rdfeo	54		2014-12-10 11:51:37		
4835	eucmc	54	it should read:	2014-12-10 11:51:37		
4836	rdfeo	54		2014-12-10 11:51:37		
4837	fmzze	54		2014-12-10 11:51:37		
4838	dgjji	54		2014-12-10 11:51:38		
4839	zeice	54		2014-12-10 11:51:38		
4840	jippy	54	It seems like something related to minimunm hamming distance	2014-12-10 11:51:38		
4841	sgiwy	55	That depends on what 'N' is. If it is the number '15', then the solution is easily found and it will be in log(N). If N is the number of digits, it is not possible to do it. Clearly you need to read the digits first to do anything.	2014-12-10 11:51:40		
4842	gilit	55	It's actually possible to get O(log(n)), assuming we're in a model where you're allowed to do bit operations and arithmetic in O(1). For arbitrary N those are not reasonable assumptions, but they're reasonable for N sufficiently small to fit into a register. Think of it this way: we consider y = ~x to be O(1), even though that operation touches every bit of x. I'm working on posting a solution.	2014-12-10 11:51:40		
4843	bexbp	55	If N is the number itself, then the number of bits is roughly equal to log(N). Since the obvious algorithm requires inspecting each bit, one could argue it's O(log(N)) where N is the decimal number itself.	2014-12-10 11:51:40		
4844	admin	55	@Epic_coder: I'm claiming O(log N) is possible where N is the number of bits, assuming we can do arithmetic on the number as a whole in O(1) (the whole number fits into a register). This would be O(log (log K)) if K is the number itself.	2014-12-10 11:51:40		
4845	vanul	55	http://www.quora.com/Algorithms/How-can-we-find-the-longest-continuous-subsequence-of-0s-in-binary-representation-of-an-integer-in-O-log-n-time-complexity/answer/Michal-Fori%C5%A1ek	2014-12-10 11:51:40		
4846	admin	55	Yes this could be done in O(log n)...you can use right shift operator which is basically dividing the number by 2 which leads to log n solution..here is a sample code	2014-12-10 11:51:40		
4847	cfzie	55		2014-12-10 11:51:40		
4848	dgjji	55		2014-12-10 11:51:40		
4849	huiqq	55	Before sending the number to this method, we need to convert an int to binary representation. I tried using Integer.toBinaryString(133) which actually returns a string on which I couldn't use the function. How to code this extension. btw i edited your code to java and it doesn't seems to give correct input. Could you help me.	2014-12-10 11:51:40		
4850	rrmeu	55	Using right shift operator would still be O(n). It has to go through each individual bit for n number of bits (which is the input).	2014-12-10 11:51:40		
4851	qywrh	55	This is not what the OP asks for. The input is a binary string already, and the n measure in the Log(n) requirement is the number of bits, not the decimal number representation.	2014-12-10 11:51:40		
4852	fmzze	55	@julius How do you know? Another ambiguous question. 1 min. to type by OP, then hours wasted by everyone else. Inefficient.	2014-12-10 11:51:40		
4853	ufdxg	55	a faster method to count number of 1s and 0s void countint0(unsigned int p) { int c0 = 0; int c1 = 0; if (p == 0) { c0 = 1; } while(p > 0) { if (p & 1 == 1) { if (p == 0xffff) { c0 = 0; c1 = 32; break; } else { int q = p+1; int cc1 = ((p ^ q) + 1) /4; cc1 = 1+ log(cc1) / log(2); c1 += cc1; p = p >> cc1; } } else { int q = p-1; int cc0 = ((p ^ q) + 1) /4; cc0 = 1 + log(cc0)/ log(2); c0 += cc0; p = p >> cc0; } } }	2014-12-10 11:51:40		
4854	tenuw	55	It is possible. The question is reduced to how you can represent a number as addition of numbers which are power of 2  N = 133 = 128 + 5 = 128 + 4 +1 Now, for each such number above, you know how many bits you need to represent that number and max diff of bits between two consecutive numbers is your answer. So for N = 128 + 4 +1 , you need bits 8(for 128), 3(for 4) and 1(for 1), so the answer is Max[ (7-3) and (2-1) ] = 4. Why 7 and 2? Because with 8 bits to represent 128, MSB is set already so max you can have 7 bits 0 and same with 4 where you have MSB set so max 2 remaining bits.	2014-12-10 11:51:40		
4855	bjsiw	55		2014-12-10 11:51:40		
4856	tenuw	55		2014-12-10 11:51:40		
4857	tenuw	55	As an example N = 133 ==> 10000101 NumBits = 7 (= CEILING(log 133)) NextN = 133 - 128 ( = pow(2,7) ) now NextN becomes 5 NumZero = NumBits - CEILING(long NextN)) = 7 - 3 = 4 Check if NumZero is max so far, Make N = NextN and repeat loop then return max	2014-12-10 11:51:40		
4858	nwkeg	55	Correction:	2014-12-10 11:51:40		
4859	cfzie	55		2014-12-10 11:51:40		
4860	rrmeu	55		2014-12-10 11:51:40		
4861	vanul	55	If N is equal to a ((power of 2) - 1), I think the complexity will still be O(n).	2014-12-10 11:51:40		
4862	ftfck	55		2014-12-10 11:51:40		
4863	mrjku	55	>>If N is equal to a ((power of 2) - 1), I think the complexity will still be O(n). You are correct anonyco. Worst case complexity will be O(N) and I don't think you can do better than that.	2014-12-10 11:51:40		
4864	ufdxg	55	This is O(n) worst case, imagine you'd have 11111110 instead of 10000101, means you'll have 8 iterations == O(n)	2014-12-10 11:51:40		
4865	zeice	55	Running time for this is O(NumberOfSetBits), which you can argue is just O(N) but this code is slick. And if you could think of this solution on the spot, then I think your interview will be delighted :)	2014-12-10 11:51:41		
4866	jippy	56	ideone.com/tJRIsZ	2014-12-10 11:51:45		
4867	qywrh	56	This one is reporting correct results ! Can you elaborate more on the logic used ? it's not easy to trace what you're doing.	2014-12-10 11:51:45		
4868	sqzqo	56	During preprocessing, i am calculating two matrices, lets say 'a' and 'b'. In array 'a', a[i][j] stores number of valid combinations of length i+1 starting from (j+1)th character. e.g. first row in Matrix 'a' will contain all 1s as there is only valid combination of length 1 starting from a,b,c...z. For calculating a[1][0], we need all valid combinations of lenth 2 starting from from character 'a' and it is equivalent to valid combinations of length 1 starting from character b,c,..z. So,a[1][0]=a[0][1]+a[0][2]+...+a[0][25]. Now, b[i][j] represents index of first valid combination of length i+1 starting from (j+1)th character. b[i][j] can be calculated by taking sum of prev elem of array 'a' and array 'b'. i.e. b[i][j] = a[i][j-1] + b[i][j-1] After calculating array b, we just need to calculate index of desired string from array 'b'  I am bad at explaining things in writing.. Let me know if more explanation is needed on this	2014-12-10 11:51:45		
4869	cfzie	56	The total words is 2^26 -1. For a given word, the word with small size occur first. Let n be the length of the word, Total number of words with size less than n is C(26, 1) + C(26, 2) + ...+ C(26, n -1) Then calculate how many words with the same size prior to the given word the sum of two numbers plusing one is the index sites.google.com/site/spaceofjameschen/annnocements/printtheindexofawordwithlettersinascendingorder--microsoft	2014-12-10 11:51:45		
4870	rdfeo	56	Perfect James ! I was missing the part where you're 'z'-j C str.len - i -1 this is exactly what I needed.  Thanks and +1 for that answer.	2014-12-10 11:51:45		
4871	jippy	56	You can define your matrix a global array. It will save a lot of time.	2014-12-10 11:51:45		
4872	mrjku	56	You are not suppose to do brute force.....  That what you are doing with loops??? Will it work for 'abcde'?  Regards, Manu	2014-12-10 11:51:45		
4873	ufdxg	56	For calculation of aez:  Get yz value . It is equal to 26 + 25 + .... + 1 = 351  abc = yz + 1 = 352 acd = abc + 23 + 1 = 376 ade = acd + 22 + 1 = 399 aef = ade + 21 + 1 = 421  Finally aez = aef + 20 = 421 + 20 = 441	2014-12-10 11:51:45		
4874	jippy	56	You are right, I overlooked view examples and took it as 26-based system, thanks	2014-12-10 11:51:45		
4875	eucmc	56	Nice approach, but could you please devise an algorithm? For ex: how would you compute the value of 'acegi'?	2014-12-10 11:51:45		
4876	ftfck	56	your idea is correct.. i think in the same way	2014-12-10 11:51:45		
4877	eucmc	56	The total words is 2^26 -1. For a given word, the word with small size occur first. Let n be the length of the word, Total number of words with size less than n is C(26, 1) + C(26, 2) + ...+ C(26, n -1) Then calculate how many words with the same size prior to the given word the sum of two numbers plusing one is the index sites.google.com/site/spaceofjameschen/annnocements/printtheindexofawordwithlettersinascendingorder--microsoft	2014-12-10 11:51:45		
4878	eucmc	56	nice	2014-12-10 11:51:45		
4879	nwkeg	56	ab ----> 27 -------------------------------- ba ----> 0 -------------------------------- bc ----> 52 -------------------------------- aez ----> 441 -------------------------------- cde ----> 928 -------------------------------- cdb ----> 0 -------------------------------- cdf ----> 929 -------------------------------- The output is correct moqx ----> 16983 -------------------------------- xyz ----> 2951 -------------------------------- hjmoqsu ----> 930152	2014-12-10 11:51:45		
4880	mrjku	56	very neat. would be better if there are more comments	2014-12-10 11:51:45		
4881	dkebi	56	output is equivalent to first solution, but much faster	2014-12-10 11:51:45		
4882	bexbp	56	Nice approach	2014-12-10 11:51:45		
4883	sqzqo	56	green to c++, so I converted it to c#. got hung up on char to int. also had to get my head around the nCk principle.	2014-12-10 11:51:45		
4884	fmzze	56		2014-12-10 11:51:45		
4885	nhibd	56		2014-12-10 11:51:46		
4886	plapd	56	what do think will be the brute force algorithm for this ???	2014-12-10 11:51:46		
4887	jippy	56	I think a brute force approach for this algorithm is, given a string str, generating all values in order starting from "a", incrementing a counter, until we find the string str and return the value of the counter. So, for the example "aez", we will need to iterate 441 times.	2014-12-10 11:51:46		
4888	sqzqo	56	yes but I think it could be done more optimized using combinations but couldn't get far more than 3 letters. Formula for 3 letters could look like that: 26C1 + 26C2 + [(26-i) {i=2 to n2-1}] + n3 - n2 Where n1,n2 and n3 represents the index of the character in the alphabet (1->26)  So in the case of aez: n1 = 1 n2 = 5 n3 = 26  = 26 + 325 + 24 + 23 + 22 + 26 - 5 = 441  So in case I'm in the right track, we need this formula to be more general for n characters where 2 <= n <= 26	2014-12-10 11:51:46		
4889	dgjji	56	"aez" is calculated as this: 26+(25+24+23+22+21+20+19+18+17+16+14+13+12+11+10+9+8+7+6+5+4+3+2+1+0+0) +25+24+23+22+21 modified form below: 26+25(24)/2 +25+24+23+22+21  26 + n*(n-1)/2+sum of arithmetic progression of 5(e) numbers starting from (26-e) 21  26+sum of arithmetic progression till 25 + sum of arithmetic progression of 5(e) numbers starting from (26-e) 21  I don't know if it will work for all numbers.	2014-12-10 11:51:46		
4890	nhibd	56	i think it should be 26+26*(25)/2 +24+23+22+21	2014-12-10 11:51:46		
4891	ftfck	56	this should do it if you have 3 letters, but what if more than that ? can we get a more generalized formula ?	2014-12-10 11:51:46		
4892	sgiwy	56	i think it should be 26+26*(25)/2 +24+23+22+21	2014-12-10 11:51:46		
4893	wbqzu	56	Lets start with reducing our problem space. suppose there are only 5 alphabets in question here a,b,c,d,e so it would be like a=1 b=2 c=3 d=4 e=5 ab = 6 ac = 7 ad = 8 ae = 9.....  to find 'cde' we will do = c*5^2 + d*5^1+c - invalid combinations.(aa,ba,bb,...) etc  finding invalid combinations - of length 2 starting with a=1(aa) b=2(ba,bb) c= 3(ca,cb,cc) d=4(da,db,dc,dd) e =5(ea,eb,ec,ed) ----------- length 3 a = (a-a+1)*5^(length-2)+#(b-e) invalid of length 2 b= (b-a +1)*5^(length-2)+(c-e) invalid of length 2 and so on ----------------- length 4 a = (a-a+1)*5^(length-2)+#(b-e) in valid of length 2 ---------------------------  We also need to find invalid combinations selectively like in case of cde. we need to subtract total #invalid combinations of length 2 but we need to be selective in case of length 3. We will subtract only those invalids which start with a*, b*,ca*,cb*,cc*,cda, cdb,cdc,cdd	2014-12-10 11:51:46		
4894	fmzze	56	Yes. its better to find invalid combinations then subtract from the total. let say sequecne goes as follows  a = 1 b = 2 c = 3... z = 26... aa = 27. ab = 28... ... aez = 832.  whatever be the string input (if it is invalid, it can be found in 1 attempt). if it is valid get corresponding numbers as follows.	2014-12-10 11:51:46		
4895	sgiwy	56		2014-12-10 11:51:46		
4896	plapd	56		2014-12-10 11:51:46		
4897	ufdxg	56	above code returns ab = 28. and aez = 832 now maths lies here. till ab there is only one invalid combination that is aa = 1 so subtracting 1 from 28 gives 28-1 = 27 is answer for ab  now take case of aez first find invalid combinations for 2 letter strings. a=1(aa) b=2(ba,bb) c=3(ca,cb,cc) d=4(da,db,dc,dd) e=5(ea,eb,ec,ed,ee)  and so on...  total invalid 2 letter combinations are 1 + 2 + 3+ .......26 = 26*27/2 = 351 next find invalid combinations of three letters strings starts with aa there are 26 invalid combinations (aaa,aab.........aaz) starts with ab there are 2 invalid combinations (aba,abb) starts with ac there are 3 invalid combinations (aca,acb,acc) starts with ad there are 4 invalid combinations (ada,adb,adc,add) starts with ae there are 5 invalid combinations (aea,aeb,aec,aed,aee)  so there are total (26+2+3+4+5) = 40 three letter invalid combinations.  so aez value = 832 - 351 (2 letter invalid combinations) - 40 (3 letter invalid combinations till aez) = 832 - 391 = 441 is answer.  but i dont know how to put this in general coding logic.	2014-12-10 11:51:46		
4898	fowai	56	Thanks for very simple code, could you please explain the logic.	2014-12-10 11:51:46		
4899	fmzze	56	Shouldn't the "return isValid" be outside the "for" loop?!	2014-12-10 11:51:46		
4900	huiqq	56	The idea is to change the string into base-26 system. The pseudo code as follows:	2014-12-10 11:51:46		
4901	sgiwy	56		2014-12-10 11:51:46		
4902	bjsiw	56		2014-12-10 11:51:46		
4903	azmjc	56	It is not base 26 system as it is mentioned in the question that ab is valid but ba is not valid	2014-12-10 11:51:46		
4904	wbqzu	56		2014-12-10 11:51:46		
4905	ufdxg	56		2014-12-10 11:51:46		
4906	sgiwy	56		2014-12-10 11:51:46		
4907	rdfeo	56		2014-12-10 11:51:46		
4908	zeice	56	not sure this is optimized code. but written based on getting number and subtracting invalid strings from that.	2014-12-10 11:51:46		
4909	sqzqo	56		2014-12-10 11:51:46		
4910	gilit	56		2014-12-10 11:51:46		
4911	dkebi	56	ideone.com/hT22xi	2014-12-10 11:51:46		
4912	bjsiw	56	I tried your code with the input efhjkmopwxyz it was running in 5+ minutes so I had to force it to stop.  efhjkmopwxyz ==> 27828178	2014-12-10 11:51:46		
4913	qywrh	56		2014-12-10 11:51:46		
4914	jippy	56		2014-12-10 11:51:47		
4915	krxlv	56		2014-12-10 11:51:47		
4916	zeice	56		2014-12-10 11:51:47		
4917	rrmeu	56		2014-12-10 11:51:47		
4918	dkebi	56		2014-12-10 11:51:47		
4919	xhgls	56		2014-12-10 11:51:47		
4920	plapd	56		2014-12-10 11:51:47		
4921	sgiwy	56		2014-12-10 11:51:47		
4922	ewigy	56		2014-12-10 11:51:47		
4923	huiqq	56		2014-12-10 11:51:47		
4924	zeice	56		2014-12-10 11:51:47		
4925	ufdxg	56	Minor fix:	2014-12-10 11:51:47		
4926	sqzqo	56		2014-12-10 11:51:47		
4927	ewigy	56		2014-12-10 11:51:47		
4928	dkebi	56	should change to:	2014-12-10 11:51:47		
4929	ewigy	56		2014-12-10 11:51:47		
4930	admin	56		2014-12-10 11:51:47		
4931	dkebi	56	Sorry, please ignore this answer. The right is submitted again, see below.	2014-12-10 11:51:47		
4932	bexbp	56		2014-12-10 11:51:47		
4933	ethan	56		2014-12-10 11:51:47		
4934	bjsiw	56	When I tested this function with this input: Console.WriteLine(GetSequenceNo(3, "aez")); It returned 27 which is not correct, aez should return 441.	2014-12-10 11:51:47		
4935	mrjku	56	numberOfChars: number of valid characters, e.g. 3 means only a, b, c are valid characters.  Thanks for your test case. I think I need to add validation logic for this right after 2nd if statement:	2014-12-10 11:51:47		
4936	dgjji	56		2014-12-10 11:51:47		
4937	jippy	56		2014-12-10 11:51:47		
4938	dkebi	56		2014-12-10 11:51:47		
4939	jippy	56		2014-12-10 11:51:47		
4940	wbqzu	56		2014-12-10 11:51:47		
4941	dgjji	56	that's only 1 part of the answer, you need also to print the index of the word if it's valid.	2014-12-10 11:51:47		
4942	nhibd	56	Shouldn't the "return isValid" be outside the "for" loop?!	2014-12-10 11:51:47		
4943	xhgls	57	You can represent 2^n values with n bits.  However, you can represent 2^n + 2^(n-1) + 2^(n-2) + ... 1 = 2^(n+1) - 1 values with *atmost* n bits  So you can represent 2^11 - 1 = 2047 different values using just 10 bits.  Now here's the catch in the problem, as brennahan already mentioned - the order of the pieces doesn't matter. So there are 64C2 = 2016 possible ways to arrange two pieces on an 8x8 chessboard.  Therefore, it should definitely be possible to represent 2016 ways using 10 bits. In fact, you can represent 2016 values using all 5, 6, 7, 8, 9 and 10 bit sequences.  Here's one method:  Consider all possible relative positionings:	2014-12-10 11:51:49		
4944	cfzie	57		2014-12-10 11:51:49		
4945	dgjji	57		2014-12-10 11:51:49		
4946	eucmc	57	Just keep on repeating this procedure, using all sequences of 5, 6, 7, 8, 9 and 10 bits You should be able to represent 32 + 64 + 128 + 256 + 512 + 1024 = 2016 ways to arrange the pieces.  Edit: I just wrote a program to automatically assign bit sequences to every possible configuration. There are a lot of them for 8x8 so I'll just show a solution for a 4x4 chessboard(120 configurations) using atmost 6 bits:	2014-12-10 11:51:49		
4947	huiqq	57		2014-12-10 11:51:49		
4948	gilit	57		2014-12-10 11:51:49		
4949	nwkeg	57	I can't seem to edit my answer. I have a much more elegant solution which uses a maximum of 10 bits, based upon pretonesio's 11 bit solution:  1. If the two pieces are on opposite vertical halves, the first 5 bits should represent the location of the piece in the first half and the next 5 bits should represent the location of the piece in the second half = 10 bits  2. If the pieces are in the same vertical half but in different quarters, use 1 bit to represent which half they are in, the next 4 bits to represent location of piece in upper quarter, next 4 for location of lower quarter piece = 9 bits  3. If they are in the same quarter but in different vertical eighths, use 2 bits to represent which quarter they are in, next 3 bits for location of piece in left eighth and next 3 bits of location of piece in right eighth = 8 bits  4. If they are in the same vertical eighth but in different sixteenth, use 3 bits for the eighth they are in, 2 bits for the piece in upper sixteenth and 2 bits for the piece in lower sixteenth = 7 bits  5. If they are in the same sixteenth but in different vertical thirtysecondths, use 4 bits for the sixteenth and 1 bit each for the location of each piece in respective thirtysecondth = 6 bits  6. If they are in the same thirtysecondth, use 5 bits to represent the location of that thirtysecondth = 5 bits	2014-12-10 11:51:49		
4950	ftfck	57	Nice!!! I think you got it! Love your solution, great job!	2014-12-10 11:51:49		
4951	rrmeu	57	... As nice and elegant as this is, you still have to have a preconceived idea of where they are in order to decode from any given bit representation among all of them... which would require more bits to store that info. X_X  I mean if having extra information outside of the bit-representation is allowed this is a wonderful solution. If not, then you're trying to mash 2016 different combinations into a bit representation that at max holds 1024 and I'm not entirely sure if its possible.  Edit: tl;dr Given only the bit-representation, there is no schema to fit 2016 explicit combinations into 1024 slots using bit-representation.	2014-12-10 11:51:49		
4952	fowai	57	You're treating space differently from 0, which means your number system is not strictly base 2, and your solution cannot qualify as using only 10 bits.  @Brennahan: it is not possible to mash 2016 combinations into a bit representation that holds 1024 combinations at max. Consider any function that maps a 10-bit value to a set of 2 positions. Clearly, since there are only 1024 possible inputs, there are only 1024 possible outputs. Some of the 2016 sets of 2 positions therefore have no 10-bit value that can represent them.	2014-12-10 11:51:49		
4953	huiqq	57	@brennahan: The limitation you're talking about is true for any encoding/decoding scheme. Even the 11 and 12 bits schemes. If you're using the 12 bit scheme, you have to know which 6 bits stand for the first piece's location and which for the second's. And how the locations are encoded to 6 bits. When you're using the 1 bit representation, you have to specify the combination that '0' represents and the combination that '1' represents. Which can also be phrased like this: It is not possible to have an encoding/decoding scheme whose decoder is an empty program.  @eugene.yaravoi: Yes you're correct, the solution is not strictly base 2. You cannot use a 10 bit integer datatype to represent all 2016 configurations. However, it seemed to me that the phrasing of the question allowed for this solution.	2014-12-10 11:51:49		
4954	tenuw	57	how will u represent 2^(n+1) - 1 nos with atmost n bits? explain. with atmost n bits only 2^n nos can be represented..	2014-12-10 11:51:49		
4955	nhibd	57	One way of doing it with 11 bits is like the following: You use 6 bits to represent your first position, and you use 5 bits to represent your second. You first position is represented by a simple x,y bit scheme. The second position will be represented as follows: If 5 bits for the second position are passed in, make a x,y grid on the opposite half of the board and use the 5 bits to locate the second position. If 4 bits are passed in, do the same thing as previously but in the opposite quadrant on the same half of the first picked point. If 3 bits, use them to find it on the opposite eight on the same quadrant If 2 bits , on the opposite sixteenth of the same eight If 1, on the same thirtysecondth of the same sixteenth if no bits, the second position is right below/above the first one  So basically you exploit the fact that no 2 pieces can be in the same place and save a bit	2014-12-10 11:51:49		
4956	gilit	57	(I am Bren, just logged in to acct.) The only other way I can think of is the case where order does not matter. In this case, you can have a base piece and a moving piece. The base piece sits on a spot, and the moving piece would cover the rest of the "NEW" combinations of spots. This mean you just have a summation for the total combination. 63 summation comes out to 2016 possible combinations, though again, you would still need 11 bits to cover it all.	2014-12-10 11:51:49		
4957	bjsiw	57	Exactly! But I know there is a way of solving the problem with only 10 bits. However I'm not sure how.	2014-12-10 11:51:49		
4958	rdfeo	57	how are u concerned about two adjacent positions, two positions could be any where in chess board	2014-12-10 11:51:49		
4959	plapd	57	@pretonesio.  >> If 5 bits for the second position are passed in, make a x,y grid on the opposite half of the board and use the 5 bits to locate the second position.  Could you please define/elaborate what you mean by 'opposite half of the board'?  If the first piece is located at position (0,0) and the second piece is located at (8,8), how will 5 bits suffice to identify the second piece relative to the first? Please clarify.	2014-12-10 11:51:49		
4960	azmjc	57		2014-12-10 11:51:49		
4961	sgiwy	57		2014-12-10 11:51:49		
4962	fmzze	57		2014-12-10 11:51:49		
4963	fowai	57	@m@}{: your solution seems to be the most elegant one if I am not missing anything.  3 bits - to represent 'quarter' (0,1,2,3) 3 bits - to represent 'x' inside quarter (0,1,2,3) 3 bits - to represent 'y' inside quarter (0,1,2,3)	2014-12-10 11:51:49		
4964	dgjji	57	@m@}{: I'm not sure what you're trying to do, but I think your solution uses 9 bits to store the position of 1 piece, which can be done with just 6 bits. Moreover, your code doesn't compile!	2014-12-10 11:51:49		
4965	rrmeu	57	Let's consider how many ways there are to place two pieces on an 8x8 chessboard. The first piece can be placed in one of 64 locations. The second piece can be placed in any one of the 63 remaining locations. Then, assuming you don't care about the order of locations, every pair of locations (i, j) is equivalent to the pair (j, i), so to get the total number of different pairs of locations, we need to divide by 2.  We get 64 * 63 / 2 = 2016.  There is therefore no way to do this with 10 bits, since a 10-bit value can only have one of 2^10 = 1024 possible values. With only 10 bits, only 1024 of the 2016 possibilities could have a representation. All the claims in this thread that you can do it with 10 bits are groundless.  With 11 bits, you can represent 2048 values, which is sufficient. The algorithm for encoding two locations as an 11-bit value is relatively straightforward. Give each chess square a number from 1 to 64. Then represent a pair of locations as the smaller number followed by the larger number. Map an integer to each pair in order, like this: (1, 2) -> 0 (1, 3) -> 1 ... (1, 64) -> 62 (2, 3) -> 63 (2, 4) -> 64 ... (2, 64) -> 124 (3, 4) -> 125 ... (63, 64) -> 2015  You can do some simple math to compute the mapping efficiently.  The locations then have a 1-to-1 correspondence with integers between 0 and 2015. 11 bits are necessary and sufficient to represent these.	2014-12-10 11:51:49		
4966	huiqq	57	what if you consider 00010 and 10 as two different numbers then the whole argument you made will not hold good..	2014-12-10 11:51:49		
4967	krxlv	57	If you consider 10 and 00010 as two different numbers, you are not working in base 2. You've implicitly introduced a third type of symbol: the space. The designation "bit" applies to a 0 or 1 symbol in base 2.	2014-12-10 11:51:49		
4968	bjsiw	57	yes you are right but if you take any bit compactness .. golomb , exp golomb..you would use start and end symbol which inherently will give you space symbol	2014-12-10 11:51:50		
4969	dgjji	57	The idea of some compression schemes is that you can save space on frequently-occurring bit sequences by encoding them with shorter bit sequences. You would then save on the more frequently-occurring bit sequences at the expense of the less frequently-occurring ones.  That's not really what we're talking about, though. To represent just one object (just one selection of two positions on an 8x8 chessboard), if you want to be able to represent all 2016 possibilities, you cannot do it in less than ceil (log_2(2016)) = 11 bits. There is no way around this.  For that matter, even if we talk about space usage when you need to store N objects, you can't be guaranteed to be able to represent N such objects in less than (roughly) 11N bits. Compression schemes are only effective when some objects occur more frequently than others. Unless you know for a fact that your distribution of objects is non-random, you can't be guaranteed any space savings.	2014-12-10 11:51:50		
4970	krxlv	57	There are 4,032 total combinations for 2 different positions on a chessboard (=64*63(2 pieces can't occupy the same space assuming chess rules)) 2^12 would be 4096 so we would need 12 bits in order to cover all possibilities for the 2 positions.  In terms of determining the exact positions from the bit representation, you would need to set up a schema to translate(i.e. the first 6 bits determine where the first position is and the later 6 bits represent the second position is.)	2014-12-10 11:51:50		
4971	fmzze	57	It is true that a naive way can use 12 bits. All you need to do is label the different rows and columns of the board from 0-7 and use that as a x,y guide. That way, just like you described, you can use 12 bits. However, I know there is a way of doing it with only 10 bits. I'm just not sure how.	2014-12-10 11:51:50		
4972	vanul	57	6 bits.. bcz.. on an 8x8 chess board... there can be 64 boxes... thus... in the worst case... we need atleast 6 bits.. to distinguish all d boxes dintinctly	2014-12-10 11:51:50		
4973	zeice	57	That's good enough to only represent one position. We need to represent 2.	2014-12-10 11:51:50		
4974	nhibd	57	lets see the possible number of combinations possible 8*8*8*8/2 = if positions mutually independent = 12 bits otherwise 8*8*(8*8-1)/2 = 2016 combinations total number of combinations possible with 3 bits= 0,1,00,01,10,11,000,001,010,011,100,101,110,111 2+2^2+2^3 = 14 = 2 (2^3-1) total combination with 10 bits= 2(2^10-1)= 2046 combinations.. i will update the answer with a logical division or some1 can work it out	2014-12-10 11:51:50		
4975	fowai	57	combinations for one 8x8 grid = 64 we have two pieces to take into account = 64 *2 two pieces cannot occupy the same space = (64 * 2) - 1 how many bits we need = floor(Lg2((64*2) - 1) answer: 6	2014-12-10 11:51:50		
4976	jippy	57	There are 64 squares and 32 pieces. I take it, that 2 positions means the state of ALL of the white and black pieces at a given time or a "snapshot". To represent 2 positions: won't you need 32 longs (each with 64 bits), so that each long represents a chess piece and each bit (long has 64 bits) in that long represents the position on any one of the 64 squares.	2014-12-10 11:51:50		
4977	dkebi	57	what do you thing about this solution: we can use 5 bits for the white squares and 5 bit for the black squares. then you have another bit to tell if you need to refer to a white or a black square i think even you can do this only with 6 bits: one bit is for the color and let say if color is white then you go to the 5 bit positions by starting at 00000 and if is black you start at 00001 then each loop you move two positions	2014-12-10 11:51:50		
4978	admin	57	I dont know where you all get those ideas...  An 8x8 chessboard with two pieces, where each position is represented as tuple (x,y) and the two pieces using two tuples as a set (since order does not matter), like {(x1,y1),(x2,y2)}... That is the basic mathematic abstraction of the input space. Now for the real question. We are to find the number of all possible, different tuple-sets, which is given by  256!/(254! 2!) - 256 = 32384  Minus 256 in the end, because thats the amount of tuple-sets, where both tuples are equal, a case that is not possible.  Now that makes 14 < log2(32384) <15, so we can conclude that we can save one bit, that is encode the whole thing with 15 bits instead of the obvious 16...	2014-12-10 11:51:50		
4979	mrjku	57	You realize, with the way this question is asked, the answer of '2 bits' suffices. You are only asking bits to represent two positions out of 64 positions, not every possible combination of the 2 positions on the board...	2014-12-10 11:51:50		
4980	mrjku	57	Not a very plausible interpretation of what the question asker likely meant.	2014-12-10 11:51:50		
4981	qywrh	58	We need to run three iterations over a linked list, which takes O(n) time.  input: a b c NULL output: a' b' c' NULL  1) Create nodes for an output and adjust "next" pointers for the input and the output in such a way to build a a' b b' c c' NULL  2) Adjust "random" pointers for the output by using the random and next pointers of the input list. For example, b'->random = b->random->next  3) Adjust next pointers for the input and output lists. For example, temp = (b'->next)?b'->next->next:NULL; b->next = b'->next; b'->next = temp;	2014-12-10 11:51:51		
4982	dgjji	58	Nice idea! O(n) time and O(1) extra space!	2014-12-10 11:51:51		
4983	plapd	58	Step 2 should be b'->random = (b->random->next)' which requires a log(n) search of the output list.  Also, in step 3, why are you modifying the original input list?	2014-12-10 11:51:51		
4984	jippy	58	Nice idea! Your sample code is not clear enough though. Here is the complete code based on your idea:  Node* CopyLinkedList(Node* head) { Node* n = head; // First pass, insert a copy next to the code. while (n) { Node* n1 = new Node(); n1->data = n->data; n1->next = n->next; n->next = n1; n = n->next->next; } // Second pass, set random pointer. n = head; while (n) { n->next->random = n->random->next; n = n->next->next; } // Third pass, detach two lists. n = head; Node* head1 = n->next; while (n) { Node* temp = n->next->next; n->next->next = temp ? temp->next : nullptr; n->next = temp; n = temp; } return head1; }	2014-12-10 11:51:52		
4985	bjsiw	58	L: a b c d ...  L': a A b B c C ...  Arandom = arandomnext  Split L' into two list	2014-12-10 11:51:52		
4986	tenuw	58	There are ways that involve trickery, which you want to avoid in interview settings. It might be fun to try these funky ways when you are home drinking coffee and chilling.  A good linear way is to use a map.  1) Go through your linked list, and for each node v, create a new node u, such that u->data = v->data. Now store (v,u) in your map. {Note, doesn't matter where you set the u->next, just leave the new nodes dangling in the air}  2) Now go through your original linked list again, and visit every v.  Now do 3 lookups in the map for every in your original linked list.... Look up v to get u. Look up v->next to get whatever, call it x Look up v->random to get whatever, call it y  Now set u->next = x, u->random=y.	2014-12-10 11:51:52		
4987	nwkeg	58	So, in interview we should use a straight forward approach, right? Is a trickery approach more impressive? Thanks!	2014-12-10 11:51:52		
4988	eucmc	58	I like the Hash Map approach. If you complete that, and still have time, then suggest that we can improve this code by doing XYZ and then try to do it. 1) You have solved the problem 2) You have shown the interviewer that you are aware that optimizations can be carried out and you know how to do it.  even if you don't end up coding the tricky solution, you will still get the points for having a creative approach - which is crucial for companies like google, fb etc	2014-12-10 11:51:52		
4989	dkebi	58	I don't think this works the way you think, for a couple reasons:  1) You're creating a half-copy really, not a true deep copy. Think in terms of your memory pointers... Your 'u' nodes are pointing back at nodes in the original list, not pointing to other 'u' nodes.  - your intention is correct, but instead of assigning u->next = x directly for example, you need to do u->next = map[x]  2) hash maps need something to hash on.. what are you assuming that is? The value of the node? What if several nodes have the same value? Your map is going to get messed up pretty quick	2014-12-10 11:51:52		
4990	xhgls	58	A simple implementation using a map from old nodes to the corresponding new. First clone the list while setting the next pointers. Then, iterate again and adjust the random pointers using the map created in the previous step.	2014-12-10 11:51:52		
4991	rdfeo	58		2014-12-10 11:51:52		
4992	ufdxg	58		2014-12-10 11:51:52		
4993	dgjji	58	can we use extra data structure, like map something, it makes big difference in terms of difficulty.	2014-12-10 11:51:52		
4994	dkebi	58		2014-12-10 11:51:52		
4995	azmjc	58		2014-12-10 11:51:52		
4996	jippy	58	Clone linked list having random references between nodes Random references don't loop nodes. This solution is in JavaScript for Demo Purposes only. It is unacceptable JavaScript structure since it creates loops between objects in memory and JavaScript is not capable to GC it.	2014-12-10 11:51:52		
4997	ufdxg	58		2014-12-10 11:51:52		
4998	ethan	58		2014-12-10 11:51:52		
4999	bjsiw	58		2014-12-10 11:51:52		
5000	eucmc	58		2014-12-10 11:51:52		
5001	qywrh	58	This question was asked to me for a Google SRE Phone screen Interview 2 years back. The solution uses 1 hashmap and 3 passes.  Create a copy of the link list (without considering the random pointer) while you do that fill the hashmap with Key = Original Node Value = New Node  Second pass go over both the linked (new and original) again then go over hashmap and use the value to fill up the random pointer position in the new list.	2014-12-10 11:51:52		
5002	bexbp	58	The original question is "how will you deep copy a linked list" not just copy.	2014-12-10 11:51:52		
5003	eucmc	58		2014-12-10 11:51:52		
5004	ewigy	58		2014-12-10 11:51:52		
5005	sqzqo	59	No Recursion needed.  Complexity: O(n) * no of combinations  The simplest way to solve this is to consider the number of diff combinations (num_of_comb) and representing that in binary starting from 0 to (num_of_comb - 1).  Ex a?b?c? has 8 comb. i.e 2^3 . i.e. 2 power no of '?'s. Obviously the possible combinations are 000, 001, 010, ..... 110, 111.  Complexity: O(n) * no of combinations. O(n) to find no of '?'s.  Down below is the complete working code with minor description along. Comment if you can improvise further.	2014-12-10 11:51:54		
5006	rdfeo	59		2014-12-10 11:51:54		
5007	rdfeo	59		2014-12-10 11:51:54		
5008	rrmeu	59	How is this O(n) + k ? Its more like O(k.N)	2014-12-10 11:51:55		
5009	azmjc	59	My bad, thanks noted and edited.	2014-12-10 11:51:55		
5010	ufdxg	59		2014-12-10 11:51:55		
5011	plapd	59		2014-12-10 11:51:55		
5012	dgjji	59	When I saw this question, the first way I can think of is to use recursion. It's good that you remind me that I could also choose not to use recursion.	2014-12-10 11:51:55		
5013	gilit	59	Recursion is not so good if you'll try to find all combinations for a long string like "a?b?c?d?a?b?c?da?b?c?da?b?c?da?b?c?da?b?c?da?b?c?da?b?c?da?b?c?d". You'll probably get an "out of memory".	2014-12-10 11:51:55		
5014	qywrh	59	@ravio : This code is using recursion. The helper function replaceHelper is actually called recursively!	2014-12-10 11:51:55		
5015	fowai	59		2014-12-10 11:51:55		
5016	wbqzu	59		2014-12-10 11:51:55		
5017	bexbp	59	Why did this get downvoted? It's correct.	2014-12-10 11:51:55		
5018	fowai	59	Too much unnecessary recursion I guess. You can actually skip some recursions by directly copying those letters before next "?" prefix.	2014-12-10 11:51:55		
5019	jippy	59		2014-12-10 11:51:55		
5020	jippy	59		2014-12-10 11:51:55		
5021	ftfck	59		2014-12-10 11:51:55		
5022	sqzqo	59		2014-12-10 11:51:55		
5023	vanul	59	}	2014-12-10 11:51:55		
5024	nwkeg	59	Tail recursive version in Scala:	2014-12-10 11:51:55		
5025	bexbp	59		2014-12-10 11:51:55		
5026	rdfeo	59		2014-12-10 11:51:55		
5027	huiqq	59	public static void doReplace(String data){ long x = 0; while(data.indexOf('?')>-1){ data = data.replaceFirst("\\?", "%s"); x++; }  long max = (long)Math.pow(2, x); if(max>1){ for(int i=0; i<max; i++){  String[] items = String.format("%"+x+"s",Integer.toBinaryString(i)) .replace(" ", "0") .split("");  System.out.println( String.format(data, Arrays.copyOfRange(items,1,items.length) ) ); } }else{ System.out.println(data); }  }	2014-12-10 11:51:55		
5028	krxlv	59	And i tried to run it and get an error then i replaced Arrays.copyOfRange(items,1,items.length) with items and everything works fine.	2014-12-10 11:51:55		
5029	fmzze	59	My algorithm is similar to yours but i use explicit bitwise operations and on big data my algo is about 30 times faster.	2014-12-10 11:51:55		
5030	krxlv	59	Here is the recursive approach:	2014-12-10 11:51:55		
5031	eucmc	59		2014-12-10 11:51:55		
5032	tenuw	59		2014-12-10 11:51:55		
5033	azmjc	59	void Print(char p[], size_t len) { for (int i = 0; i < len; ++i) { cout << p[i]; } cout << endl; }  bool Replace(char p[], size_t cur, char ch, size_t len) { size_t pos = cur; for (; pos < len; ++pos) { if (p[pos] == '?') { break; } } if (pos < len) { p[pos] = ch; if (Replace(p, pos + 1, '0', len)) { Replace(p, pos + 1, '1', len); } p[pos] = '?'; return true; } else { Print(p, len); return false; } } void Replace(char p[], size_t len) { if (Replace(p, 0, '0', len)) { Replace(p, 0, '1', len); } }	2014-12-10 11:51:56		
5034	tenuw	59	One way of doing this is to generate the bits in-place and print the string once all the ? are replaced appropriately.	2014-12-10 11:51:56		
5035	mrjku	59		2014-12-10 11:51:56		
5036	wbqzu	59		2014-12-10 11:51:56		
5037	fowai	59	Below is java code:	2014-12-10 11:51:56		
5038	bjsiw	59		2014-12-10 11:51:56		
5039	ftfck	59		2014-12-10 11:51:56		
5040	rrmeu	59		2014-12-10 11:51:56		
5041	xhgls	59		2014-12-10 11:51:56		
5042	rdfeo	59		2014-12-10 11:51:56		
5043	dgjji	59		2014-12-10 11:51:56		
5044	ftfck	59		2014-12-10 11:51:56		
5045	ewigy	59		2014-12-10 11:51:56		
5046	bjsiw	59		2014-12-10 11:51:56		
5047	dgjji	59		2014-12-10 11:51:56		
5048	rdfeo	59	import java.util.ArrayList; import java.util.List;  public class Replaceby0and1 {  public static void main(String[] args) { String test = "a?b?ab?"; List<String> replacedStrings = replace(test); for (String temp : replacedStrings) { System.out.println(temp); }  }  private static List<String> replace(String test) {  List<String> replacedStrings = new ArrayList<>();  if (test.indexOf('?') == -1) { replacedStrings.add(test); return replacedStrings; } else {  if (test.length() == 0) { replacedStrings.add(test); return replacedStrings; } else if (test.length() == 1) { if (test.equals("?")) { replacedStrings.add("0"); replacedStrings.add("1");  } else { replacedStrings.add(test); } return replacedStrings; } else {  List<String> replacedSubStrings = new ArrayList<>(); replacedSubStrings = replace(test.substring(1, test.length())); if (test.charAt(0) == '?') { for (String temp : replacedSubStrings) { replacedStrings.add('0' + temp); replacedStrings.add('1' + temp); }  } else { for (String temp : replacedSubStrings) { replacedStrings.add(test.charAt(0) + temp);  } }  return replacedStrings; }  } }  }	2014-12-10 11:51:56		
5049	bjsiw	59		2014-12-10 11:51:56		
5050	rdfeo	59		2014-12-10 11:51:56		
5051	huiqq	59	}	2014-12-10 11:51:56		
5052	ftfck	59		2014-12-10 11:51:56		
5053	cfzie	59		2014-12-10 11:51:56		
5054	fmzze	59		2014-12-10 11:51:56		
5055	rdfeo	59		2014-12-10 11:51:56		
5056	cfzie	59	Recursive Program in Java: public class ReplaceQuestionMark { public static void main(String[] args) { String input = "a?b?c?"; replace(input.toCharArray()); } public static void replace(char[] input) { boolean found = false; for(int i=0;i<2;i++) { int foundAt = 0; for(int j=0;j<input.length;j++) { if(input[j] == '?') { foundAt = j; found = true; break; } } if(found) { input[foundAt] = (char)(i + 48); replace(input); input[foundAt] = '?'; foundAt = 0; } else { System.out.println(input); return; } } } }	2014-12-10 11:51:56		
5057	rrmeu	59	Recursive program in Java:	2014-12-10 11:51:56		
5058	azmjc	59		2014-12-10 11:51:56		
5059	zeice	59		2014-12-10 11:51:56		
5060	krxlv	59	I think my code will works.  import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Scanner;  class Replace { private int[] number; private List<Integer> indexlist; char[] thestring;  public Replace(String s) { indexlist = new LinkedList<Integer>(); thestring = s.toCharArray(); int count = 0; for(int i=0; i<thestring.length; i++) { if(thestring[i] == '?') { count++; } }  number = new int[count];  for(int i=0; i<count; i++) { number[i] = 0; }  for(int i = 0; i<thestring.length; i++) { if(thestring[i] == '?') { indexlist.add(i); } }  }  public void output(char[] a) { System.out.println(a); }  public void RemoveQ(int[] array, int start, int end) { if(start == end) { char[] result = new char[thestring.length]; int i = 0; result = thestring.clone(); Iterator<Integer> iter = indexlist.iterator(); while(iter.hasNext()) { result[iter.next()] = (char)(array[i]+48); i++; }  output(result); return; } else { array[start] = 0; RemoveQ(array, start+1, end); array[start] = 1; RemoveQ(array, start+1, end); } }   public void run() { int[] temp = new int[number.length]; temp = number.clone(); RemoveQ(temp, 0, temp.length); }  }       public class Main {  public static void main(String args[]) { Scanner in = new Scanner(System.in); String instring = in.nextLine(); in.close(); Replace R = new Replace(instring); R.run(); }  }	2014-12-10 11:51:56		
5061	rdfeo	59	I think my code will works.  import java.util.Iterator; import java.util.LinkedList; import java.util.List; import java.util.Scanner;  class Replace { private int[] number; private List<Integer> indexlist; char[] thestring;  public Replace(String s) { indexlist = new LinkedList<Integer>(); thestring = s.toCharArray(); int count = 0; for(int i=0; i<thestring.length; i++) { if(thestring[i] == '?') { count++; } }  number = new int[count];  for(int i=0; i<count; i++) { number[i] = 0; }  for(int i = 0; i<thestring.length; i++) { if(thestring[i] == '?') { indexlist.add(i); } }  }  public void output(char[] a) { System.out.println(a); }  public void RemoveQ(int[] array, int start, int end) { if(start == end) { char[] result = new char[thestring.length]; int i = 0; result = thestring.clone(); Iterator<Integer> iter = indexlist.iterator(); while(iter.hasNext()) { result[iter.next()] = (char)(array[i]+48); i++; }  output(result); return; } else { array[start] = 0; RemoveQ(array, start+1, end); array[start] = 1; RemoveQ(array, start+1, end); } }   public void run() { int[] temp = new int[number.length]; temp = number.clone(); RemoveQ(temp, 0, temp.length); }  }       public class Main {  public static void main(String args[]) { Scanner in = new Scanner(System.in); String instring = in.nextLine(); in.close(); Replace R = new Replace(instring); R.run(); }  }	2014-12-10 11:51:57		
5062	eucmc	59	Simple and concise recursive solution in Java.	2014-12-10 11:51:57		
5063	azmjc	59		2014-12-10 11:51:57		
5064	fmzze	59		2014-12-10 11:51:57		
5065	vanul	59		2014-12-10 11:51:57		
5066	gilit	59		2014-12-10 11:51:57		
5067	huiqq	59		2014-12-10 11:51:57		
5068	jippy	59		2014-12-10 11:51:57		
5069	ufdxg	59	You haven't backtracked. Will it work?	2014-12-10 11:51:57		
5070	tenuw	59	Here code in C using recursion.	2014-12-10 11:51:57		
5071	fmzze	59		2014-12-10 11:51:57		
5072	ufdxg	59		2014-12-10 11:51:57		
5073	jippy	59		2014-12-10 11:51:57		
5074	fmzze	59		2014-12-10 11:51:57		
5075	fowai	59		2014-12-10 11:51:57		
5076	xhgls	59		2014-12-10 11:51:57		
5077	eucmc	59	I have two solutions. One with permutation and one without permutation using bitset.  #include "stdafx.h" #include <iostream> #include <string> #include <set> #include <bitset>  using namespace std;  set<string> perm;  void replace(string str, string strWith) { int index = 0; for(int i=0; i< str.length(); ++i) { if(str[i] == '?') str[i] = strWith[index++]; } cout << str << endl; }  void parmutation(string str, string endStr) { if(str.length() == 0) perm.insert(endStr); for(size_t i = 0; i < str.length(); ++i) { string StrIn = str; string StrEnd = endStr; StrIn.erase(i,1); StrEnd += str.at(i); parmutation(StrIn,StrEnd); } }  void replaceString(string str) { perm.insert("0000"); parmutation("0001",""); parmutation("0011",""); parmutation("0111",""); perm.insert("1111");  for(auto it= perm.begin(); it != perm.end(); ++it) { replace(str,*it); } }  void replaceWithPermutation(string str) { for(int i=0; i< 16; ++i) { bitset<4> bt(i); replace(str,bt.to_string<char,string::traits_type,string::allocator_type>()); } }  int main() { replaceString("a?b?c?d?"); cout << endl; replaceWithPermutation("a?b?c?d?"); while(1) {} return 0; }	2014-12-10 11:51:57		
5078	sqzqo	59		2014-12-10 11:51:57		
5079	wbqzu	59		2014-12-10 11:51:57		
5080	nhibd	59	How about this code?	2014-12-10 11:51:57		
5081	ethan	59		2014-12-10 11:51:57		
5082	sgiwy	59		2014-12-10 11:51:57		
5083	rdfeo	59	An iterative solution using bit manipulation (we want to replace the n ? with all the possible values of an n-bit vector).	2014-12-10 11:51:57		
5084	dgjji	59		2014-12-10 11:51:57		
5085	ethan	59		2014-12-10 11:51:57		
5086	vanul	59		2014-12-10 11:51:57		
5087	krxlv	59		2014-12-10 11:51:57		
5088	ufdxg	59	private static void generateValues(String s, int index) { if (index == s.length()) { System.out.println(s); return; } for (int i= index; i < s.length(); i++) { if (s.charAt(i) == '?') { s = s.substring(0, i) + '0' + s.substring(i + 1); generateValues(s, i + 1); s = s.substring(0, i) + '1' + s.substring(i + 1); generateValues(s, i + 1); } } }	2014-12-10 11:51:57		
5089	plapd	59		2014-12-10 11:51:57		
5090	nhibd	59		2014-12-10 11:51:57		
5091	krxlv	59		2014-12-10 11:51:58		
5092	cfzie	59		2014-12-10 11:51:58		
5093	bjsiw	59		2014-12-10 11:51:58		
5094	jippy	59		2014-12-10 11:51:58		
5095	bjsiw	59		2014-12-10 11:51:58		
5096	sqzqo	59		2014-12-10 11:51:58		
5097	bjsiw	59	Code in Java	2014-12-10 11:51:58		
5098	tenuw	59		2014-12-10 11:51:58		
5099	nhibd	59		2014-12-10 11:51:58		
5100	dgjji	59	It eats less memory. But is it faster than the recursive method? I think the recursive method is O(n) but this method is O(2^n). Please correct me if I'm wrong.	2014-12-10 11:51:58		
5101	plapd	59	Both areO( 2^k.n) where k is the number of ? chars in str of length n. This approach is much faster and desirable than the recursive approach.	2014-12-10 11:51:58		
5102	bjsiw	59		2014-12-10 11:51:58		
5103	rrmeu	59		2014-12-10 11:51:58		
5104	sgiwy	59	}	2014-12-10 11:51:58		
5105	nwkeg	59		2014-12-10 11:51:58		
5106	bexbp	59		2014-12-10 11:51:58		
5107	ufdxg	59	C++ solution	2014-12-10 11:51:58		
5108	wbqzu	59		2014-12-10 11:51:58		
5109	rrmeu	59		2014-12-10 11:51:58		
5110	mrjku	59	C++ solution	2014-12-10 11:51:58		
5111	mrjku	59		2014-12-10 11:51:58		
5112	rrmeu	59		2014-12-10 11:51:58		
5113	rdfeo	59		2014-12-10 11:51:58		
5114	dkebi	59		2014-12-10 11:51:58		
5115	azmjc	59		2014-12-10 11:51:58		
5116	nwkeg	59		2014-12-10 11:51:58		
5117	vanul	59		2014-12-10 11:51:58		
5118	tenuw	59		2014-12-10 11:51:59		
5119	bjsiw	59		2014-12-10 11:51:59		
5120	azmjc	59		2014-12-10 11:51:59		
5121	nwkeg	59		2014-12-10 11:51:59		
5122	krxlv	59		2014-12-10 11:51:59		
5123	sgiwy	59		2014-12-10 11:51:59		
5124	cfzie	59		2014-12-10 11:51:59		
5125	ewigy	59	Basically I converted the number of ? on a binary number, from there I subtracted 1 and then I produce the string:	2014-12-10 11:51:59		
5126	bexbp	59		2014-12-10 11:51:59		
5127	sgiwy	59		2014-12-10 11:51:59		
5128	ftfck	59	import java.util.*; import java.lang.*; class googleinterview { public static void main(String args[]) { int count=0,r; Scanner sc=new Scanner(System.in); System.out.print("Enter the expression:"); String s=sc.next(); int len=s.length(); for(int i=0;i<s.length();i++) { if(s.charAt(i)=='?') { count++; } } //System.out.println("Count="+count); int power=(int)Math.pow(2,count); //System.out.println("Power="+power); int[][] a=new int[power][count]; int[][] b=new int[power][count]; int[] x=new int[power]; for(int i=0;i<power;i++) { x[i]=i; }  for(int i=0;i<power;i++) { int k=0; while(x[i]!=0) { r=x[i]%2; //System.out.print(r); a[i][k]=r; x[i]=x[i]/2; k++; }  } String s1=s; System.out.println("**********Total possible combinations**********"); char[] ch=new char[len]; ch=s1.toCharArray(); for(int i=0;i<power;i++) { int k=count-1; for(int j=0;j<len;j++) { if(s1.charAt(j)=='?') { if(k>=0) { System.out.print(a[i][k]); k--; } else break; } else System.out.print(ch[j]); } System.out.println("\n"); }  } } /* Output: --------------------------------------------------- Enter the expression:?a?b?c **********Total possible combinations********** 0a0b0c  0a0b1c  0a1b0c  0a1b1c  1a0b0c  1a0b1c  1a1b0c  1a1b1c  */	2014-12-10 11:51:59		
5129	jippy	59		2014-12-10 11:51:59		
5130	plapd	59		2014-12-10 11:51:59		
5131	sgiwy	59		2014-12-10 11:51:59		
5132	dkebi	59		2014-12-10 11:51:59		
5133	huiqq	59		2014-12-10 11:51:59		
5134	qywrh	59		2014-12-10 11:51:59		
5135	gilit	59	Not the best solution, but its another one	2014-12-10 11:51:59		
5136	zeice	59		2014-12-10 11:51:59		
5137	eucmc	59		2014-12-10 11:52:00		
5138	huiqq	59		2014-12-10 11:52:00		
5139	wbqzu	59		2014-12-10 11:52:00		
5140	plapd	59		2014-12-10 11:52:00		
5141	ftfck	59		2014-12-10 11:52:00		
5142	ufdxg	59		2014-12-10 11:52:00		
5143	mrjku	59		2014-12-10 11:52:00		
5144	jippy	59	public class StringReplacer {  private String input;  public StringReplacer(String in) { this.input = in != null ? in : "?"; }  public String[] replace() { int count = 0, size = 0;  for (char c : this.input.toCharArray()) { if (c == '?') { size = 1<<(++count); } }  String[] out = new String[size]; int replacer = size; replacer--; for (int z=0; z<size; z++,replacer--) { String replacerString = Integer.toBinaryString(replacer); while (replacerString.length()<count) { replacerString = "0"+replacerString; }  int c=0; char[] chars = this.input.toCharArray(); for (int p=0; p<chars.length; p++) { if (chars[p] == '?') { chars[p] = replacerString.charAt(c++); } }   out[z] = new String(chars); }  return out;  }  public static void main(String[] args) { StringReplacer replacer = new StringReplacer("a?b?c?");  String[] replaced = replacer.replace();  for (String s : replaced) { System.out.println(s); } }  }	2014-12-10 11:52:00		
5145	bjsiw	59		2014-12-10 11:52:00		
5146	krxlv	59		2014-12-10 11:52:00		
5147	ewigy	59		2014-12-10 11:52:00		
5148	admin	59		2014-12-10 11:52:00		
5149	ewigy	59	In Ruby: Assume there are 3 question marks, use binary string from 000 to 111. Convert it to string, replace binary chars with each question marks.	2014-12-10 11:52:00		
5150	dkebi	59		2014-12-10 11:52:00		
5151	bjsiw	59		2014-12-10 11:52:00		
5152	jippy	59	Backtracking in C++:	2014-12-10 11:52:00		
5153	admin	59		2014-12-10 11:52:00		
5154	ewigy	59		2014-12-10 11:52:00		
5155	jippy	59		2014-12-10 11:52:00		
5156	sgiwy	59		2014-12-10 11:52:00		
5157	ewigy	59		2014-12-10 11:52:00		
5158	eucmc	59		2014-12-10 11:52:00		
5159	tenuw	59	well you can try something like this....	2014-12-10 11:52:00		
5160	bjsiw	59		2014-12-10 11:52:00		
5161	azmjc	59		2014-12-10 11:52:00		
5162	qywrh	59	and the out put would be as..  [a0b0c0, a0b0c1, a0b1c0, a0b1c1, a1b0c0, a1b0c1, a1b1c0, a1b1c1]	2014-12-10 11:52:01		
5163	jippy	59		2014-12-10 11:52:01		
5164	mrjku	59		2014-12-10 11:52:01		
5165	krxlv	59	Java solution - no recursion. Memory O(n), does n * 2^n operations.	2014-12-10 11:52:01		
5166	fowai	59		2014-12-10 11:52:01		
5167	rrmeu	59		2014-12-10 11:52:01		
5168	vanul	59		2014-12-10 11:52:01		
5169	ufdxg	59		2014-12-10 11:52:01		
5170	bjsiw	59	Here is simple readable code with working solution using recursion. Just copy paste and compile  public class aqbqcq { public static void main(String[] args) { replace("a?b?c?d?"); }  public static void replace(String s) { char c;  for (int i = 0; i < s.length(); i++) { c = s.charAt(i);  if (c == '?') { replace(rc(s,i,'0')); replace(rc(s,i,'1')); return; } }  System.out.println(s); }  // Replace char in string at certain index public static String rc(String s, int index, char c) { return s.substring(0,index) + c + s.substring(index+1); } }	2014-12-10 11:52:01		
5171	qywrh	59	Code in C:	2014-12-10 11:52:01		
5172	tenuw	59		2014-12-10 11:52:01		
5173	zeice	59		2014-12-10 11:52:01		
5174	vanul	59	#!/usr/bin/env python import string import sys def comb(s): c = s.lower().count('?') for i in range(c ** 2 -1 ): l1 = list(bin(i)[2:].zfill(c)) s1 = s[:] for j in range(c): s1 = string.replace(s1,'?', l1[j], 1) print s1  if __name__ == "__main__": s = sys.argv[1] comb(s)	2014-12-10 11:52:01		
5175	rdfeo	59	play.google.com/store/apps/details?id=com.couponkart.couponcodes  try this out . might be useful	2014-12-10 11:52:01		
5176	sqzqo	59	play.google.com/store/apps/detai... try it out	2014-12-10 11:52:01		
5177	dkebi	60	Use quicksort on array a and swap elements of x as you are sorting a.	2014-12-10 11:52:02		
5178	mrjku	60	Quicksort is O(n2) in the worst case. Heapsort is an in-place O(n log n) sort. Maybe that would work.	2014-12-10 11:52:02		
5179	jippy	60	Can be done in O(n) by employing in-place marker to the index array. The test data with the code below is carefully chosen to cover all cases..	2014-12-10 11:52:02		
5180	qywrh	60		2014-12-10 11:52:03		
5181	bexbp	60		2014-12-10 11:52:03		
5182	zeice	60	Result: Values: [5, 12, 14, 27, 3, 2, 13, 17, 7, 21] Index: [3, 6, 2, 9, 7, 1, 4, 8, 5, 0] Values: [21, 2, 14, 5, 13, 7, 12, 3, 17, 27]	2014-12-10 11:52:03		
5183	huiqq	60	Correction: since the original question already states index are > 0, the above code should be modified as below:	2014-12-10 11:52:03		
5184	cfzie	60		2014-12-10 11:52:03		
5185	nwkeg	60		2014-12-10 11:52:03		
5186	tenuw	60	Values: [5, 12, 14, 27, 3, 2, 13, 17, 7, 21] Index: [4, 7, 3, 10, 8, 2, 5, 9, 6, 1] Values: [21, 2, 14, 5, 13, 7, 12, 3, 17, 27]	2014-12-10 11:52:03		
5187	plapd	60	The code is correct. How to prove that the complexity is o(nlgn)?	2014-12-10 11:52:03		
5188	vanul	60	@chenw, actually the time complexity is not O(nlgn), but O(n) since at worst case (where no element happens to be in right place initially) , every element is relocated once.	2014-12-10 11:52:03		
5189	vanul	60	I think the expected output for your test case is: [7, 14, 5, 27, 17, 3, 12, 21, 13, 2]  Even if I sort your array before calling your function, I still get something that looks inverted.	2014-12-10 11:52:03		
5190	bexbp	60	@Anonymous, can you explain how you arrive your result? Using 7, the first element in your result, as example, it originally resides at cell 8 and is to be relocated to 5 (6 - 1). And, why you have to sort the array first?	2014-12-10 11:52:03		
5191	tenuw	60	Just wondering why a Google interviewer ask for O(nlogn) solution when there exists o(n) one.	2014-12-10 11:52:03		
5192	ewigy	60	If not forbidding destruction the permutation, this in-place marker solution can be further improved as below. Instead of using negative index value to mark a cell happening to be in the right location, mark a processed cell as such. It simplifies the logic and operation a bit, while still maintaining the O(n) performance.	2014-12-10 11:52:03		
5193	ethan	60		2014-12-10 11:52:03		
5194	vanul	60		2014-12-10 11:52:03		
5195	sgiwy	60	Values: [5, 12, 14, 27, 3, 2, 13, 17, 7, 21] Index: [4, 7, 3, 10, 8, 2, 5, 9, 6, 1] Values: [21, 2, 14, 5, 13, 7, 12, 3, 17, 27]	2014-12-10 11:52:03		
5196	admin	60	Sorry but he's *NOT* solving the right problem. Values given in the index array is the order *after* sorted and not the order in the values array. Just think. If this was solvable in O(N), you would sort N elements in O(N) by passing index=[1,2,3,4...]... and might win a Fields medal !!	2014-12-10 11:52:03		
5197	xhgls	60	Built for zero based arrays but can be modified to one based values. Can't explain why it works... :)	2014-12-10 11:52:03		
5198	bexbp	60		2014-12-10 11:52:03		
5199	zeice	60		2014-12-10 11:52:03		
5200	plapd	60	Well, as iroodaz commented (and for some reason deleted) I have implemented X[i] = X[A[i]] while the question requests X[A[i]] = X[i] so here is a correction (already written by others here) again for 0 based A's All the is left, again, is to calculate the complexity :)	2014-12-10 11:52:03		
5201	vanul	60		2014-12-10 11:52:03		
5202	krxlv	60		2014-12-10 11:52:03		
5203	xhgls	60	Great job Levitan. I apologize for deleting the comment. I was constantly mixing things when trying test cases and finally got completely lost. After that, concluded that, I'd better not talk as I was starting to talk nonsense :-D Nevertheless, we now have a superb algorithm for each of the two cases that you mentioned. Thanks buddy!	2014-12-10 11:52:03		
5204	eucmc	60	It's a clever solution and performs at O(n) time complexity, better than the interviewer asks for. But, it wont work when asking to preserve the original permutation. The algorithm above this one can achieve the same performance O(n) without destructing the permutation.	2014-12-10 11:52:03		
5205	gilit	60	It is O(n); however, we should first sort the array normally and then pass it to this method. So, overall, it is O(nlogn).	2014-12-10 11:52:03		
5206	bexbp	60	Nice solution. However, consider the worst case when the array, As, is reversed. Say, [100000,99999,....1]. In this case, it seems to me, the double loop of this algorithm degrades into O(n2).	2014-12-10 11:52:03		
5207	wbqzu	60	I believe the solution is based on the fact that in[] Xs is already sorted, right?	2014-12-10 11:52:03		
5208	dgjji	60	Hey guys, the correct solution is the original one, not the one in the comments and it is indeed O(n). I sincerely apologize to Levitan for posting a misleading comment under his original post. I screwed up terribly. :-( :-( Please please up-vote the original post so the solution gets to be seen. It is a super elegant algorithm and it does not even modify array A.  Thanks!	2014-12-10 11:52:04		
5209	nhibd	60	it works because you're first checking where 1 goes in the permutation. then you check where 2 goes. but you only go to an new index farther or equal to the current index. this makes sure you don't double swap. the reason why the while loop always ends is because the iteration a = As[a] will always and come back to i again (in n or less iterations). you're basically iterating through the different cycles in the cycle decomposition of the permutation	2014-12-10 11:52:04		
5210	admin	60	To anyone who knows the exact specifications of the problem: Are we allowed to modify contents of the array A? Thanks :-)	2014-12-10 11:52:04		
5211	qywrh	60	That's what I thought at first, because the problem definition didn't mention it otherwise. However, if the content of array A is modifiable then there is a O(n) solution:	2014-12-10 11:52:04		
5212	krxlv	60		2014-12-10 11:52:04		
5213	nhibd	60		2014-12-10 11:52:04		
5214	tenuw	60	Exactly! However, do not forget O(nlogn) normal sorting that should be done before calling this function. By the way, could you please correct the part that says A[i] = X[temp]?	2014-12-10 11:52:04		
5215	nhibd	60	There are two things not explained clearly in the problem: 1) Require stable sort or not? 2) Can overwrite the array A or not?  Assume stable sort not requried and A can be overwrote. The solution is: Step 1: HeapSort(X); [Note: Use Maximum Heap] Step 2: PermutationReorder(X,A);  Step 1: HeapSort is satisfied in this problem. 1) Big-O: O(n*log(n)) even in the wrost case. 2) In-space: No extra space required. 3) But not stable. (Assume not required. if required, need to modify HeapSort) [Note: it is time costly to code the HeapSort in a short time, so be careful]  Step 2: PermutationReorder: ------------------------- Step 2.1: Loop A A[i] = X[A[i]];  Step 2.2: Loop X X[i] = A[i]; ------------------------ If A is not allowed to be overwrote. I do not have a solution. I see there are many talking about the "Swap Solution" proposed by Levitan. But I think that solution is wrong. The "Swap Solution" is basically "sorting A", which is not exactly what the problem want.	2014-12-10 11:52:04		
5216	eucmc	60	Cool.	2014-12-10 11:52:04		
5217	fowai	60	If you try it out, you will find out that the swap and sort solution works. You can think about it. For example the easiest case, we have x = 11, 24, 15, a = 2, 1, 3, Then you swap a[0] with a[1], you get 24, 11, 15 which is exactly what you want. Certainly, this case is not convencing, but you can try other cases. It should work.	2014-12-10 11:52:04		
5218	plapd	60		2014-12-10 11:52:04		
5219	eucmc	60		2014-12-10 11:52:04		
5220	cfzie	60	this doesn't work. try:	2014-12-10 11:52:04		
5221	fowai	60		2014-12-10 11:52:04		
5222	dgjji	60		2014-12-10 11:52:04		
5223	eucmc	60	Can be done in o(n). You just have to recursively put each number in its correct position.	2014-12-10 11:52:04		
5224	rrmeu	60	How do you do this in place? Each time you 'put a number in its correct position' you are overwriting a number you will need later on.	2014-12-10 11:52:04		
5225	ethan	60	My first instinct was recursive as well - I just submitted a solution that works like this. The key is to 'remember' the values you need before making the recursive call. That way you dont have to worry about the values changing later, and when the recursion bubbles back up, you just set the value you were remembering in to its correct location.. (assuming my code does in fact work ;) )	2014-12-10 11:52:04		
5226	admin	60	quick sort..............................	2014-12-10 11:52:04		
5227	cfzie	60	Treat the permutation array [a1~an] as as node index of min-heap, (and sequence array [x1~xn] are node value).  It was O(nlogn) to build such min-heap, and we can achieve that by "swap" elements in array, no extra array required.	2014-12-10 11:52:04		
5228	bexbp	60	If not forbidding destruction the permutation, this in-place marker solution can be further improved as below. Instead of using negative index value to mark a processed cell, mark a processed cell as such. It simplifies the logic and operation a bit, while still maintaining the O(n) performance.   public class InPlaceRearrangeViaShadowIndex {  public static void doIt(int[] numbers, int[] index) { if (numbers == null || index == null || numbers.length != index.length) { return; }  for (int loopHead = 0; loopHead < index.length; loopHead++) { // Check if it is already in right position if (index[loopHead] != loopHead + 1) { int goingTo = index[loopHead] - 1; int valueToMove = numbers[loopHead]; while (loopHead != goingTo) { int temp = numbers[goingTo]; numbers[goingTo] = valueToMove; valueToMove = temp; temp = index[goingTo] - 1; // Mark it as already in right position index[goingTo] = goingTo + 1; goingTo = temp; } numbers[loopHead] = valueToMove; } } }  public static void main(String[] args) { int[] arr = { 5, 12, 14, 27, 3, 2, 13, 17, 7, 21 }; int[] index = { 4, 7, 3, 10, 8, 2, 5, 9, 6, 1 }; System.out.println("Values: " + Arrays.toString(arr)); System.out.println(" Index: " + Arrays.toString(index)); doIt(arr, index); System.out.println("Values: " + Arrays.toString(arr)); } } Values: [5, 12, 14, 27, 3, 2, 13, 17, 7, 21] Index: [4, 7, 3, 10, 8, 2, 5, 9, 6, 1] Values: [21, 2, 14, 5, 13, 7, 12, 3, 17, 27]	2014-12-10 11:52:04		
5229	ftfck	60	The basic idea is: 1. Sort X. 2. Assume we're going to make 1,2,3,4,......,n sequence become a[1], a[2].......a[n]. we swap x[] as we swap a[]. For example, if a[1] = 3, we swap 1 and 3 to make 3 at a[1]. At the same time, we swap x[1] with x[3] and so on.	2014-12-10 11:52:04		
5230	rrmeu	60		2014-12-10 11:52:04		
5231	krxlv	60		2014-12-10 11:52:04		
5232	vanul	60	This would not work unfortunately. Consider the following test case:  A = {2, 1, 3} X = {1, 2, 3}  sort(X) => X = {1, 2, 3} first iteration of the for-loop: X = {2, 1, 3} second iteration: X = {1, 2, 3} third iteration: X = {1, 2, 3}	2014-12-10 11:52:04		
5233	vanul	60	Thanks for checking out my code. I didn't notice that I need to keep tracking the status of the index array. Correct the previous solution as below:	2014-12-10 11:52:05		
5234	qywrh	60		2014-12-10 11:52:05		
5235	sgiwy	60		2014-12-10 11:52:05		
5236	ufdxg	60	Thanks for the new code. :-)  I believe this one is correct.  However, the algorithm should not use any additional arrays, so we should do something about array b. The good news is, we can do what the array b does using the original array a.  Cheers!	2014-12-10 11:52:05		
5237	plapd	60	I can't figure out how to use the original array a to solve the problem. Could you explain more?	2014-12-10 11:52:05		
5238	qywrh	60	We can do something like what oOZz has done. Putting permuted X in array A and destroying A as we go forward. Also check Levitan's original code(not the one in comments) to see how he does not even modify A and solve this. It is super cool.	2014-12-10 11:52:05		
5239	sqzqo	60	C#, NUnit	2014-12-10 11:52:05		
5240	ethan	60		2014-12-10 11:52:05		
5241	ftfck	60		2014-12-10 11:52:05		
5242	plapd	60	My approach would be to use heapsort and mirror the changes. Heapsort is in-place and O(n log n).	2014-12-10 11:52:05		
5243	nhibd	60		2014-12-10 11:52:05		
5244	ftfck	60		2014-12-10 11:52:05		
5245	qywrh	60	O(n) simple solution:	2014-12-10 11:52:05		
5246	jippy	60		2014-12-10 11:52:05		
5247	sgiwy	60		2014-12-10 11:52:05		
5248	huiqq	60	It doesn't work for x = { 17, 5, 1, 9 } and a = { 2, 1, 3, 0 } it return {17, 5, 17, 17}, but must return { 9, 5, 17, 1 }	2014-12-10 11:52:05		
5249	dgjji	60	first, use quick sort in place to sort the array, then do reorder according to the second sequence.	2014-12-10 11:52:05		
5250	qywrh	60		2014-12-10 11:52:05		
5251	vanul	60		2014-12-10 11:52:05		
5252	eucmc	60	You need to sort the array first.	2014-12-10 11:52:05		
5253	nhibd	60	What do we need to change on @babula code if we do not want to use an additional memory?	2014-12-10 11:52:05		
5254	rrmeu	60	p = {x1,x2,...xn} ; a = {a1,a2,...an};  sort(p); //O(nlogn)  // O(n) for (int i = 0; i < p.size(); i++) { a[i] = p[a[i]-1]; } // O(n) for(int i = 0; i < a.size(); i++) { p[i] = a[i]; }	2014-12-10 11:52:05		
5255	rrmeu	60	Clever. The problem is	2014-12-10 11:52:05		
5256	ftfck	60		2014-12-10 11:52:05		
5257	eucmc	60		2014-12-10 11:52:05		
5258	bexbp	60	Which will over write values in 'a' that you'll need in subsequent iterations of that very loop.	2014-12-10 11:52:05		
5259	plapd	60	Use A={a1,a2,a3..} for comparison and swap X.	2014-12-10 11:52:05		
5260	bexbp	60		2014-12-10 11:52:06		
5261	wbqzu	60		2014-12-10 11:52:06		
5262	zeice	60	Tricky swap, utilize A to preserve sorted X:	2014-12-10 11:52:06		
5263	nhibd	60		2014-12-10 11:52:06		
5264	rdfeo	60		2014-12-10 11:52:06		
5265	plapd	60	Whoops... if j - 1 < i not if j < i:	2014-12-10 11:52:06		
5266	admin	60		2014-12-10 11:52:06		
5267	bexbp	60		2014-12-10 11:52:06		
5268	ethan	60		2014-12-10 11:52:06		
5269	bjsiw	60		2014-12-10 11:52:06		
5270	sgiwy	60		2014-12-10 11:52:06		
5271	xhgls	60		2014-12-10 11:52:06		
5272	ftfck	60		2014-12-10 11:52:06		
5273	qywrh	60		2014-12-10 11:52:06		
5274	rrmeu	60	Merge Sort, without helper array for merge. O(n log n)	2014-12-10 11:52:06		
5275	huiqq	60	This is not right by the input int[] x = {0,3,5,1,4,2}; int[] a = {0,4,2,3,1,5}; it outputs 4 5 1 3 2,	2014-12-10 11:52:06		
5276	dgjji	60	void swap (int &a, int &b) { int temp = a; a = b; b = temp; }  void change_seq (int a[], int b[], int size) { for (int i=1 ;i<=size; ) { int j = i; while (b[j-1] != j) { int temp = a[j-1]; swap(a[j-1], a[b[j-1]-1]); swap(b[j-1], b[b[j-1]-1]); } i++; } }  int main() { int a[] = {2,19, 99,88,0,6}; int b[] = {2,3, 4, 1,6,5}; change_seq(a, b, 6); for (int i=0; i<6; i++) cout << a[i] <<endl; return 0; }	2014-12-10 11:52:06		
5277	vanul	60	O(n) solution	2014-12-10 11:52:06		
5278	bexbp	60		2014-12-10 11:52:06		
5279	sqzqo	60		2014-12-10 11:52:06		
5280	ethan	60	This looks like O(n2) when b[] is reversed (worst case).	2014-12-10 11:52:06		
5281	jippy	60		2014-12-10 11:52:06		
5282	ethan	60		2014-12-10 11:52:06		
5283	bjsiw	60		2014-12-10 11:52:07		
5284	qywrh	60		2014-12-10 11:52:07		
5285	ftfck	60	My solution in C#.  The 2nd phase -the relative ordering of array X based on array A- takes O(n) time, I believe. It appears like n power of 2, since there's a while loop inside a for loop (but it's not).  Now, the 1st phase, the sorting of array X, takes O(n log n). So I would ask the interviewer if he/she has a superb and guaranteed-working sorting algorithm that works well with array X such that the complexity is better than O(n log n), then implement/call that sort :)	2014-12-10 11:52:07		
5286	tenuw	60		2014-12-10 11:52:07		
5287	plapd	60		2014-12-10 11:52:07		
5288	azmjc	60	- Indra Bayu Vrije Universiteit Brussel	2014-12-10 11:52:07		
5289	rrmeu	60	{{  This solution is in Java and its time complexity is O(n).  package arrays;  public class arrangement {  public static void main(String[] args) {  int a_arr[] = {30,40,10,20,70,50,60,100,80,90}; int b_arr[] = {3,4,1,2,7,5,6,10,8,9}; int n = 0; int curr = a_arr[0]; int loc = b_arr[0]; int temp_curr,temp_loc; while(n < a_arr.length) { n++; System.out.println("Iteration :" + n); System.out.println("Curr :" + curr); System.out.println("Location :" + loc);  temp_curr = a_arr[loc-1]; temp_loc = b_arr[loc-1]; if(temp_curr == curr && temp_loc == loc) { n--; curr = a_arr[loc]; loc = b_arr[loc]; continue; } a_arr[loc-1] = curr; b_arr[loc-1] = loc; curr = temp_curr; loc = temp_loc;  }  System.out.println("After completion");  for(int i = 0; i < a_arr.length;i++) { System.out.println("i : " + i); System.out.println("a[i] : " + a_arr[i]); System.out.println("b[i] : " + b_arr[i]); }  }  }       }}	2014-12-10 11:52:07		
5290	ewigy	60	{{ This solution complexity is O(n).  package arrays;  public class arrangement {  public static void main(String[] args) {  int a_arr[] = {30,40,10,20,70,50,60,100,80,90}; int b_arr[] = {3,4,1,2,7,5,6,10,8,9}; int n = 0; int curr = a_arr[0]; int loc = b_arr[0]; int temp_curr,temp_loc; while(n < a_arr.length) { n++; System.out.println("Iteration :" + n); System.out.println("Curr :" + curr); System.out.println("Location :" + loc);  temp_curr = a_arr[loc-1]; temp_loc = b_arr[loc-1]; if(temp_curr == curr && temp_loc == loc) { n--; curr = a_arr[loc]; loc = b_arr[loc]; continue; } a_arr[loc-1] = curr; b_arr[loc-1] = loc; curr = temp_curr; loc = temp_loc;  }  System.out.println("After completion");  for(int i = 0; i < a_arr.length;i++) { System.out.println("i : " + i); System.out.println("a[i] : " + a_arr[i]); System.out.println("b[i] : " + b_arr[i]); }  }  }     }}	2014-12-10 11:52:07		
5291	zeice	60	for (int i=0; i<x.length; i++) { x[i] = x[i] * / ( 10 ^ num of digits in x[i]) x[i] = x[i] + a[i] }  Now use any O (n . log n) algorithm to sort the x  for (int i=0; i<x.length; i++) { x[i] = x[i] - a[i] x[i] = x[i] * ( 10 ^ num of digits in x[i] except zero) }  we are done!	2014-12-10 11:52:07		
5292	ethan	60		2014-12-10 11:52:07		
5293	rrmeu	60		2014-12-10 11:52:07		
5294	azmjc	60	With a little trick, this problem can be easily solved in O(n) time complexity. Below is the code:	2014-12-10 11:52:07		
5295	admin	60		2014-12-10 11:52:07		
5296	dgjji	60		2014-12-10 11:52:07		
5297	ewigy	60	Nice solution !! can you please explain why the modulo operator is needed?	2014-12-10 11:52:07		
5298	fowai	60		2014-12-10 11:52:07		
5299	rdfeo	60		2014-12-10 11:52:07		
5300	vanul	60	Here is a simple O(n) solution:	2014-12-10 11:52:08		
5301	sgiwy	60		2014-12-10 11:52:08		
5302	huiqq	60		2014-12-10 11:52:08		
5303	azmjc	60		2014-12-10 11:52:08		
5304	mrjku	60		2014-12-10 11:52:08		
5305	cfzie	60	private static void arrange() { int [] arr = {17, 5, 1,9}; int [] dup = {2, 1, 3, 0}; int n = dup.length; for (int i =0;i<dup.length;i++) { dup[i] += (dup[dup[i]]%n)*n; }  for (int i =0;i<dup.length;i++) { dup[i] = dup[i]/n; }  for (int j=0;j<dup.length;j++) { dup[j] = arr[dup[j]]; }  for (int j=0;j<dup.length;j++) { arr[j] = dup[j]; } for (int i =0;i<arr.length;i++) { System.out.print(arr[i]+""); } }	2014-12-10 11:52:08		
5306	rdfeo	60		2014-12-10 11:52:08		
5307	fmzze	60		2014-12-10 11:52:08		
5308	ewigy	60	Algo:  1)Assumption is a will contain the numbers less than length of array. So we can first do minus one from each element for ease of writing the algo.  2) change a[a[i]%n] = x[i]*n + a[a[i]%n] 3) Then x[i] = a[i]/n 4) Restore a, by a[i] = a[i]%n;  code:	2014-12-10 11:52:08		
5309	ftfck	60		2014-12-10 11:52:08		
5310	azmjc	60		2014-12-10 11:52:08		
5311	eucmc	60	Here is a simple recursive solution that does not modify the ordering array, and runs in O(n) I borrowed some test case arrays from other answers, i hope that is ok:	2014-12-10 11:52:08		
5312	dkebi	60		2014-12-10 11:52:08		
5313	tenuw	60		2014-12-10 11:52:08		
5314	fmzze	60	Here's an O(n.log(n)) solution. Sort x[] (which can be done in n.log(n)), then for each a[], do a binary search in x[] and swap (n * log(n)). I think this is what the interviewer wanted. Tho, there are better solutions to this like O(n) but that will require additional space complexity (e.g. by indexing a[] first then traversing and swapping elements in x[]).	2014-12-10 11:52:08		
5315	gilit	60		2014-12-10 11:52:08		
5316	bjsiw	60		2014-12-10 11:52:08		
5317	dgjji	60	Note: this handles duplicate integers in x[]. Also, the comments are todos for additional error checking	2014-12-10 11:52:08		
5318	fmzze	60	1. Sort the number array - n log n 2. Do this:	2014-12-10 11:52:08		
5319	qywrh	60		2014-12-10 11:52:08		
5320	nhibd	60		2014-12-10 11:52:08		
5321	fmzze	60	So n log n + n = n log n if I am not wrong.	2014-12-10 11:52:08		
5322	vanul	60	My solution has a big O of (n*logn). Where Arrays.sort has a big O of n*logn and swapping the array values has a big O of (n). Since the solution is O( (n*logn) + n), it is reduce to (n*logn).  Note: Arrays.sort is java built in Merge sort.	2014-12-10 11:52:08		
5323	xhgls	60		2014-12-10 11:52:08		
5324	xhgls	60		2014-12-10 11:52:08		
5325	tenuw	60	This a O(n) C++ code with no extra space. The idea is to keep swapping both x & a based on the indices of a untill a is sorted. In the while loop we only visit each index once, hence is loops n times at the worst case.  void sort_with_aSeq(int a[], int x[], int n) { int ia = 0; while(true){ int ai = a[ia]; swap(a[ai-1], a[ia]); swap(x[ai-1], x[ia]);  while(a[ia] == ia+1) ia++; if(ia == n) break; } } void swap(int &a, int &b){ int tmp = a; a = b; b = tmp; }	2014-12-10 11:52:08		
5326	dgjji	60	here is an O(n) simple solution:	2014-12-10 11:52:08		
5327	gilit	60		2014-12-10 11:52:08		
5328	mrjku	60		2014-12-10 11:52:09		
5329	jippy	60	This is the best solution: O(n) performance, simple logic, and the least code. The code could be even shorter: replace doubleSwap method with regular swap(int arr[], int i, int j), and then calling swap twice inside the the while loop.	2014-12-10 11:52:09		
5330	gilit	60	This seems to be broken code, not sure why it would be O(n) until the array is sorted.	2014-12-10 11:52:09		
5331	nwkeg	61	It's doable in O(N) but not easy. Look up the paper "Selection in X + Y and matrices with sorted rows and columns* ".	2014-12-10 11:52:18		
5332	ethan	61	this is the right answer.	2014-12-10 11:52:18		
5333	fowai	61	But this requires the computation of the elements of the matrix A and that itself has an order of growth n^2. So how is this a O(n) solution for the complete solution?	2014-12-10 11:52:18		
5334	sqzqo	61	I don't think above is the right answer, though I haven't got it either, because the above solution can not work in the following case: a[]: 1 2 3 b[]: 1 4 7	2014-12-10 11:52:18		
5335	ewigy	61	KlogK will be too slow in case if K ~ n^2; It will be approximately N^2log(N^2) I can solve it in exactly N^2 :) just write out every pair a[i] + b[j], and find k-th; in C++ it is builtin function nth_element(); other have to implement nth order median statistics	2014-12-10 11:52:18		
5336	fmzze	61	The time complexity lower bound of this problem is O(klgk) rather than O(n). With a min-heap, we can solve it with O(klgk) time complexity and O(k) space complexity. I'll show you the code later.	2014-12-10 11:52:18		
5337	jippy	61	I think I have same idea, though not in O(k) space complexity. Problem is that k is in range of 1 to n^2, so the time complexity goes to O(n^2 lgn^2).....	2014-12-10 11:52:18		
5338	huiqq	61	@Alexy. 1. when k is up to n^2, actually you need to sort all these n^2 numbers. Since no appropriate linear sorting algorithm can be applied here, the lower bound of a comparison sorting algorithm' time complexity is O(n^2lgn^2)=O(n^2lgn). Theorectically, you can't do it better.  2. Although k is a variable no greater than n^2, O(n^2lgn) is only the upper bound for O(klgk). So O(klgk) is more accurate than O(n^2lgn).	2014-12-10 11:52:18		
5339	rdfeo	61	B.T.W. I just want to clarify the question: do we need k minimum numbers or just the kth number? If only need the kth, we can achieve O(n^2) time complexity by taking "median of medians" algorithm. If we need k mininum numbers, the lower bound of time complexity is O(klgk).	2014-12-10 11:52:18		
5340	ftfck	61	Here's the code. Most of the code is a min_heap implementation.	2014-12-10 11:52:18		
5341	mrjku	61		2014-12-10 11:52:19		
5342	rdfeo	61		2014-12-10 11:52:19		
5343	xhgls	61	Finally I realized that in c++ we can take priority_queue in stl as a heap, thus we would not bother implementing a heap from scratch.	2014-12-10 11:52:19		
5344	rrmeu	61	package careercup;  public class KthMinSum { public static Integer[] find(int k, int[] a, int[] b) { final Integer[] _result = new Integer[k];  int q = (int) Math.sqrt(k);  for (int i = 0; i < q; i++) { for (int j = 0; j < q; j++) { _result[i * q + j] = a[i] + b[j]; } }  int left = 0; int right = 0;  for (int i = q * q; i < k; i++) { _result[i] = (a[q] + b[left]) < (b[q] + a[right]) ? (a[q] + b[left++]) : (b[q] + a[right++]); }  return _result; } }	2014-12-10 11:52:19		
5345	fowai	61	sorry to tell you that this method does not work. For example, a = {1,5,7,35,42}, b = {6,8,9,35,37}, K=3, the expected result is {7,9,10}, but this method returns {7,9,11}	2014-12-10 11:52:19		
5346	sqzqo	61	I'm trying to submit working code for returning first K min sums, but unfortunately system does not allow for me to do it :(	2014-12-10 11:52:19		
5347	huiqq	61	Ooops, please remove duplicated answers ;)	2014-12-10 11:52:19		
5348	mrjku	61	The way I implemented this takes O(K log(K)) time if I use a heap, or O(K^2) if I use a naive sorted array.  Here is the key idea: Obviously, the first pair is A[0] and B[0]. Furthermore, the first pair where we take index "i" from array "A" is indeed (A[i], B[0]). So we can initialize a list of "K" pairs of (A[i], B[0]) for "i = 0, 1, ..., K- 1".  Assume this list is sorted (or Heap with Extract Min). Take first Pair out say, (A[0], B[0]). NOTE: If the next pair leading to K-minimum sum includes (A[0]) it must be (A[0], B[1]). So we simply put the pair (A[0], B[1]) inside. In general, when you extract the pair (A[i], B[j]), you must Insert (A[i], B[j + 1]) back in.  Insertion and Extraction takes O(K) time if you use a simple sorted array, and O(log(K)) if you use a Heap. Overall, it takes, O(K Log(K)) = O(K^2).  Here is what I used for class Pair:	2014-12-10 11:52:19		
5349	tenuw	61		2014-12-10 11:52:19		
5350	bexbp	61		2014-12-10 11:52:19		
5351	qywrh	61	Here is the code for the main for-loop	2014-12-10 11:52:19		
5352	dgjji	61		2014-12-10 11:52:19		
5353	cfzie	61		2014-12-10 11:52:19		
5354	zeice	61	Here is a sample test:	2014-12-10 11:52:19		
5355	rrmeu	61		2014-12-10 11:52:19		
5356	cfzie	61		2014-12-10 11:52:19		
5357	rrmeu	61	Output:	2014-12-10 11:52:19		
5358	dkebi	61		2014-12-10 11:52:19		
5359	gilit	61		2014-12-10 11:52:19		
5360	cfzie	61	My answer is almost the same with yours, but with slight difference. That is, you initialize a list of "K" pairs of (A[i], B[0]) for "i = 0, 1, ..., K- 1", thus form a min heap naturally. But I insert (A[i], B[0]) to the heap only when (A[i-1], B[0]) is extracted from the heap.See my code.	2014-12-10 11:52:19		
5361	dgjji	61		2014-12-10 11:52:19		
5362	vanul	61		2014-12-10 11:52:19		
5363	bjsiw	61	Interesting problem that kept me busy some time but the trick is that arrays are sorted so, given a[0]+b[0] is for sure the first number that is to be produced, what are the next possible sums, well: - S1 = a[a_i+1] + b[b_i]; - S2 = a[a_i+1] + b[0]; - S3 = a[a_i] + b[b_i+1]; - S4 = a[0] + b[b_i+1];  as you want to iterate over each arrays always checking the sum result of the other first array element when you increment either A index or B index. The smallest sum of the above for is the next one given that you: - discard any sum smaller than the previous generated sum - does not go beyond array boundaries  resulting code passing all the test series in this page is:	2014-12-10 11:52:19		
5364	dgjji	61		2014-12-10 11:52:19		
5365	azmjc	61		2014-12-10 11:52:19		
5366	nhibd	61	Consider the following input: a = [ 1, 3, 4, 10 ] b = [ 2, 3, 8, 9] First pair is {1,2} . Iteration 1 selects S3 {1,3} // b_i++ Iteration 2 selects S2 {2,3} // a_i++, b_i=0 Iteration 3 selects S1 {4,2} // a_i++ Iteration 4 selects S3 {4,3} // a_i++ Note that {3,3} is missed and can't be found later since sum has now grown to 7. The {3,3} pair had to be selected at iteration 3 as S3, but there was no criterion to prefer it over S1 as they both yield the same sum. More logic of this type can be added, but the basic truth is there are more than 4 different options at every step. There are actually N options (worst case) as demonstrated by the min-heap based solutions. The pairs sit in a matrix, each row has a cursor running from min to max (two cursors a,b are not enough) and in each step one "row" is selected as having the minimal value. If you don't use a min-heap and just go thru the cursors top-to-bottom, then you can have the following optimization: all the cursors we have not checked yet AND point to columns bigger-equal than ours must have higher-equal values, so can be skipped. Anyway, using min-heap is simpler and faster.	2014-12-10 11:52:19		
5367	bjsiw	61	You are write if was focused on making it simple but turns out that in case you have multiple time the same number it even gets into a locking situation:	2014-12-10 11:52:19		
5368	jippy	61		2014-12-10 11:52:19		
5369	gilit	61		2014-12-10 11:52:19		
5370	bjsiw	61	does not produce at all the expected result !!	2014-12-10 11:52:19		
5371	krxlv	61	How about the following solution, it will run as long as we don't request K to be more then the number of all the possible combinations	2014-12-10 11:52:19		
5372	sgiwy	61		2014-12-10 11:52:19		
5373	admin	61		2014-12-10 11:52:19		
5374	admin	61	sorry, it does not work out. Example, a={1,5,7,35,42}, b={6,8,9,35,37}, K=10, then we expect result as {7,9,10,11,13,13,14,15,16,26}. However, your proposal returns [7, 9, 10, 11, 13, 36, 38, 11, 13, 14].	2014-12-10 11:52:19		
5375	ftfck	61	Finally I worked out it! It can pass all the test cases before! Here is the code:	2014-12-10 11:52:19		
5376	nwkeg	61		2014-12-10 11:52:19		
5377	sqzqo	61		2014-12-10 11:52:19		
5378	ufdxg	61	And with the all test cases:	2014-12-10 11:52:19		
5379	bjsiw	61		2014-12-10 11:52:19		
5380	plapd	61		2014-12-10 11:52:19		
5381	rrmeu	61	I don't think it's O(N). Obviously your function nexIdx() is not O(1).	2014-12-10 11:52:19		
5382	tenuw	61	This is actually a *hard* problem, worth publishing a paper on (if you do it in O(K)).	2014-12-10 11:52:19		
5383	azmjc	61	I have to admit that the algorithm is not straightly O(N). But I think there might be a way to prove that, in the worst case, nextIdx() could be in a limited complexity. Maybe I will think about it later.	2014-12-10 11:52:19		
5384	rrmeu	61	This complexity is O(K^2 log(K)). You are not using some of the information about A and B. We know that A and B are sorted, which implies that you only need the first "K" elements. But that is not all that is implied. If the first "K" elements of A and B are not sorted, then the list of numbers A[i] + B[j] could form (K^2)! different types of orderings. Then, your algorithm might have been optimal since the complexity is that of sorting.  For this problem we know that A and B are sorted. An O(K log(K)) algorithm actually exists). I guess even an O(K) algorithm might exist but as Anonymous said, if it does, it looks very hard to be found.  ** Nevermind, I only saw the second algorithm which you already mentioned is O(N*N)  Also for the first algorithm, in the main loop you are increasing either "i" or "j" by 1 in each iteration. Then each time you also call "nextIdx" which has a for loop running for (N - i) or (N - j) iterations. So the complexity seems to be O(K N).	2014-12-10 11:52:19		
5385	ftfck	61		2014-12-10 11:52:19		
5386	ftfck	61		2014-12-10 11:52:19		
5387	eucmc	61	public class MaxSumsOf2SortedArrays {   public MaxSumsOf2SortedArrays() { a = new int[]{0, 1, 3, 5}; b = new int[]{1, 2, 4, 7}; } int[] a;int[] b;  void findMax(int K){ int a1=0;int a2=1; int b1=0;int b2=1; int count = 0; System.out.println(a[0]+b[0]); while(count<K && count<=a.length*b.length){ count++;  int aSum = a[a1]+b[a2]; int bSum = b[b1]+a[b2]; if(aSum<=bSum){ System.out.println(aSum + "--"+a[a1]+"+"+b[a2]); a2++; if(a2==b.length){ a1++; a2=a1; }  } else{ System.out.println(bSum+ "--"+b[b1]+"+"+a[b2]); b2++; if(b2==a.length){ b1++; b2=b1; }  } }  }  public static void main(String[] args) { // TODO Auto-generated method stub MaxSumsOf2SortedArrays m = new MaxSumsOf2SortedArrays(); m.findMax(100);  } }	2014-12-10 11:52:19		
5388	admin	61	O(n) algorithm was proposed from this paper www dot cse dot yorku dot ca/~andy/pubs/X+Y.pdf, however it doesn't fit for an interview.	2014-12-10 11:52:19		
5389	nhibd	61		2014-12-10 11:52:19		
5390	plapd	61		2014-12-10 11:52:19		
5391	azmjc	61	Minimum value will be a[0] + b[j] or a[i] + b[0]  so the answer is	2014-12-10 11:52:19		
5392	nhibd	61		2014-12-10 11:52:19		
5393	dgjji	61		2014-12-10 11:52:19		
5394	rdfeo	61	Minimum value will be a[0] + b[j] or a[i] + b[0] Note# a[0] + b[0] is the special case, we need to be careful for this case. k > N case is also special case.  so the answer is	2014-12-10 11:52:19		
5395	fowai	61		2014-12-10 11:52:19		
5396	cfzie	61		2014-12-10 11:52:19		
5397	nhibd	61	A (klog k) Soluton	2014-12-10 11:52:19		
5398	bjsiw	61		2014-12-10 11:52:19		
5399	tenuw	61		2014-12-10 11:52:19		
5400	dkebi	61	Since both are sorted array,The first element of both the array will be minimum. So the sum a[0]+b[0] will be less than any of other a[i]+b[j]  so the answer is straight  A[0] + B[0]	2014-12-10 11:52:19		
5401	fowai	61	k = 1: a[0] + b[0] k = 2: min(a[0] + b[1], a[1] + b[0]) k = 3: max(a[0] + b[1], a[1] + b[0]) k = 4: a[1] + b[1] ... k = 3n-1: min(a[n-1] + b[n], a[n-1] + b[n]) k = 3n: max(a[n-1] + b[n], a[n-1] + b[n]) k = 3n + 1: a[n] + b[n] k = 3	2014-12-10 11:52:19		
5402	krxlv	61	Here is the code that was implemented based on the above generalization.	2014-12-10 11:52:19		
5403	wbqzu	61		2014-12-10 11:52:19		
5404	sgiwy	61		2014-12-10 11:52:19		
5405	krxlv	61	Please tell me how wrong I am:	2014-12-10 11:52:19		
5406	ftfck	61		2014-12-10 11:52:19		
5407	bjsiw	61		2014-12-10 11:52:19		
5408	rdfeo	61	Nick, This will not work. consider a: 1, 30, 35 b: 5,6,50 your code will return k=1: 1+5=6 ok k=2: 30+5=35 (not ok as the real answer is 1+6 =7)	2014-12-10 11:52:19		
5409	gilit	61		2014-12-10 11:52:19		
5410	krxlv	61		2014-12-10 11:52:19		
5411	bjsiw	61	I think this is correct way.... any use-case invalidating this solution ?	2014-12-10 11:52:20		
5412	ftfck	61	Consider the example: a: 1, 30, 35 b: 5,6,50  k = 1 : 1 + 5 k = 2 : 1 + 6 k = 3 : correct ans: (30 + 5) your algo: (30 + 6)	2014-12-10 11:52:20		
5413	gilit	61	you do not need to calculate sums inside the loop. Just keep track of the indexes.	2014-12-10 11:52:20		
5414	zeice	61		2014-12-10 11:52:20		
5415	zeice	61		2014-12-10 11:52:20		
5416	jippy	61	This doesn't work, it skips some numbers. For example, if the sequence of mins goes like that: a[0] + b[1] a[1] + b[1] a[0] + b[2] We need to go backwards sometimes.  If consider a matrix where each cell contains summation of array elements, then next min is a cell adjacent to ANY explored cell not only current cell... hopefully that make sense	2014-12-10 11:52:20		
5417	bexbp	61	Got it finally: (1)do merge process, record each item is from a[] or b[]. (2)find the Kth smallest pair(remember a pair must be one from a[], the other from b[]).  time complexity: O(N) space complexity: O(N)  As I'm more familiar with C++, following is my C++ code with annotation:	2014-12-10 11:52:20		
5418	admin	61		2014-12-10 11:52:20		
5419	plapd	61		2014-12-10 11:52:20		
5420	ethan	61	I think your answer is wrong. Your program can not pass the following test data. int a[] = {0, 1, 3, 5}; int b[] = {1, 2, 4, 7};	2014-12-10 11:52:20		
5421	wbqzu	61	You are right. The above solution is not correct. I'm Sorry.	2014-12-10 11:52:20		
5422	fmzze	61	public int kthMinimum(int a[], int b[], int k){ ArrayList<Integer> temp = new ArrayList<Integer>(); for(int i=0; i<a.length-1; i++){ for(int j=0; j<b.length-1; j++){ temp.add(a[i]+b[j]); } } Collections.sort(temp); return temp.get(k); }	2014-12-10 11:52:20		
5423	ewigy	61		2014-12-10 11:52:20		
5424	xhgls	61		2014-12-10 11:52:20		
5425	ewigy	61	dont keep computing sums inside the loop. Just need to keep track of which is the kth min and (k+1)th min number in combined array.	2014-12-10 11:52:20		
5426	rrmeu	61		2014-12-10 11:52:20		
5427	dgjji	61		2014-12-10 11:52:20		
5428	xhgls	61	Sorry but i am not sure you code works in the following case: a[] = {100,200,300,400} b[] = {1,2,3,4} k = 1 the result should be 100+1 neither pMin nor PMinLast will point to a.	2014-12-10 11:52:20		
5429	rdfeo	61		2014-12-10 11:52:20		
5430	jippy	61		2014-12-10 11:52:20		
5431	xhgls	61	Like Alexey mentioned below, this doesn't work. Downvoting so it doesnt show up as top voted result (which it currently does)  "a = new int[] { 1, 2, 3,4,5,7,8,9,10 }; b = new int[]{1,20,30,40,50,60,70,80,90,100}; doesnt work  Also, k can be up to n^2, so the first double loop can take n^2  - Alexey on December 18, 2013 | Flag"	2014-12-10 11:52:20		
5432	azmjc	61		2014-12-10 11:52:20		
5433	qywrh	61		2014-12-10 11:52:20		
5434	xhgls	61	a = new int[] { 1, 2, 3,4,5,7,8,9,10 }; b = new int[]{1,20,30,40,50,60,70,80,90,100}; doesnt work  Also, k can be up to n^2, so the first double loop can take n^2	2014-12-10 11:52:20		
5435	gilit	61	thanks for review. That was big fail ;)  > Also, k can be up to n^2, so the first double loop can take n^2  in original problem need to return first K elements, not just Kth element which was described as PS, that's why at least need to fill K elements. So algorithm's expected complexity is O(K). If K is equal to max value n^2, do you know any algorithm which fill n^2 elements in O(N)?	2014-12-10 11:52:20		
5436	ethan	61		2014-12-10 11:52:20		
5437	plapd	61		2014-12-10 11:52:20		
5438	azmjc	61		2014-12-10 11:52:20		
5439	zeice	61		2014-12-10 11:52:20		
5440	ethan	61	slight correction: last line should read	2014-12-10 11:52:20		
5441	vanul	61		2014-12-10 11:52:20		
5442	ethan	61		2014-12-10 11:52:20		
5443	rrmeu	61	like merge sort, increase pointers from a and b. You do not need to calculate the min values, you just count the min values while increasing the pointers. And when you exceed the desired k, you can calculate a[i] + b[j] for the kth min.	2014-12-10 11:52:20		
5444	huiqq	61		2014-12-10 11:52:20		
5445	huiqq	61		2014-12-10 11:52:20		
5446	dkebi	61	Ooops, it does not work for	2014-12-10 11:52:20		
5447	plapd	61		2014-12-10 11:52:20		
5448	wbqzu	61		2014-12-10 11:52:20		
5449	nwkeg	61	O(n) algorithm: suppose you have initial minimum: a[i]+b[j] To find next minimum you need to test the following 4-6 pairs and find the pair with minimum sum that is greater than the current one. Rinse-repeat K times.  Code:	2014-12-10 11:52:20		
5450	nwkeg	61		2014-12-10 11:52:20		
5451	ewigy	61		2014-12-10 11:52:20		
5452	tenuw	61	Oops, forgot to write up pairs in explanations  Here goes: current min is a[i]+b[j]; next min will be amongs a[i-1]+b[j+1] // test only if i>0 a[i+1]+b[j-1] // test only if j>0 a[i]+b[j+1] // if j+1 is out of bound test a[i+1]+b[0] instead a[i+1]+b[j] // if i+1 is out of bound test a[0]+b[j+1] instead  amongst these candidates your next minimum is the smallest one which is greater than the current minimum.	2014-12-10 11:52:20		
5453	wbqzu	61		2014-12-10 11:52:20		
5454	sqzqo	61		2014-12-10 11:52:20		
5455	ufdxg	61	This doesn't work with these inputs:  A: (1,4,20,24) B: (1,21,22,25)  1st min: 1+1 2nd min: 4+1 3rd min: 1+20 4th min should be 1+21 but with your method it doesn't check the i=0 in this step.	2014-12-10 11:52:20		
5456	krxlv	61	Minimum value will be a[0] + b[j] or a[i] + b[0]  so the answer is	2014-12-10 11:52:20		
5457	azmjc	61		2014-12-10 11:52:20		
5458	xhgls	61		2014-12-10 11:52:20		
5459	sqzqo	61	Since both are sorted array,The first element of both the array will be minimum. So the sum a[0]+b[0] will be less than any of other a[i]+b[j]  so the answer is straight  A[0] + B[0]	2014-12-10 11:52:20		
5460	wbqzu	61	I think your solution ignores the "first K" part, which sounds like a k-th order statistic.	2014-12-10 11:52:20		
5461	krxlv	61	Can we reuse the same array's elements to compute multiple sums? I mean for this ex and K = 4: a[]: 1 2 3 b[]: 1 4 7 The correct answer is 1+1, 2 + 1, 3+1, 1+4 ?	2014-12-10 11:52:20		
5462	nwkeg	61	I am sure it is..	2014-12-10 11:52:20		
5463	wbqzu	62	Sort the array. The largest numbers should be in the least significant positions, so build up your two integers by alternating from the two arrays. E.g. 1 3 5 7 8 9 => 1 and 3, then 15 and 37, then 158 and 379. 0 is a special case, if not allowed to use that as a leading digit then have to use it as the second digit.	2014-12-10 11:52:21		
5464	fmzze	62	And why does it work? Because it's clearly not how two numbers in the answer are built however the answer is the same - 207.	2014-12-10 11:52:21		
5465	vanul	62	Try adding two numbers, you would find all that matters is the order of magnitude of a digit and not which of the two numbers that a digit belongs. (e.g. 178+29 = 128+79 = 179+28 = 129+78)	2014-12-10 11:52:21		
5466	gilit	62	nice one Mr. Manoj	2014-12-10 11:52:21		
5467	ftfck	62	My approach was to create two vectors with alternate elements after sorting the original vector in O(nlogn) time complexity. Then sum each vector's digit. Written in C++.  Output:	2014-12-10 11:52:21		
5468	rrmeu	62		2014-12-10 11:52:21		
5469	nhibd	62		2014-12-10 11:52:21		
5470	ewigy	62	Code:	2014-12-10 11:52:22		
5471	huiqq	62		2014-12-10 11:52:22		
5472	rrmeu	62		2014-12-10 11:52:22		
5473	qywrh	62	for sorting array of digits, we have linear ( O(n) ) algorithms, e.g. counting sort.	2014-12-10 11:52:22		
5474	ufdxg	62	the code does not work for inputs that contain zeros, like 11110. For this input sum should be 112, instead I get 22.	2014-12-10 11:52:22		
5475	gilit	62	@azil Can you explain why 11110 should be 112?	2014-12-10 11:52:22		
5476	sgiwy	62	because the smallest numbers that can be created of those digits are 101 and 11 and their sum is 112.	2014-12-10 11:52:22		
5477	mrjku	62	@azil. Ok, and what about 011 + 11? The sum is 22. All the digits are contained in the array and it's the smallest sum.	2014-12-10 11:52:22		
5478	rrmeu	62	Best answer ever.	2014-12-10 11:52:22		
5479	qywrh	62	Why does the approach work?	2014-12-10 11:52:22		
5480	bexbp	62	To make sum minimum, both of its operands should also be minimum. For given set of digits, a number will be minimum when smallest unused digit appears at higher positional value. Having sorted array of digits makes it easy, just give next available smallest number to higher position to each number. Code is as follows -	2014-12-10 11:52:22		
5481	zeice	62		2014-12-10 11:52:22		
5482	krxlv	62		2014-12-10 11:52:22		
5483	mrjku	62		2014-12-10 11:52:22		
5484	dkebi	62		2014-12-10 11:52:22		
5485	qywrh	62	You should handled if X[0]=0	2014-12-10 11:52:22		
5486	gilit	62	kidding code boy	2014-12-10 11:52:22		
5487	tenuw	62	1 - You create too many redundunt String objects 2 - You don't process zeros. For example if you have {0, 0, 1, 2} sorted input array your sum will be 01 + 02 = 3. But I think it should be 10 + 20 = 30	2014-12-10 11:52:22		
5488	fmzze	62	public void findMinSum(int[] x){ Arrays.sort(x); String first = ""; String second = ""; for(int i=0; i<x.length; i=i+2) { first+=x[i]; second+=x[i+1]; } int num1 = Integer.parseInt(first); int num2 = Integer.parseInt(second); System.out.println("Numbers are : " + first + " and " + second); System.out.println("Sum is : " + (num1+num2)); }	2014-12-10 11:52:22		
5489	bexbp	62	@Pirate : If the input digits are 3,5,7,9 ; then your code will return 3579 for string 2 (definitely not the minimal sum) . I guess the minimal sum here would be 37 + 59 = 96.  Can you please elaborate on your algorithm?	2014-12-10 11:52:22		
5490	sqzqo	62		2014-12-10 11:52:22		
5491	dkebi	62		2014-12-10 11:52:22		
5492	jippy	62	}	2014-12-10 11:52:22		
5493	mrjku	62	Strange "programming language used" comment in there...  And yeah, strange language used (php! Yuck!).	2014-12-10 11:52:22		
5494	xhgls	62	You should revisit this condition inside the while loop.	2014-12-10 11:52:22		
5495	krxlv	62		2014-12-10 11:52:23		
5496	plapd	62		2014-12-10 11:52:23		
5497	wbqzu	62	Reason: You're accessing the next two indexes of $i inside the while loop. But checking only the existence of $i.	2014-12-10 11:52:23		
5498	zeice	62		2014-12-10 11:52:23		
5499	qywrh	62		2014-12-10 11:52:23		
5500	ufdxg	62	This is some thing that looks easy but very tough when u check with all possible values. I have got the answer finally..	2014-12-10 11:52:23		
5501	ftfck	62		2014-12-10 11:52:23		
5502	azmjc	62		2014-12-10 11:52:23		
5503	azmjc	62	Why not explain an algorithm rather than giving a program?	2014-12-10 11:52:23		
5504	admin	62	@confused_banda, May be because developers understand program better than reading the text :)	2014-12-10 11:52:23		
5505	admin	62	algo would be like this: 1. Sort array O(nlogn) 2. Divide the array in two parts and add that two parts , if length of array is not even then take even no. of elements in first part and odd number of elements in second part and then add them up. - O(n) 2.a If array contain 0(zero) then take starting point of array from non zero element.  So total complexity would be O(nlogn) + O(n) = O(nlogn) Please let me know if there is an negative test case.	2014-12-10 11:52:23		
5506	ftfck	62	From looking over the example given your algo does not give the right solution  1 8 2 9 7 => 1 2 7 8 9 => 12 + 789 = 901 which is not the right answer.  Even if you split it correctly (adding the ODD number of numbers, in the beginning, to the EVEN number left)  127 + 89 = 216 which is still not the right answer of 207.  The correct solutions would be 129 + 78 or 178 + 29	2014-12-10 11:52:23		
5507	xhgls	62	1. Sort the numbers using a linear sort (O(n)) 2. int x=0, y=0 3. While(i < n) { if(i%2 == 0) { x *= 10 + a[i]; } else { y *= 10 + a[i]; } } min_sum = x + y;	2014-12-10 11:52:23		
5508	sqzqo	62	Since the sum has to be minimum, implies 1) both the numbers are supposed to in ascending order 2) length of both the numbers should be half the length of array. 3) The minimum number in the array has to be the as the starting(first) number of either of the two numbers to be found. assume 1,2,7,8,9 - then 1 has to be first number in either of the two numbers to be found (127).  Steps a) sort the array in ascending order. b) Take the first element of the array (minimum in the array) as the starting of either of the numbers to be found. c) Now first element of a number to be found is fixed. Have a global variable min initialized to a high value. d) As in the example you have to choose numbers among 2,7,8,9 and in (b) we chose 1 as a part of a number to be found. e) Now as for the (2) point one number will be of length 3, another will be of length 2. f) Get 2 numbers from the array left 2,7,8,9 to be grouped with 1 (already choosen). for instance 27 89, remember both the numbers here should be in ascending order (1). No of ways to choose two numbers here are 6 [4!/(2!*2!)]. g) Now we can have 127 and 89 or 189 or 27 sum and compare both, next 28 is chosen another will be 79 again do sum and comparision, In short this logic is exactly same as Subset sum problem (Dynamic Programming) logic, with a slight modification. Using recursion you can find the two numbers from the array 2,7,8,9 associate each of them with 1 and check whether it's minimum. h) For handling zeros in the array, after the sort neglect all the zeros and start the work with the fresh array with no zeros. 2,7,8,9  27,89 => 127,89 or 27,189 28,79 => 128,79 or 179,28 29,78 => 129,78 or 178,29  Hence the six combinations.	2014-12-10 11:52:23		
5509	mrjku	62	Assuming all the number are position (including zero) 1) Sort the array in ascending order 2) Ignore all the leading zeros and assume that list starts from the first non-zero number 3) For all non-zero numbers, make number at position 1 first digit of first number and number at position 2 first digit of second number. Make number at position 3 the second digit of first number ans number at position 4 the second digit of second number and keep going like this until the end of list reached. Example: sorted list: 1 2 3 4 5 6 First Number: 1 Second Number: 2 First Number: 13 Second Number: 24 First Number:135 Second Number 246 Solution 135 + 246 = 381	2014-12-10 11:52:23		
5510	nhibd	62	Python code:  a = [1, 2, 7, 8, 9] a.sort()  n1=n2=''  for i in range(0, len(a)): if i % 2 == 0: n1 = n1 + str(a[i]) else: n2 = n2 + str(a[i])  print 'First number: %s'%n1 print 'Second number: %s'%n2	2014-12-10 11:52:23		
5511	sqzqo	62	Python code:  a = [1, 2, 7, 8, 9] a.sort()  n1=n2=''  for i in range(0, len(a)): if i % 2 == 0: n1 = n1 + str(a[i]) else: n2 = n2 + str(a[i])  print 'First number: %s'%n1 print 'Second number: %s'%n2	2014-12-10 11:52:23		
5512	bjsiw	62	Three questions: Can highest magnitude digits be 0? Is the array size constrained? Can digits be duplicated in the array?	2014-12-10 11:52:23		
5513	bexbp	62	Here my solution in C++... you all should handle different length for a and b giving the min sum:  int get_front_rm_front(std::vector<int> &vec, int &ten_unit) { int r = vec.front() * ten_unit; ten_unit /= 10; vec.erase(vec.begin()); return r; }  std::pair<int,int> find_min_sum(std::vector<int> &vec) { int len_first = (vec.size() / 2) + vec.size() % 2; int len_second = vec.size() / 2; int first_ten_unit = pow(10, len_first-1); int second_ten_unit = pow(10, len_second-1); int first = 0; int second = 0;  if(vec.size() < 2) { return std::pair<int,int>(0,0); }  std::sort(vec.begin(), vec.end());  if(len_first > len_second) { first += get_front_rm_front(vec, first_ten_unit); }  while(vec.size() > 1) { if(first > second) { first += get_front_rm_front(vec, first_ten_unit); second += get_front_rm_front(vec, second_ten_unit); } else { second += get_front_rm_front(vec, second_ten_unit); first += get_front_rm_front(vec, first_ten_unit); } }  return std::pair<int,int>(first,second); }	2014-12-10 11:52:23		
5514	fowai	62		2014-12-10 11:52:23		
5515	bexbp	62		2014-12-10 11:52:23		
5516	qywrh	62	After sorting the array: Basically there are two cases: 1) If the number of digits are even: first two digits are multiplied with 10^(mid-1) each and added second two digits are multiplied with 10^(mid -2) each and added and so on.. 2)odd: first digit is multiplied with 10^mid.. and so on as in 1 above The theory is digit at highest place value should be least for both numbers..	2014-12-10 11:52:23		
5517	rrmeu	62		2014-12-10 11:52:23		
5518	rdfeo	62		2014-12-10 11:52:23		
5519	tenuw	62	#include <stdio.h> #include <stdlib.h> #include <ctype.h>  #define MAX_SIZE 10  void sort_arr(int arr[], size_t aSize) { int i, j, temp;  for ( i = 0; i < aSize - 1; i++) { for (j = i + 1 ; j < aSize ; j++) { if ( arr [ i ] > arr[j ] ) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } }   int make_min_sum(int arr[], int size) { int i=0; int num1=0, num2=0, temp;  while ( i < size ) { while ( i <= size /2) { if ( i == size / 2) { num1 = num1 + arr[size -1]; num1 = num1 * 10; temp = i++; break; } num1 = num1 + arr[i]; num1 = num1 * 10; i++; }  if ( i == size -1) { num2 = num2 + arr[temp]; num2 = num2 * 10; break; }  num2 = num2 + arr[temp]; temp = i; num2 = num2 * 10; i++; }  return (num1 + num2) / 10; }  int main(int argc, char **argv) {  int arr[MAX_SIZE]; char str[3]; int sum, size = 0; int i, i_val, num;  printf("Enter number"); gets(str); num = atoi(str);  while (num != 0) { i_val = num % 10; arr[size++] = i_val; num = num /10; }  sort_arr(arr, size);  printf("arr elements are after sort:\n"); for ( i = 0; i < size; i++) printf("%d", arr[i]);  sum = make_min_sum(arr, size);  printf("min sum :%d\n", sum);  return 0; }	2014-12-10 11:52:23		
5520	dkebi	62	1) Arrange the elements in array in ascending order 2) make two sub arrays with half of the length each ( if total digits are 6, one with 3 and other with 3 and if total is 5 one with 3 and other with 2). 3) Now lowest element to first array and then next lowest to second and so on. 4) Logic is simple, we should have lowest values in most significant bit.  Below program is in java. I just written so casually. but it gives the solution	2014-12-10 11:52:23		
5521	bjsiw	62		2014-12-10 11:52:23		
5522	tenuw	62		2014-12-10 11:52:23		
5523	azmjc	62		2014-12-10 11:52:23		
5524	ewigy	62		2014-12-10 11:52:23		
5525	cfzie	62	Here's my attempt, done in Java.	2014-12-10 11:52:23		
5526	vanul	62		2014-12-10 11:52:23		
5527	krxlv	62		2014-12-10 11:52:23		
5528	bjsiw	62	}  Output:	2014-12-10 11:52:23		
5529	bexbp	62		2014-12-10 11:52:23		
5530	nwkeg	62		2014-12-10 11:52:23		
5531	huiqq	62		2014-12-10 11:52:23		
5532	ftfck	62		2014-12-10 11:52:23		
5533	dgjji	62	the example given in the question wont work	2014-12-10 11:52:23		
5534	vanul	62	gggg, it outputs 207, which is the correct answer.	2014-12-10 11:52:23		
5535	tenuw	62	only sum is asked no need to generate both the numbers	2014-12-10 11:52:23		
5536	fmzze	62		2014-12-10 11:52:23		
5537	jippy	62		2014-12-10 11:52:23		
5538	rdfeo	62	just generate the sum;	2014-12-10 11:52:23		
5539	cfzie	62	instead of starting from the start of the sorted array we can try from end please find the algo  1) sort the array 2)two numbers A,B(initialize to 0) 3)A=last element of array 4)i=last-1 5)if(i<0) return (A+B) 6)if(A<B) go to 7 else goto 8 7)A=pow(10,lengthof(A)) + array[i], goto 9 8)B=pow(10, lenghtof(B)) + array[i] 9)i--; goto 5.	2014-12-10 11:52:23		
5540	cfzie	62	I found a simple solution Array : {1 2 7 8 9} Assumption : Array is sorted  Output : need to construct the 2numbers from array numbers such that sum is min  Solution :  1)num1=num2=0 2)mul1=mul2=1 3)for(int i=0;i<arr.len;i++) { if(i%2 = 0 && arr[i] !=0) { num1=arr[i]*mul1 ; mul1*=10; } else if(arr[i]!=0) { num2=arr[i]*mul2; mul2*=10; } } 4)Print num1 and num2 5) So min sum is num1+num2	2014-12-10 11:52:23		
5541	bjsiw	62		2014-12-10 11:52:23		
5542	bjsiw	62		2014-12-10 11:52:23		
5543	krxlv	62	- Remove the zeros - Sort the the digits - First number will be number formed with digits with even indices - Second number will be number formed with digits with odd indices  For example, if input is 845101420023  When the zeroes are remove it becomes 845114223 When it is sorted it becomes 112234458 First number: 12348 Second number: 1245	2014-12-10 11:52:23		
5544	azmjc	62	Suppose this array is sorted. coding as below. #include <stdio.h>  #define ARRAY_NULL 1 int main(int argc, char **argv){ if(array = NULL){ return ARRAY_NULL; } int first_int = 0; int second_int = 0; int length;  length = sizeof(array); for(int i = 0; i < length; i++){ if(i % 2){ first_int = first_int * 10 + array[i]; } else{ second_int = second_int * 10 + array[i]; } } printf("The least sum number is : %d = %d + %d\n", first_int+second_int, first_int, second_int); return 0; }	2014-12-10 11:52:23		
5545	krxlv	62	Suppose this array is sorted. coding as below. #include <stdio.h>  #define ARRAY_NULL 1 int main(int argc, char **argv){ if(array = NULL){ return ARRAY_NULL; } int first_int = 0; int second_int = 0; int length;  length = sizeof(array); for(int i = 0; i < length; i++){ if(i % 2){ first_int = first_int * 10 + array[i]; } else{ second_int = second_int * 10 + array[i]; } } printf("The least sum number is : %d = %d + %d\n", first_int+second_int, first_int, second_int); return 0; }  If this array not be sorted, we will sort it first.	2014-12-10 11:52:23		
5546	azmjc	62	1. Sort the array. 2. Use two temporary number for the two integer. Append the next digit to them in turn. 3. Use a temporary variable to remember the leading 0s. When the first non-zero digit is found, add it to the head.	2014-12-10 11:52:23		
5547	sqzqo	62		2014-12-10 11:52:23		
5548	sgiwy	62		2014-12-10 11:52:23		
5549	ftfck	62	public static int findMinimum(int[] arr) { Arrays.sort(arr); int i = 0; while (arr[i] == 0) { i++; } if (arr.length - i < 2) { return -1; } swap(arr, 0, i); swap(arr, 1, i + 1); int value = 0; int start = 0; if (arr.length % 2 == 1) { value = arr[0]; start++; } for (int k = start; k < arr.length; k += 2) { value = 10 * value + arr[k] + arr[k + 1]; } return value; }  private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }	2014-12-10 11:52:23		
5550	wbqzu	62	#include <iostream> #include <algorithm> #include <string> using namespace std;  int min_sum(int *a, int len) { int size= len-1, flag=0; int unit1=0,unit2=0,tens1=0,tens2=0,hundreds1=0,hundreds2=0; int thousands1=0,thousands2=0,tenthousands1=0,tenthousands2=0; int num1=0,num2=0;  cout << "Total number of elements in array =" << len << "\n";  unit1=a[size]; size--; //cout << size; unit2=a[size]; size--; //cout << size;  if (size>=0) { tens1=a[size]; size--; }  if (size>=0) { tens2=a[size]; size--; }   if (size>=0) hundreds1=a[size]; size--;  if (size>=0) hundreds2=a[size--];  if (size>=0) thousands1=a[size--];  if (size>=0) thousands2=a[size--];  if (size>=0) tenthousands1=a[size--];  if (size>=0) tenthousands2=a[size--];   num1 = unit1 + tens1 * 10 + hundreds1 * 100 + thousands1 * 1000 + tenthousands1 * 10000; num2 = unit2 + tens2 * 10 + hundreds2 * 100 + thousands2 * 1000 + tenthousands2 * 10000;  for (int i=0;i<len;i++) { if (a[i]==0) flag++; }  int t1=num1,t2=num2;  while(t1) { t1=t1/10; cout << "\n t1=" << t1; }  if(flag--) num2=num2 * 10; if(flag--) num1=num1 * 10;  cout << "The two numbers which form min sum are:\n" << num1 << "\t" << num2 << "\n"; cout << "Minimum sum required = " << num1+num2 << "\n";  return 1;  }  int sort_it (int *a, int len) {  int i,j,temp; for (i=0;i<len;i++) { for (j=0;j<len-1-i;j++) { if (a[j]>a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } }  cout<< "\n{\t";  for (int i=0; i<len; i++) { cout << a[i]<< "\t"; }  cout<< "\t}\n"; }  int main() { int array[]= {1,9,0,2}; //{9,2,7,5,7,2,1,5,4,6}; //{1,3,5,3}; //{1,2,7,8,9}; //{ 2,7,6,5,3,4,8,9,1};  int len= sizeof(array)/sizeof(array[0]);   cout<< "{\t";  for (int i=0; i<len; i++) { cout << array[i]<< "\t"; }  cout<< "\t}";  sort_it(array,len); min_sum(array,len);  return 0; }	2014-12-10 11:52:23		
5551	nhibd	62		2014-12-10 11:52:23		
5552	ufdxg	62		2014-12-10 11:52:23		
5553	sgiwy	62	Slightly different approach than much of what has already been posted.  1) Assume that the list is sorted 2) Note that when we do our sum, digits in the same position can exist in either number and provide the same result: eg, 145 + 39 vs 135 + 49. This solution provides only the sum, not the list of possible ways to get there. 3) backtrack through the numbers to put digits in their right spots right away	2014-12-10 11:52:23		
5554	sqzqo	62		2014-12-10 11:52:23		
5555	bexbp	62		2014-12-10 11:52:23		
5556	ftfck	62	If we assume that numbers starting with 0 (like 017) are invalid, that doesn't mean we should throw out all zeros, as someone previously stated. We could still have 107. In this case after you do your initial sort you should move the zeros so they start at the 3rd index, and move the first 2 integers after the zeros the the first two index. You can check out the Matlab code at my blog meditationsofmarcus.blogspot.com. I'll also include it here. I didn't try to make it very clean:	2014-12-10 11:52:23		
5557	cfzie	62		2014-12-10 11:52:23		
5558	ftfck	62		2014-12-10 11:52:23		
5559	sqzqo	62	Firstly, the elements in the array can belong to a finite set {0-9}. So, instead of sorting the array, just a class that can handle such frequency distribution will do. Creation of an instance and population of data will take place in linear time Secondly, allowing 0 in the input array makes sense only if leading zeros were not allowed, otherwise, a linear time pre-processing can get rid of all the zeros. So, I have made a separate function to handle such a case which is invoked only if leading zeros are not allowed  Input format : t //number of test cases {//each test case n//number of elements in array za//=1 if leading zeros are not allowedother wise !=1 <ai> ith element of array } test cases that I have tested upon : 6 5 0 1 2 7 8 9 5 1 0 2 7 8 9 5 1 1 8 2 9 7 5 1 0 0 0 6 7 5 0 0 0 0 6 7 10 1 9 2 7 5 7 2 1 5 4 6 Expected output: 207//as given 287//208+79 : leading zero not allowed 207//just another permutation of given test case 670//600+70 : leading zero not allowed 13//006+07 : leading zero allowed 37146//12567+ 24579  Code :	2014-12-10 11:52:24		
5560	nwkeg	62		2014-12-10 11:52:24		
5561	jippy	62		2014-12-10 11:52:24		
5562	admin	62		2014-12-10 11:52:24		
5563	rdfeo	62		2014-12-10 11:52:24		
5564	wbqzu	62		2014-12-10 11:52:24		
5565	dkebi	62		2014-12-10 11:52:24		
5566	tenuw	62	Sort the array. Then take the larger digits higher then zero. Then insert zeros in a way that that satisfies the requirement.  Sorting in the code is done using a library function, but it can be achieved in O(n) using counting sort. The remaining code is O(n), so its O(n) overall...	2014-12-10 11:52:24		
5567	gilit	62		2014-12-10 11:52:24		
5568	tenuw	62		2014-12-10 11:52:24		
5569	mrjku	62		2014-12-10 11:52:24		
5570	wbqzu	62		2014-12-10 11:52:24		
5571	eucmc	62		2014-12-10 11:52:24		
5572	nhibd	62		2014-12-10 11:52:24		
5573	ftfck	62		2014-12-10 11:52:24		
5574	vanul	62		2014-12-10 11:52:24		
5575	nhibd	62	Why is it voted down? It is absolutely right.	2014-12-10 11:52:24		
5576	dkebi	62	Is there a reason why this one is not right?	2014-12-10 11:52:24		
5577	ufdxg	62	you should not have 0 in the example	2014-12-10 11:52:24		
5578	mrjku	63	The "SLIDING WINDOW" proposed by ninhnnsoc is a great idea. But his answer is not the best. Basically, "SLIDING WINDOW" has four key attributes: 1) window_sum: sum of all numbers in the window. 2) wL: left index of the window, initialized to be 0; 3) wR: right index of the window, initialized to be 0, also; 4) minimum_sequence_length: the final answer, initialized to be INT_MAX;  The algorithm is basically a while-loop. while (wR < array_size) { Move_wR(); // Find the next wR, window_sum > S; Move_wL(); // Remove unnecessary left numbers; UpdateMinimumSequenceLength(); }  //Note the window_sum should always larger than S, except: 1) in the initialization phase. 2) There is no solution to the question, (minimum_sequence_length == INT_MAX)	2014-12-10 11:52:25		
5579	fmzze	63	Thanks.	2014-12-10 11:52:25		
5580	dgjji	63	Thanks for providing a better answer. Your basic while-loop is really nice!  One thing I was concerned is how to work with negative numbers. (My implementation does).  Your answer can also deal with negative numbers, with a bit elaboration.	2014-12-10 11:52:25		
5581	ewigy	63	Hi, ninhnnsoc, Thanks, It is a lot fun to code here. I append the Logic in Move_wR(): 1) At least move +1 to the right. 2) If array[wR] < 0, (negative), keep going to the right. ("negative numbers in boundary" never be a solution, so no need to check) 3) If window_sum < 0, start a new window. wR + 1 and wL = wR; (It means "The left side will never be part of a solution", so drop the numbers and strat over)	2014-12-10 11:52:25		
5582	huiqq	63	how about move_wL(), is there anything to clarify?	2014-12-10 11:52:25		
5583	sgiwy	63	move_wR() guarantees that window_sum > S, the responsibility of move_wL() is to shrink the left side to find the minimum size. It is exactly the same with your solution. hah	2014-12-10 11:52:25		
5584	xhgls	63	/* here is the code n is number of elements in array wl is left boundry of minimum sequence initailly passed as zero wr is right boundry of minimum sequence initailly passed as zero S is the given sum */	2014-12-10 11:52:25		
5585	bexbp	63		2014-12-10 11:52:25		
5586	fmzze	63		2014-12-10 11:52:25		
5587	wbqzu	63	what if the input sum is negative?	2014-12-10 11:52:25		
5588	jippy	63	Implementation below - it seems to work fine.	2014-12-10 11:52:25		
5589	ufdxg	63		2014-12-10 11:52:25		
5590	rrmeu	63		2014-12-10 11:52:25		
5591	sgiwy	63	// minseq.java	2014-12-10 11:52:25		
5592	tenuw	63		2014-12-10 11:52:25		
5593	admin	63		2014-12-10 11:52:25		
5594	rrmeu	63	I have an idea, using SLIDING WINDOW: I use a "window" from index wL to wR to slide on the array, while keeping track of its sum and the minimum window size that satisfied sum > S.  While the sum of numbers inside the window is not greater than S, slide the right side (wR++). At any moment, while the sum is greater than S, record the minimum so far and then slide into the left side (wL++).  This takes O(n) since the window is always sliding into 1 direction (left to right), which stops at most O(n) steps.  This works for array with negative values as well.  O(n) time, O(1) space.  EDITED: It doesn't work for negative values, AS WELL!  EDITED (2nd time): For negative values:  If the sum is <=0 at position v, then start new window at v+1;  If the sum is <=S: sliding the right side wR++;  If the sum is >S: try to shrink the left side to find the minimum size.  Please see my code below and tell if it doesn't work. Thanks!	2014-12-10 11:52:25		
5595	krxlv	63	Sorry man, but I don't think it works well for negative values. Think of such case: arr[] = {-1, 1} and threshold = 0. The result should be 1, but according to your algorithm: (1)at first winleft = 0, winright = 0, winsum = arr[0] = -1. (2)winsum < threshold, so we slide to right, ++winright. (3)now winsum = winsum + arr[1] = 0 <= threshold, yet we can not slide to right any more, so there exists no such sequence.	2014-12-10 11:52:25		
5596	jippy	63	thanks! I edited my post.	2014-12-10 11:52:25		
5597	tenuw	63	How about this:  I try to expand the window to the right, but if at any position, say v, the sum become non-positive, I skip all the current window and start a NEW window at position v+1.  If the sum is > S: I try to shrink the window by sliding the left side wL++ iteratively, to find the minimum size.	2014-12-10 11:52:25		
5598	tenuw	63	I found it complicated for negative case.  Any one can fix it?	2014-12-10 11:52:25		
5599	tenuw	63	This can work for NEGATIVE values:	2014-12-10 11:52:25		
5600	jippy	63		2014-12-10 11:52:25		
5601	ewigy	63		2014-12-10 11:52:25		
5602	sgiwy	63	Great job! That was beautiful :-)	2014-12-10 11:52:25		
5603	nwkeg	63	Hi uuuouou and iroodaz:  Please look at my code and tell if it's wrong. Thanks!	2014-12-10 11:52:25		
5604	nwkeg	63	This does the trick in your code:	2014-12-10 11:52:25		
5605	rrmeu	63		2014-12-10 11:52:25		
5606	xhgls	63		2014-12-10 11:52:25		
5607	rdfeo	63	Nice one! Couldn't find a bad test case for the code.	2014-12-10 11:52:25		
5608	fowai	63	Arr[] = {2, 1, 1, 4, 3, 1, 4} Sum = 6  your code will give answer 4 = (2,1,1,4) because wr will be 3 after it has find the above answer. Now wl will also become 3 in the inside while loop, sum becomes 0 and when outside loop starts wr =4.  Answer should be 2 = (4,3)  correct me if I am wrong?	2014-12-10 11:52:25		
5609	vanul	63	oops...for the above input it will give output 3 = {3, 1, 4} which is still wrong.	2014-12-10 11:52:25		
5610	ethan	63	It's really a good answer. However, since you want to solve negative input at the same time, you might want to handle the solution when S < 0 ? For example, S= -5, array is {-1}, the result should be 1. I guess that is asking too much :P	2014-12-10 11:52:25		
5611	ftfck	63	I ran your program.  int n = 7; //size of input Arr; int Arr[] = {2, 1, 1, 4, 0, 1, 4}; int S = 6;  It gives answer 3 which is wrong.	2014-12-10 11:52:25		
5612	ewigy	63	@babula: I think the case S < 0 is trivial to handle, isn't it?  Or do you mean the case when S<0 and we need to find a sequence that its sum is LESS THAN S? For this, we can do the same, except that we need to negate all the numbers (including S) first. Right?	2014-12-10 11:52:25		
5613	rdfeo	63	@ Anonymous: Please double-check!	2014-12-10 11:52:25		
5614	ewigy	63		2014-12-10 11:52:25		
5615	cfzie	63		2014-12-10 11:52:25		
5616	qywrh	63	start and end move n positions each. O(n+n) = O(n)	2014-12-10 11:52:25		
5617	eucmc	63		2014-12-10 11:52:25		
5618	eucmc	63		2014-12-10 11:52:25		
5619	fowai	63	}	2014-12-10 11:52:25		
5620	rdfeo	63	I am not sure why you assume that the question ask for the sequence with the lowest sum above threshold and not the one with the min length.	2014-12-10 11:52:25		
5621	rdfeo	63	assuming ur response is to my solution, the lowest sum above the threshold would make sure that the window is minimal in length. Just pick the window with the minimal size and that is your answer. I think its elaborate enough for you to understand now!!	2014-12-10 11:52:26		
5622	sgiwy	63	I was referring to the original post.  mayankme0077, min length and lowest sequence above the bound is two different things. Your solution is broken for both. It does not return lowest seq : gives {15} for {2, 1, -7, 7, 15},6 instead of 7. It also does not return the shortest seq: gives {2, -7, 7, 5 } for {2,-7, 7, 5},6 instead of 7.  All the best.	2014-12-10 11:52:26		
5623	rdfeo	63	Good question! I think if we can check for all possible windows, then just record whatever minimum we want. Depends on which question is asked, we have to adjust accordingly.	2014-12-10 11:52:26		
5624	plapd	63	n^2 algorithm is straight forward I think. I don't know if I can come up with a DP one. Incidentally, does anyone know if brute force is good enough for a phone interview?	2014-12-10 11:52:26		
5625	nwkeg	63		2014-12-10 11:52:26		
5626	ewigy	63		2014-12-10 11:52:26		
5627	vanul	63		2014-12-10 11:52:26		
5628	azmjc	63		2014-12-10 11:52:26		
5629	cfzie	63	O(n) solution taking off min of the end of arrays.	2014-12-10 11:52:26		
5630	azmjc	63	Can it work for negative values?	2014-12-10 11:52:26		
5631	krxlv	63	Doesn't work for: { 1, 2, 3, 4, -10, -2, 22 },7, 10 O/P is 4 should be 3	2014-12-10 11:52:26		
5632	dgjji	63	I think this gets caught on large numbers even if they're all positive. With array = {4, 4, 1, 1, 5} and sum = 7, the loop will move the front of the window and conclude {4, 1, 1, 5} is the min sequence of length 4. When {4, 4} is the min.	2014-12-10 11:52:26		
5633	azmjc	63		2014-12-10 11:52:26		
5634	rrmeu	63		2014-12-10 11:52:26		
5635	qywrh	63		2014-12-10 11:52:26		
5636	huiqq	63		2014-12-10 11:52:26		
5637	nhibd	63	}	2014-12-10 11:52:26		
5638	tenuw	63	On solution	2014-12-10 11:52:26		
5639	rdfeo	63		2014-12-10 11:52:26		
5640	dgjji	63		2014-12-10 11:52:26		
5641	rrmeu	63	What is the Big-O notation for this? Since you iterate array at most 2 times, it will be 2n, so O(n)?	2014-12-10 11:52:26		
5642	ethan	63		2014-12-10 11:52:26		
5643	fowai	63		2014-12-10 11:52:26		
5644	qywrh	63	Hi dude,  You are not supposed to sort the array, it should remain as the original order. Check the question dude.	2014-12-10 11:52:26		
5645	cfzie	63	public int functions(int[] a, sum){ arrays.sort(a); sort O(nlogn) Int count; int last = length-1; // the maximum in the array  for(int i=length-2;i>-1;i++){ if(a[i]+a[last]<=sum){ count++; } }  return count;  }	2014-12-10 11:52:26		
5646	fowai	63		2014-12-10 11:52:26		
5647	admin	63		2014-12-10 11:52:26		
5648	ethan	63	removing the post as I misunderstood the problem. thanks srini	2014-12-10 11:52:26		
5649	xhgls	63	After heapification, the order of the elements is lost. Isn't it?	2014-12-10 11:52:26		
5650	plapd	63	n^2 algorithm. works with negatives	2014-12-10 11:52:26		
5651	nwkeg	63		2014-12-10 11:52:26		
5652	zeice	63		2014-12-10 11:52:26		
5653	qywrh	63	just noticed this doesnt handle zero case	2014-12-10 11:52:26		
5654	ewigy	63		2014-12-10 11:52:26		
5655	nwkeg	63		2014-12-10 11:52:26		
5656	ethan	63		2014-12-10 11:52:26		
5657	krxlv	63		2014-12-10 11:52:26		
5658	azmjc	63		2014-12-10 11:52:26		
5659	rdfeo	63		2014-12-10 11:52:26		
5660	ethan	63		2014-12-10 11:52:26		
5661	cfzie	63		2014-12-10 11:52:26		
5662	zeice	63	Right now my code maintains the invariant that the sum inside the window after every iteration is greater than the given sum and is the window is "tight" from both the ends.  This solution won't work for negative numbers as the invariant fails in that case. There should be a simple modification to maintain that invariant. I will update soon.  EDIT : This modification maintains the invariant as mentioned above and the solution should work for negative numbers as well.	2014-12-10 11:52:26		
5663	bjsiw	63		2014-12-10 11:52:26		
5664	ethan	63		2014-12-10 11:52:26		
5665	mrjku	63	That said this is the solution to what you are trying to do in nlong. You are not expected to understand this.	2014-12-10 11:52:26		
5666	rdfeo	63		2014-12-10 11:52:26		
5667	huiqq	63		2014-12-10 11:52:26		
5668	rrmeu	63		2014-12-10 11:52:26		
5669	dkebi	63		2014-12-10 11:52:26		
5670	dkebi	63	python code with O(n^2) dynamic programming	2014-12-10 11:52:26		
5671	gilit	63	This code runs in O(n) time and O(1) space:	2014-12-10 11:52:26		
5672	admin	63		2014-12-10 11:52:26		
5673	wbqzu	63		2014-12-10 11:52:26		
5674	dgjji	63		2014-12-10 11:52:26		
5675	fowai	63		2014-12-10 11:52:26		
5676	zeice	63	discard above code. it is printing the set numbers that equals sum not greater than sum which is asked in the question.	2014-12-10 11:52:26		
5677	rdfeo	63		2014-12-10 11:52:26		
5678	ufdxg	63		2014-12-10 11:52:26		
5679	ethan	63	}	2014-12-10 11:52:26		
5680	nhibd	63	/* n is number of elements in array wl is left boundry of minimum sequence initailly passed as zero wr is right boundry of minimum sequence initailly passed as zero S is the given sum */  void find_Minseq(int arr[],int n,int *wl,int *wr, int s) { int i; int l=*wl; int r=*wr; int sum=0; int min=n+1; for(i=0;i<n;i++) { sum =sum+arr[i]; if(sum<0) { sum=0; l=i+1; continue; } if(sum<=s) { r=i; continue; } else { while(sum>s && l<=i) { sum=sum-arr[l]; l++; } l--; r=i; sum=sum+arr[l]; } if(min>(r-l+1) && sum>s) { *wl=l; *wr=r; min=*wr-*wl+1; } } }	2014-12-10 11:52:26		
5681	xhgls	63		2014-12-10 11:52:26		
5682	ethan	63		2014-12-10 11:52:26		
5683	dgjji	63		2014-12-10 11:52:26		
5684	wbqzu	63		2014-12-10 11:52:26		
5685	fowai	63		2014-12-10 11:52:26		
5686	bjsiw	63		2014-12-10 11:52:26		
5687	qywrh	63	int main(){  int arr[] = {2,1,1,4,3,6,5,7,3,18,3,5,7};   int sum = 0; int minstart = 0; int minseq = 0,i,tempminseq;   for(i=0;i<sizeof(arr);i++){  // k = 0; tempminseq = 0; sum = 0; while((sum < 18) &&((i+tempminseq) < sizeof(arr)){  sum+= arr[i+tempminseq]; tempminseq++; }  if((tempminseq < minseq ) || (minseq == 0)){  minseq = tempminseq; minstart = i;  }   }  printf(" minstart %d minseq %d ",minstart,minseq); tempminseq = 0; for(i = minstart;i<sizeof(arr);i++){ printf(" %d ",arr[i]);  tempminseq++; if(tempminseq >= minseq) break;  }  return 0;   }	2014-12-10 11:52:26		
5688	admin	63		2014-12-10 11:52:27		
5689	xhgls	63		2014-12-10 11:52:27		
5690	dkebi	63	O(n) solution	2014-12-10 11:52:27		
5691	ftfck	63		2014-12-10 11:52:27		
5692	huiqq	63		2014-12-10 11:52:27		
5693	rdfeo	63	int[] a= {2,1,1,4,3,9}; int min = 50;  for(int i = 0 ; i < a.length;i++) { int sum = 0; int count = 0; for (int j = i; j< a.length ; j ++) { count = count + 1; sum = sum + a[j]; if(sum>8 && count < min) { min = count; break; } } } System.out.println(min);	2014-12-10 11:52:27		
5694	fmzze	64	This is a DFS algorithm which gives correct results. Not sure how to improve this by smart algorithms.	2014-12-10 11:52:28		
5695	rdfeo	64		2014-12-10 11:52:28		
5696	krxlv	64		2014-12-10 11:52:28		
5697	fowai	64	It seems, that you have much more than k swaps here...	2014-12-10 11:52:28		
5698	nhibd	64	Actually, I just try different combination of K swaps here.	2014-12-10 11:52:28		
5699	vanul	64	also a correct solution, using std::map, with one round of greedy swap	2014-12-10 11:52:28		
5700	eucmc	64		2014-12-10 11:52:28		
5701	admin	64		2014-12-10 11:52:28		
5702	ftfck	64	Solution in python :	2014-12-10 11:52:28		
5703	admin	64		2014-12-10 11:52:28		
5704	fowai	64		2014-12-10 11:52:28		
5705	plapd	64	complexity O(N)+O(k log k)	2014-12-10 11:52:28		
5706	huiqq	64	improved solution in python. Complextiy: time O(N)+O(k log k), space O(N)	2014-12-10 11:52:28		
5707	ewigy	64		2014-12-10 11:52:28		
5708	cfzie	64		2014-12-10 11:52:28		
5709	tenuw	64	I tried to find a smart solution but in the end they all fail... I think an "intelligent brute force" in the for of DFS has to be used here. Imagine that your digits are in array A of digits. My algo is generally the following: 1.) you sort your digits in descending order, with this you receive the biggest possible number for this digits M. 2.) Your target number will have common prefix with this one (since the primary target in k swaps is to maximize the most significant digits); 3.) Now you start your dfs from the most significnat number(say, A[0]), if it is the same as M[0] you try to maximise the remaining 1..n-1 digits with k swaps. If it is not equal to M[0], you try to swap it with any digit in A that equals M[0] and for each such swap solve a subproblem for 1..n-1 digits with k-1 swaps. 4.) as soon your arrive at a problem with 0 swaps you check if the current number is the largest number generated so far, and if so, memorize it.  Although this solution has very roughly estimated complexity of O(n!/(n-k)!) (where n is the number of digits, and k is the number of swaps), I believe that the in-depth math analysis would prove it to be much faster. One more point is to involve dynamic programming, but this seems to work at the cost of very high memory consumption.	2014-12-10 11:52:28		
5710	nwkeg	64	Algorithm: a. We start at the leftmost digit (current-position=0). b. We start with the highest digit value (current-digit-value=9). c. We scan the number and note all the positions of the digits of the current digit value. Example: N=8799 , positions=[2, 3] (the digit 9 is in positions 2 and 3). d. We put the K digits starting at the current position in a list (if some of these digits are equal or higher then the current digit value, then we skip them). Example: K=2 digits={8, 7} (the 2 digits starting from the current position). e. Now we swap the rightmost digit from the "positions" list in step c, with the lowest value digit from "digits" list from step d. We repeat this with the next digit in each list, until either list is exhausted. Example: first swap right-most 9 with 7 (lowest value): N=8997, then swap second 9 from right with next leowest digit 8: N=9987. f. Decrement K by the number of swaps made. Exit if K is zero. Example: K=0 g. Increment current-position similarly. Exit if we reached the end. h. Decrement current-digit-value (current-digit-value=8). Exit if we reached zero. i. Repeat steps c,d,e,f,g,h,i  Complexity: O(N)+O(k log k) if implementing the list in step d as a heap.	2014-12-10 11:52:28		
5711	xhgls	64	I think you have flaw in your solution. consider next example : 1189119999 and k = 5; The correct answer will be 9999981111. Your algorithm on step c will get all indexes of '9' {3,6,7,8,9} , on step d indexes of 5 lower digits while skipping '9'th {0,1,2,4,5}. Then you starting swap digits in ascending order with 9th from right to left. It will give you 9998991111. The problem is with last 9. After 4 swap operation and before last one your number looks like 99 "89" 991111, ( i put in quotes the only unswapped digits ). The correct answer achieved by swap 8 with already used in swap '9'.  The solution i think is to remember how much digits you skipped in step d, lets say it x digits, and after k-x swap operations, do next x swaps with the already swapped '9'th from right to left   EDIT : No, my solution won't work too. consider 191899 k = 3 after two swaps 999811 , it is allready maximum , now my solution will do last swap and will make it 998911. We can solve it if we will check that we are not swapping 9 to lower index, but i am not sure i see all the problems with this algorithm,   EDIT 2: It seems this greedy algorithm is working. code :	2014-12-10 11:52:28		
5712	nhibd	64		2014-12-10 11:52:28		
5713	jippy	64		2014-12-10 11:52:28		
5714	krxlv	64	Testing:  k - 2 input - 8799 output - 9987  k - 2 input - 7899 output - 9987  k - 2 input - 34155 output - 55143  k - 2 input - 12520 output - 52210  k - 3 input - 876959 output - 998657  k - 2 input - 1399 output - 9931  k - 5 input - 1189119999 output - 9999981111  k - 5 input - 191899 output - 999811  k - 350 input - 123456789098765432199998888777777266655 output - 999999888888777777776666655545433222110  k - 35 input - 123456789098765432199998888777777266655 output - 999999888888777777143216650775432266655  k - 9 input - 123456789098765432199998888777777266655 output - 999999888858765432143218760777777266655  Program ended with exit code: 0     EDIT 3 the last one.  No this solution doesn't work either. I got to conclusion you can't do it with greedy algorithm. You have to do some routines recursively If someone could tell me how easily i can come to conclusion that some problem can't be solved greedy, i will appreciate it.	2014-12-10 11:52:28		
5715	qywrh	64	This question is a bit tricky. This is the logic I propose.  Put the numbers in an array A[n] (referenced by 0 to n-1) For k=1: Swap A[k-1] with the maximum number in A[k : n-1] such that the number is greater than A[k-1]. If there are 2 such numbers of same value greater than A[k-1], pick the rightmost one(one with larger index). . . . For k=i: Swap A[k-i] with the maximum number in A[k : n-1] such that the number is greater than A[k-i]. If there are 2 such numbers of same value greater than A[k-i], pick the rightmost one(one with larger index).  Basic Selection Sort logic with a little modification till K-steps. Whatever remains in the array is the solution.  Time : O(n) * k = effectively O(n)	2014-12-10 11:52:28		
5716	nwkeg	64	this is not effectively O(n), this is effectively O(nk)	2014-12-10 11:52:28		
5717	ewigy	64	Guys. This is not a correct solution. I will correct it and post it in a few days. Please look below.	2014-12-10 11:52:28		
5718	cfzie	64	This is just a simple K iterations of selection sort with one exclusions: - when looking for maximum element from all leftmost ones we take the position of the "latest" one - e.g. for "26316" - if we are at "2" digit now we swap it with latest "6" - not with first met.  Here is the code (it's rather big because I need to convert from int to list of ints and back)	2014-12-10 11:52:28		
5719	rdfeo	64		2014-12-10 11:52:28		
5720	sqzqo	64		2014-12-10 11:52:28		
5721	rdfeo	64	I think this greedy algorithm does not give correct solution to the test case : "M = 8799 and K = 2 output = 9987".	2014-12-10 11:52:28		
5722	fowai	64	agree, there is no way to solve this greedely.  Below I provided the recursive solution (not the first one to provide it, though) with deep explanation of steps.	2014-12-10 11:52:28		
5723	qywrh	64		2014-12-10 11:52:28		
5724	krxlv	64		2014-12-10 11:52:28		
5725	mrjku	64		2014-12-10 11:52:28		
5726	cfzie	64		2014-12-10 11:52:28		
5727	cfzie	64		2014-12-10 11:52:28		
5728	dgjji	64		2014-12-10 11:52:28		
5729	xhgls	64		2014-12-10 11:52:28		
5730	bjsiw	64		2014-12-10 11:52:28		
5731	jippy	64	I know that this answer is not fully correct (as Moi found the case, when this doesn't work), but as I spent a lot of time and would like to safe it for anyone, who comes here to find the solution, but cannot underestand it. So I added lots of comments and will explain it here.  To my mind if this algorithm is provided on the interview - they would accept it anyway, though it's not always correct :))  So, the main idea is to recurse the list and support the following invariant: - maximum equal elements in the current sublist are moved to the head - the swapped elements are moved to their position in descending order  So at each iteration we find the next LEN maximum elements and substitute them with LEN elements at the head of current sublist. Though elements at the head must be sorted so that to support the invariant.  Hope, this helps anybody, as I spend half a day on this and initially wrote incorrect greedy algorithm, suppose, that there are many such people.	2014-12-10 11:52:28		
5732	sqzqo	64		2014-12-10 11:52:28		
5733	dkebi	64		2014-12-10 11:52:28		
5734	ftfck	64	Not time to code, will just give an outline. Index for walking forward. Array size 10 of indexes for walking backward, initialized with last occurence of digit. array[5] will have last index of 5. state variable start with 9 and decrement to 0. walking forward, if state 9 and not 9, swap with array[9]. update array[9] walking backward but stop as soon as reached forward index. Do all states like that but stop as soon as reached amount of swaps.	2014-12-10 11:52:28		
5735	nwkeg	64	Simplification. Do not need array because doing one index at a time. Just backward index, but start from end at every state decrement	2014-12-10 11:52:28		
5736	admin	64	Sorry, will not work	2014-12-10 11:52:28		
5737	fowai	64		2014-12-10 11:52:28		
5738	fowai	64		2014-12-10 11:52:28		
5739	zeice	64	vector<int> largest_swap(vector<int> num, int swap) { if(num.size() == 0 || swap == 0) return num; vector<vector<int>> result; largest_swap(result, num, swap,0); return get_largest(result); } void largest_swap(vector<vector<int>> & result, vector<int> num, int swap, int location) { if(location == num.size() -1 || swap == 0) { result.push_back(num); return; }  int max = num[location]; for(int i = location + 1; i < num.size(); i ++) { if(max < num[i]) max = num[i]; }  if(max != num[location]) { for(int i = location + 1; i < num.size(); i ++) { if(num[i] == max) { swap(num[location], num[i]); largest_swap(result, num, swap -1, location + 1); swap(num[location], num[i]); } } } else { largest_swap(result, num, swap, location + 1); } }	2014-12-10 11:52:28		
5740	fmzze	64	vector<int> largest_swap(vector<int> num, int swap) { if(num.size() == 0 || swap == 0) return num; vector<vector<int>> result; largest_swap(result, num, swap,0); return get_largest(result); } void largest_swap(vector<vector<int>> & result, vector<int> num, int swap, int location) { if(location == num.size() -1 || swap == 0) { result.push_back(num); return; }  int max = num[location]; for(int i = location + 1; i < num.size(); i ++) { if(max < num[i]) max = num[i]; }  if(max != num[location]) { for(int i = location + 1; i < num.size(); i ++) { if(num[i] == max) { swap(num[location], num[i]); largest_swap(result, num, swap -1, location + 1); swap(num[location], num[i]); } } } else { largest_swap(result, num, swap, location + 1); } }  vector<int> get_largest (vector<vector<int> result)	2014-12-10 11:52:28		
5741	rrmeu	64	Below is my java solution to the problem. The time complexity of my solution is O(M*K), where M is equal to the number of digits of M and K is k. What do you think? Please leave feedBack.	2014-12-10 11:52:28		
5742	dgjji	64		2014-12-10 11:52:28		
5743	nhibd	64		2014-12-10 11:52:28		
5744	mrjku	64	Greedy solution doesn't work here, see above. Also int conversion is not correct	2014-12-10 11:52:29		
5745	wbqzu	64	Alisovenko,  Thank you for leaving feedback.  why is my int conversion incorrect? It works in eclipse.  My out works for all inputs in the question and potentially inputs I see on this page.  Example of output: In M is 876959, K is 3 Output: 998657	2014-12-10 11:52:29		
5746	eucmc	64	sorry, conversion is correct, I thought each decimal will be converted to direct ASCII symbol 1. check inputs 8799 and 7899 they must provide the same result for k=2	2014-12-10 11:52:29		
5747	ufdxg	64	Alisovenko,  Again, Thank you for leaving feedback. You are correct, my solution is incorrect!! (See below). So this means my Java algorithm finds a suboptimal solution. Is it best to find all suboptimal solutions, then select the best solution from there?  Output: In M is 8799, K is 2 Output: 9987  In M is 7899, K is 2 Output: 9978	2014-12-10 11:52:29		
5748	wbqzu	64	solve this problem with O(n) complexity, (1) if K >= arr.length - 1, sort the arr by descending order (2) iterate the array, count the number of 1 ~ 9. (3) swap from digit 9 to 1 in a loop. As to one digit, swap Min(k, count[digit]) count. (4) sort the element which are swapped by descending order, pay attention to the element which is unnecessary to be swapped.  code:	2014-12-10 11:52:29		
5749	fmzze	64		2014-12-10 11:52:29		
5750	dgjji	64		2014-12-10 11:52:29		
5751	admin	64	In step 4, if array is {8, 7, 9, 9} or {7, 8, 9, 9} and k = 2, we will swap 8 to the first occurrence of 9, swap 7 to the second occurrence. So, it is the same as we sort the element which will be swap to the larger digits, then swap the element with the larger number one by one.	2014-12-10 11:52:29		
5752	xhgls	64	Can you give the full source? This does not give correct numbers for 1, 3, 2 and k=2	2014-12-10 11:52:29		
5753	huiqq	64	Here's a solution that I cheated a little to get.	2014-12-10 11:52:29		
5754	fowai	64		2014-12-10 11:52:29		
5755	rrmeu	64		2014-12-10 11:52:29		
5756	krxlv	64	I found a case that didn't work. In the case of 1399, k=2 swaps will produce 9913, even though 9931 is possible. Disregard this answer.	2014-12-10 11:52:29		
5757	azmjc	64		2014-12-10 11:52:29		
5758	ufdxg	64		2014-12-10 11:52:29		
5759	xhgls	64	This code (Scala) prints all combinations. Instead on print we can just get hold of the max and print that one.   val a = Array(8,7,9,9, 0, 9, 6, 5, 4, 9, 9) val n = 2  def swapz(a: Array[Int], n: Int, idx: Int) : Unit = { if (n==0) { println(a mkString(",")) return }  val bigs = a.drop(idx).max for((x, i) <- a.view.zipWithIndex) { if (x == bigs && i >= idx) { val cp = a.map(i=>i).array cp(i) = cp(idx) cp(idx) = x swapz(cp, n - 1, idx + 1) } } }  swapz(a, 3, 0)	2014-12-10 11:52:29		
5760	qywrh	64	def swap2large(num, K): nlen = len(num) for i in range(0, nlen): if K <= 0: break; cmax = num[i] count = 0 found = False swappos = i for j in range(i + 1, nlen): if num[j] > cmax: cmax = num[j] count = 1 swappos = j elif num[j] == cmax and count > 0: count += 1  if count == 0: break  if count == 1: num[i], num[swappos] = num[swappos], num[i] K -= 1 continue  for j in range(i + 1, nlen): if num[j] == cmax: swappos = j if found and K > 1: break elif num[j] < num[i]: found = True   num[i], num[swappos] = num[swappos], num[i] K -= 1 return num   print(swap2large([1, 3, 2], 1)) print(swap2large([1, 3, 2], 2)) print(swap2large([7, 8, 9, 9], 2)) print(swap2large([8, 7, 9, 9], 2)) print(swap2large([7, 8, 9, 9], 1)) print(swap2large([8, 7, 9, 9], 1))	2014-12-10 11:52:29		
5761	tenuw	64		2014-12-10 11:52:29		
5762	plapd	64		2014-12-10 11:52:29		
5763	tenuw	64	I am not sure how correct the solution is but it works for almost all cases mentioned here	2014-12-10 11:52:29		
5764	mrjku	64		2014-12-10 11:52:29		
5765	sqzqo	64		2014-12-10 11:52:29		
5766	admin	64	#include<iostream>  using namespace std;  void klargest(int a[], int len, int k){ for(int i=0; i<k; i++){ int maxInd = i; for(int j=i+1; j<len;j++){ if(a[j]>a[maxInd]) maxInd = j; }  int temp = a[i]; a[i] = a[maxInd]; a[maxInd] = temp; } for(int i=0; i<len; i++) cout<<a[i]<<" "; cout<<endl; }  int main(){ int a[4]={8,7,9,9}; for(int i=0; i<4; i++) cout<<a[i]<<" "; cout<<endl; int k; cout<<"Enter K"<<endl; cin>>k; klargest(a,4,k);  }	2014-12-10 11:52:29		
5767	tenuw	64		2014-12-10 11:52:29		
5768	eucmc	64		2014-12-10 11:52:29		
5769	sqzqo	64		2014-12-10 11:52:29		
5770	rrmeu	64		2014-12-10 11:52:29		
5771	rrmeu	64		2014-12-10 11:52:29		
5772	xhgls	64		2014-12-10 11:52:29		
5773	wbqzu	64	This question is K level DFS. We may use recursive calls with depth of K to solve it.	2014-12-10 11:52:29		
5774	dgjji	64		2014-12-10 11:52:29		
5775	cfzie	64		2014-12-10 11:52:29		
5776	rdfeo	64	i think just like this for example "1234976" find the biggest continous two digits(if both of them are bigger than the first digit ,we beleve it is continous: 9>1,7>1) and then swap it with the first, The result is: 97 23416  The left part(23416) recursive using the above method.  If we find the digit that is not continous, we just swap it with the first (6>1), The result is 97 (6 3412)   Time is O(n^2)	2014-12-10 11:52:29		
5777	rdfeo	64	1 setup a vector<int> freq[10] to record frequency and index of each digit, scan the input once to record, now we know each digit's correct position of descendant order 2 from 9~0 in freq array fetch first 2*K digit which is not in his correct position, unless get to latest digit. 3 loop these 2*K digit in descendant order, if current is not in his correct position, just swap the digit with the one in his correct position, each time we switch, swapcount ++. (note during this step, some digit which is not in correct position previously could be swapped to his correct position, so that's why 2*K is necessary) 4 if swapcount reach K, return.	2014-12-10 11:52:29		
5778	mrjku	64	I have crafted a solution of O(N) + O(K*logK). An implementation of O(N+K) is still possible. Please refer, cpluspluslearning-petert.blogspot.co.uk/2014/11/data-structure-and-algorithm-find.html, for more detail. It takes a while to explain what I am doing. So have a coup of tea and read through if interested. Here is the code.	2014-12-10 11:52:29		
5779	ftfck	64		2014-12-10 11:52:29		
5780	ethan	64		2014-12-10 11:52:29		
5781	dkebi	64	// TEST	2014-12-10 11:52:29		
5782	vanul	64		2014-12-10 11:52:29		
5783	rdfeo	64		2014-12-10 11:52:29		
5784	bexbp	64	The logic is fairly simple assuming that the number is stored in an array.So once the number is stored in an array we can modify the bubble sort to run the outer loop only for k times.At the end of the loop,the k largest numbers will be at the end in their appropriate position(see working of bubble sort) After this you can reverse the contents of array to get the maximum possible integer.	2014-12-10 11:52:29		
5785	nhibd	64	bubble sort approach will not work for 7899 for k = 2 if u start from beginning and want to sort in non-decreasing order then it becomes 8979 if u start from the end then it becomes 9798	2014-12-10 11:52:29		
5786	ewigy	64		2014-12-10 11:52:29		
5787	xhgls	64		2014-12-10 11:52:29		
5788	xhgls	64	Your solution is incorrect.  Test case: N=876959 K=3 Your output: 996857 Correct solution: 998756	2014-12-10 11:52:29		
5789	dkebi	64	Solution above has too many mistakes...	2014-12-10 11:52:29		
5790	gilit	64		2014-12-10 11:52:29		
5791	huiqq	64		2014-12-10 11:52:29		
5792	nhibd	64	Input: 8, 7, 6, 9, 5, 9 and k=3 You get: 9, 9, 8, 6, 5, 7. Optimum: 9, 9, 8, 7, 5, 6 (swap 8 with 6, then 6 with the rightmost 9 and then 7 with the middle 9)	2014-12-10 11:52:29		
5793	ewigy	64	Nice test case. It shows all of the current answers to be incorrect :)	2014-12-10 11:52:29		
5794	sqzqo	64	package google;  import java.util.Scanner;  /** * * @author brian */ public class Google {  /** * @param args the command line arguments */  int numofdig; String usernumber; int number; Scanner input=new Scanner(System.in); int inddig[]; int numofswap; int max;      int sort(int k) { int temp;  for(int i=k;i<inddig.length-2;i++) { if(inddig[k]>=inddig[k+1]) { temp=inddig[k]; inddig[k]=inddig[k+1]; inddig[k+1]=temp; }     } System.out.println("Sorted Elements"); for(int s=0;s<=inddig.length-2;s++) { System.out.println(inddig[s]); }  return 0; }   int max(int[] temp,int j) { int limit=0; max=temp[j]; for(int s=0;s<=temp.length-2;s++) {  System.out.println(temp[s]); } for(int p=j;p<=temp.length-2;p++) { if(max<temp[p]){ max=temp[p]; limit=p; }  } System.out.println("Max Element in Array:"+temp[limit]); return limit;    }  int breakdig(int temp) { int temp1[]=new int[numofdig+1]; int n ; n=temp; int i=0; while(n>0) { n=temp%10;  temp1[i]=n; i++; temp=temp/10; } int k=0; for(int j=temp1.length-2;j>=0;j--) {  inddig[k]=temp1[j]; k++; }    swap(); return 0;    } int swap() { int temp; int j,i=0; int k; while(numofswap>0) {  sort(i); j=max(inddig,i); System.out.println("j="+j);  temp=inddig[i]; System.out.println("i="+i); inddig[i]=inddig[j]; inddig[j]=temp;  i++; numofswap--; }  display();     return 0;       }   int display() { for(int s=0;s<=inddig.length-2;s++) { System.out.println(inddig[s]); } return 0;    }    int getnum(String temp) {  numofdig=temp.length(); number=Integer.parseInt(temp); System.out.println("number of digits"+numofdig); inddig=new int [numofdig+1]; breakdig(number);  return 0;   }  int input() {  System.out.println("Enter the number"); usernumber=input.next(); System.out.println("Enter the number of swaps"); numofswap=input.nextInt();  getnum(usernumber);     return 0;    }     public static void main(String[] args) {  new Google().input(); // TODO code application logic here }  }	2014-12-10 11:52:29		
5795	zeice	64	OUtput	2014-12-10 11:52:29		
5796	plapd	64	Consider adding indentation and formatting to your code, at the moment it's very difficult to read.	2014-12-10 11:52:29		
5797	jippy	64	package google;  import java.util.Scanner;  /** * * @author brian */ public class Google {  /** * @param args the command line arguments */  int numofdig; String usernumber; int number; Scanner input=new Scanner(System.in); int inddig[]; int numofswap; int max;      int sort(int k) { int temp;  for(int i=k;i<inddig.length-2;i++) { if(inddig[k]>=inddig[k+1]) { temp=inddig[k]; inddig[k]=inddig[k+1]; inddig[k+1]=temp; }     }   return 0; }   int max(int[] temp,int j) { int limit=0; max=temp[j];  for(int p=j;p<=temp.length-2;p++) { if(max<temp[p]){ max=temp[p]; limit=p; }  }  return limit;    }  int breakdig(int temp) { int temp1[]=new int[numofdig+1]; int n ; n=temp; int i=0; while(n>0) { n=temp%10;  temp1[i]=n; i++; temp=temp/10; } int k=0; for(int j=temp1.length-2;j>=0;j--) {  inddig[k]=temp1[j]; k++; }    swap(); return 0;    } int swap() { int temp; int j,i=0; int k; while(numofswap>0) {  sort(i); j=max(inddig,i);   temp=inddig[i];  inddig[i]=inddig[j]; inddig[j]=temp;  i++; numofswap--; }  display();     return 0;       }   int display() {    String result = ""; for(int s=0;s<=inddig.length-2;s++) {   result+=String.valueOf(inddig[s]); }  System.out.println("Ans : "+result); return 0;    }    int getnum(String temp) {  numofdig=temp.length(); number=Integer.parseInt(temp);  inddig=new int [numofdig+1]; breakdig(number);  return 0;   }  int input() {  System.out.println("Enter the number"); usernumber=input.next(); System.out.println("Enter the number of swaps"); numofswap=input.nextInt();  getnum(usernumber);     return 0;    }     public static void main(String[] args) {  new Google().input(); // TODO code application logic here }  }	2014-12-10 11:52:29		
5798	wbqzu	64	40 responses and no one has mentioned heap?  Build a max-heap of size n from the digits. Pop-out the maximum element from the heap, swap it with the left most digit (then shift left-most pointer by one to the right). Repeat k times. Deleting an element from the heap also balances the heap, which is a O(log(heap_size)) operation.  Time complexity: O(n + klogn), space complexity : O(n). Note that any comparison (and swap) based algorithm CANNOT sort an array of size n in less than O(nlogn). If k = n, the time complexity becomes O(nlogn)	2014-12-10 11:52:29		
5799	tenuw	64	You're no considering that some numbers could already be in the correct position, thus they must not be swapped, i.e., [ 8, 7, 4, 2, 3 , 5 ], k = 1.  Also you CANNOT build a heap of size n in less than O(nlogn).	2014-12-10 11:52:29		
5800	bexbp	64	How about: j = 0 WHILE k > 0 Get highest digit (i) position from A in range of [j, digit_count] New Number := A[i] + A \ {i} K = K - 1 J = J + 1 END_WHILE  Example: A=7899 K=2  J = 0 I = [78(9)9] at index 2 A=9[789]  J = 1 I = 9[78(9)] at index = 3 A = 9978	2014-12-10 11:52:29		
5801	bexbp	65	here is my answer to this question  1. Create a new hashmap. Its key will contain starting index of contiguous set and value be ending index of contiguous set. 2. Iterator through array. 3. Let each value be x. look for x-1 and x+1 in hashmap. case1. there exists an entry for x-1, so update its value to x if x is greater than existing value case2. there exists an entry for x+1, get its value, say vx and insert an entry with key as x and value as vx. case 3. there exists an entry for x; simply ignore case 4: insert into hashmap, key x and value x   Ex: S = { 5, 1, 9, 3, 8, 20, 4, 10, 2, 11} 5 => { (5,5) } 1 => { (5,5), (1,1) } 9 => { (5,5), (1,1), (9,9) } 3 => { (5,5), (1,1), (9,9), (3,3) } 8 => { (5,5), (1,1), (8,9), (3,3) } 20 => { (5,5), (1,1), (8,9), (3,3), (20,20) } 4 => { (5,5), (1,1), (8,9), (3,4), (20,20) } 10 => { (5,5), (1,1), (8,9), (3,4), (20,20), (10,10) } 2 => { (5,5), (1,2), (8,9), (3,4), (20,20), (10,10) } 11 => { (5,5), (1,1), (8,9), (2,4), (20,20), (10,11) } 3 => { (5,5), (1,2), (8,9), (3,4), (20,20), (10,11) } -> (ignored)  after array iteration is done, repeat step 3 with minor modifications by iterating over map again and longest set will be with max diff b/w key and value.  Let key be k and value be x case1. there exists an entry for x-1, so update its value to x if x is greater than existing value. delete entry with key = k case2. there exists an entry for x+1, get its value, say vx and update k's value to vx. delete entry for with key = x+1. repeat this step with x = vx     Now iterate over { (5,5), (1,2), (8,9), (3,4), (20,20), (10,11) } 5 => no action, 1 => update 1's value to 4 and delete (2,4) resulting in { (5,5), (1,4), (8,9), (20,20), (10,11) } repeat with x = 4 update 1's key to 5 and delete (4,5) resulting in { (1,5), (8,9), (20,20), (10,11) } 8 -> update 8's value to 11 and delete (10, 11) resulting in { (1,5), (8,11), (20,20) } repeat with x = 11 -> no action 20 => no action { (1,5), (8,11), (20,20) }  Haven't mentioned above, at each step we will maintain key-value pair with max diff. So at the end of map iteration, we have result.  Complexit = O(n)...though I'm finding this complex..Is there a simplified way of doing this.	2014-12-10 11:52:30		
5802	vanul	65	you put a lot of effort into writing that up in plain text ... i wrote a similar solution shorter in code below : )	2014-12-10 11:52:30		
5803	wbqzu	65	@emalaj23: because he is here to learn and not brag about it that he solved the problem.Please explain your algorithm rather than just duming some lines of code.	2014-12-10 11:52:30		
5804	admin	65	didn't mean to brag - just suggesting that sometimes its easier to try to code it rather than explaining it in text  my solution is very similar to his in that we keep a map where the key and value represent the range of consecutive numbers, except that i combine the ranges of consecutives before and after, so when inserting 4 with existing entries (2,3) (3,2) (5,7) (7,5), all of that is simplified to (2,7) (7,2)	2014-12-10 11:52:30		
5805	fmzze	65	It is very hard to implement the iteration over hash map. It is simply not good to modify the hash map while erasing existing entries and inserting new entries. Of course I don't mean the solution is incorrect, I am just expressing the practicality of writing a source code.	2014-12-10 11:52:30		
5806	jippy	65	When you iterate over { (5,5), (1,2), (8,9), (3,4), (20,20), (10,11) } and merge (1,2) and (3,4) for instance, how do you know there won't be (5, 6) and others for instance ?  If so, how can you guarantee that this merging operation is in constant time (not linear, for instance) ?	2014-12-10 11:52:30		
5807	cfzie	65	Sorting seems too obvious. If this is a legit Google interview question, I'd suspect there must be a better solution than O(n log n).  I can think of a linear solution, but it has a lot of assumptions; if the numbers are small positive numbers, let's say [0,31), then you can use a 32 bit integer and set the bits with the corresponding number in the int array. e.g., S = { 5, 1, 9, 3, 8, 20, 4, 10, 2, 11, 3} becomes binary digit: 00000000 00010000 00001111 00111110  Then you can check the longest contiguous set bit sequence. This is linear time, but the worst case is the length of the bit vector, not the array length. Similarly, you can use 64 bit number for [0,64), for bigger numbers, you'll have to use a bit vector or a bit set.  Note that this solution will only make sense, if the numbers are positive, small, and/or there are a lot of repetitions.	2014-12-10 11:52:31		
5808	eucmc	65	On similar lines -- instead of trying to store them in bit array (or a binary number), we can simply iterate over [min, max] range and compute the max range that has all numbers present in given array.  This has fewer constraints. Only constraint :- [min, max] range should be reasonable. Numbers can be negative/big/repeated etc.	2014-12-10 11:52:31		
5809	gilit	65	@oOZz: what if there are duplicates? I am not sure how to interpret the word "set of numbers" here - does it mean they are unique? But if not then for instance [1,1,1,4,5] your answer would return [4,5]. Basically what you did is countring sort and we can extend it a bit for negative/bigger/not unique numbers using a different data structure.	2014-12-10 11:52:31		
5810	bexbp	65	@anon: numbers in a set have to be unique  for [1,1,1,4,5] -> answer is [4,5]	2014-12-10 11:52:31		
5811	tenuw	65	What is the expected time complexity? Sorting can get the job done easily in O(nlgn). Also, are there any pecularities about data that they all are +ve numbers and that they fall within a certain range, duplicates allowed etc etc?	2014-12-10 11:52:31		
5812	azmjc	65	sorting is definitely one solution with O(nlogn). Can we do it better?  there is no data pattern and numbers are not unique....	2014-12-10 11:52:31		
5813	nwkeg	65	@anonymous  I think we can try do better. The notion of 'consecutive numbers' divides the set into equivalence classes. We can construct an undirected graph with numbers as node values and edges between two nodes if they differ in value by 1. Run DFS to find connected components(which are equivalent classes) finding their size along. The connected component with maximum size is the maximum contiguous subset. Complexity would be O(|V| + |E|). In this case, since we have |E|<|V|, we can say that we have got a O(|V|) solution.  The disjoint-set data structure also enables to paritition the set into equivalent classes. I suppose we can use that as well to find a solution to this problem.	2014-12-10 11:52:31		
5814	gilit	65	@dumbo...this looks like good sol.  not sure how easy/difficult is to code this..	2014-12-10 11:52:31		
5815	zeice	65	@Dumbo: please explain how undirected graph can help here?	2014-12-10 11:52:31		
5816	krxlv	65	@Dumbo you can get the connected components in liner time. However, how will you create a graph with edges that differ in value by 1? Doesn't that require you to search the graph every time you try to insert a node/vertex and add the edge? That'll be a quadratic operation.	2014-12-10 11:52:31		
5817	tenuw	65	Build the adjacency list using a hash table.Keys would be the numbers and values would be (number, groupid) pairs.  Traverse the array. Add number k as a key to the hash table if not already present. If numbers k+1 and k-1 are present in the hash table, add k to their adjacency lists and vice-versa. (To add more to the implementation details, we need to add k to it's own adjacency list as well). We will then have constant time per insertion.  Initially the groupid is set to null for all of the elements.Iterate over the elements of the hash table and run DFS marking the groupid of the connected components if not already set. Alongside, maintain the size of the largest connected component and its groupid. In the end print all elements of the groupid with the largest size	2014-12-10 11:52:31		
5818	wbqzu	65	@Dumbo Is groupid just a bit set/not-set? If the elements come in the order 1,4,2,3....3 will go both in 2 and 4, how do we print that?	2014-12-10 11:52:31		
5819	wbqzu	65	@oOZz  Thought of giving a shape to my ideas using connected components of a graph. Finally, a flawless solution with O(n) time complexity that works putting an end to speculations.  Provide input as: 19 16 5 1 9 3 18 17 8 20 4 10 2 11 3 6 13 15 12 14	2014-12-10 11:52:31		
5820	krxlv	65		2014-12-10 11:52:31		
5821	eucmc	65		2014-12-10 11:52:31		
5822	tenuw	65	@dumbo..this looks good..	2014-12-10 11:52:31		
5823	nhibd	65	@Dumbo +1 my friend. This code works.	2014-12-10 11:52:31		
5824	bexbp	65	@Dumbo..  I see that you call 2 functions - readInput() which is O(n) and then findEquivalenceClasses().  In second function, you call DFS for each node. DFS is O(n) and so findEquivalenceClasses() becomes O(n^2) and thus overall complexity as O(n^2).  Not sure, I am missing out something in ur algo...	2014-12-10 11:52:31		
5825	eucmc	65	@Anonymous:  Regardless of the number of times DFS is called, the algorithm to find connected components runs in O(|V| + |E|). The reason for this is upon the first visit, DFS() marks a node as visited and explores its adjacency list. Once a node is marked as visited, its adjacency list is never explored again. Thus the adjacency list of each node in a graph is explored only once, hence the complexity O(|V| + |E|).  In this specific case, |E| < |V|, so the complexity is O(|V|) = O(n).	2014-12-10 11:52:31		
5826	ftfck	65	@Dumbo: I agree with you that since we mark nodes as visited so essentially we visit each node only once. However, how are marking nodes as visited in algo..  or shouldn't hashmap entries be removed to prevent them from being visited again.	2014-12-10 11:52:31		
5827	wbqzu	65	@anonymous  Here, I use the notion of a groupid, which is the id of a connected component. Initially the groupid is null. When a node is visited, groupid is set to a non-null value. This serves as a 'visited' flag in my algorithm. The groupid though is not much significance and is exclusively serving the purpose of a 'visited' flag.	2014-12-10 11:52:31		
5828	dkebi	65		2014-12-10 11:52:31		
5829	eucmc	65		2014-12-10 11:52:31		
5830	tenuw	65	May be some variables are unused and could be optimized. Variable name(s) are self explanatory  I think solution is so simple, does Google really look for it? Guys if you have any better solution ....	2014-12-10 11:52:31		
5831	ftfck	65	I worked out same logic!! :-)	2014-12-10 11:52:31		
5832	rrmeu	65	I made a mistake..... So in that case we need to sort it first. This may require typical nlog(n) time then some more operations.  So alternate solution is to maintain a HashTable (provided if numbers may not be unique)  NB: If the numbers are not unique then above code fragment should be changed ( a[k] == a[k + 1] + 1 || a[k] == a[k + 1]	2014-12-10 11:52:31		
5833	fowai	65		2014-12-10 11:52:31		
5834	gilit	65		2014-12-10 11:52:31		
5835	sqzqo	65	To find something hashing is better	2014-12-10 11:52:31		
5836	rrmeu	65	Can we use a hash table? we'll take the smallest element from the array and add 1 to it, and will check whether hash table has new element or not. if it has we'll again add one to the new element and check. (here we got a set of consecutive numbers). When new element is not present, we'll take the next smallest element in the hash table and go on with the same process.	2014-12-10 11:52:31		
5837	zeice	65	Declare a struct  struct consecseq{ int first; int last; }  Declare an array of this structure where elements will be stored in sorted order of first/last.  For every element in array;  1) Do binary search to find the position where to place the value 2) if currval == (structarray[i].start - 1), add this element and change the first. Check if this can be merged with structarray[i-1] if exists 3) if currval == (structarray[j].last + 1), add this element and change the last. Check if this can be merged with structarray[i+1] if exists 4) If none of above, add a new structarray element in the current position and move the later elements. 5) At the same maximum and index of maximum length should be maintained.	2014-12-10 11:52:31		
5838	jippy	65	O(n) solution using hash-table Need to traverse the array twice 1. First, fill the array elements in the hash-table Now, start with the first element (say k), 2. Check if k is present in the hash-table. If not, go to the next element. 3. If yes, find the max n such that elements between k & k+n are all present in hash-table, and then remove them from the hash-table. 4. Similarly, find the max m such that elements between k-m and k are present in the hash-table and remove them from the hash-table. 5. Now we know a sequence which is present in the array. 6. Save k-m and the count (m-n) (this is the sequence found so far). Update the min_element and the count if m-n is larger than so far count. 7. Remove k from the hash-table. 8. Move to the next element in the array and repeat step 2 9. The largest sequence is : min_element, min_element+1, ..., min_element+count	2014-12-10 11:52:31		
5839	tenuw	65	After sorting the whole list  We need two pointers start and end ->n1, n2, n3 .................................. N<- For each start pointer move pointer from end once end number == start number + (start index + difference between and start and end index) terminate program  Here if the probability is too high of getting a maximum sequence this provides best solution. If there is too low probability then it does not provide then HashTable provides best solution	2014-12-10 11:52:31		
5840	bjsiw	65	O(n) solution traversing the list only *once*	2014-12-10 11:52:31		
5841	jippy	65		2014-12-10 11:52:31		
5842	bjsiw	65		2014-12-10 11:52:31		
5843	plapd	65	The map STL itself is implemented as a BST. Even if you use it to store (key,value) pairs, it'll use logn operations every time you check whether a key exists or not. I don't really see this as an efficient solution.	2014-12-10 11:52:31		
5844	plapd	65	Instead of "map", you can use STL "unordered_map" that is implemented using a hash table. Easy as that.	2014-12-10 11:52:31		
5845	fowai	65	sites.google.com/site/spaceofjameschen/home/array/find-the-longest-subset-with-consecutive-numbers----google	2014-12-10 11:52:31		
5846	azmjc	65	I have implemented an algorithm with complexity O(n) using a Hash Table (I used STL "unordered_map") that only has to iterate over the array once, and has onl a max of 6 accesses to the Hash Table per iteration.  I have implemented other working versions of this functions with complexity O(n) (one of them using a bitset), but this is the one I like the most. Here is the C++ implementation:	2014-12-10 11:52:31		
5847	krxlv	65		2014-12-10 11:52:31		
5848	sqzqo	65		2014-12-10 11:52:31		
5849	qywrh	65	I thought of this solution:  1. Create all the subsets and store the integer of each line in a set (disregarding order of integer values). Store each set to a list. Lets say call the list as List<Set<Integer>> numberSubsetList = new ArrayList<Set<Integer>>(); 2. set int longestSetIdx = -1, currSetLen = -1, longestSet = -1 2. For each set in the list a. set currSetLen = # of item in current set a. get max and min while computing sum of integers (call the sum as totalVal) b. based on max and min compute sum of consecutive numbers between min and max consecSum ((#of items in set)/2)*(max+min) c. if totalVal = consecSum and longestSetLen < currSetLen then longestSetIdx = index of set longestSetLen = currSetLen 3. Return numberSubsetList.get(longestSetIdx)  Technically, this is O(N) disregarding of course the cost of populating numberSubsetList.	2014-12-10 11:52:31		
5850	rrmeu	65	Everyone does really complicated stuff.... Here is an order n solution that is very easy to read (in Python).	2014-12-10 11:52:31		
5851	gilit	65		2014-12-10 11:52:31		
5852	wbqzu	65		2014-12-10 11:52:31		
5853	gilit	65	Whoops forgot about those while loops :( (it's pretty late).  nvm them	2014-12-10 11:52:31		
5854	bjsiw	65	Plz explain your algorithm	2014-12-10 11:52:31		
5855	fowai	65	@Farid: 1. i think longest_option_lcs should be longest_option_lcs = lower_lcs + higher_lcs  2. It will blow up to O(n^2) when whole set is answer. O(n) for traversing the set and then for each element, you go through all elements again to construct longest set	2014-12-10 11:52:31		
5856	ftfck	65	the worst time complexity for this algorithm will be O(n^2), but i think this can easily be fixed. After using element to construct lcs, you can set hashmap[ele] = false. in the future traversal, if hashmap[ele] == false, then visit the following node. In this way, we make sure that each node is only visited once.	2014-12-10 11:52:31		
5857	gilit	65	thanks for explaination dumbo	2014-12-10 11:52:31		
5858	huiqq	65	1. find the sequences in a hashmap with H[x] = x-1 if x, x-1 both are in the list, otherwise H[X] = 0, through one iteration of the set. O(N) for example: { 5, 1, 9, 3, 8, 20, 4, 10, 2, 11, 3} maps to : { 1->-1, 2->1, 3->2, 4->3, 5->4, 8->-1, 9->8, 10->9, 11->10, 20->-1} 2. reverse the map and also get the headers of the sequences, through one iteration of the original list. new hashmap: { 1->2, 2->3, 3->4,4->5, 8->9, 9->10, 10->11 }, with headers {1, 8, 20 } (3) from each header find the sequences and return the longest one, iterate throght all numbers once. O(N)	2014-12-10 11:52:31		
5859	mrjku	65		2014-12-10 11:52:31		
5860	azmjc	65		2014-12-10 11:52:31		
5861	bjsiw	65	First we can sort the array and then start a check from the first index, checking next index value that it is consecutive with previous index value and keep incrementing count. As soon as we get a break from checking we can print the required subset up to the latest value of client.	2014-12-10 11:52:32		
5862	wbqzu	65	O(n) solution in Python.	2014-12-10 11:52:32		
5863	vanul	65		2014-12-10 11:52:32		
5864	krxlv	65		2014-12-10 11:52:32		
5865	mrjku	65	I also prefer using the hash table to solve the problem, and the expected time complexity is O(n), and here is my code in C++:	2014-12-10 11:52:32		
5866	plapd	65		2014-12-10 11:52:32		
5867	fmzze	65		2014-12-10 11:52:32		
5868	ethan	65	I first figured out the O(nlogn) solution (sort -> go through it once to find the longest sequence), and then immediately realized there must be an O(n) solution. Others have found it, but just to throw my C++, O(n) solution up here (I think others have come up with similar, but most seem to be more complex than they need to be):	2014-12-10 11:52:32		
5869	krxlv	65		2014-12-10 11:52:32		
5870	mrjku	65		2014-12-10 11:52:32		
5871	cfzie	65	A solution in Python:	2014-12-10 11:52:32		
5872	rrmeu	65		2014-12-10 11:52:32		
5873	eucmc	65		2014-12-10 11:52:32		
5874	huiqq	65	A solution in Python:	2014-12-10 11:52:32		
5875	ethan	65		2014-12-10 11:52:32		
5876	ethan	65		2014-12-10 11:52:32		
5877	plapd	65		2014-12-10 11:52:32		
5878	dgjji	65		2014-12-10 11:52:32		
5879	gilit	65	we can also try doing it with tree binary tree and then using in order traversal we can find a sequence. this sequence can be stored in an array...and then we can determine the next consecutive number in the complete sequence and so the subset.	2014-12-10 11:52:32		
5880	nhibd	65	Why can't we just use SortedSet<Integer> (close to O(1) add operation) ? This can solve the problem easily..	2014-12-10 11:52:32		
5881	ewigy	65	Amortized O(N) solution using HashSet and HashMap	2014-12-10 11:52:32		
5882	vanul	65		2014-12-10 11:52:32		
5883	ufdxg	65		2014-12-10 11:52:32		
5884	plapd	65		2014-12-10 11:52:32		
5885	fowai	65		2014-12-10 11:52:32		
5886	admin	65	=	2014-12-10 11:52:32		
5887	admin	66	Some of the previous solutions are wrong as discussed in the comments. Since the order matters, I'm not seeing a very efficient (polynomial) solution.  However, we can still use dynamic programming. We can pick bombs step by step, marking the bombs that we already used. Before we pick a bomb, we need to check if any of the previous chosen bombs affects it. We can use bitmasks with bit i set to 1 if we already picked bomb i, 0 otherwise. This leads to 2^N possible states.	2014-12-10 11:52:33		
5888	dkebi	66		2014-12-10 11:52:33		
5889	jippy	66		2014-12-10 11:52:33		
5890	ftfck	66	This takes O(2^N * N^2) time and O(2^N) memory. It's ok for N up to 20~22. To make it O(2^N * N) we can just use hashing instead of the nested loops. But it does not make a big difference here.	2014-12-10 11:52:33		
5891	wbqzu	66	Let dp[i][j] be the max value from ith and jth bomb on the circle, forcing i no greater than j. Actually by denoting any kth (i <= k and k <= j) bomb, we got a precisely sub problem with smaller size, such that: dp[i][j] = Max{ dp[i][bkd] + v[i] + dp[fwd][j] } , where bkd and fwd is by denoting kth bomb, the backward and foward range that not get effected.  Note this is a circle, sequence does matter, so dp[i][j] assumes from i to j, there are bombs, but from j to i, no bombs.	2014-12-10 11:52:33		
5892	sgiwy	66		2014-12-10 11:52:33		
5893	vanul	66		2014-12-10 11:52:33		
5894	ufdxg	66	As discussed in other posts, this kind of approach does not seem to work. You lose information about the circle part. few cases where you solution fails (you can use my semi-brute force given above to find more): v: 6 8 3 r: 7 3 1 Answer is 8, your code gives 9  v: 1 4 3 r: 9 0 3 Answer is 7, your code gives 5  v: 7 2 3 4 10 4 5 5 3 8 r: 5 5 2 6 6 1 2 4 3 3 Answer is 18, your code gives 19	2014-12-10 11:52:33		
5895	tenuw	66	@Miguel, you are right. As sequence matters, we can't simply split this circle in 2 parts and calculate them serperately. Maybe we have to use some sort of brute force.	2014-12-10 11:52:33		
5896	fowai	66	The solution can be easily modified to be correct. after detonating the first bomb, the circle is breaked up to a line; after detonating every subsequent bomb, a line is breaked up into 2 lines.  Just need to handle the first bomb (loop through all bombs as the first bomb) adds a factor of n in the complexity. But gonna be polynomial	2014-12-10 11:52:33		
5897	krxlv	66	d[i]= the best value you can get at the ith bomb. d[i]=max(when the ith bomb is included, when the ith bomb is excluded) so, d[i]=max(d[j]+v[i], such that j<i is not within the range of i or max(d[j] such that j<i))	2014-12-10 11:52:33		
5898	gilit	66	O(n2) time O(n) space	2014-12-10 11:52:33		
5899	sqzqo	66	I think this should work!	2014-12-10 11:52:33		
5900	sgiwy	66	This does not work because the array is circular, meaning that when you consider position N-1 you must not take into account positions 0..r[N-1] because they are neighbors	2014-12-10 11:52:33		
5901	dkebi	66	Can you suggest some correction here in my algo?	2014-12-10 11:52:33		
5902	huiqq	66	See the python solution posted above. Besides "i" you also need an "up_to_j" variable because positions j+1..N-1 were affected before.	2014-12-10 11:52:33		
5903	sqzqo	66	I dont think that it is missing any case even with a single variable i. Can you give some counter example?	2014-12-10 11:52:33		
5904	plapd	66	For example: v = { 1, 3, 1, 1, 1, 1 } r = { 1, 2, 1, 1, 0, 0 } The best is 4 by taking the 2nd and 5th bombs with value 3 and 1 (it affects the last bomb, so we can't add that one). However, following your description, d = { 1, 3, 3, 3, 4, 5 } because for the last bomb, you have no way to check that that value 4 actually includes a bomb that affects the last bomb.	2014-12-10 11:52:33		
5905	fmzze	66	Realized my mistake! Thanks! :)	2014-12-10 11:52:33		
5906	fowai	66	@Miguel Oliveria, isn't the ans for the test case given by you is 6: v = { 1, 3, 1, 1, 1, 1 } r = { 1, 2, 1, 1, 0, 0 } The best is 6 by taking 5th, 6th, 4th and then 2nd bombs respectively.	2014-12-10 11:52:33		
5907	rrmeu	66	@karaamaati no, it's not. Bomb 2 affects bomb 6, so we can't take both. Bomb 4 affects bomb 5, so we can't take both as well.	2014-12-10 11:52:33		
5908	vanul	66	@miguel - if the bombs were exploded in the order mentioned by karaamaati, you can get value of 6. So, what karaamaati said is right.	2014-12-10 11:52:33		
5909	ewigy	66	sorry, the order does matter. i misunderstood the problem	2014-12-10 11:52:33		
5910	fmzze	66	I'm thinking about modifying alex solution: (1) duplicate the input to make a circle Ex. given: v[]= { 1, 3, 1, 1, 1, 1 }, r[] = { 1, 2, 1, 1, 0, 0 },n=6 duplicate it to be: v'[] = { 1, 3, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1 } r'[] = { 1, 2, 1, 1, 0, 0, 1, 2, 1, 1, 0, 0 } (2) let dp[i] = {max dp[j]+v[i] | i is not in range of r[j] (consider i and j in a circle)} or {max dp[j] | i is in range of r[j]}, note that the size of dp[] is n (3) We need another loop: start at the i-th element in v', r' for internal dp; where 0<=i<n; At the end of each loop, let result = max{max of dp[], result}; I think I must have missed something...Could someone give a counter example?	2014-12-10 11:52:33		
5911	plapd	66	Bomb N-1 is neighbor to bomb 0?	2014-12-10 11:52:33		
5912	bjsiw	66	yes!	2014-12-10 11:52:33		
5913	huiqq	66	That makes it more difficult. Did you ask the limit on N, the number of bombs?	2014-12-10 11:52:33		
5914	fowai	66	No,but the idea which use a array dp[i][j] to solve this problem is right.So I think n^3 is OK.	2014-12-10 11:52:33		
5915	tenuw	66	when a bomb explodes, is the circle readjusted? I don't see anything pointing to that in the question but someone asked it and now that i checked the example it seems the order to explode the bombs matter. If that's the case, then the problem is even much harder and the DP[i][j] solution above does not work.	2014-12-10 11:52:33		
5916	bjsiw	66	I had assumed that we had to pick a set of "non-overlapping" bombs, like if they were detonated at the same time. That was the most natural "dynamic programming" way for me to solve this question.  In this case, the above python solution does not work. I don't have an efficient solution for this, i'll think about it :)	2014-12-10 11:52:33		
5917	krxlv	66	Got me puzzled for a few minutes after which I realized this:- Ever seen the MineSweeper Game on Windows OS. This is a popular game in which you find values and make sure that you bypass mines( or bombs :) ) .  Your problem is to find a WIN ( the best WIN actually) in MineSweeper. Ify ou can GOOGLE a little, you should get your answers.	2014-12-10 11:52:33		
5918	azmjc	66	First, if Bomb[i] is in effective range of Bomb[j], add a directed edge from j to i. Then we can compute strongly connected components. If we looks these strong connected component as a single node, then the original graph will transform to a DAG. In each node (strongly connected component) we can only get value from one bomb. We can get values from all node (strongly connected component) by detonating bomb start from the node with zero out degree. This is not a DP, and I am not sure if this is correct.	2014-12-10 11:52:33		
5919	rrmeu	66	this is not correct. detonating a bomb j does not detonates the bombs within its range (and so on recursively), it just destroys them which is different (we're not able to get their value).	2014-12-10 11:52:33		
5920	rdfeo	66	will greedy algorithm work? Every time detonate the bomb that has least loss (Loss is the sum of the values of all the affected bombs). This is doable in n^3	2014-12-10 11:52:33		
5921	rrmeu	66	Although the question states that it's dp, the greedy solution seems to work.	2014-12-10 11:52:34		
5922	nwkeg	66	no it doesnt. contradicting examples- v 1 1 10 1 r 0 1 2 1  greedy solution (wrt range) will destroy the bomb with v 10.  another eg: v 10 5 8 r 5 0 0  greedy solution wrt Value will destroy 5 and 8 both - which are part of actual solution (ans= 23).	2014-12-10 11:52:34		
5923	mrjku	66	Let bCnt be number of remaining bombs to be detonated Let detList be an efficient datastructure that can store the detonated bombs i-> ith bomb to be exploded  det(i,bCnt,v,r,detList) { if(bCnt<=0) return 0; else{ if i is in detList return det(i+1,bCnt,v,r,detList); else{ int detValue1 = det(i+1,bCnt,v,r,detList); add i to detList along with all neigbours in range of i's detonation int detValue2 = det(i+1,bCnt-1-2*(r[i]),v,r,detList) + v[i]; remove i and all its neigbours from detList; return max(detValue1,detValue2); } }	2014-12-10 11:52:34		
5924	jippy	66	This might work...	2014-12-10 11:52:34		
5925	vanul	66	in C++, dynamic programming	2014-12-10 11:52:34		
5926	qywrh	66		2014-12-10 11:52:34		
5927	krxlv	66		2014-12-10 11:52:34		
5928	admin	66	Can it be done this way. We first sort all bombs based on x co-ordinate, is x is same, sort on effect range. Our final solution is going to have some sequence of bombs exploding, let's say a1,a2...ak. We say that dp[i] is the solution when i is the last bomb in the sequence definitely detonated. We just calculate all other bombs from 1 to i-1 which can be detonated before i so that i can be detonated. Calculate the value obtained. That is dp[i]. Ans is max (dp[i] | 1 <=i <= n)	2014-12-10 11:52:34		
5929	admin	66	Same idea, as described before, implementation using bool vector for used marker, probably slower than bitsets, but code is cleaner	2014-12-10 11:52:34		
5930	rrmeu	66		2014-12-10 11:52:34		
5931	wbqzu	66		2014-12-10 11:52:34		
5932	nwkeg	66	My python solution with memoization.	2014-12-10 11:52:34		
5933	krxlv	66		2014-12-10 11:52:34		
5934	cfzie	66		2014-12-10 11:52:34		
5935	ewigy	66	Sorry forget to add actual update of cache dictionary	2014-12-10 11:52:34		
5936	fowai	66		2014-12-10 11:52:34		
5937	huiqq	66		2014-12-10 11:52:34		
5938	ufdxg	66	you can just edit your first post	2014-12-10 11:52:34		
5939	eucmc	66	Where do you take into account the fact that the bombs are in a circle?	2014-12-10 11:52:34		
5940	krxlv	66	the "min(j, N + i - ei)" does it	2014-12-10 11:52:34		
5941	nwkeg	66	why not try bombs([(1, 3),(0, 2), (1, 1) ]) and see what will happen	2014-12-10 11:52:34		
5942	plapd	66	We should just leave the ith bomb in the circle rather than simply remove it when it is not denoted or be affected by others. Maybe we can set the value of the denoted and affected bombs to 0, and assume that the bomb is still there but we'll never need to denote the bombs whose value is zero. Then we try in this circle over and over again until every bomb's value is set to 0.(It's just a rough idea and I don't know how to implement it for now.)	2014-12-10 11:52:34		
5943	nwkeg	66	Unfortunately, this is wrong. Consider input	2014-12-10 11:52:34		
5944	krxlv	66		2014-12-10 11:52:34		
5945	bjsiw	66		2014-12-10 11:52:34		
5946	mrjku	66	Correct answer is 8, detonation sequence is 0, 4, 1, 3. Your code gives 6.	2014-12-10 11:52:34		
5947	zeice	66	Algorithm sketch: max_bomb(v, r, denote_nothing) = max { v[i] + max_bomb(v, r, denote_i | i = 0 .. n-1}, where denote_nothing represent the initial state.	2014-12-10 11:52:34		
5948	fowai	66		2014-12-10 11:52:34		
5949	fmzze	66		2014-12-10 11:52:34		
5950	azmjc	66		2014-12-10 11:52:34		
5951	eucmc	66		2014-12-10 11:52:34		
5952	rdfeo	66		2014-12-10 11:52:34		
5953	eucmc	66	If you describe your application of MCM, you might get the votes up	2014-12-10 11:52:34		
5954	sgiwy	67	You can create a directed graph where vertices represent the characters in the language and the edges represent the order relationship, i.e., if there is an edge Eij, then character Vi comes before character Vj in the alphabet. You need to process two consecutive words in the dictionary at a time to determine the precedence relationship of the characters, so it will take O(N * M) time to create the graph, where N is the number of words and M is the length of the words. Then use topological sorting to get characters in the correct order in O(|V| + |E|) time	2014-12-10 11:52:35		
5955	azmjc	67	Could you please exemplify with a small alphabet, say {a,b,c} mapped to {c,a,b}?	2014-12-10 11:52:35		
5956	nwkeg	67	Example for Alphabet C, A, B: Imagine this is your dictionary below. 1. C 2. CAC 3. CB 4. BCC 5. BA  These are the steps based on the example above. 1. Compare line 1 and line 2. Create vertices C and A 2. Compare line 2 and 3. Create vertex B. Create Edge E = A->B, meaning A comes before B 3. Compare line 3 and 4. Add edge C->B meaning C comes before B 4. Compare line 4 and line 5: Add edge C->A  This yields to a DAG below. C->B C->A A->B  C->A->B | ^ |---------|  and the topological sort will give you: C,B,A  As you can see, you cannot determine the correct order of the alphabet, if there is a directed cycle in the graph. So the dictionary given must generate a DAG to find a solution.	2014-12-10 11:52:35		
5957	jippy	67	@oOZz - is there a way to determine that you've processed enough of the dictionary to generate the alphabet order? In an English dictionary, it may be enough to just process the a's to get enough info for a proper ordering. Not that this is a process that needs to be completely optimized since you will probably run it once per language.  How would your solution handle the case where there isn't enough info? Say the letter f only appears in three words in this strange language and those words may or may not give us any ordering info at all.	2014-12-10 11:52:35		
5958	plapd	67	I go on building pairs of characters(defining order) from each pair of strings, until I get 25 pairs with different first character(as 26 characters in total), according to this algo -- the first non-matching character from the given two strings defines an order between those unmatching characters. Ex: if str1=KPLLKDE, str2=KPLJKDE, in dictionary str1 appears before str2, L<J. So we add a pair L-J. At this point, I update two counts. If this is the first time L is found on left side of a pair, numOfOutgoings++. If this is the first time J is on right side of a pair, numOfIncomings++;  Continue this process till we have numOfIncomings == 25 && numOfOutgoings==25.  Now I build a graph as below - First 26 nodes with 1 for each char. And if my pairs are {sk, kp, pl, lm etc} in my graph these edges exist s->k, k->p, p->l, l->m etc.  At this point I have a graph with 26 nodes, with at least 25 edges defining the order between some 2 chcaracters covering enough orders to define complete ordering. Now do the topological sort on these nodes, and you have the order of the new alphabet.	2014-12-10 11:52:35		
5959	vanul	67	Correction: "until I get 25 pairs", should be "until I get numOfIncomings=25 & numOfOutgoings=25" as explained in later statements.  Also, it is true that graph has enough info to give required info. But any topological sort may not necessarily give the answer.	2014-12-10 11:52:35		
5960	bexbp	67	But topological sorting will work only if the graph is DAG. This may not happen.	2014-12-10 11:52:35		
5961	nhibd	67	Hi,  I dont know whether i am clear with the question. My Answer is, you just want to find out the order of Alphabets. -> Take the first string and in that take out the first Alphabet, this represents the first alphabet. -> Select second string, such that 1st alphabet should be different, than the previous, which represents second alphabet in the series. EX: Let dictionary be Gun God Graveyard Money Maintain -> here 1st alphabet is g, in the second string check whether 1st alphabet == g, if yes, skip else store, which represents Second alphabet. -> Hope this solution can work. Now once u get all the alphabets u can store in a graph or linked list.	2014-12-10 11:52:35		
5962	huiqq	67	Seems to be right.. but in case if there is no word starting from a particular letter, you might miss it in the sequence...	2014-12-10 11:52:35		
5963	cfzie	67	In Dictionary is there any word, starting with special characters means #, ?.. etc. If it starts like that also, it will store the first alphabet, as i am checking with letters which we got previously. here checking 'm' with 'g'.	2014-12-10 11:52:35		
5964	nhibd	67	Exactly how I will approach the solution	2014-12-10 11:52:35		
5965	rrmeu	67	@prashanthreddy: question clearly states that characters will be of english alphabet, so we can assume, you wont get special characters.  @sgarg: this solution should be extended to resolve this issue.  1) We prepare a new ordering list of alphabets based on 1st character of new dictionary. Also will keep count for number of characters found. 2) If number of characters are less than 25, then we should continue the same process for second alphabet. This time for only those string which has same matching first character. 3) During step 2, we may found new characters which must be in between of existing list, so list should be updated accordingly. 4) If after 2 & 3 steps, we still lacks required number of characters, then same 2 & 3 steps should be repeated but this time for 3 character of strings whose 1st two characters are same.  Repeatedly doing this until we get all characters.	2014-12-10 11:52:35		
5966	krxlv	67	Suppose the first letter is 'z' for this language. But no word starts from z in this language so no word starting from z is present in the dictionary.  Where will your algorithm put z if you are checking only first characters and z is not present as the first character of any word?	2014-12-10 11:52:35		
5967	admin	67	Create a DAG (Directed Acyclic Graph) from the list of provided words, and perform a topological sort on the graph.	2014-12-10 11:52:35		
5968	huiqq	67		2014-12-10 11:52:35		
5969	xhgls	67		2014-12-10 11:52:35		
5970	xhgls	67	}	2014-12-10 11:52:35		
5971	wbqzu	67	There is a cycle in here and hence it is an invalid DAG.  "HACD", "HIEF",  "ID", "JAC", "K", "KG", "L", Order of the strings above suggest that a -> i -> j -> k -> l  "LZ", "Z", "A" This order suggests that l -> z -> a which is contradictory to the order deduced above. This is leading to a loop - a -> i -> j -> k -> l -> z -> a	2014-12-10 11:52:35		
5972	plapd	67	Build a directed graph according to the relationship of sorted strings. Also add a directed cycle detect logic to do the input detection in case the input is not correct. Then use a topological sort to get the sorted chars, it is basically a depth-first-search, then use a stack to reverse, which will get the ordered output.	2014-12-10 11:52:35		
5973	gilit	67	What about another approach? What if we just sort the dictionary of new alphabet words by length and hopefully find a very small set of words with a very long length. For instance, en.wikipedia.org/wiki/Longest_word_in_English has the longest words. If we can find just one word that is unique in length, then we can easily map it back from the scrambled to the original alphabet. If we have a few, well, then we could then go and try each of them out exhaustively.	2014-12-10 11:52:35		
5974	dgjji	67	import java.util.HashMap; import java.util.Map;  public class AlphabetOrder {  static class Pos {  public Pos(int start, int end) {  this.start = start; this.end = end; }  private int start, end;  public void setStart(int start) {  this.start = start; }  public void setEnd(int end) {  this.end = end; }  public int getStart() {  return start; }  public int getEnd() {  return end; } }  private static String getChar(String word) {  return word.substring(0, 1); }  private static boolean put(Map<String, Pos> alp, String ch, int pos) {  boolean insert = false; if (alp.containsKey(ch)) {  Pos p = alp.get(ch); if (p.getStart() > pos) { p.setStart(pos); } if (p.getEnd() < pos) { p.setEnd(pos); } } else { alp.put(ch, new Pos(pos, pos)); insert = true; }  return insert; }  private static void calculate(String[] dictionary, int start, int end, Map<String, Pos> alp) {  if (end - start == 1) return;  int mid = (start + end) / 2; String ch = getChar(dictionary[mid]); boolean insertFlag = put(alp, ch, mid); if (insertFlag) { calculate(dictionary, start, mid, alp); calculate(dictionary, mid, end, alp); } else { if (start < alp.get(ch).getStart()) {  calculate(dictionary, start, alp.get(ch).getStart(), alp); } if (end > alp.get(ch).getEnd()) {  calculate(dictionary, alp.get(ch).getEnd(), end, alp); } } }  public static void main(String... args) {  String[] dictionary = { "plenty", "poem", "pink", "pink", "pink", "pink", "pink", "pink", "pink", "pink", "pink", "pink", "pink", "pink", "pink", "about", "and", "computer", "college", "cat", "june", "eight" }; // String[] // dictionary={"plenty","poem","pink","mood","mango","mike","is","ink","ilets","in","table","type","toy","tv","apple","about","and","computer","college","cat","june","eight"};  Map<String, Pos> alp = new HashMap<String, Pos>();  int i = 0; int j = dictionary.length - 1; put(alp, getChar(dictionary[i]), i); put(alp, getChar(dictionary[j]), j);  calculate(dictionary, i, j, alp);  System.out.println(alp.keySet()); System.out.println(alp.keySet().size());  }  }	2014-12-10 11:52:35		
5975	huiqq	67	It's time complexity is O(logn)	2014-12-10 11:52:35		
5976	mrjku	67	Another approach for this is you maintain one bool array of 26 elements(assuming new language alphabet can be represented with ASCII char set). You traverse the first word's characters and set the right position in bool, if its not set, it means it's a unique char, Add it to one List collection. If its already set, don't add it. Once you list collection size is 26, it means you discovered all character sequences.	2014-12-10 11:52:35		
5977	bjsiw	67	Why not recursively:  Take the dictionary, first word, ok starting letter is [a]. Last world, starting letter is [z]. World at half the dictionary, starting letter is [X]. ([X]!=[a] && [X]!=[z]) then call again the function for 2 separate dictionaries: [a-x] and [x-z]. Of course the dictionary could split in one half only not 2, if [X]=[a] or [X]=[z]. And so on.	2014-12-10 11:52:35		
5978	admin	67	*word not *world, my bad XD	2014-12-10 11:52:36		
5979	ethan	67	write recursive function which will use the chunk of dictionary, take first letter in the middle of chunk (put in the middle of alphabet), than call itself twice with left and right portion of chunk.  speed O(logn)	2014-12-10 11:52:36		
5980	dgjji	67	Yeah, exactly. The best way I guess. (I proposed the recursive version), forgot to put the name :)  But it took me longer than 15 minutes, 'cause I tried an approach with tree sets, to split the array of word node by node... but that is lot more complex. And useless. An array and 2 indexes. Easy and straightforward.  sadly, no link allowed, so no solution from ideone. :(	2014-12-10 11:52:36		
5981	rrmeu	67	//the recursive part  public void split(int a, int z) { iterations++; int offset = a; int split = z - a; if (vocabulary[a].toLowerCase().charAt(0) == vocabulary[z].toLowerCase().charAt(0)) { if (letterOrder.indexOf(vocabulary[a].toLowerCase().charAt(0))==-1) { letterOrder = letterOrder + vocabulary[a].toLowerCase().charAt(0); } return; } else { split(a, offset + split / 2); split(offset + split / 2 + 1, z); }  }	2014-12-10 11:52:36		
5982	xhgls	67	How about this, Take first word of dictionary. Add its first letter in a linked list. Lets call this linked list Alphabets. Take next word of dictionary. Find the index where this word is differnent from the last word. If the letter of difference is not in list already, insert it in the list after the position of letter in last word at the same index. For ex: let the last word be 'uiodl' and the current word is 'uiydk' or 'uiydl'. then the new letter would be 'y'. Now as it replaces the 'o' in last word. 'y' should come after 'o' in the Alphabet. Now insert letter 'y' in Alphabet linked list after 'o'. Repeat this for rest or the words.	2014-12-10 11:52:36		
5983	ethan	67	The process stops if the dictionary ends or 26 letters are listed.	2014-12-10 11:52:36		
5984	azmjc	67	That seems to be slower than the recursive solution.  Still, the cost-efficient recursive version has one problem: if the dictionary does not contain any letter starting with one letter, said that "h", for example. If you consider this particular condition, you will have to consider also the possibility of a letter contained in one word only.  If you include that as a possibility, there is no other way to deal with the problem than to scan it completely. Every word of it. In that case, which kind of storing you will use (string, linked list etc) doesn't do any difference, 'cause the expensive part of the problem will be the search.	2014-12-10 11:52:36		
5985	wbqzu	67	1. Take every two consecutive words and find first difference letters in them	2014-12-10 11:52:36		
5986	ewigy	67		2014-12-10 11:52:36		
5987	ftfck	67		2014-12-10 11:52:36		
5988	rrmeu	67	here we have the letters order a->e  For every letter of alphabet create an array where check what letters are before it. It can be bit array. 4 bytes integer is enough for 26 letters alphabet. 26 letters * 4 bytes = 104 bytes memory.  2. Next step for every letter of alphabet count how much letters are before it. Here use array of ranks and recursion algorithm for counting not counted letters before.	2014-12-10 11:52:36		
5989	bjsiw	67		2014-12-10 11:52:36		
5990	nwkeg	67		2014-12-10 11:52:36		
5991	huiqq	67	3. Last step sort 26 letters by rank.  big O( size_of_dictionary * size_of_word) and just 208 bytes memory!	2014-12-10 11:52:36		
5992	gilit	67	import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.Map;   class DictionaryCopmerator implements Comparator{  Map map = new HashMap();  DictionaryCopmerator() { map.put("c", 1); map.put("b", 2); map.put("a", 3); map.put("t", 4); }  @Override public int compare(Object o1, Object o2) { // TODO Auto-generated method stub String s1 = (String)o1; String s2 = (String)o2;  boolean b = true;  int i=0,j=0;  while(b) { String c1 = ""+s1.charAt(i); String c2 = ""+s2.charAt(j);  Integer order1 = (Integer)map.get(c1);  Integer order2 = (Integer)map.get(c2);   if(order1>order2) return 1;  if(order1==order2) { if(s1.length()>s2.length()) return 1; else if(s1.length()<s2.length()) return -1; return 0; }   if(order1<order2) return -1;  i++; j++; }  return 0; }  }  public class NewDictionary {   public static void main(String[] args) {  String s[] ={"a","cat","c","bat","c"};   for (int i = 0; i < s.length; i++) { System.out.println(s[i]); }  System.out.println("\n");  Arrays.sort(s, new DictionaryCopmerator());  for (int i = 0; i < s.length; i++) { System.out.println(s[i]); }   } }	2014-12-10 11:52:36		
5993	rdfeo	67	Duplicate of: /question?id=19114716	2014-12-10 11:52:36		
5994	mrjku	67	r u sure your "sorted words" correct? " ntr " comes before "act" means, "n" is ahead of "a", but words " tan" shows "a" comes before "n".	2014-12-10 11:52:36		
5995	cfzie	67	Sorry , I misunderstood. I got the meaning.	2014-12-10 11:52:36		
5996	ufdxg	67	Will someone please tell me how to infer "n" is head of "r"? In my opinion, the order of "n" and "r" can not be determined based on the given example.	2014-12-10 11:52:36		
5997	qywrh	67	Yeah seems like you can only conclude "r" comes before "c" because "arc" comes before "act". So I guess in this case both "n r c a t" and "r n c a t" are valid solutions, and I returning any one of them is fine? The question should indeed specify which solution to return when there are multiple...	2014-12-10 11:52:36		
5998	ufdxg	67	if the order of some character can be determined, this character is not in final result.	2014-12-10 11:52:36		
5999	nhibd	67		2014-12-10 11:52:36		
6000	rrmeu	67		2014-12-10 11:52:36		
6001	wbqzu	67	sorry, typo " can't be determined"	2014-12-10 11:52:36		
6002	cfzie	67	Question about this code:	2014-12-10 11:52:36		
6003	nwkeg	67		2014-12-10 11:52:36		
6004	ethan	67		2014-12-10 11:52:36		
6005	wbqzu	67	Does it mean the new relation will replace the existing one if their keys (the first characters) are the the same? Ex: you have (a,b) relation in the map already. And then a new relation (a,c) coming up. Does (a,c) replace (a,b)?	2014-12-10 11:52:36		
6006	admin	67	What is the running time?	2014-12-10 11:52:36		
6007	krxlv	67	How about you have 26 trees, one for each alphabet, Properties of the tree: It has a root, and n children Root occurs before all its children.  In English tree for A has 25 children, B has 24 Children. Similarly keep building the trees and stop when the number of children in all the trees is 25*(25+1)/2=325. Now order the roots based on the number of children you have.	2014-12-10 11:52:36		
6008	ewigy	67		2014-12-10 11:52:36		
6009	sqzqo	67		2014-12-10 11:52:36		
6010	zeice	67	This is naive implementation -- will not perform efficiently:  1. Check 2 words of alien dictionary at a time (eg: check word1 & word2, word2 & word3 and so on..) 2. Iterate each letter in both words, find differing letters. Eg: if the words are:	2014-12-10 11:52:36		
6011	ftfck	67		2014-12-10 11:52:36		
6012	rdfeo	67		2014-12-10 11:52:36		
6013	bjsiw	67	Then we know a comes after h.  3. Continue to store this 'comes after' information in a list datastructure until all word in the dictionary is visited	2014-12-10 11:52:36		
6014	bexbp	67	Edit: instead of a list, use a tree data structure. If the 'comes after' information we receieve is transitive, eg: x->u , u->q then we can simply create a tree x->u->q. But if it's branching, eg: x->u x->w, we don't know yet what's the precedence of u vs w. Temporarily add both as children of x until more information is found. The memory address of tree nodes can be indexed using a map to improve performance	2014-12-10 11:52:36		
6015	ethan	67	We can start with the first character of the first word of the Alien's dictionary and go through all the words until the entire dictionary is exhausted. In each step we can search for the next word that starts with an new character (hence the new alphabet of this particular language) in 2^k and locate its exact location within the list of the words via searching between 2^(k-1) and 2^k. The code is somewhat like this:	2014-12-10 11:52:36		
6016	cfzie	67		2014-12-10 11:52:36		
6017	qywrh	67		2014-12-10 11:52:36		
6018	mrjku	67	there o(lg n) to find k, and O(lg n) to find index m. The for loop will take maximum of O(n). Hence, the complexity is O(n log n). Please correct me if there is a mistake in my interpretation.	2014-12-10 11:52:36		
6019	zeice	67	Hi peeps, read through a few answers and couldn't find someone thinking the same way I did, could someone point out whether this is correct  Approach:	2014-12-10 11:52:36		
6020	vanul	67		2014-12-10 11:52:36		
6021	krxlv	67		2014-12-10 11:52:36		
6022	rdfeo	67	Pseudo code: will add later	2014-12-10 11:52:36		
6023	zeice	67	Perhaps a stupid answer - but I have used dictionary (English) and it also contains 'one letter word' representing a character in an alphabet.	2014-12-10 11:52:36		
6024	bexbp	67		2014-12-10 11:52:36		
6025	xhgls	67		2014-12-10 11:52:36		
6026	plapd	68	There are two O(n) solutions for this problem that does not require ordering.  1. You can find the median in O(n) and then rearrange the elements around the median  2. (Better Solution) If you notice the desired ordering, the even numbered elements are bigger (or equal) than the next element, and the odd numbered elements are less than (or equal) than the next element, of course I am assuming the array is 0 offset.  So, you can iterate the array and swap the elements that doesn't match this arrangements,e.g., swap A[i] and A[i+1], when i is even and A[i] < A[i + 1].	2014-12-10 11:52:38		
6027	zeice	68	or swap A[i] and A[i+1], when i is odd and A[i] > A[i + 1].	2014-12-10 11:52:38		
6028	nhibd	68	Beautiful!	2014-12-10 11:52:38		
6029	huiqq	68	The 2nd solution may not work always. E.g:- It works for (0 1 2 3) giving 1 0 3 2 but for (2 3 0 1) it gives 3 2 1 0 which is incorrect.	2014-12-10 11:52:38		
6030	dgjji	68	Are you sure solution 2 works? Check for this input 8 9 6 7	2014-12-10 11:52:38		
6031	wbqzu	68	The median solution looks cool. Find elements greater than the median and put them in even numbered locations. Find elements smaller than the median and put them in odd numbered locations.	2014-12-10 11:52:38		
6032	admin	68	Yeah, the median solution is cool. But what is it's efficiency class? Isn't it quadratic?	2014-12-10 11:52:38		
6033	qywrh	68	No, finding median is O(n). And then we linearly traverse the input array A. If A[i] > median, we put it in a even numbered location in the output array. If A[i] < median, we put it in a odd numbered location. So this will also take O(n) time but O(n) space too.	2014-12-10 11:52:38		
6034	gilit	68	Yeah, finding median is O(n). That is fine. My question is about worst case efficiency. How does it perform on this worst case input (1 2 3 4 5 6 7 8 9)?	2014-12-10 11:52:39		
6035	gilit	68	It will still be linear for your input. The basic code is as follows:-	2014-12-10 11:52:39		
6036	eucmc	68		2014-12-10 11:52:39		
6037	krxlv	68		2014-12-10 11:52:39		
6038	zeice	68	Here is the C++ code for solution 2:	2014-12-10 11:52:39		
6039	tenuw	68		2014-12-10 11:52:39		
6040	wbqzu	68		2014-12-10 11:52:39		
6041	krxlv	68	Very nice solution of swapping adjacent numbers if they don't fit in the arrangement. O(n) solution without any extra space. How did you come up with this?	2014-12-10 11:52:39		
6042	ftfck	68	Sorry the above code needs a few changes, because I typed too fast:	2014-12-10 11:52:39		
6043	nwkeg	68		2014-12-10 11:52:39		
6044	krxlv	68		2014-12-10 11:52:39		
6045	bjsiw	68	@pratik Here are the trace output after each swap for your counter example: Start: 2 3 0 1 3 2 0 1 3 0 2 1 End: 3 0 2 1  @srini  Start: 8 9 6 7 9 8 6 7 9 6 8 7 End:9 6 8 7	2014-12-10 11:52:39		
6046	sqzqo	68	@pratik, Yes, your above code runs in linear time but uses additional storage which is equal to original array.	2014-12-10 11:52:39		
6047	dgjji	68	@oOZz, That's cool. You are right, it runs in linear time. This can also be solved with 3 elements at a time, placing smallest of 3 in the middle position and moving 2 positions right, as I mentioned below. Also, about your solution 1, isn't it quadratic time in worst case?	2014-12-10 11:52:39		
6048	dgjji	68	No srini, they are both linear time solutions. In solution 1 you, you first find median in O(n) and then rearrange the elements in O(n), so it's 2 *O(n) , which is O(n) asymptotically, not O(n^2).	2014-12-10 11:52:39		
6049	azmjc	68	@oOZz, And you mean without using extra storage?	2014-12-10 11:52:39		
6050	dgjji	68	I support this solution. just keep checking backward for its right place. Only need update is swap once more if i-1<i<i+1 or other way around. if once more time swap then it will break the order and then it will algo will never look further back. So its still O(n).	2014-12-10 11:52:39		
6051	mrjku	68	Right. But after two numbers are swapped, don't forget to check if it violate the order of A[i-1] and A[i], it may happen.	2014-12-10 11:52:39		
6052	qywrh	68	Your solution 2 is the best. @Avaln: you don't need to check backwards. It is satisfied automatically.	2014-12-10 11:52:39		
6053	cfzie	68	For the 2nd solution, you will want to check the number at every index, not only the even-index ones. Otherwise it will not work, as shown by the counter example given previously by the other person: 8 9 6 7 => 9 8 7 6  So you should do as such (0-index): at even index i, swap A[i] and A[i+1] if A[i] < A[i+1] at odd index j, swap A[j] and A[j+1] if A[j] > A[j+1]	2014-12-10 11:52:39		
6054	bjsiw	68	2nd sol does not work for {8,7,3,10,0,4,13,9,11,2};	2014-12-10 11:52:39		
6055	rdfeo	68	@DD, FYI 8 7 3 10 0 4 13 9 11 2 8 3 7 10 0 4 13 9 11 2 8 3 10 7 0 4 13 9 11 2 8 3 10 0 7 4 13 9 11 2 8 3 10 0 7 4 13 9 11 2 8 3 10 0 7 4 13 9 11 2 8 3 10 0 7 4 13 9 11 2 8 3 10 0 7 4 13 9 11 2 8 3 10 0 7 4 13 9 11 2	2014-12-10 11:52:39		
6056	huiqq	68	Sort array first and swap pairs of numbers?  So 7 6 5 4 3 2 1 becomes - 7 5 6 3 4 1 2	2014-12-10 11:52:39		
6057	bexbp	68	Simple and elegant, thumbs up!	2014-12-10 11:52:39		
6058	zeice	68	impresive .but this problem can have multiple sequence of answer .so what if they ask for some other sequence.	2014-12-10 11:52:39		
6059	admin	68	Swap is correct but you seriously don't need to sort it first, really!	2014-12-10 11:52:39		
6060	rdfeo	68		2014-12-10 11:52:39		
6061	eucmc	68		2014-12-10 11:52:39		
6062	xhgls	68	An O(n) time, O(1) space solution:  Consider 3 consecutive numbers A(i), A(i+1), A(i+2)  Suppose A(i) and A(i+1) are in correct order. If A(i+1) and A(i+2) are also in correct order, then continue doing for A(i+1), A(i+2), A(i+3);  If A(i+1) and A(i+2) are not in correct order, then swap A(i+1) and A(i+2). After swapping, A(i), A(i+2), A(i+1) must be all in correct order (can you check that ?). Then, continue doing for A(i+2), A(i+1), A(i+3)...  Initially, we can swap A(1) with the max of (A). Then A(1), A(2) will be in correct order.	2014-12-10 11:52:39		
6063	bjsiw	68		2014-12-10 11:52:39		
6064	krxlv	68		2014-12-10 11:52:39		
6065	bjsiw	68		2014-12-10 11:52:39		
6066	ethan	68		2014-12-10 11:52:39		
6067	ethan	68	Arrange first 3 elements (0,1,2) in desired order and then shift 2 positions right and again order next 3 elements (2,3,4) and continue doing the same till you reach end of the array. Resultant array is the desired one.  This algorithm does n/2 iterations and no extra space.	2014-12-10 11:52:39		
6068	zeice	68	How can it be n/2? What about comparisons done to arrange 3 numbers?	2014-12-10 11:52:39		
6069	eucmc	68	It is n/2 because you are shifting 2 positions right. But this will make 2 comparisons to find smallest of 3 on each iteration. So, effectively it is O(n).  And regarding comparisons, compare 3 elements and place smallest of 3 elements in the middle position (which is always odd position because we are shifting 2 positions on each iteration) of the 3 element window.  Example  Input: 1 2 3 4 5 6 7  1st: 3 1 2 4 5 6 7 2nd: 3 1 5 2 4 6 7 3rd: 3 1 5 2 7 4 6	2014-12-10 11:52:39		
6070	xhgls	68		2014-12-10 11:52:39		
6071	bexbp	68		2014-12-10 11:52:39		
6072	bexbp	68	O(n) Solution, can any tell am I correct or not? Thanks in advance.	2014-12-10 11:52:39		
6073	gilit	68		2014-12-10 11:52:39		
6074	nhibd	68		2014-12-10 11:52:39		
6075	cfzie	68	void sort_like_wave(vector<int>& a){ bool rise = false; for (int i = 0; i < a.size()-1; i++){ if (rise){ if (a[i] > a[i+1]) swap(a[i], a[i+1]); }else{ if (a[i+1] > a[i]) swap(a[i], a[i+1]); } } }	2014-12-10 11:52:39		
6076	rdfeo	68		2014-12-10 11:52:39		
6077	ethan	68		2014-12-10 11:52:39		
6078	mrjku	68	sol1. First sort the array, then swap pairs of numbers. sol2. Traverse the array starting from the first vertex till the second last vertex, when at an even position swap the value with the next position if the former is smaller; when at an odd position swap the value with the next position is the former is larger	2014-12-10 11:52:39		
6079	nwkeg	68		2014-12-10 11:52:39		
6080	bexbp	68		2014-12-10 11:52:39		
6081	cfzie	68	if we dont need to satisfy a1<a3<a5... and a2<a4<a6..., then will took O(n) if we do, just do a quick sort before this, any way the sort will always took O(nlogn) average	2014-12-10 11:52:39		
6082	ethan	68		2014-12-10 11:52:39		
6083	krxlv	68		2014-12-10 11:52:39		
6084	admin	68	I have implemented simple soultion as mentioned by - tejaswi.yvs	2014-12-10 11:52:40		
6085	zeice	68		2014-12-10 11:52:40		
6086	fowai	68		2014-12-10 11:52:40		
6087	ewigy	68	Please visit java-fries site for the complete article.	2014-12-10 11:52:40		
6088	fmzze	68	Keep track of the current wave trend, up or down in a boolean value, swap adjacent numbers if the trend is violated. If swapped, go back one position to make sure it doesn't violate the sorted trend, but do not go back if i is already 0.  P.S. Can't believe the solution that requires sorting the entire array got the most votes.	2014-12-10 11:52:40		
6089	rdfeo	68		2014-12-10 11:52:40		
6090	dkebi	68		2014-12-10 11:52:40		
6091	tenuw	68		2014-12-10 11:52:40		
6092	bjsiw	68		2014-12-10 11:52:40		
6093	sgiwy	68		2014-12-10 11:52:40		
6094	sqzqo	68		2014-12-10 11:52:40		
6095	azmjc	68		2014-12-10 11:52:40		
6096	sgiwy	68		2014-12-10 11:52:40		
6097	fowai	68	//without expensive sorting algo; complexity O(n)  public class waveSort2 {  public static void main (String[] args){ int [] arr = {9,12,10,3,7,17,4,10,20}; //output must be {a1 >= a2 <= a3 >= a4 <= a5 >=a6 <=a7}, {12 9 10 3 7 4 17 10 20} waveSort(arr); printArray(arr); }  private static void printArray(int[] arr) { // TODO Auto-generated method stub for (int i : arr) { System.out.print(i + " "); } }  public static void waveSort(int[] arr) { // TODO Auto-generated method stub for (int i=1; i < arr.length-2; i=i+2) { if ((arr[i-1] < arr[i]) && (arr[i] < arr[i+1]) && (arr[i-1] < arr[i+1])) { swap(i-1, i+1, arr);  } else if ((arr[i-1] < arr[i]) && (arr[i] > arr[i+1]) && (arr[i-1] < arr[i+1])) { swap(i-1, i, arr);  } else if ((arr[i-1] > arr[i]) && (arr[i] > arr[i+1]) && (arr[i-1] > arr[i+1])) { swap(i, i+1, arr);  } else if ((arr[i-1] < arr[i]) && (arr[i] > arr[i+1]) && (arr[i-1] > arr[i+1])) { swap(i, i+1, arr);  } else if ((arr[i-1] < arr[i]) && (arr[i] > arr[i+1]) && (arr[i-1] < arr[i+1])) { swap(i, i-1, arr);  }  }  }  public static void swap(int i, int j, int[] arr) { // TODO Auto-generated method stub int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }  }	2014-12-10 11:52:40		
6098	jippy	69	Use two heaps a MAX Heap and a MIN Heap. This lets us decide in O(1) time to decide in which heap to enter the new number. If the heaps fall out of order, rebalance them by moving one item in LogN.	2014-12-10 11:52:41		
6099	ethan	69	I don't quite understand how to use two heaps to find the midian. Can you explain in detail for me? thank you	2014-12-10 11:52:41		
6100	rdfeo	69	I have the same question, will watch the thread..so far the reply of Asaf Nachmany seems to be more accurate	2014-12-10 11:52:41		
6101	vanul	69	I agree with Abhi. Using two heaps(min and max) is the right way to go about it.	2014-12-10 11:52:41		
6102	sqzqo	69	Median is the middle element in the sorted array of numbers. In other words if you partition the sorted array into two sets of equal size, the element on the borders of the sets will be the median. Now when an element comes, we insert to the left set or right set in such a way that left and right set always remain sorted as well as contain equal number of elements. So when element less than max of the left set comes it will go to the left set and when an element greater than the min of the right set comes it will go to the right set . and in order to keep the sets equal the max element from the left set will move across the border to the right set or the min element from the right set will move across the border to the left set.  So we need an efficient way of insert element in a sorted list and extracting min and max out of the sorted list. Heap qualifies just for that purpose. Left set is modeled with a max heap and right set is modeled with a min heap.	2014-12-10 11:52:41		
6103	cfzie	69	How about a height balanced bst with median as root?	2014-12-10 11:52:41		
6104	krxlv	69	it's all very, very unclear without the code, can you provide it?	2014-12-10 11:52:42		
6105	dkebi	69	MaxHeap max; //to store left set MinHeap min; //to store right set   Array array;  max.Insert( array.GetNext() )  while( array.HasNext() ) {  int data = array.GetNext(); if( data < max.GetMax() ) { max.Insert( data ) } if( data > min.GetMin() ) { min.Insert( data ) }  int num_left = max.GetNumElements(); num_left -= min.GetNumElements();  if( num_left < -1 ) { int data = min.PopMin() max.Insert( data ) } if( num_left > 1 ) { int data = max.PopMax() min.Insert( data ) }  }  int num_left = max.GetNumElements(); num_left -= min.GetNumElements();  if( num_left < 0 ) median = min.GetMin() else median = max.GetMax()	2014-12-10 11:52:42		
6106	zeice	69	what is the initial min value of the min heap?	2014-12-10 11:52:42		
6107	xhgls	69	@Arun "Median is the middle element in the sorted array of numbers" - sorted array is quite weak assumption	2014-12-10 11:52:42		
6108	qywrh	69	See my answer that begins with "Let's assume memory and disk are both constrained...". It elaborates on the dual-heap approach in the context of large datasets.	2014-12-10 11:52:42		
6109	sgiwy	69	@Arun same question as S.Abakumoff, what's the initial value for min???	2014-12-10 11:52:42		
6110	admin	69	Ok we have O(1) check time, but we do inserting on each ellement O(log(n)). So actually complexity is O(n*log(n)) wich is equal to basic quick sort solution. Where am I wrong? Sorry for stupid question.	2014-12-10 11:52:42		
6111	ufdxg	69	Ok guys,all problems resolved,I think i finally found out what Abhi actually meant... Basically there are two heaps and one integer holding the median value..  if data> median insert into minheap else insert into maxheap  if abs(sizediff)>1  adjust such that an element from the higher sized heap is popped into the median variable and erstwhile median is pushed onto the other heap thus balancing the heaps...  The actual median can be gotten using the tops of heaps plus the median variable because we may need to average if the total size is even.  Here's the actual code...	2014-12-10 11:52:42		
6112	plapd	69		2014-12-10 11:52:42		
6113	sgiwy	69		2014-12-10 11:52:42		
6114	rdfeo	69	Building two heaps with half a billion integers in them? just the integers alone require around 8GB main memory. Any other memory efficient way? using secondary storage?	2014-12-10 11:52:42		
6115	tenuw	69	Sometimes, an interviewer will ask you to describe an algorithm to identify the kth smallest element in an array of n elements. To do this, you select a random pivot and partition the array as you would in the quicksort algorithm. Then, based on the index of the pivot element, you know which half of the array the desired element lies in. For example, say k = 15 and n = 30, and after you select your pivot and partition the array, the first half has 10 elements (the half before the pivot). You know that the desired element is the 4th smallest element in the larger half. To identify the element, you partition the second half of the array and continue recursively. The reason that this is not O(n log n) is that the recursive partition call is only on one half of the array, so the expected running time is n + (n/2) + (n/4) + (n/8) + ... = O(n). Note that finding the median of an array is a special case of this where k = n / 2. This is a very important point, as an interviewer will often ask you to find a way to get the median of an array of numbers.	2014-12-10 11:52:42		
6116	bexbp	69	Are you sure this implementation will work and you will not miss the true median ? I have been asked once to find the first 4 largest elements in the array and I provided an O(4n) solution. Find first maximum then take it out, the 2nd maximum, etc. In the case of a median this will be O(n-square).	2014-12-10 11:52:42		
6117	xhgls	69	@aalimian. Google kth selection algorithm or quick select algorithm. There's also a guaranteed O(n) algo that is a little more complicated to understand called the median of medians selection. Basically quick select evaluates and partitions n elements then n/2 then n/4, etc to find the top k elements.. This sums to 2n on average.	2014-12-10 11:52:42		
6118	sqzqo	69	Write all the elements to disk in a first O(N) pass, and randomly capture about 99 of them into memory. Sort the 99 elements to create 100 ranges for the billion elements to be bucketed into. Each range will be a file on disk. For each of the billion integers, do a binary search on your 99 randomly sampled integers to determine which file they go to next. Keep track of how many integers are in each file. At the end of the second pass you will have a hundred files, each with about ten million elements each. You'll know how many elements are in each file, and you'll be able to easily compute which file contains the median, and where the median ranks within that file. At that point, use an in-memory solution to find the nth element in the file that you know contains the median. Sorting ten million integers is pretty fast, so you can probably just sort all of them without having to go to a fancy heap-based approach. The total cost here is roughly 2 billion disk writes and roughly 11 billion integer comparisons.  This will get the job done easily for most data sets, but you can refine it by having provisions for one range taking an unexpectedly large number of values. Also, after a certain amount of time, you'll know that it will be impossible for certain ranges to ever contain the median, so you can short circuit writing values to their files and simply update their counts.	2014-12-10 11:52:42		
6119	fmzze	69	This is much better than the two heap approach,I am not even sure whether the heap approach can actually work...An upgrade to this algorithm would be to try to split till we get a partition of size at most 10^7,also while writing to a file we could keep track of max and min and divide intervals based on those instead of random sampling.  After we get a partition of about 10^7 we could use the ith order statistic method(similar to quicksort) to get the median in O(n) time instead of sorting the elements and taking O(NlogN) time..  But with infinite input i dont think it is possible to retrieve the median in O(1) time at any given time..	2014-12-10 11:52:42		
6120	nhibd	69	Let's assume memory and disk are both constrained, but you can assume that your dataset is ordered in a fairly random way. Use the first element as the provisional median. Maintain two heaps, one for numbers lower than the median and one for numbers higher than the median. For each new number, decide which heap to update and keep track of the size of both heaps. Whenever you get two elements in a row that go to the same heap, you pop off the top element from the large heap, compare it to the most recent number, and decide the new provisional median. Put the other number in the smaller heap.  Since memory and disk are constrained, you will want to limit the size of the heaps. This means that numbers that are "extreme" will get tossed. This is risky, because the "extreme" number might actually be a non-extreme number that's only "extreme" relative to early numbers in the dataset. For real world problems, this is often an acceptable risk, as you're effectively treating early values as outliers. You can detect the situation by keeping track of the max number discarded for being too small and keeping track of the min number discarded for being too big.  If you want to compute the *exact* median, then you have to store the first half billion integers *somewhere*, since every one of the first half billion integers could theoretically still be the median without any knowledge of the second half of the sample.	2014-12-10 11:52:42		
6121	qywrh	69	you need to ask more information. for example do we know the min, max (if so maybe bucket sort is a good way to go), or in what way is the numbers represented(array, bitmap)? you can't find a optimal solution without necessary knowledge.	2014-12-10 11:52:42		
6122	nwkeg	69	For a finite input (1 Billion integers), the most efficient way (in both time and space) is simply sorting the array (e.g merge sort) and returning the middle item in the array - the median. Efficiency is O(n) in space and O(n*log(n)) where n = 1,000,000,000.  For the infinite output, the best way would be to hold a self-balanced Binary Search Tree, or BST. With each input from the infinite stream of integers, the integer is inserted in the BST at a cost of O(log(n)) in time where n is the current number of elements in the tree.	2014-12-10 11:52:42		
6123	dkebi	69	For the infinite numbers, the two heaps approach described by Abhi is much better. In the self balanced BST, you will have to do O(log(N)) work to get the median everytime it is asked for, while in heap approach, you get it in O(1), rest of the complexities remaining the same for both algos.	2014-12-10 11:52:42		
6124	qywrh	69	self balanced BST - would not it have median as root or child nodes of root?	2014-12-10 11:52:42		
6125	xhgls	69	For the BST, you can just find the new median every time you insert. Insert is still O(log n).	2014-12-10 11:52:42		
6126	mrjku	69	Assume that the integers are 32-bit integers and that you can read the data stream four different times (either by asking for it again or persisting it to disk). You can solve this in four passes. In the first pass, shift each number by 24 bits and increment one of 256 buckets. After the first pass, iterate through the buckets to find out which contains the median value and what its rank will be. On the second pass, mask out the highest eight bits to filter values then use the next eight bits to to populate 256 buckets again. Repeat for the third pass and fourth pass. After the fourth pass you will have your result.	2014-12-10 11:52:42		
6127	sgiwy	69	P.S. After the first pass you will already have an estimate of the median that is within 16 million of the exact median. On the second pass you will have an estimate that is within 64k of the precise median. After the third pass you will be at most 256 off. After the 4th pass you'll know the precise integer median. If you're dealing with 64-bit numbers, you will do eight passes.	2014-12-10 11:52:42		
6128	vanul	69	Another solution can be by doing binary search for median. First iteration is used for Max,Min. And then we start binnary search for value withinh Min,Max each time iterating over all array. Storage O(1) complexity O(n*Log(n)) Log(n) - iteration for binnary search.	2014-12-10 11:52:42		
6129	tenuw	69	Approach Given by @Showell30 is probably the most elegant version I could see. Good job!	2014-12-10 11:52:42		
6130	bjsiw	69	Use AVL tree for stream of integers. The root will be pretty good estimate of median	2014-12-10 11:52:42		
6131	krxlv	69	As for the first question, I think the "select" or "median of medians" algorithm could solves it perfectly, as the time complexity is O(n) to find the kth order statistic. For the second one, I think Ahbi's idea is good, and I think an AVL search tree could also do the job, because the root divides the elements in two subtrees, the left tree is less than the root element and the right tree is larger than the root element, and the difference of the subtree tree's size should be less than 1. The median could be get in three cases: 1) the balance factor of the root is 0, then the root is the median, which is O(1); 2) the balance factor of the root is -1, which means the size of the right subtree has one more element than the left subtree, and the root should be the median; 3) the balance factor of the root is 1, and this case maybe tricky, because the root is the upper median instead of the lower median(the number of element is even, definitely), and in order to get the lower median, we need to get the rightest element of the left subtree, whose time complexity is O(logn). The insertion time complexity of the AVL search tree is O(logn), of course.	2014-12-10 11:52:42		
6132	nwkeg	69	For finite approach use median of medians For infinite use bucket sort, which places incoming elements into their corresponding buckets. Also we keep track of size of each bucket.	2014-12-10 11:52:42		
6133	qywrh	69	Full solution in C++ using two heaps. Running time is O(n*log n):	2014-12-10 11:52:42		
6134	plapd	69		2014-12-10 11:52:42		
6135	nwkeg	69		2014-12-10 11:52:42		
6136	jippy	69	i think we could use sth lile bitmap to store the # of integers. then we can get o(n) algorithms	2014-12-10 11:52:42		
6137	ewigy	69	@Abhi...there are billions of numbers and if we use the concept of two heaps then we need space O(n). Is it possible to reduce space cmplexity..	2014-12-10 11:52:42		
6138	ftfck	69	that's impossible in theory. if you need the median, you need all the numbers.	2014-12-10 11:52:42		
6139	rrmeu	69	How about we assume the value of integer have some limitation to 2<<32.	2014-12-10 11:52:42		
6140	bjsiw	69	If the integers can range from 0 to 2<<32 (approximately 4 billion), then you still have scaling issues. Assume the first half of your dataset ranges from 1 billion to 1.5 billion. You need to track every number, since the second half of the dataset could all be less than 1 billion or all be more than 1.5 billion.  It's a good question, though. If you constrain the size of the numbers more, than the "bucket" approach becomes practical.	2014-12-10 11:52:42		
6141	cfzie	69	For a fixed input, median can be found in O(n) time if you can modify the array. See Selection_algorithm in wikipedia.	2014-12-10 11:52:42		
6142	dgjji	69	For constant-length array, select algorithm works well.  For continuous stream, it is unknown how much to allocate for the array ahead of time. Array allocation at runtime is very expensive. Hence, use a BST and keep a count of the total number of elements N. Then, when it is needed to find the median, do in-order traversal for the N/2-th element; worst-case O(N), best-case O(logN).	2014-12-10 11:52:42		
6143	bexbp	69	Max/Min Heap does not work when the streams of integer is infinite, since it will need to record all these numbers. Since the number is integer already is billion, assume the value of integer is less than 2<<32, i would use 2<<32 number of array to counter the number of element with that value in the infinite integer streams and track the media value in the array.	2014-12-10 11:52:42		
6144	qywrh	69	My approach is quiet the same and dump maybe... but billion is ~ 2^30 (GB). Since these numbers are integers, you have a range: 2^32 possibilities. If each possibility is a counter of 32bit (which gives you a massive support, despite hotspots, for the endless stream) you could use a int array to count the integers. Since this counter is indexed, the counting process is O(n) and scales with the stream. More, you can use a double to count the TOTAL number of entires (or BigInteger), then to find the median, just /2 the Total and use a pointer to sum and reach that value. Issues: The median is not real-time and the stream would need to stop I would say the heap or bst options and not mine... but it was just a new idea...	2014-12-10 11:52:42		
6145	plapd	69		2014-12-10 11:52:42		
6146	ewigy	69	I thought of the same solution. But, it won't work!  How many numbers would you keep track of, at any instant?  Consider the worst case, where a lot of numbers are inserted at one particular side of the median (i.e left or right of the median). Assume that you keep track of 4 numbers,  60,70,80,90 --> median = 70  I have lost track of other numbers like 50,55,95,100, since we are keeping track of the nearest neighbors of median, that is 4 here.  Now, I am inserting 20 numbers with values between (20 to 40). How would you get the median? You have lost the values 50, 55, etc which you should have considered. This is where it would fail.  So, the correct solution would be to use self-balancing trees like AVL tree. The root of the tree would be the median.	2014-12-10 11:52:42		
6147	rdfeo	69		2014-12-10 11:52:42		
6148	dkebi	70	try this? inspired the the recursive approach.Processing the string from the end.	2014-12-10 11:52:43		
6149	fowai	70		2014-12-10 11:52:43		
6150	mrjku	70		2014-12-10 11:52:43		
6151	dkebi	70	only good solution on this page	2014-12-10 11:52:44		
6152	nwkeg	70	your algorithm returns match for string that doesn't have "*" or "." ex, sA="abcdg" and sB="aaag",it returns match,because you only check the last char for the strings that dont have "*" and ".".	2014-12-10 11:52:44		
6153	vanul	70	Simple recursive approach :	2014-12-10 11:52:44		
6154	wbqzu	70		2014-12-10 11:52:44		
6155	cfzie	70		2014-12-10 11:52:44		
6156	dgjji	70	Does * also mean any repetitions of the character before it ? So for instance	2014-12-10 11:52:44		
6157	rrmeu	70		2014-12-10 11:52:44		
6158	mrjku	70		2014-12-10 11:52:44		
6159	rrmeu	70	I forgot to clarify that * can only delete the character before it, but * can be skipped. So	2014-12-10 11:52:44		
6160	nwkeg	70		2014-12-10 11:52:44		
6161	bjsiw	70		2014-12-10 11:52:44		
6162	azmjc	70		2014-12-10 11:52:44		
6163	dgjji	70		2014-12-10 11:52:44		
6164	vanul	70	s1 contains special chars, s2 is only a-z.  Iterative:	2014-12-10 11:52:44		
6165	sgiwy	70		2014-12-10 11:52:44		
6166	ufdxg	70		2014-12-10 11:52:44		
6167	bjsiw	70	Recursive:	2014-12-10 11:52:44		
6168	plapd	70		2014-12-10 11:52:44		
6169	rdfeo	70		2014-12-10 11:52:44		
6170	fmzze	70	Iterative solution does not work.	2014-12-10 11:52:44		
6171	dkebi	70		2014-12-10 11:52:44		
6172	ewigy	70		2014-12-10 11:52:44		
6173	nwkeg	70	Otherwise this would be simple edit distance with minor modifications : substitutions not allowed, if one of the characters is * then deletion cost is 0 otherwise 1, if one of the characters is . then insertion cost is 0 otherwise 1, in the end if the edit distance returns a non-zero distance then false, otherwise true.	2014-12-10 11:52:44		
6174	krxlv	70	yep, but I'm looking for some linear solution, because with edit distance I only know a dp solution, or is the case that exists a non-dp approach?	2014-12-10 11:52:44		
6175	bexbp	70	IsMatch(string s1, string s2) { int n1 = s1.Length; int n2 = s2.Length; int j = 0; while(i < n1 && j <n2 ) { if (i < n1-1 && s1[i+1] == '*') { i +=2; if (i == n1) break; }  if (s2[j] == s1[i] || s1[i] == '.') j++; else break;  }  if (i == n1 && j == n2) return true; return false; }	2014-12-10 11:52:44		
6176	bjsiw	70	I'm not sure if your algorithm works correctly, in the comparison between s2[j] and s1[i], why don't you increase i?. And why do you always skip the character before *?, some other examples: isMatch("a*abc", "abc") = true; isMatch("a*a*a*", "a") = true; isMatch("a*bd*c","abc") = true;	2014-12-10 11:52:44		
6177	qywrh	70	Adjust code, this should work bool IsMatch(string s1, string s2) { int n1 = s1.Length; int n2 = s2.Length; int j = 0; while(i < n1 && j <n2 ) { if (s1[i] == s[j] || s[i] == '.') { i++; j++; } else if (i < n-1 && s1[i+1] == '*') { i+=2; } else if (s1[i] == '*') { i++; } else { return false; } }  if (j < n2) return false;  if (i < n1) { if (s1[i] == '*') i++; while (i < n1-1 && s1[i+1] == '*') { i+=2; } } if (i == n1 && j == n2) return true; return false }	2014-12-10 11:52:44		
6178	bjsiw	70	I think that your algorithm for this case: isMatch("a*abc", "abc") = true; will return false. Let me know if I'm wrong.	2014-12-10 11:52:44		
6179	tenuw	70	FYI: Qus filler has commented missed clause in qus: [I forgot to clarify that * can only delete the character before it, but * can be skipped. So "a*" is "a" or is an empty string ""]  Approach: -Traverse both of the strings from right side  -In case found char [a-z] in str_1 just match this particular char in str_2  -In case found [.] in str_1 skip one char in str_2  -In case found [*] in str_1, check the char before [*] and check also no. of time it is repeating consecutively say N. [For ex: abbb*c : Here before [*] char 'b' is repeating 3 times]  -Now check in str_2 it should have either (N) or (N-1) no. of time char 'b' [As in case of abbb*c valid str are: {abbc} & {abbbc}]  -Repeat above steps until anything unmatch not occurs or string ends.	2014-12-10 11:52:44		
6180	plapd	70	What if you have something like this	2014-12-10 11:52:44		
6181	vanul	70		2014-12-10 11:52:44		
6182	zeice	70		2014-12-10 11:52:44		
6183	xhgls	70	I am not very sure if a linear solution is feasible.\	2014-12-10 11:52:44		
6184	cfzie	70		2014-12-10 11:52:44		
6185	sgiwy	70		2014-12-10 11:52:44		
6186	fmzze	70	}	2014-12-10 11:52:44		
6187	krxlv	70	javacode: public class MatchStr {  public static void main(String[] args) { // String s1 = "a*abc"; // String s2 = "abc"; // String s1 = "a*a*a"; // String s2 = "a"; // String s1 = "a."; // String s2 = "ab"; // String s1 = "a*bd*c"; // String s2 = "abdc"; String s1 = "ada*d*a"; String s2 = "ada"; System.out.println(isMatch(s1,s2,0,0));   } public static boolean isMatch(String s1,String s2,int n1,int n2){ int l1 = s1.length(); int l2 = s2.length(); System.out.println("n1:"+n1+"-----n2:"+n2); if(n1 > l1 || n2 > l2 ){ return false; }else if(n1 == l1 && n2 == l2){ return true; }else{ if(n2 < l2 && n1 < l1 && ((s1.charAt(n1) == s2.charAt(n2)) || s1.charAt(n1) == '.')){ return isMatch( s1, s2, n1+1, n2+1); }else if( n1 < l1 && s1.charAt(n1) == '*'){ if(n2>0){ return isMatch( s1, s2, n1+1, n2-1) || isMatch( s1, s2, n1+1, n2); }else{ return isMatch( s1, s2, n1+1, n2); } }else{ if(n1+1 < l1 && s1.charAt(n1+1) == '*'){ return isMatch( s1, s2, n1+2, n2); }else{ return false; } } }  }  }	2014-12-10 11:52:44		
6188	wbqzu	70		2014-12-10 11:52:44		
6189	rdfeo	70		2014-12-10 11:52:44		
6190	huiqq	70	I think you missed the case where its like b*dc and bdc, the person who posted the question forgot to mention this in the question and then specified it later,in pne of the below comments	2014-12-10 11:52:44		
6191	dgjji	70	Why check isHeadWithAsterisk(s2) - on s2? I think there was a confusion here - s2 has only a-z chars.	2014-12-10 11:52:44		
6192	wbqzu	70	how about 2 counters i&j going from m and n. while(i<m&&j<n){ if (str1.charAt(i)==str2.charAt(j) || str1.charAt(i)=='.') i++,j++ else(str1.charAt(i+1)=='*') i+=2, j++; else return false; } if(str1.length()==i and str2.length==j) this is O(m+n)	2014-12-10 11:52:44		
6193	dgjji	70	Addition in while loop if (j>n) break; after while loop all chars following i should alternate between * and char till end of i	2014-12-10 11:52:44		
6194	eucmc	70		2014-12-10 11:52:44		
6195	nhibd	70		2014-12-10 11:52:44		
6196	zeice	70	Is recursion an inefficient way to handle this? Here's a fully functional php script which reverses both strings for comparison and then recurses only if the it finds a successful "*" match, in order to determine whether to skip or match it. I also assume that ".*" is not legal.	2014-12-10 11:52:45		
6197	dkebi	70		2014-12-10 11:52:45		
6198	rrmeu	70		2014-12-10 11:52:45		
6199	zeice	70	Finite state machine. Sudo code:  {{ fun IsMatch(s1, s2): pos1 = 0; pos2 = 0; while (pos1 < s1.Length && pos2 < s2.Length) match = false; if (s1[pos1] == s2[pos2] || s1[pos1]=='.') //A charachter match match = true; pos1++; pos2 ++; if (s1[pos1] == '*') //Ignorable * match = true; pos1++; //pos2 doesn't change if (!match && pos < s1.Length - 1 && s1[pos+1] == '*') //Deleted charachter match match = true; pos1+=2; pos2 ++; if (!match) break;  if (match) print "Match" }}	2014-12-10 11:52:45		
6200	sgiwy	70	I have never been on a technical interview, so please don't laugh at me... But how do I understand if I can use something already built-in in the language or whether I have to write everything from scratch? For example, in this situation, why can't we just write something like this:	2014-12-10 11:52:45		
6201	jippy	70		2014-12-10 11:52:45		
6202	fmzze	70		2014-12-10 11:52:45		
6203	mrjku	70	} ?	2014-12-10 11:52:45		
6204	ethan	70	Another solution for this would be to, simply replace the '*' by a '?' and use your languages regex library to check the string.  Pros: Less Code (fewer potential bugs), Easy to understand code.	2014-12-10 11:52:45		
6205	eucmc	70		2014-12-10 11:52:45		
6206	ufdxg	70		2014-12-10 11:52:45		
6207	xhgls	70	+ (BOOL)isMatch:(NSString *)expression :(NSString *)string; { if(expression==nil || string==nil) return NO; if(!expression.length && !string.length) return YES; if([expression hasPrefix:@"*"] || [expression hasPrefix:@"."]) return NO; NSMutableString *expreCopy = [NSMutableString stringWithString:expression]; for(int i=0;i<expression.length;i++){ unichar c = [expression characterAtIndex:i]; unichar ch = '*'; if (c == ch) { [expreCopy replaceCharactersInRange:NSMakeRange(i-1, 2) withString:@"**"]; } } expression = [expreCopy stringByReplacingOccurrencesOfString:@"**" withString:@""]; if(expression.length != string.length)return NO; for(int i=0;i<expression.length;i++){ BOOL match = ([expression characterAtIndex:i] == '.') || ([expression characterAtIndex:i] == [string characterAtIndex:i]); if(!match) return NO; } return YES; }	2014-12-10 11:52:45		
6208	plapd	70	We can achieve the O(n) solution without using recursion def isMatch(reg, str): if not reg and not str:##both reg and str are NULL return True if len(reg) == 2 and reg[1]=='*':##reg='a*' and b='' return str==''  i = 0 j = 0 while i < len(reg) and j < len(str): if i+2<len(reg) and reg[i+2]=='*': if reg[i] == str[j]: i = i + 3 j = j + 1 else: return False  elif reg[i] == '.': i += 1 j += 1 else: if reg[i]==str[j]: i += 1 j += 1 else: return False  return (i == len(reg) and j==len(str))	2014-12-10 11:52:45		
6209	vanul	70	Run over the chars in the regexp and try find matches in the string itself.  Pseudo code:	2014-12-10 11:52:45		
6210	fmzze	70		2014-12-10 11:52:45		
6211	fmzze	70		2014-12-10 11:52:45		
6212	cfzie	70	If the usage of Java's Pattern object is allowed, this is a simple Regular Expression question - each 'a*' turns into "(a)?" regex string, and each '.' turns into '.' regex string. For example, "ab*..d" turns into "a(b)?..d" regex string. Compile the pattern and match away.	2014-12-10 11:52:45		
6213	bexbp	70		2014-12-10 11:52:45		
6214	tenuw	70		2014-12-10 11:52:45		
6215	wbqzu	70	public class RegularExpression {  // s1 regex s2 match  public static boolean isMatch(String s1, String s2) { // recursive implementation keeps shortening both strings from the right to left if (s1.length() == 0 && s2.length() == 0) return true;   int i, j; boolean point = false; boolean star = false;  for(i = s1.length() - 1, j = s2.length() - 1;i >= 0 && j >= 0;) { if(s1.charAt(i) == s2.charAt(j)) { i--; j--; continue; }  if(s1.charAt(i) == '.') { i--; j--; point = true; continue;  }  if(s1.charAt(i) == '*') { j -= 2; star = true; continue; }  if(s1.charAt(i) != s2.charAt(j)) { if(star) { if(s1.charAt(i) == s2.charAt(j + 1)) { i--;  star = false; continue; }else return false; } return false;  }  }  return true; }  public static void main(String []argc) { System.out.println(isMatch("a*", "")); System.out.println(isMatch("Co.s*", "Cos")); System.out.println(isMatch("Co.s", "Coas")); System.out.println(isMatch("Co.sb*", "Coss")); System.out.println(isMatch("a*abc", "abc"));  } } Is this ok? It should be better than the recursive solution.	2014-12-10 11:52:45		
6216	azmjc	70		2014-12-10 11:52:45		
6217	vanul	70		2014-12-10 11:52:45		
6218	plapd	70	DP solution.  use array to record previous match. when s[i] == p[j] or p[j] is '.' current match is true only when p's previous match s's previous  but when p[j] is '*', there are two conditions: 1) ignore the '*', current match is true only when p's previous match current s 2) delete previous p[j-1], current match is true only when p's previous'previous match with current s     bool isMatch(string s, string p) { int n = s.length(); int m = p.length();  vector<bool> pv(n+1, false); // row -2 vector<bool> v(n+1, false); // row - 1 v[0] = true;  for(int i=0; i<m; i++) { vector<bool> nv(n+1, false); for(int j=0; j<n; j++) { if (p[j] == s[i] || p[j] == '.') // 'a' == 'a' { nv[j+1] = v[j]; // only when previous match } else if (p[j] == '*') { nv[j+1] = v[j+1] || pv[j+1]; // ignore * || delete previous c } } pv = v; // row i-2 for next round v = nv; // row i-1 for next round }  return v[n]; }	2014-12-10 11:52:45		
6219	bexbp	70		2014-12-10 11:52:45		
6220	wbqzu	70		2014-12-10 11:52:45		
6221	dgjji	70	Ruby 2.0.0 implementation	2014-12-10 11:52:45		
6222	qywrh	70		2014-12-10 11:52:45		
6223	ethan	70		2014-12-10 11:52:45		
6224	wbqzu	70		2014-12-10 11:52:45		
6225	mrjku	70		2014-12-10 11:52:45		
6226	azmjc	70		2014-12-10 11:52:45		
6227	cfzie	70		2014-12-10 11:52:45		
6228	azmjc	70	How about comparing the string and the regex from the end. The non-trivial case of '*', we need to follow both paths of deleting and not deleting the previous character.  Can be solved using recursion.	2014-12-10 11:52:45		
6229	admin	70	#include <iostream> #include <string> using namespace std;  bool isMatch(string regex, string input){ for (int i = regex.length()-1, j=input.length()-1; i >= 0;) { if(regex[i] == input[j]) {i--; j--; continue;} else if(regex[i]=='.') {i--; j--;continue;} else if(regex[i] =='*') { if(i >= 0 && isMatch(regex.substr(0,i), j >= 0 ? input.substr(0,j+1) : "")) return true; if(i-1 >=0) return isMatch(regex.substr(0,i-1), j >=0 ? input.substr(0,j+1): "");  else return false; } else return false; } return true; }  int main(){ string regex, pattern; cin >> regex; cin >> pattern; cout << "Match = " << isMatch(regex, pattern) << endl; return 0; }	2014-12-10 11:52:45		
6230	admin	70		2014-12-10 11:52:45		
6231	qywrh	70		2014-12-10 11:52:45		
6232	sgiwy	71	If a simple match (i.e. no repetition sign following) just recurse with str.substring(1) and regex.substring(1) IFF match found. At any given point we either pass down unmodified regex with str.substring(1) OR unmodified str with "*" part taken away. We need to reduce + to *. For that, if current char matches recurse with str.substring(1) and regex where + is replaced by *.	2014-12-10 11:52:46		
6233	bexbp	71		2014-12-10 11:52:46		
6234	xhgls	71		2014-12-10 11:52:46		
6235	tenuw	71	}	2014-12-10 11:52:46		
6236	ethan	71	good one	2014-12-10 11:52:46		
6237	plapd	71	if string is "" and regex is "abcdefgh*" it will return true you should do if regex.length() == 0 || (regex.length() == 1 && regex.charAt(regex.length() - 1)	2014-12-10 11:52:46		
6238	nhibd	71	You need to construct an NFA to do pattern matching with regular expressions.	2014-12-10 11:52:46		
6239	bjsiw	71	I think we don't need to construct any kind of automata as it is a simple pattern o match. Below is a simple implementation in C:	2014-12-10 11:52:46		
6240	mrjku	71		2014-12-10 11:52:46		
6241	mrjku	71		2014-12-10 11:52:46		
6242	zeice	71	Below is the code you can check it it takes the following approach: a.If currently both the characters match increment both the pointers that is first and second. b.If currently a * is there then you have to consider either the current character of second string or ignore it. c.If there is a + then consider the fact such as the previous character of first string is equal to the previous character of second string (if there is only one instance) and then consider both either consider the current character or ignore it.	2014-12-10 11:52:46		
6243	nhibd	71		2014-12-10 11:52:46		
6244	jippy	71		2014-12-10 11:52:46		
6245	bjsiw	71	Does not work for: test("c*a*b", "aab"); -> gives No, should be yes test("a*b", "bb"); -> gives No, should be yes	2014-12-10 11:52:46		
6246	plapd	71	For your kind information a*b here b is only one instance and not 2 so only b should give yes and bb should give no and plzz again check for first case i haqve tested it and it gives yes.....!!!!!	2014-12-10 11:52:46		
6247	krxlv	71	Not sure how you tested. Here is what I get when running your code:  int main() { test("a*b", "aaaab"); // Yes - correct test("a+bc*", "bccc"); // No - correct test("ab+cd*", "abbcdd"); // Yes - correct test("c*a*b", "aab"); // No - wrong test("a*b", "b"); // No - wrong test("a+a*b*", "ab"); // No - wrong test("aa*b*ab+", "aab"); // No - wrong }	2014-12-10 11:52:46		
6248	rdfeo	71	It appears to be working now after you modified it. You should have mentioned you changed your second return statement to exit with 1 and added extra check: else if(*first!=*second&&*(first+1)=='*').	2014-12-10 11:52:47		
6249	wbqzu	71	Actually, even with your changes still does not work for this: test("b*", "bcc"); // gives Yes - wrong	2014-12-10 11:52:47		
6250	wbqzu	71	@Anonymous: I have modified the code plzz check it.I think it works for now every possible case you could think of.	2014-12-10 11:52:47		
6251	sqzqo	71	Post working code please, it does not work for very basic cases,  test("b", "bb") - fails, and i suppose the test("b*", "bcc") should return yes.	2014-12-10 11:52:47		
6252	cfzie	71	@Anonymous: I respect your comments but please correct your basics. For bb it should give no as in the input string you are giving a single b and not a b*. Also further for the second case in the input string it is b* and you are bcc. Remember my friend it is b 'c' 'c' not multiple instances of b because b* MEANS multiple instances of only b not anything else....All right...????	2014-12-10 11:52:47		
6253	nhibd	71	No, the regex 'b' matches with 'bb'.	2014-12-10 11:52:47		
6254	rrmeu	71	Not in the context of this question.	2014-12-10 11:52:47		
6255	krxlv	71	Has anyone tried the Java solution in the beginning of this thread? It hangs there since day 1 unmodified and still covers all test cases this one failed to clear.	2014-12-10 11:52:47		
6256	fowai	71	please do act logically. You might be saying from the first part that b matches bb as it shows aaab b outputs 1. But please, that determines the different states of a finite automata and also a space between aaab and b .It means that a* which is null.If there is no comma in between then you consider that it should accept bb. But it should not..You can ask anybody in the context of this question that only when given b and bb whether they should match or not.The answer would be no.Please do refer somebody on this question and then provide some further comments...	2014-12-10 11:52:47		
6257	ufdxg	71	as per example 1 in the question, we are having four matching patterns , right.? ab, aab, aaab, ab  the above four patterns are satisfying a*b . a is occuring 0 or more times and then single 'b' is at end of the string. so the output should be 4, right.?	2014-12-10 11:52:47		
6258	cfzie	71	Yes output should be 4 and if you consider single b then output will be 5	2014-12-10 11:52:47		
6259	wbqzu	71	Yes.. thats it. Cool.. thanks a lot. :)	2014-12-10 11:52:47		
6260	zeice	71	How can anyone write this code in a 45 min interview? One needs extreme practice and one should have seen such questions earlier. There is no way one can think about the algorithm in the interview, leave alone the edge cases.	2014-12-10 11:52:47		
6261	qywrh	71	Agree. Having a full algorithm done covering all edge cases would be next to impossible to deliver. I doubt the interviewer would actually be looking for that though. General direction would be more important here.	2014-12-10 11:52:47		
6262	cfzie	71	I think the interviewer in such cases is only evaluating your awareness level. Wildcard string matching happens by constructing an NFA, which can't happen in an hour. But one should at least know that.	2014-12-10 11:52:47		
6263	qywrh	71	can anyone explain why Example 2 output is 0? The pattern a+aabc matches the 2nd string (aaabc), does not it?	2014-12-10 11:52:47		
6264	gilit	71	The example 2 output is 0 because in string there is a pattern ab which does not matches with a+aabc as a+ means one or more instance of a followed by two necessary instances of a.Note those a are alone they are not followed by any notation .So in ab one a is there for a+ but it should have been followed by 2 a's but it is not..So the output comes out to be 0.. I hope it is clear..	2014-12-10 11:52:47		
6265	dkebi	71	Yea the output for the example is confusing.  There are 4 or 5 strings given, and the answer is 0 or 1? Does it output 0 if the pattern doesn't match with any of them?	2014-12-10 11:52:47		
6266	mrjku	71	Following is my code in python. 1. First the pattern string is converted into a pattern list of tuples. A) a* becomes (a, True, 0) where True signifies that the # of occurence is "GREATER THAN EQUAL" to 0 B) a+ becomes (a, True, 1) where True signifies that the # of occurence is "GREATER THAN EQUAL" to 1 C) a with no */+ becomes (a, False, 1) meaning that there is no "GREATER THAN" condition but only "EQAUL" condition to 1 a+aabc => [('a', True, 1), ('a', False, 1), ('a', False, 1), ('b', False, 1), ('c', False, 1)]  2. Then the pat list simplified so that we accumulate contiguous occurences of the same character. => [('a', True, 3), ('b', False, 1), ('c', False, 1)]  3. Then the resulting pat list is expanded so that either we have exact matches or "*" matches .. there are no "+" matches => [('a', False, 1), ('a', False, 1), ('a', False, 1), ('a', True, 0), ('b', False, 1), ('c', False, 1)]  with the expanded pattern list consisting of exact matches and * matches, we iterate over the expanded pattern list and the match_string	2014-12-10 11:52:47		
6267	sqzqo	71		2014-12-10 11:52:47		
6268	admin	71		2014-12-10 11:52:47		
6269	gilit	71	Just wrote a solution using NFA in Java:	2014-12-10 11:52:47		
6270	ethan	71		2014-12-10 11:52:47		
6271	rdfeo	71		2014-12-10 11:52:47		
6272	bjsiw	71	Here is my solution	2014-12-10 11:52:47		
6273	sgiwy	71		2014-12-10 11:52:47		
6274	zeice	71		2014-12-10 11:52:47		
6275	plapd	71	I think your code will not work for  aab aa*b*ab+	2014-12-10 11:52:47		
6276	krxlv	71	And it will give yes for  aab aa*b*ac+	2014-12-10 11:52:47		
6277	fmzze	71		2014-12-10 11:52:47		
6278	sqzqo	71		2014-12-10 11:52:47		
6279	azmjc	71		2014-12-10 11:52:47		
6280	ftfck	71		2014-12-10 11:52:47		
6281	sqzqo	71		2014-12-10 11:52:47		
6282	fowai	71		2014-12-10 11:52:47		
6283	azmjc	71	My code is working you can try ,I always welcome peoples who will find out sum issue :	2014-12-10 11:52:47		
6284	huiqq	71		2014-12-10 11:52:47		
6285	nwkeg	71		2014-12-10 11:52:47		
6286	xhgls	71	Here is a simple code in C:	2014-12-10 11:52:47		
6287	ufdxg	71		2014-12-10 11:52:47		
6288	qywrh	71		2014-12-10 11:52:47		
6289	plapd	71	Did they really ask this question on a white board interview? The solution would be very time consuming.	2014-12-10 11:52:47		
6290	cfzie	71	I think we can use 2-order DP, here is my python code:	2014-12-10 11:52:47		
6291	cfzie	71		2014-12-10 11:52:47		
6292	ewigy	71		2014-12-10 11:52:47		
6293	krxlv	71	We can build a "Trie", where every edge will represent alphanumeric symbols from pattern. '+' and '*' will result in a tree loops. After building a trie, we can traverse it recursively following every loop, until the whole string is matched.	2014-12-10 11:52:47		
6294	jippy	71		2014-12-10 11:52:48		
6295	jippy	71		2014-12-10 11:52:48		
6296	rdfeo	71	Simple recursive solution :	2014-12-10 11:52:48		
6297	rrmeu	71		2014-12-10 11:52:48		
6298	huiqq	71		2014-12-10 11:52:48		
6299	nhibd	71	This code will be ok.	2014-12-10 11:52:48		
6300	dgjji	71		2014-12-10 11:52:48		
6301	fowai	71		2014-12-10 11:52:48		
6302	sgiwy	71		2014-12-10 11:52:48		
6303	rdfeo	71		2014-12-10 11:52:48		
6304	nhibd	71	}	2014-12-10 11:52:48		
6305	ethan	71		2014-12-10 11:52:48		
6306	qywrh	71		2014-12-10 11:52:48		
6307	vanul	71		2014-12-10 11:52:48		
6308	ufdxg	71		2014-12-10 11:52:48		
6309	sqzqo	72	sort all three arrys and take 1st element from each array a,b,c calculate min ( |a-b|+ |b-c| +c-a| ,ans) then take next element from min(a,b,c) and then again repeat above step time -O(nlogn) +O(n) just think of this as sorting and then merging all 3 arrays and calculating |a-b|+ |b-c| +c-a| for each consecutive triplet.. u ll have the correct ans	2014-12-10 11:52:49		
6310	admin	72	Solution with merging is valid one.  Another one solution:  1. Sort 'b' and 'c'. 2. For each element in 'a' do binary search inside 'b' and 'c' (binary search will find existing element or closest one). 3. Compare min = min( abs(a[i] - b[k]) + abs(a[i] - c[j]) + abs(b[k] - c[j]), minSoFar )  time: O(N*lgN) space: O(1)	2014-12-10 11:52:49		
6311	rrmeu	72	sorry for asking but why we have taken abs? value	2014-12-10 11:52:50		
6312	xhgls	72	What if the 3 arrays have a different number of elements in them? How does sorting stop you from checking every combination?	2014-12-10 11:52:50		
6313	nwkeg	72		2014-12-10 11:52:50		
6314	bjsiw	72		2014-12-10 11:52:50		
6315	bjsiw	72	Your algorithm returns the min as 4 when it is actually 0. The algorithm sorting b and c and searching for the closest element within to every a also fails on:	2014-12-10 11:52:50		
6316	bjsiw	72		2014-12-10 11:52:50		
6317	nwkeg	72		2014-12-10 11:52:50		
6318	eucmc	72	This algorithm will return the min of 8 when the answer is 6.	2014-12-10 11:52:50		
6319	bexbp	72	This solution also fails for this example:  A -3, -2, 0, 0 1 4 B -10, -8, -5, -3, -1 C 1, 5, 10, 15, 20  The answer here is 0, -1, 1 which never align in the above mentioned triplet fashion.	2014-12-10 11:52:50		
6320	xhgls	72	This solution is correct as far as i can see. And it will pass examples above. Both previous posters probably misunderstood the "triplet" scheme. On each step we change only smallest number in triplet to the next one in corresponding array.	2014-12-10 11:52:50		
6321	krxlv	72	I think this solution is correct. If you think a,b,c as three points on the number line, then it make sense.  The only problem is that, if the minimum number are all from one array, then it will move to the end of the array. So we have to deal with this special case.	2014-12-10 11:52:50		
6322	mrjku	72	@ m@}{, the algorithmic complexity is sorting O( j Log j + k Log K ) + searching O(i * (Log j + Log k) ) versus the other approach of sorting O (i Log i + j Log j + k Log K ) + searching O( i + j + k) where i = length of a, j = length of b and k = length of c. I think that approach would be hit by the no free lunch theorem.	2014-12-10 11:52:50		
6323	admin	72	Tushar is solving totally different problem  i.e. arrayOne = {1,1,1}; i.e arrayTwo = {2,10, 13}; i.e arrayThree = {3,20, 23};  So Tushar's answer will give 1 1 and 1 but the question says "Find three numbers a, b, c from each of array A, B, C" a,b and c from each array. So the correct answer is 1 , 2 and 3  Voting -1.	2014-12-10 11:52:50		
6324	sgiwy	72	The proposed approach is based on the assumption that the question is to find the min(|a-b| + |b-c| + |a-c|).  Supposing the problem is reduced to two arrays (a,b) instead of three(a,b,c). To find the min, I think we need to sort both array a and array b, then set two indice i and j, initializing with 0.	2014-12-10 11:52:50		
6325	sgiwy	72		2014-12-10 11:52:50		
6326	wbqzu	72		2014-12-10 11:52:50		
6327	cfzie	72	Right now the problem grows to three arrays (a,b,c). To find the min(Math.abs(a[i]-b[j]) + Math.abs(b[j]-c[k]) + Math.abs(a[i]-c[k])), we suppose that (a[i], b[j], c[k]) is the tuple we need to find, a[i] > b[j] > c[k]. If we could find the min pair of (a[i], c[k]), as long as b[j] is between a[i] and c[k], it will not affect the Math.abs(a[i]-b[j]) + Math.abs(b[j]-c[k]) + Math.abs(a[i]-c[k]), because Math.abs(a[i]-b[j]) + Math.abs(b[j]-c[k]) == Math.abs(a[i]-c[k]), which means Math.abs(a[i]-b[j]) + Math.abs(b[j]-c[k]) + Math.abs(a[i]-c[k]) == 2 * Math.abs(a[i]-c[k]), if a[i] > b[j] > c[k]. So abstract the three arrays as two arrays, one only "store" (actually don't need to really keep them in an array) the max values of a[w], b[w] and c[w], w is index of max array, the other only "store" the min values of a[w], b[w] and c[w]. Then apply the approach on the top, which I think could work.	2014-12-10 11:52:50		
6328	sqzqo	72		2014-12-10 11:52:50		
6329	bjsiw	72		2014-12-10 11:52:50		
6330	dgjji	72	Can be done without sorting which is most expensive component.  Keep Hash set of local minimum triplets and track minimum of them as final answer.  Start at first element of each. At each step, consider up to 6 possibilities of changing triplet to better: one of previous / next on one of the arrays. Make most improving change. If there is none, that is a local min, put in hash set.  Now, if one of the up to 6 changes is in hash set, keep moving in the same direction till it is not. (For instance, instead of previous 2 before or more)  Consider arrays as cyclical.	2014-12-10 11:52:50		
6331	sqzqo	72	Just one more detail. After local min take the best of 6 modified, even though not improving	2014-12-10 11:52:50		
6332	gilit	72	Since this approach doesn't end early and must keep searching after finding a local minimum, won't this approach simply brute force every possible combination of values?	2014-12-10 11:52:50		
6333	jippy	72	I structured the problem as follow -- calculate the min(A[0], B, C), .., min(A[n], B, C) & find the min in this set.  To calculate min(A[i], B, C), I first create a matrix of distance between B and C. Then I add the Distance(A[i], B) and Distance(A[i], C) to the matrix. The smallest number in the matrix is the min (A[i], B, C)  Apparently I am not allow to give you a github link but you can find it under edithau/findMinDistance	2014-12-10 11:52:50		
6334	ufdxg	72		2014-12-10 11:52:50		
6335	tenuw	72		2014-12-10 11:52:50		
6336	bjsiw	72	}	2014-12-10 11:52:50		
6337	qywrh	72	Just one more detail. After local min take the best of modified 6	2014-12-10 11:52:50		
6338	admin	72	hey suppose you have 3 arrays with sizes m,n,p such that m<n<p. you can do it with O(m*p) complexity and O(m) space complexity. first take the m and p sized arrays say they are M and P. for every element in M find element in P such that their difference in min and store the index of that element in P in another array called M'.. now you have another M sized array with all min values. now for every element in M find value in N such that their difference is min and also get the diff with element in P using indices in M' array.	2014-12-10 11:52:50		
6339	cfzie	72	Sorry there's a mistake in the above ans. M' stores indices of P having min diff with element in M. example, M'[0] stores index of element in P which has min diff for M[0].	2014-12-10 11:52:50		
6340	mrjku	72	We need to find some definition of what is the meaning of minimum. "... |a-b|, |b-c| and |c-a| are minimum"  If we try to sum up (a-b) + (b-c) + (c-a), the answer should be 0 according to algebra.  a-b = d1 b-c = d2 c-a = d3  Should we just pick the maximum number between the three, minimum, or pick the middle one for comparison ?	2014-12-10 11:52:50		
6341	rrmeu	72	By minimizing |a-b| and |b-c|, |c-a| will implicitly be minimized. O(n) running time, and O(1) space...	2014-12-10 11:52:50		
6342	ethan	72		2014-12-10 11:52:50		
6343	sqzqo	72		2014-12-10 11:52:50		
6344	azmjc	72	This works just fine although complexity is a bit high for this one.	2014-12-10 11:52:50		
6345	bexbp	72		2014-12-10 11:52:50		
6346	bexbp	72		2014-12-10 11:52:50		
6347	rdfeo	72	First sort all arrays then folowing code would give the required output   #include<iostream> #include<stdio.h>  using namespace std;  int abs(int a,int b) { if(a>b) { return a-b; } else {  return b-a; } }  void checkArr(int *p,int *q,int m,int n) { int i=0,j=0,elea=p[0],eleb=q[0]; int diffab=abs(p[0],q[0]); int ldiffab=0; while(i<m && j<n) {  ldiffab=abs(p[i],q[j]); if(ldiffab<diffab) { diffab=ldiffab; elea=p[i]; eleb=q[j]; } if(p[i]<q[j]) { i++; } else { j++; } } cout<<elea<<" "<<eleb<<endl; }  int main() { int a[]={1,4,9,10}; int b[]={21,22,23,24}; int c[]={7,10,16,25}; checkArr(a,b,4,4); checkArr(b,c,4,4); checkArr(c,a,4,4); return 1; }	2014-12-10 11:52:50		
6348	mrjku	72	Find a and b such that we get min|a-b| in O(n^2) by using brute force method. Now we need a c in such a manner that |b-c| and |c-a| are minimum. For this to happen we need a value c as close as possible to (a+b)/2 . We can find this c value using Binary search on C. Hence a possibe solution would be in O(n^2logn)	2014-12-10 11:52:50		
6349	azmjc	72	#include<iostream> #include<iomanip>  using namespace std;  int main() {    // finding minimum number in array 1 // const int MAX = 5; int arr_1[MAX];  cout << "Enter First Array : " << endl; for (int count_1 = 0; count_1 < MAX; ++count_1) { cout << "\tEnter Number : "; cin >> arr_1[count_1];  }  for (int i = 0; i < MAX; i++) {  for (int j = 0; j < MAX ; j++) {  while (arr_1[i] < arr_1[j]) { int temp; temp = arr_1[i]; arr_1[i] = arr_1[j]; arr_1[j] = temp; } }  }  // array 2 //  int arr_2[MAX]; cout << "\nEnter Second Array : " << endl ; for (int count_1 = 0; count_1 < MAX; ++count_1) { cout << "\tEnter Number : "; cin >> arr_2[count_1];  }  for (int i = 0; i < MAX; i++) {  for (int j = 0; j < MAX; j++) {  while (arr_2[i] < arr_2[j]) { int temp; temp = arr_2[i]; arr_2[i] = arr_2[j]; arr_2[j] = temp; } }  }  // array 3 //  cout << "\nEnter Third Array : " << endl ; int arr_3[MAX];  for (int count_1 = 0; count_1 < MAX; ++count_1) { cout << "\tEnter Number : "; cin >> arr_3[count_1];  }  for (int i = 0; i < MAX; i++) {  for (int j = 0; j < MAX; j++) {  while (arr_3[i] < arr_3[j]) { int temp; temp = arr_3[i]; arr_3[i] = arr_3[j]; arr_3[j] = temp; } }  }   int sub_1, sub_2, sub_3, res;  sub_1 = (arr_1[0] > arr_2[0]) ? arr_1[0] - arr_2[0] : arr_2[0] - arr_1[0]; sub_2 = (arr_2[0] > arr_3[0]) ? arr_2[0] - arr_3[0] : arr_3[0] - arr_2[0]; sub_3 = (arr_3[0] > arr_1[0]) ? arr_3[0] - arr_1[0] : arr_1[0] - arr_3[0];    cout << "\n|a-b| " << sub_1; cout << "\n|b-c| " << sub_2; cout << "\n|c-a| " << sub_3; res = sub_1 + sub_2 + sub_3; cout << "\n\n|a-b|+|b-c|+|c-a| = " << res << endl;  cout << "\n\n\n" << setw(70) << "H.P." ;   cout << endl; system("pause"); return 0; }	2014-12-10 11:52:50		
6350	sgiwy	72		2014-12-10 11:52:50		
6351	jippy	72		2014-12-10 11:52:50		
6352	ethan	72	First merge & sort all three lists into one sorted list, named 'pts'; but keep a marker of what was an item's original list.  As long as the left most and right most items belong to different original lists, and there exists an item from the 3rd list in-between them, then it is a potential solution.	2014-12-10 11:52:51		
6353	bjsiw	72		2014-12-10 11:52:51		
6354	gilit	72		2014-12-10 11:52:51		
6355	dgjji	72		2014-12-10 11:52:51		
6356	ufdxg	72		2014-12-10 11:52:51		
6357	ftfck	72	L is the left most index R is the right most index M is a middle index in-between, L < M < R  remember that R - L = (R - M) + (M - L), so it doesn't really matter what M is, just that pts[L], pts[M] and pts[R] all belong to different arrays. The best solutions will minimize R - L.	2014-12-10 11:52:51		
6358	wbqzu	72	Uses twice the space since all three lists are merged into one. We all know the sort would be O(nlogn).  get_min() is O(n^3) but it skips over all the non-valid candidates, only does a siple compute and check for valid candidates.	2014-12-10 11:52:51		
6359	ethan	72	I think, on the inner most loop, for M:  ... best_R = R; break; // we can skip the rest }	2014-12-10 11:52:51		
6360	fowai	72	cut short the loop for R, since if we find the current best solution when R - L = x, then incrementing R will not give us a better solution.	2014-12-10 11:52:51		
6361	tenuw	72	I think we can do this in linear time if we sort the three arrays.  Logic: 1# Sort the arrays in ascending order 2# take three pointers pointing to the first elements of the arrays 3# Calculate the value of |a-b|+|b-c|+|c-a| and put it into result 4# increment the pointer with minimum value, if the new value is less than the one calculated above, replace it 5# keep checking till we reach the end of the arrays	2014-12-10 11:52:51		
6362	huiqq	72	I think we can do this in linear time if we sort the three arrays.  Logic: 1# Sort the arrays in ascending order 2# take three pointers pointing to the first elements of the arrays 3# Calculate the value of |a-b|+|b-c|+|c-a| and put it into result 4# increment the pointer with minimum value, if the new value is less than the one calculated above, replace it 5# keep checking till we reach the end of the arrays	2014-12-10 11:52:51		
6363	xhgls	72	I think you should store all minimum(a,b,c) pairs having sum ==(min && equal)  Original Question: Find three numbers a, b, c from each of array A, B, C such that |a-b|, |b-c| and |c-a| are minimum	2014-12-10 11:52:51		
6364	nwkeg	72	Here is the pseduo-code 1. Combine the 3 arrays into one with data structure to indicate which array the value comes from 2. Sort this big array (of data structure) with the value from A, B and C as key 3. Assign minAbsSum, prevA, prevB and prevC as invalid (to track last A, B and C visited so far) 4. Go through each element in the big array.(Loop the big array) 4.1 If curVal is from array A, pick curVal, prevB and prevC. Go to 4.4 4.2 If curVal is from array B, pick curVal, prevA and prevC. Go to 4.4 4.3 If curVal is from array C, pick curVal, prevA and prevB. Go to 4.4 4.4 Calculate the sum of the absolute values of difference if prevB and prevC are valid in case of 4.1 if prevA and prevC are valid in case of 4.2 if prevA and prevB are valid in case of 4.3 4.5 Update the minAbsSum if absSum < minAbsSum, 4.6 Return if minAbsSum = 0, otherwise continue  The whole article including code and test find here: cpluspluslearning-petert.blogspot.co.uk/2014/10/data-structure-and-algorithm-find-least.html	2014-12-10 11:52:51		
6365	fowai	72		2014-12-10 11:52:51		
6366	wbqzu	72		2014-12-10 11:52:51		
6367	rdfeo	72	Implementation in C++ of solution given previously. Just a couple of enhancements: - Algorithm valid for n sets, example for 3 - Sorted the biggest 2 (or n-1) sets, the shortest one is the one I will iterate.  So 2 sorts, 1 iteration doing binary searchs in both other vectors   tushar aggarwal on September 04, 2014 | Flag Reply 3 of 5 votes  Solution with merging is valid one.  Another one solution:  1. Sort 'b' and 'c'. 2. For each element in 'a' do binary search inside 'b' and 'c' (binary search will find existing element or closest one). 3. Compare min = min( abs(a[i] - b[k]) + abs(a[i] - c[j]) + abs(b[k] - c[j]), minSoFar )  time: O(N*lgN) space: O(1)"	2014-12-10 11:52:51		
6368	nhibd	72		2014-12-10 11:52:51		
6369	sqzqo	72		2014-12-10 11:52:51		
6370	gilit	72	I think its more starightforward than that. Why cant we simply pick A(min, max), B(min, max), C(min, max) and then get abs of (A(min, max) - B(min, max)? Likewise for C....or is there something that I am missing	2014-12-10 11:52:51		
6371	ewigy	72	it will fail in the following test case a[]={1,10,20} b[]={2,10,23} c[]={3,10,24} ans shud be 0 by picking 10,10,10	2014-12-10 11:52:51		
6372	zeice	72	to my understanding, basically we need to pick the min number from each array to get the min combination. we really don't need to sort them. we could use a heap structure with minimum being the root node. heap structure gives us a better complexity since we dont need to sort the full array. once we have 3 heaps, pick the root node and we will get our best combination. finding the minimum will be o(1) and creating the heap will be o(n).	2014-12-10 11:52:51		
6373	sgiwy	72	a[] = {1, 1001} b[] = {1, 1001} c[] = {1001, 1001}  You'll get answer 1, 1, 1001 and correct is 1001, 1001, 1001.	2014-12-10 11:52:51		
6374	mrjku	72	When you do insertion in heap, it takes log n time. If n numbers have to be inserted, it is n*log n. Same as sorting.	2014-12-10 11:52:51		
6375	ufdxg	72	For this problem, the first, second, and third values are all interconnected. Any solution that doesn't consider them all at the time is bound to leave room for invalid use cases. A valid brute force solution is located below. The space requirement is O(1) as it only requires minimal storage variables and not copy/sort. The run time is a sad O(n^3) for the triple for loop. That makes me think there should be a better solution, but such an algorithm defies me at this time.  Note that this algorithm will actually allow for arrays that contain positive and negative integer values (as well as floating point with some modification to the data types) as well as arrays of variable length.  Here is my coded solution:	2014-12-10 11:52:51		
6376	dgjji	72		2014-12-10 11:52:51		
6377	gilit	72		2014-12-10 11:52:51		
6378	jippy	72		2014-12-10 11:52:51		
6379	fmzze	72		2014-12-10 11:52:51		
6380	bexbp	72	This works when all the three arrays are of same length.	2014-12-10 11:52:51		
6381	ewigy	72		2014-12-10 11:52:51		
6382	azmjc	72		2014-12-10 11:52:51		
6383	sqzqo	73	Here is an O(nlogn) [amortized] approach using a threaded BST where each node points to the next in order successor. 1) read the array from right to left 2) Insert each element into a threaded BST. 3) Output the inorder successor after each insertion.  Perhaps we could reshape the threaded tree in between to make it balanced and increase performance but am not sure if we can modify a threaded tree.	2014-12-10 11:52:53		
6384	admin	73	I thought the same thing. its the best solution so far..	2014-12-10 11:52:53		
6385	cfzie	73	Could you explain in more details	2014-12-10 11:52:53		
6386	sgiwy	73	Sure ryaan The brute force solution O(n^2) does not structure the data in any way. So to optimize it lets try to bring a structure in the data. The operation to optimize is the linear search of the next greater element to the right, currently O(n). If all the elements on the right were in the form of a BST the search would take O(logn) time (if the BST was threaded. please lookup on internet for more information about binary threaded tree). So we start by building the tree from the right of the array (step 1) Each time we insert a new element in the BST we find out its successor which is the output we desire. I have mentioned it as amortized performance as its not a balanced BST that we are using. Am not sure if we can build a balanced threaded BST. Hope it helps	2014-12-10 11:52:53		
6387	nhibd	73	Just a balanced tree is enough to give an O(nlogn) (guaranteed) algorithm. No need for threaded tree. You can always find the required number in O(log n) time in a "normal" balanced tree.	2014-12-10 11:52:53		
6388	nwkeg	73	Yup you are right we can extract the inorder successor from a BST in logn time. So we will use the balanced BST instead of a threaded BST.	2014-12-10 11:52:53		
6389	huiqq	73	Your logic doesn't seems to be correct. Being in-order successor only means the next largest number to the given number. In the question it's asked to find the the next largest number which is on the right-side.	2014-12-10 11:52:53		
6390	vanul	73	it is not considering , if a number has appered before or after in the list. just replacing with next greater number.	2014-12-10 11:52:53		
6391	admin	73	You can achieve nlgn by using a min heap or min priority queue. Start from right to left, if the min heap is empty or min item is less than the current capture -1 otherwise capture the min value, then insert the current item into the heap and repeat to the left. Time complexity is dominated by the n lgn lg n insertions to the heap so nlgn	2014-12-10 11:52:53		
6392	mrjku	73		2014-12-10 11:52:53		
6393	tenuw	73		2014-12-10 11:52:53		
6394	qywrh	73	min.add(out[i]) should be min.add(in[i]) and should occur outside the else but otherwise good	2014-12-10 11:52:53		
6395	dkebi	73	this is wrong since it always compares to the min item to the right, you need the next highest. storing in a tree and then retrieving the next highest would do	2014-12-10 11:52:53		
6396	rdfeo	73		2014-12-10 11:52:53		
6397	plapd	73		2014-12-10 11:52:54		
6398	ftfck	73	C++ solution O(nlogn)	2014-12-10 11:52:54		
6399	mrjku	73		2014-12-10 11:52:54		
6400	sgiwy	73		2014-12-10 11:52:54		
6401	ethan	73	My Solution would be, breate a binary search tree from the given array. Now from pick one element, find it's inorder successor, delete it from tree and continue this till you get empty tree.	2014-12-10 11:52:54		
6402	zeice	73		2014-12-10 11:52:54		
6403	qywrh	73		2014-12-10 11:52:54		
6404	ufdxg	73	This will give you the immediate value which is greater than the current node not the least one on right side.	2014-12-10 11:52:54		
6405	fmzze	73	O(nLogn) solution using C++ map (BST). Scanning the array from right to left, insert the element into the map (BST). If the element inserted is the max., then print -1, else print the next highest element. This could also have been achieved using PriorityQueue in C++.  Note that the output is in reverse order.	2014-12-10 11:52:54		
6406	jippy	73		2014-12-10 11:52:54		
6407	bjsiw	73		2014-12-10 11:52:54		
6408	qywrh	73	How would you use PriorityQueue? Please enlighten us.	2014-12-10 11:52:54		
6409	bjsiw	73	best solution is by using binary search tree. Insert all the elements in to BST. this takes O(N) Now go through the array and find its successor,(this will be the leftmost leaf, in its right subtree, if it has left subtree, or parent node, or null) and replace it with successor if exits or delete the element. this will take O(NlogN) total time will be O(NlogN)	2014-12-10 11:52:54		
6410	zeice	73	dude insertion into bst only takes O(nlogn)	2014-12-10 11:52:54		
6411	vanul	73	Can be done much much simpler in O(n) by looking it from right to left.	2014-12-10 11:52:54		
6412	nwkeg	73		2014-12-10 11:52:54		
6413	tenuw	73		2014-12-10 11:52:54		
6414	eucmc	73	LEAST GREATER ELEMENT. ARE YOU DOING THAT?  YOU ARE DOING LEFTMOST GREATER ELEMENT ARENT YOU?	2014-12-10 11:52:54		
6415	azmjc	73	You're not following the requirements. You have to replace every element with an element that was originally to the right of it AND that element must be greater than it.	2014-12-10 11:52:54		
6416	mrjku	73	The inorder traversal method is incorrect. In the example in the questionm 43 should be replaced with 80 but the inorder successor in the tree is 58. The inorder successor does not have any relation to how the elements appear in the actual array. The trick is start inserting elements into a BST from the right. On insertion, remember the most recent left child path you took while inserting the current element. The node you last took the left child of is the value we replace the current element with. The invariant is on inserting element at index i, the only elements in the BST are the elements at index > i. The last "left turn" node keeps track of the smallest number greater than curr element. If no left turns are taken, replace it with -1. Time complexity is O(n^2) if numbers are sorted in ascending order from left to right. A balanced binary tree will O(n log n)	2014-12-10 11:52:54		
6417	bjsiw	73	We can scan the array from left to right for each item rank<- find the rank of that item find the item i<-from array which has the rank (rank+1); then base on i's value replace iteam. end for.	2014-12-10 11:52:54		
6418	plapd	73		2014-12-10 11:52:54		
6419	rdfeo	73		2014-12-10 11:52:54		
6420	gilit	73	well, can't we just sort the array with quicksort (O(nlogn)) and do another pass from left to right(O(n)) on the sorted array to make the replacements? Am I missing something?	2014-12-10 11:52:54		
6421	nwkeg	73	Lets take an example 3,2,4,1 The actual answer is 4,4,-1,-1 By your method: Quicksort: 1,2,3,4 Replace next greater on right: 2,3,4,-1 Hope it helps	2014-12-10 11:52:54		
6422	mrjku	73	I agree with kr.neerav and use BST to solve this problem. 1. Read the input array from right to left 2. Insert each array element into a BST. Note that I can find out the whether the least greater number for element k exists or not , from existed sub-tree when inserting k: the least greater number for k must be a predecessor of k if it exists.	2014-12-10 11:52:54		
6423	admin	73		2014-12-10 11:52:54		
6424	vanul	73		2014-12-10 11:52:54		
6425	dkebi	73		2014-12-10 11:52:54		
6426	xhgls	73		2014-12-10 11:52:54		
6427	fowai	73	}	2014-12-10 11:52:54		
6428	fmzze	73	I think people here have misunderstood the problem , we don't have to find the inorder successor here or the next greatest element of the array , we have to find the next greater element present in the right side of the element in the array , so even if there is a greater element in the left side of the array of the element being inspected the result would be -1. So , the index of the greater element should be more than the element being inspected. My solution would be like this: 1. Sort array using quick sort or merge sort and put the sorted array in a different array or create a binary search tree.(Time taken : nlogn) 2. In the above step modify the algorithm to store the index of each element in a map. 3. Now start inspecting elements of the array from left to right , pick the element one by one , find the successor from the sorted array or BST created in step one , then find the index of the successor from the map. If the index of the successor is more than the index of the element being inspected then replace the current element being inspected by the successor else replace it by -1.	2014-12-10 11:52:54		
6429	tenuw	73	Final step of algorithm may take O(n2) which is actually a brute force algorithm.	2014-12-10 11:52:54		
6430	rrmeu	73	// In c  #include<stdio.h> #define MAX 15  int main(){ int a[MAX]={8,58,71,18,31,32,63,92,43,3,91,93,25,80,28}; int i,j,k,x;  for(i=0;i<MAX;i++){ for(j=i+1;j<MAX;j++){ if(a[i]<a[j]){ x=a[j]; break; } } if(j==MAX){ x=-1; }else { for(k=j+1;k<MAX;k++){ if(a[j]>a[k]){ if(a[k]>a[i]){ x=a[k]; j=k; } } } } a[i]=x; } for(i=0;i<MAX;i++){ printf("%d\n",a[i]); } return 0; }	2014-12-10 11:52:54		
6431	ethan	73		2014-12-10 11:52:54		
6432	fmzze	73		2014-12-10 11:52:54		
6433	admin	73		2014-12-10 11:52:54		
6434	cfzie	73		2014-12-10 11:52:54		
6435	cfzie	73	would this work?  1) sort the original array using counting sort (sortedArray)- O(n+k) 2) for each element in original array (Array) we binary search for its location in the sorted array and return the next element if it exists (check for -1 or end of array), -1 otherwise. - O(logn) 3) set that index to -1 to mark as removed 4) return a new array with the data from step 2  This might make the complexity less than nlogn depending on the initial array given	2014-12-10 11:52:54		
6436	tenuw	73		2014-12-10 11:52:54		
6437	fmzze	73		2014-12-10 11:52:54		
6438	sgiwy	73	/*Write a program to replace each element of an array with a number present on the right side of the element such that the number is least greater than the element. If there is no greater number replace it with -1  e.g : 8, 58, 71, 18, 31, 32, 63, 92, 43, 3, 91, 93, 25, 80, 28 ans : 18, 63, 80, 25, 32, 43, 80, 93, 80, 25, 93, -1, 28, -1, -1*/  using System; using System.Collections.Generic; using System.Linq; using System.Text;  namespace Swaparray { class Program { static void Main(string[] args) { int[] arr=new int[15] {8,58,71,18,31,32,63,92,43,3,91,93,25,80,28}; int x=0,i,j; for (i=0; i<=14;i++) { Console.Write(" "+arr[i]+" ");  for (j =i+1; j <= 14; j++) { if (arr[i] < arr[j]) { x = arr[j]; break;  }  } if (j == 15) { x = -1; } else { for (int k = j + 1; k <= 14; k++) { if (arr[j] > arr[k]) { if (arr[k] > arr[i]) {  x = arr[k]; j = k; }  } } } arr[i] = x; } Console.WriteLine("\n\n"); for (i = 0; i < 15; i++) {   Console.Write(" " + arr[i] + " "); } Console.ReadLine(); } } }	2014-12-10 11:52:54		
6439	ufdxg	73	O(nlogn) solution. 1. Loop the array from 0 to n-1. Pick every element, say picked element has index "p". 2. Find the "ceil" of the picked number on the array from index "p+1" to "n-1". 3. Replace the number with the ceil value, as desired. 4. Use Binary Search to find the ceil value O(logn). 5. Doing for all n elements thus O(n*logn).	2014-12-10 11:52:54		
6440	admin	73	Not sure if we can use binary search since the array from index p+1 to n-1 is not sorted.	2014-12-10 11:52:54		
6441	dkebi	73	true, my bad..!!	2014-12-10 11:52:54		
6442	sgiwy	73	/* time: O(n^2logn), space: n */ 1. do a merge sort on a new array 2. do a binary search on each element, and find the next value.	2014-12-10 11:52:54		
6443	bjsiw	73	O(n log n) solution is to sort array first, then simply iterate through array and replace each element with the next element if it is greater. If it isn't greater, go to next one. This has expected/average time of O(n log n), but worst-case performance is O(n^2) if all elements are the same and you cannot find an element greater.	2014-12-10 11:52:54		
6444	dgjji	74	There can be at most one celebrity. Suppose A and B are both celebrities. A knows B by virtue of B's celebrity. But then A can't be a celebrity, by virtue of the rule that celebrities can't know anyone. Given that you have only celebrity, you can use a linear algorithm. Start with person 1, and they're the provisional celebrity. With person 2, see if either 2 doesn't know 1 or 1 knows 2, and if so, 1 is no longer a celebrity, and swap 1 and 2. For each new person, try to see if you can eliminate the celebrity's status with two simple checks, and then swap as needed.  After the first linear pass, you'll have a provisional celebrity, and then take another linear pass to verify that he really is a celebrity.  If there are no celebrities, then the second pass will be terminate fairly quickly.	2014-12-10 11:52:56		
6445	rrmeu	74	Well said. +1	2014-12-10 11:52:56		
6446	sqzqo	74	I don't know if that finds all the celebrities.	2014-12-10 11:52:56		
6447	vanul	74	@bunnybare: Amazing. You managed to skip right past the very first sentence.	2014-12-10 11:52:56		
6448	mrjku	74	If his answer is only for doing one celebrity, then the well said comment is unworthy.  If his answer is saying only one celebrity look up is possible given the linear time restriction, then I'll accept it.	2014-12-10 11:52:56		
6449	nwkeg	74	@bunnybare: Only one celebrity is possible. Period. Irrespective of the algorithm time complexity required.	2014-12-10 11:52:56		
6450	huiqq	74	@bunnyabare, According to the rules, there can be at most one celebrity. Proof: Suppose A and B are both celebrities. A knows B by virtue of B's celebrity and the rule that a celebrity is known by everybody. But then A can't be a celebrity, by virtue of the rule that celebrities can't know anyone. Since any pair of celebrities leads to a contradiction of the rules, there can be at most one celebrity.	2014-12-10 11:52:56		
6451	tenuw	74	implement showell30's algorithm with c++	2014-12-10 11:52:56		
6452	mrjku	74		2014-12-10 11:52:56		
6453	ethan	74		2014-12-10 11:52:56		
6454	bexbp	74	@duckling That's a nice refinement of my solution. As your code illustrates, there's no need to actually perform a swap; just change the value of candidate to be the new i.	2014-12-10 11:52:56		
6455	bjsiw	74	@duckling : Nice efficient implementation.. but could you please explain why are you using 'or' instead of 'and' in the if-condition ? because if a[i][candidate]=1, then i can be no way in which i can be the next possible candidate.. plz verify.	2014-12-10 11:52:56		
6456	huiqq	74	@ss,i think showell30 explained it very clearly," see if either 2 doesn't know 1 or 1 knows 2". if person i doesn't know the candidate or the candidate knows person i,then the candidate is not a celebrity	2014-12-10 11:52:56		
6457	dkebi	74	@duckling One possible optimization here is that we try to eliminate candidates more aggressively. When you have i and candidate, call both KNOW(i, candidate) and KNOW(candidate, i). If both know each other or both don't know each other, then you've eliminated both, and you can advance candidate to be i+1 and i to be i+2. I haven't thought this all the way through, and it might not be worth the trouble, but if you can get all the bookkeeping right, it might eliminate the final linear pass and possibly speed up the first linear pass, especially if the KNOW() function call is expensive for some reason.	2014-12-10 11:52:57		
6458	bjsiw	74	Here is a full JavaScript solutions, including structure, which represents the relations among people:  The relations: We have people A, B, C, D, E. In the example below "A" knows B, C and E.	2014-12-10 11:52:57		
6459	vanul	74		2014-12-10 11:52:57		
6460	azmjc	74		2014-12-10 11:52:57		
6461	ftfck	74	Here is the code:	2014-12-10 11:52:57		
6462	rrmeu	74		2014-12-10 11:52:57		
6463	vanul	74		2014-12-10 11:52:57		
6464	gilit	74	The answer is C. The time is O(n)	2014-12-10 11:52:57		
6465	ethan	74	And here is isRelated function, forgot to paste it:	2014-12-10 11:52:57		
6466	nwkeg	74		2014-12-10 11:52:57		
6467	zeice	74		2014-12-10 11:52:57		
6468	ufdxg	74	@duckling - okk.. got it.. actually I was thinking the other way round..	2014-12-10 11:52:57		
6469	mrjku	74	showell30@yahoo.com We can eliminate both A and B at the same time if they don't know each other. Since they cannot both be celebs, and neither is known, they must both be non-celebs. I'm not sure if you considered this but it isn't in your original description.  This reduces the runtime but not the complexity.  (Sweet solution BTW)	2014-12-10 11:52:57		
6470	krxlv	74	@Barry, thanks. If you scroll up in the comments, I respond to duckling about the optimization where you can eliminate A and B at the same time. As you point out, it doesn't reduce the overall complexity, which is why I'd be somewhat shy about trying to handle this case, unless I were really trying to squeeze out extra performance.	2014-12-10 11:52:57		
6471	dkebi	74	we can eliminate A and B if both knows or both doesnot know each other	2014-12-10 11:52:57		
6472	nwkeg	74	@Showell nice answer. but at the first glance of the question, I was thinking about KNOWS(A,B) as some kind of comparative function, which can be used in sorting. and once we sort the list we would get the celebrities at one end, ofcourse there is no comparitive sort which can perform in linear time.	2014-12-10 11:52:57		
6473	bjsiw	74	@goutham467, Instead of thinking of this as a sorting problem, think of it as a min-item-in-list problem. You can easily find the minimum element of an unsorted list in linear time, as long as the list has some sort of transitive ordering. The twist here is that you don't have a truly transitive ordering, since A can know B can know C can A. From the celebrity's standpoint, though, it doesn't really matter, because he or she is not allowed to be in any strange friendship cycles.  When you solve the traditional min-item-in-a-list problem, you have a provisional min and you keep trying to dethrone the provisional min as you iterate through the list. For the celebrity problem, it's the same algorithm with a slightly different mechanism to dethrone the provisional celebrity.	2014-12-10 11:52:57		
6474	wbqzu	74	@showell Thanks for a such a clear explanation."min-item-in-list" problem, how can I forgot a basic thing. I am struggling with a question though, could you please comment on it, id=15489912	2014-12-10 11:52:57		
6475	ewigy	74	@goutham467 BTW here is a way to solve this that explicitly uses a comparison function with a generic algorithm:	2014-12-10 11:52:57		
6476	sqzqo	74		2014-12-10 11:52:57		
6477	bjsiw	74		2014-12-10 11:52:57		
6478	sgiwy	74	I omitted the extra step to fully verify celebrity status.	2014-12-10 11:52:57		
6479	qywrh	74	#include <stdio.h> #include <stdlib.h>   int people; extern int knows(int a, int b);  int celebrity() { int celebrity, left = 1, right = people; while (left < right) { if (knows(left, right)) { left++; } else { right--; } } celebrity = left; return celebrity; }  int main(int argc, char *argv[]) { printf("Number of people: "); scanf("%d", &people); printf("The celebrity is number %d\n", celebrity()); return 0; }	2014-12-10 11:52:57		
6480	krxlv	74	given a and b : check Knows(a,b) and Knows(b,a). If both result match eliminate both a and b to move forward as none are celebrity candidate , if only one is true say Knows(a,b) then eliminate a , b is still a candidate. get the next person in the list . On each step you exhaust at least one and hence linear time	2014-12-10 11:52:57		
6481	fowai	74	I too tried something on it. Please let me know for impvements. My thought of doing it is as follows: 1. Assume list is {A,B,C,D,E} and i=0,j=1 initially. Since only one celebrity or none exists, start with first two elements in list. 2. If knows() returns true, change i,j to j,j+1 else i,j+1. 3. Once j reaches last position, it means either i or j can be celebrities. So check which one is celebrity using normal for loop. It returns position of celebrity in list. It visits each element for 2 times hence O(2N)=O(N).	2014-12-10 11:52:57		
6482	rdfeo	74		2014-12-10 11:52:57		
6483	rrmeu	74		2014-12-10 11:52:57		
6484	krxlv	74	geeksforgeeks . org /the-celebrity-problem/	2014-12-10 11:52:57		
6485	fowai	74	idk dude	2014-12-10 11:52:57		
6486	azmjc	74	Code in C#.	2014-12-10 11:52:57		
6487	nhibd	74		2014-12-10 11:52:57		
6488	gilit	74		2014-12-10 11:52:57		
6489	dgjji	74	This problem is similar to finding a universal sink in a graph in linear time. If A knows B then there is a edge between node A and node B.  Universal Sink is then a node with all incoming edges and no outgoing edges  You can also find the universal sink problem in Cormen et al and its solution in its solution manual.	2014-12-10 11:52:57		
6490	gilit	74	if cur don't know next one means: next one is not celebrity so i++; if cur know next one means: cur is not celebrity so cur = i; the people between i and cur don't known by cur so they are all not celebrity.	2014-12-10 11:52:57		
6491	fowai	74		2014-12-10 11:52:57		
6492	nhibd	74		2014-12-10 11:52:57		
6493	bexbp	74	sorry the last line should be return arr[cur]; if cur don't know next one means: next one is not celebrity so i++; if cur know next one means: cur is not celebrity so cur = i; the people between i and cur don't known by cur so they are all not celebrity.	2014-12-10 11:52:58		
6494	xhgls	74		2014-12-10 11:52:58		
6495	gilit	74		2014-12-10 11:52:58		
6496	xhgls	74		2014-12-10 11:52:58		
6497	nwkeg	74	Your check doesn't work.  Better:  If A knows B, then A cant be celebrity. Discard A, and B may be celebrity. If A doesnt know B, then B cant be celebrity. Discard B, and A may be celebrity.	2014-12-10 11:52:58		
6498	vanul	74	Although it's overkill for this problem, you can model this like an NCAA March Madness single-elimination, which runs in linear time. For each "game," see if A knows B. If A knows B, then B wins, else A wins. After 63 games, you will have a winner that is least as "famous" as all other contenders. To verify that they're actually a celebrity, you'd still need to check the winner's relationship to the 63 losers in another linear pass.	2014-12-10 11:52:58		
6499	ftfck	74	I like the NCAA solution better. Here's the semi-solution with modification to Integer.	2014-12-10 11:52:58		
6500	fmzze	74		2014-12-10 11:52:58		
6501	admin	74		2014-12-10 11:52:58		
6502	plapd	75		2014-12-10 11:52:59		
6503	wbqzu	75		2014-12-10 11:52:59		
6504	wbqzu	75	Really straightforward and simple solution. Runs in O(maxlen(a,b)) time.	2014-12-10 11:52:59		
6505	dkebi	75	Very nice. My only issue is that c[0] will be null (or undefined) if there is a carry on the most significant digit.	2014-12-10 11:52:59		
6506	plapd	75	@Michael - First assuming all values of the arrays are initialized to zero, the fact that c is of length maxlen+1 will avoid that problem (the new array will always be one digit longer than the longest input, allowing room to contain the correct sum after the final carry step).	2014-12-10 11:52:59		
6507	eucmc	75	Nice !!. Neat and clean implementation.	2014-12-10 11:52:59		
6508	gilit	75	For fun because I wanted to act on a hunch that a few liner was possible. Though I expanded a line into multiple to make it clear that 3 possible cases of sum are being calculated.  Call this with b[] being bigger array, r[] having length b.length+1, and last argument 0 (use a wrapper if you like): b stands for bigger, s for smaller, r for result	2014-12-10 11:52:59		
6509	xhgls	75		2014-12-10 11:52:59		
6510	ewigy	75		2014-12-10 11:52:59		
6511	ufdxg	75	I used this diagram (in notepad) to play with to scratch my itch (the hunch):	2014-12-10 11:52:59		
6512	fmzze	75		2014-12-10 11:52:59		
6513	qywrh	75		2014-12-10 11:52:59		
6514	wbqzu	75	Yes, there are limitations to the design, but it looks cool (and different from the ones already posted). And probably has off by one errors.  Compiled on scrap paper, tested on that notepad diagram above.	2014-12-10 11:52:59		
6515	bjsiw	75	Ughh careercup messed up alignments. Trying again:	2014-12-10 11:52:59		
6516	ewigy	75		2014-12-10 11:52:59		
6517	mrjku	75		2014-12-10 11:52:59		
6518	nwkeg	75	And:	2014-12-10 11:52:59		
6519	nwkeg	75		2014-12-10 11:52:59		
6520	jippy	75		2014-12-10 11:52:59		
6521	nhibd	75	#include <stdio.h> #include <stdlib.h> int array_add(int *result, int data_1[], int len_1, int data_2[], int len_2){ if( len_1 < 0 || len_2 < 0 ){ return -1; } int i,j,k; int temp;  // i = (len_1 < len_2 ? len_1-1:len_2-1); temp = 0; i = len_1 -1; j = len_2 -1; k = (len_1 > len_2 ? len_1:len_2);  for( ; i > -1 && j > -1 ; i--,j--){ temp = data_1[i] + data_2[j] +result[k]; result[k] = temp%10; result[k-1] = result[k-1] + temp/10; k--; }  // j = (len_1 > len_2 ? len_1-len_2-1 : len_2-len_1-1);  if(i > -1){ while( i > -1 ){ temp = result[k] + data_1[i]; result[k] = temp%10; result[k-1] = result[k-1] + temp/10; i--; k--; } }else if( j > -1 ){ while( j > -1 ){ temp = result[k]+ data_2[j]; result[k] = temp%10; result[k-1] = result[k-1] + temp/10; j--; k--; } } return 1; } int main(){ int array_1[5] = {2,3,4,6,7}; int array_2[6] = {5,7,2,7,8,3}; int i; int *result = (int *)malloc(sizeof(int)*7); for ( i = 0; i < 7 ; i++ ){ result[i] = 0; } array_add(result,array_1,5,array_2,6); for ( i = 0; i < 7 ; i++ ){ printf("%d ",result[i]); } printf("\n"); return 1; }	2014-12-10 11:52:59		
6522	jippy	75	Not sure if I'm missing something or I misunderstood the problem but here is mine. It seems to work.	2014-12-10 11:52:59		
6523	cfzie	75		2014-12-10 11:52:59		
6524	bexbp	75		2014-12-10 11:52:59		
6525	ufdxg	75	doesn't work for all cases it seems. nevermind...	2014-12-10 11:52:59		
6526	zeice	75	Also remember these are very large numbers. This means that the regular Integer class could not hold the value so parsing the array's string representation does not work.	2014-12-10 11:52:59		
6527	vanul	75	Well, here's a fun way of doing it, not really any more efficient than the other methods shown here, this one uses a stack.	2014-12-10 11:52:59		
6528	ethan	75		2014-12-10 11:52:59		
6529	ewigy	75		2014-12-10 11:52:59		
6530	gilit	75	It will always take O(max(a.length,b.length)) time (so, O(n) where n is longest array's length). In no event will it have a extraneous digit on the front.  It's not a pretty or short solution, unfortunately, but it works and it is time efficient. It only works if you are adding in the following manner ( there is another version where the last digit is the highest)  {1,2,3} = 123. {4,5,6} = 456. {1,2,3} + {4,5,6} = 579	2014-12-10 11:52:59		
6531	cfzie	75		2014-12-10 11:52:59		
6532	sqzqo	75		2014-12-10 11:53:00		
6533	ftfck	75	}	2014-12-10 11:53:00		
6534	eucmc	75	Java Solution:	2014-12-10 11:53:00		
6535	vanul	75		2014-12-10 11:53:00		
6536	admin	75		2014-12-10 11:53:00		
6537	vanul	75	I guess I also could've added a check for the length of one and two to make sure they actually had values on the IllegalArguementException	2014-12-10 11:53:00		
6538	sqzqo	75		2014-12-10 11:53:00		
6539	nwkeg	75		2014-12-10 11:53:00		
6540	nhibd	75		2014-12-10 11:53:00		
6541	tenuw	75		2014-12-10 11:53:00		
6542	sgiwy	75	github.com/vikhyath/c-runs/tree/master/sum-arrays  github.com/vikhyath/python-runs/tree/master/sum-arrays	2014-12-10 11:53:00		
6543	nhibd	75	Java Solution	2014-12-10 11:53:00		
6544	eucmc	75		2014-12-10 11:53:00		
6545	huiqq	75		2014-12-10 11:53:00		
6546	bjsiw	75	There's already a simple straightforward solution.  A more performant solutions would use some sort of SIMD, like SSE2. You'd have to do an add operation to add the two arrays, divide by 10 to get the carry, re-align the resultant carry data, then add the carry.	2014-12-10 11:53:00		
6547	dkebi	75	My intuitive algorithm:	2014-12-10 11:53:00		
6548	vanul	75		2014-12-10 11:53:00		
6549	mrjku	75		2014-12-10 11:53:00		
6550	sgiwy	75	The time complexity: O(max(|a|,|b|))	2014-12-10 11:53:00		
6551	plapd	75	// assume the integers are positive // 1-Select the size of the biggest array maxLen // 2-Start the sum from the end of the selected array // carry = 0; // x goes from maxLen-1 to 0 // y = ( 0 or a[x] if x<aLen ) + ( 0 or b[x] if x<bLen ) + carry // if y>9 // y = 10-y and carry = 1 // else // carry = 0	2014-12-10 11:53:00		
6552	mrjku	75		2014-12-10 11:53:00		
6553	eucmc	75		2014-12-10 11:53:00		
6554	ftfck	75	I used long instead of int just so it could handle larger values.  public static void main(String arg[]) { long[] arraySum1 = { 1, 2, 3, 4, 5, 1, 9, 8, 9, 3, 4 }; long[] arraySum2 = { 1, 2, 9, 4, 5, 2, 3, 8, 5 }; long arraySum = arraySum(arraySum1, arraySum2); System.out.println(arraySum); } public static long arraySum(long[] x, long[] y) { int a = x.length - 1, b = y.length - 1; long sum = 0; while (a >= 0 || b >= 0) { if (a >= 0) {sum += x[a] * Math.pow(10, x.length - a - 1);} if (b >= 0) {sum += y[b] * Math.pow(10, y.length - b - 1);} System.out.println(sum); a--; b--; } return sum; }	2014-12-10 11:53:00		
6555	huiqq	75	I used long instead of int just so it could handle larger values.  public static void main(String arg[]) { long[] arraySum1 = { 1, 2, 3, 4, 5, 1, 9, 8, 9, 3, 4 }; long[] arraySum2 = { 1, 2, 9, 4, 5, 2, 3, 8, 5 }; long arraySum = arraySum(arraySum1, arraySum2); System.out.println(arraySum); } public static long arraySum(long[] x, long[] y) { int a = x.length - 1, b = y.length - 1; long sum = 0; while (a >= 0 || b >= 0) { if (a >= 0) {sum += x[a] * Math.pow(10, x.length - a - 1);} if (b >= 0) {sum += y[b] * Math.pow(10, y.length - b - 1);} System.out.println(sum); a--; b--; } return sum; }	2014-12-10 11:53:00		
6556	wbqzu	75	Assuming arrays can be of different length:	2014-12-10 11:53:00		
6557	gilit	75		2014-12-10 11:53:00		
6558	gilit	75		2014-12-10 11:53:00		
6559	cfzie	75	This seems too easy to be a Google SE Intern question... I'm suspicious.	2014-12-10 11:53:00		
6560	rrmeu	75	How's it stored and in what type of array?	2014-12-10 11:53:00		
6561	tenuw	75	The numbers are stored from most sig digit to least from right to left in the array, as you'd probably naturally imagine.  int[] arr = {1, 2, 3}; // 123  The type of array is int[]. (This was originally in Java when asked).	2014-12-10 11:53:00		
6562	zeice	75	Ok, that's interesting.  Let me try recursive for fun.	2014-12-10 11:53:00		
6563	gilit	75	public class Sum {  static int a1[] = {1,2,3,4}; static int a2[] = {9,9,9,9}; static int a3[];  static void findSum(int a1[], int a2[]){  int len1 = a1.length-1, len2 = a2.length-1, len3 = a3.length-1; int carry = 0,sum; while(len2 != -1){ sum = a1[len1--] + a2[len2--]+carry; carry = sum / 10; a3[len3--] = sum%10; } while(len1 != -1){ sum = a1[len1--] + carry; a3[len3--] = sum%10; carry = sum/10; } a3[len3] = carry; for(int i = 0; i <a3.length; i++){ System.out.print(a3[i]); } }  public static void main(String args[]){ if(a1.length>a2.length){ a3 = new int[a1.length+1]; findSum(a1,a2); } else{ a3 = new int[a2.length+1]; findSum(a2,a1); } } }	2014-12-10 11:53:00		
6564	fowai	75	seems to add an extra 0 at the beginning in some cases	2014-12-10 11:53:00		
6565	xhgls	75	public static void main(String[] args) { int[] a = {9,5,7,2,4,8,5,9,1,5}; int[] b = {9,1,1,1,2,3,8,5,9,1}; add(a,b); }  static void add(int[] x, int[] y){ int xLength = x.length; int yLength = y.length; int zLength = Math.max(xLength, yLength)+1; int[] z = new int[zLength]; int k = 0; for (int i=1;i<=zLength;i++){ if(xLength-i<0 && yLength-i>=0){ z[zLength-i] = (y[yLength-i]+k)%10; k = (y[yLength-i]+k)/10; } else if(yLength-i<0 && xLength-i>=0){ z[zLength-i] = (x[xLength-i]+k)%10; k = (x[xLength-i]+k)/10; } else if(yLength-i<0 && xLength-i<0){ z[zLength-i] = k; } else if(yLength-i>=0 && xLength-i>=0){ z[zLength-i] = (x[xLength-i]+y[yLength-i]+k)%10; k = (x[xLength-i]+y[yLength-i]+k)/10; } } for (int i=0;i<zLength;i++){ System.out.print(z[i]); } System.out.println(); }	2014-12-10 11:53:00		
6566	rdfeo	75		2014-12-10 11:53:00		
6567	dkebi	75		2014-12-10 11:53:00		
6568	rrmeu	75	No need for so much duplicated code. Check this:	2014-12-10 11:53:00		
6569	dgjji	75		2014-12-10 11:53:00		
6570	dkebi	75		2014-12-10 11:53:00		
6571	qywrh	76	Solution with a some simplification: Call the function with the root of the tree The root is at height 0.	2014-12-10 11:53:01		
6572	bjsiw	76		2014-12-10 11:53:01		
6573	azmjc	76		2014-12-10 11:53:01		
6574	ftfck	76	This is a "true" recursive version.  Assuming sum returns the required value for a given node, then recursively what we need is (assuming root is even level)  (-sum(right)) + (-sum(left)) + (-root) which is exactly what you have.	2014-12-10 11:53:01		
6575	nwkeg	76	Excellent approach!	2014-12-10 11:53:02		
6576	sgiwy	76	what if we want to find (sum of values at even height)-(sum of values at ODD height) without using helper function.	2014-12-10 11:53:02		
6577	bexbp	76	@sapy just call the same function and change the sign of the result.	2014-12-10 11:53:02		
6578	eucmc	76	can someone explain in greater detail why this works?	2014-12-10 11:53:02		
6579	ftfck	76	The core idea is that, negative of a negative number is positive. And this can be used to find out if a level of a tree is odd or even. its similar to having a boolean and negating it at every level so that the the value flips as it goes deeper into the tree. so, Level -> (even, odd, even, odd, even,...) => (-1, -(-1), -(-(-1)), -(-(-(-1))), -(-(-(-(-1)))), ...) => (-1, 1, -1, 1, -1, ...)  For example,  (0) 1 / \ (1) 2 3 / \ / \ (2) 4 5 6 7  Level <--> Expression 2 <--> -(4+0+0), -(5+0+0)), -(6+0+0), -(7+0+0)  1 <--> -(2+ (-4) + (-5)), -(3 + (-6) + (-7))  0 <--> -(1 + (-(2+ (-4) + (-5))) + (-(3 + (-6) + (-7))))  At root => -1 + (2+3) - (4+5+6+7). Hence, the solution	2014-12-10 11:53:02		
6580	plapd	76		2014-12-10 11:53:02		
6581	nwkeg	76		2014-12-10 11:53:02		
6582	xhgls	76		2014-12-10 11:53:02		
6583	azmjc	76	This code fails to compute this tree	2014-12-10 11:53:02		
6584	nwkeg	76	This is wrong because height is different from depth . Two nodes have same depth doesn't necessarily means they have the same height. Your solution is correct when doing this for nodes at odd depth - node at even depth.	2014-12-10 11:53:02		
6585	sqzqo	76	Do a postorder also maintain a level, if level is odd then add the root->val otherwise subtract it.	2014-12-10 11:53:02		
6586	krxlv	76		2014-12-10 11:53:02		
6587	sgiwy	76		2014-12-10 11:53:02		
6588	plapd	76	Working code available at: ideone.com/X2QIIR	2014-12-10 11:53:02		
6589	rrmeu	76	as per the question function takes only root node as argument.	2014-12-10 11:53:02		
6590	fowai	76	ohh! then we must use BFS.	2014-12-10 11:53:02		
6591	fmzze	76		2014-12-10 11:53:02		
6592	plapd	76		2014-12-10 11:53:02		
6593	bjsiw	76	This can always be made a helper function... I don't see the question disallow that.	2014-12-10 11:53:02		
6594	xhgls	76	Same can be achieved using BFS.	2014-12-10 11:53:02		
6595	ewigy	76	or dfs	2014-12-10 11:53:02		
6596	huiqq	76		2014-12-10 11:53:02		
6597	admin	76		2014-12-10 11:53:02		
6598	rrmeu	76	This wont work. The level will come out to be 0 for each level. This is because you're initializing a new int each recursive call. Then incrementing it to one, then decrementing it to 0.	2014-12-10 11:53:02		
6599	eucmc	76	level is declared as static int, so it retains value between recursive calls	2014-12-10 11:53:02		
6600	ufdxg	76	I think it will work...... It is just algorithm........ function SUM(root,level) { if(root==NULL) return(0); if(level%2==0) return(SUM(root->left,level+1)+SUM(root->right,level+1)-root->data); return(SUM(root->left,level+1)+SUM(root->right,level+1)+root->data); }	2014-12-10 11:53:02		
6601	ufdxg	76	Working code:  public static int getDiffOfEvenOddLevel(Node root, boolean isLevelEven) { if (root == null) return 0;  if (isLevelEven) return root.data + getDiffOfEvenOddLevel(root.left, false) + getDiffOfEvenOddLevel(root.right, false); else return -root.data + getDiffOfEvenOddLevel(root.left, true) + getDiffOfEvenOddLevel(root.right, true); }	2014-12-10 11:53:02		
6602	fowai	76		2014-12-10 11:53:02		
6603	vanul	76		2014-12-10 11:53:02		
6604	tenuw	76	level order traversal..	2014-12-10 11:53:02		
6605	rrmeu	76	Assuming root is at height '0' which is at even height.	2014-12-10 11:53:02		
6606	plapd	76		2014-12-10 11:53:02		
6607	qywrh	76		2014-12-10 11:53:02		
6608	cfzie	76		2014-12-10 11:53:02		
6609	tenuw	76		2014-12-10 11:53:02		
6610	qywrh	76	private void DifferenceSumatOoddandSumatEven(ref int sum, BinaryTreeNode<T> node, int level) { if (node == null) return; if ((level & 1)==0)//if level is even sum+=node.item; else sum += -1 *node.item; DifferenceSumatOoddandSumatEven(ref sum, node.Left, level + 1); DifferenceSumatOoddandSumatEven(ref sum, node.Right, level + 1); }	2014-12-10 11:53:02		
6611	ufdxg	76	Was asked in Flipkart phone round.	2014-12-10 11:53:02		
6612	fmzze	76		2014-12-10 11:53:03		
6613	ftfck	76		2014-12-10 11:53:03		
6614	nhibd	76	Use BFS, use some counters and a flag to track odd or even levels. If count == 0, a new level starts and the flag needs to be reset. The program will stop when the linked list is empty. struct node{ int value; struct node *l; struct node *r; struct node *next; } node; int getValue(node * root){  int count = 1; //Root int values = 0; int count1= 0; int flag = 0; node *head = (node *)calloc(sizeof(node), 1); head->next = root; p1 = head->next; //p tracks the tail of the list while(head->next != NULL){ if(flag == 1) values +=head->next->value; count --; // Take out the next node  if(count == 0){ count = count1; if(flag == 0) flag = 1; else flag = 0; } if(head->next->l != NULL){ p->next = (node*)calloc(sizeof(node), 1); p = p->next; count1 ++; } if(head->next->r != NULL){ p->next = (node*)calloc(sizeof(node), 1); p = p->next; count1 ++; } node *p1 = head->next; head->next = head->next->next; free(p1);  }   }	2014-12-10 11:53:03		
6615	fmzze	76	Here is a BFS solution, using two Queues to store nodes and the level of nodes. then it can be easily solved.	2014-12-10 11:53:03		
6616	plapd	76		2014-12-10 11:53:03		
6617	bexbp	76		2014-12-10 11:53:03		
6618	rdfeo	76	Using Bfs	2014-12-10 11:53:03		
6619	bjsiw	76		2014-12-10 11:53:03		
6620	wbqzu	76		2014-12-10 11:53:03		
6621	tenuw	76	}	2014-12-10 11:53:03		
6622	rrmeu	76		2014-12-10 11:53:03		
6623	zeice	76		2014-12-10 11:53:03		
6624	azmjc	76		2014-12-10 11:53:03		
6625	sgiwy	76		2014-12-10 11:53:03		
6626	plapd	77	I say, the extra data to keep in your node is a flag to indicate if the node is deleted. When you have a chance, e.g., walking the list from the head, you can unlink a node if it is marked deleted, otherwise just respect the deleted flag when handling any node.	2014-12-10 11:53:07		
6627	dkebi	77	How can you walk if the head is not given?	2014-12-10 11:53:07		
6628	vanul	77	I think the soln is possible if we have pointer to the pointer of last node,i/e double pointer..	2014-12-10 11:53:08		
6629	ufdxg	77	That's a doubly linked list. Not allowed.	2014-12-10 11:53:08		
6630	bexbp	77	So to delete the last node from a singly linked list, you invoke a function from that node (this is the additional data I believe the interviewer was talking about) that:  1. Checks if this node is the last node - if so set it to null 2. Iterates through the list looking 2 nodes ahead (n.next.next) to find the end of the list 3. Finally moves to the last node and sets it to null  Brief example:  Node n = myLinkedList.getRandomNode(); (this is any node that is part of a linked list)  n.deleteLast();	2014-12-10 11:53:08		
6631	rrmeu	77		2014-12-10 11:53:08		
6632	qywrh	77		2014-12-10 11:53:08		
6633	xhgls	77	Head pointer is not given, thats the key point here. So we can not iterate through the list.	2014-12-10 11:53:08		
6634	plapd	77	@yolo  You can iterate through a LinkList without the head pointer, so long as you have one of the nodes from the list. My example above does not utilize a head pointer, but definently utilizes iteration. Every node in a list has a pointer to next, and therefore you can start at any node N and move/look forward.	2014-12-10 11:53:08		
6635	dgjji	77	The main thing about removal of node in a LinkedList is to break the chain properly. The above code does not break the linked list chain. There must be some code that assigns "node.next" with a new value. I can't see this from the above code. The statement this=null does not make sense.	2014-12-10 11:53:08		
6636	krxlv	77	this = null wont work. What about having this as your method:	2014-12-10 11:53:08		
6637	huiqq	77		2014-12-10 11:53:08		
6638	qywrh	77		2014-12-10 11:53:08		
6639	zeice	77	then when you need to delete, you get the last node:	2014-12-10 11:53:08		
6640	fowai	77		2014-12-10 11:53:08		
6641	gilit	77		2014-12-10 11:53:08		
6642	ethan	77	but you actually only do the delete the next time you use the list e.g. for printing, by doing something like:	2014-12-10 11:53:08		
6643	fmzze	77		2014-12-10 11:53:08		
6644	sqzqo	77		2014-12-10 11:53:08		
6645	gilit	77	probably not what they want, just my 2 cents..	2014-12-10 11:53:08		
6646	ufdxg	77	Keep refernce of the node in this case...... and as temp will be null and in else case the last node will be set to null  void del(struct node * &nxt){  struct node *temp=nxt->next;  if(temp!=NULL){ nxt->data=temp->data; nxt->next=temp->next;  free(temp);  }else  nxt=NULL; //your answer  }	2014-12-10 11:53:08		
6647	ewigy	77	Your statement of the problem is confusing. I think you want to delete the previous node? If all we need is to delete the last node or tail then it's fairly trivial. You could easily add a head member to each node. Then you have your list start off with a dummy head that never gets removed. Still will take you iterating back to the given node from the head.	2014-12-10 11:53:08		
6648	ethan	77	Nope. No iteration allowed.	2014-12-10 11:53:08		
6649	azmjc	77	I am sorry but... I think question filler didn't get question properly...	2014-12-10 11:53:08		
6650	nwkeg	77	I got the question properly. And I gave him the correct answer also.  If you have any doubt at any part, let me know.	2014-12-10 11:53:08		
6651	gilit	77	@yolo: oh... my fault... Apologies for that....	2014-12-10 11:53:08		
6652	mrjku	77	@yolo, Can you tell the solution.	2014-12-10 11:53:08		
6653	ftfck	77	The solution is possible if you can have a tail pointer and the linked list is made circular.	2014-12-10 11:53:08		
6654	ethan	77		2014-12-10 11:53:08		
6655	plapd	77		2014-12-10 11:53:08		
6656	bexbp	77	There is a type of single linked list where the pointer of a node contains the XOR of the previous and next nodes  In such type of a linked list, going back to the previous node is to XOR with the next node, in this case null.  Once we reach the previous node this way its just a matter of completing the formalities	2014-12-10 11:53:08		
6657	plapd	77	I guess in c or c++ you can do this,	2014-12-10 11:53:08		
6658	rrmeu	77		2014-12-10 11:53:08		
6659	azmjc	77		2014-12-10 11:53:08		
6660	huiqq	77	Use a static variable in the linked list structure.	2014-12-10 11:53:09		
6661	cfzie	77		2014-12-10 11:53:09		
6662	bexbp	77		2014-12-10 11:53:09		
6663	ewigy	77	While creating the list, keep updating the static variable so that it points the second last one. Then it's simple	2014-12-10 11:53:09		
6664	plapd	77		2014-12-10 11:53:09		
6665	vanul	77		2014-12-10 11:53:09		
6666	nwkeg	77	There is no way you can delete the last node when only pointer to a node is given.Generally the question is asked for middle node and the answer still remains NO. But there you can simulate this behavior by copying the contents to next node and deleting the given node.	2014-12-10 11:53:09		
6667	rdfeo	77	what is given to us?	2014-12-10 11:53:09		
6668	nwkeg	77	@yolo Can u please post answer this que?	2014-12-10 11:53:09		
6669	eucmc	77	Keep a deleted bit field in the Node. struct Node { int data; struct Node * next; int isDeleted; }  Your function would just set this bit to 1 (isDeleted = 1) when you ask something to delete. It takes 2 things into consideration. 1. Deleting the last node where there is only 1 node in the LL. 2. Deleting the last node where the random pointer given is itself the last node.  When you traverse the link list later. You can handle these deleted Node blocks in memory: 1. Skip the ones where Node->isDeleted = 1 (not a good option but not wrong either) 2. While traversing at a later point your program would check if any node is marked as deleted and at this time rearrange pointers correctly. (efficient - this is also the technique used in paging where a page is marked as deleted in memory and delayed the deletion on disk)	2014-12-10 11:53:09		
6670	fmzze	77	Thanks to the post on stack overflow for the answer-	2014-12-10 11:53:09		
6671	jippy	77		2014-12-10 11:53:09		
6672	nwkeg	77		2014-12-10 11:53:09		
6673	sgiwy	77	I'm not getting the question. What are you given? If you are given a pointer to some random node in a circular (singly) linked list, and you want to delete the node before it, just hold a pointer to that node and go through the list. when you reach that 'starting' element again, delete the previous one. e.g. given: 'p' q=p while(q->next != p && q->next!=NULL) q=q->next; (*q)=(*p); //gets rid of the node you are pointing to	2014-12-10 11:53:09		
6674	bexbp	77		2014-12-10 11:53:09		
6675	bexbp	77	last node has no next...its next is NULL..read the question carefully	2014-12-10 11:53:09		
6676	sgiwy	77	It is a bad approach to copy data among the nodes. Since we use this data as integer, its okay, consider having a Gigabyte of data stored in the link list node. Would you still copy data among nodes. Nah!  I mentioned a solution to this. Please check above with having an extra bit for deleted node.	2014-12-10 11:53:09		
6677	nwkeg	78	Use two pointers both pointing to the head of the linked list. Move one of the pointers k ahead. Now move both of the pointers one node ahead at a time. When the first one reaches the end the second one would be k nodes behind it.	2014-12-10 11:53:10		
6678	dgjji	78		2014-12-10 11:53:10		
6679	fowai	78		2014-12-10 11:53:10		
6680	rdfeo	78		2014-12-10 11:53:10		
6681	xhgls	78		2014-12-10 11:53:10		
6682	fowai	78	must change to	2014-12-10 11:53:10		
6683	fmzze	78		2014-12-10 11:53:10		
6684	ewigy	78		2014-12-10 11:53:10		
6685	nhibd	78	to deal with the pathological case you are checking. Just a way to avoid that extra if block.	2014-12-10 11:53:10		
6686	dgjji	78	if	2014-12-10 11:53:10		
6687	fmzze	78		2014-12-10 11:53:10		
6688	rrmeu	78		2014-12-10 11:53:10		
6689	nwkeg	78	, then	2014-12-10 11:53:10		
6690	huiqq	78		2014-12-10 11:53:10		
6691	rdfeo	78		2014-12-10 11:53:10		
6692	xhgls	78	should not be moved at the preparing stage! Thus count should starts from 1 rather than 0.	2014-12-10 11:53:10		
6693	qywrh	78	Here's a simpler code	2014-12-10 11:53:10		
6694	rrmeu	78		2014-12-10 11:53:10		
6695	fmzze	78		2014-12-10 11:53:10		
6696	nwkeg	78	This is O(N) and we are only scanning the linked list once.	2014-12-10 11:53:10		
6697	fowai	78	Just have two references/pointers. Ref1 and Ref2	2014-12-10 11:53:10		
6698	sqzqo	78		2014-12-10 11:53:10		
6699	eucmc	78		2014-12-10 11:53:10		
6700	plapd	78	Now move both pointers together. As soon as Ref2 will hit NULL, you will get Ref1 as desired.	2014-12-10 11:53:10		
6701	gilit	78		2014-12-10 11:53:11		
6702	krxlv	78		2014-12-10 11:53:11		
6703	fmzze	78	You are not doing range checking	2014-12-10 11:53:11		
6704	xhgls	78		2014-12-10 11:53:11		
6705	qywrh	78		2014-12-10 11:53:11		
6706	krxlv	78	Can be done in O(n) time. Travel the list in O(n) time. This will give you the length of the list - lets say 'n'. SUbtract k from the length and 1 in it. (n-k)+1 Once again travel from beginning and n-k+1 is the kth element from the tail.	2014-12-10 11:53:11		
6707	admin	78	I cant see anything wrong in this sol...	2014-12-10 11:53:11		
6708	xhgls	78	Requires two scans to the list there is a better way.	2014-12-10 11:53:11		
6709	sqzqo	78	I think your missing an important fact that could partition to n/2, just by adding a counter to the list you will know where to start if from head or tail...	2014-12-10 11:53:11		
6710	sgiwy	78	With Size given problem will be too simple to solve so i will try solving without the Size 1.Have two pointers both of them pointing to head at first assume P1 and P2 2.move p2 to k times in the list(assuming the question is kth to last )	2014-12-10 11:53:11		
6711	rdfeo	78		2014-12-10 11:53:11		
6712	rdfeo	78		2014-12-10 11:53:11		
6713	admin	78	4.now P2 will be k node in to the list and P1 still pointing to the head 5.now move P1 and p2 on the same speed iterating over the list	2014-12-10 11:53:11		
6714	dgjji	78		2014-12-10 11:53:11		
6715	admin	78		2014-12-10 11:53:11		
6716	fowai	78	If size is not a constraint, then for finding length traverse through the list and at the same time copy the data into a array. Now you can directly get the kth data in single shot. total time complexity is O(N) for getting length, and O(1) for getting kth element.	2014-12-10 11:53:11		
6717	sgiwy	78		2014-12-10 11:53:11		
6718	wbqzu	78		2014-12-10 11:53:11		
6719	mrjku	78	take a pointer say k = head 1. increment it k times, 2. now increment both head and k till k reaches last, the element head points to is the kth from last :)	2014-12-10 11:53:11		
6720	dgjji	78	An answer below this question uses two pointers which has the distance k. Move them simultaneously. When the first pointer catch the last one, the second pointer reach to kth element from the tail. There is a trick, this method have to move 2 * length in the whole. So there is an more efficient method.  Just as the answer mentioned above, we have: first pointer second pointer  second pointer points to the head, while first pointer points to kth element in the linked list  You can simply move first pointer k(sometimes less than k times, because maybe list has not enough elements to traverse) times every single loop, remember the times to T, after every k times movement, check whether first pointer reach the end. If not, let second pointer point to the position which first pointer points when this loop begins, and go on. If so, move second pointer T times and this is the kth element from the tail in the linked list.   Now i just use k to be the number of moves for first pointer every single loop. When k is much smaller than the linked list length, this method seems not more efficient than traditional one. So how to makes this method most efficient? With my glance, I think we could choose the number of moves every single loop dynamically. The best number is related to k and length of linked list.	2014-12-10 11:53:11		
6721	gilit	78		2014-12-10 11:53:11		
6722	dgjji	78		2014-12-10 11:53:11		
6723	jippy	78		2014-12-10 11:53:11		
6724	rdfeo	78		2014-12-10 11:53:11		
6725	gilit	78		2014-12-10 11:53:11		
6726	dkebi	78		2014-12-10 11:53:11		
6727	tenuw	78	This is O(N) and we are only scanning the linked list once.	2014-12-10 11:53:11		
6728	bjsiw	78	xx: temp=head; for(i=0;i<k;i++) { temp->temp->next; } if(temp->next==NULL) { return(head->no); } else { head=head->next; goto xx; }	2014-12-10 11:53:11		
6729	ethan	78	My solution in C#	2014-12-10 11:53:11		
6730	cfzie	78		2014-12-10 11:53:11		
6731	bexbp	78		2014-12-10 11:53:11		
6732	admin	78	--  Indra Bayu Vrije Universiteit Brussel	2014-12-10 11:53:11		
6733	cfzie	78		2014-12-10 11:53:11		
6734	vanul	78		2014-12-10 11:53:11		
6735	dkebi	78	In java --same as C++ program above. Please include the check for K > size of the list. 1.) move the fast pointer to kth position 2.) move the fast and slow pointers by one 3.) exit when fast reached the end 4.) print the value of the slow pointer	2014-12-10 11:53:11		
6736	nhibd	78		2014-12-10 11:53:11		
6737	tenuw	78		2014-12-10 11:53:11		
6738	tenuw	78	Either hold last k seen nodes (time compexity O(n), space O(k)), or traverse the list twice (O(n) / O(1))	2014-12-10 11:53:11		
6739	jippy	78	If you know the length of the given linked list, just subtract from the length and do one traversal to get it from the "front" of the list:	2014-12-10 11:53:11		
6740	plapd	78		2014-12-10 11:53:12		
6741	xhgls	78		2014-12-10 11:53:12		
6742	sgiwy	78	In Java	2014-12-10 11:53:12		
6743	fmzze	78		2014-12-10 11:53:12		
6744	nhibd	78		2014-12-10 11:53:12		
6745	sgiwy	78		2014-12-10 11:53:12		
6746	dgjji	78		2014-12-10 11:53:12		
6747	dkebi	78	convert the linked list into a min-heap and return the kth element	2014-12-10 11:53:12		
6748	jippy	78	#include<iostream> using namespace std; struct node{ int data; node *next; };  int my_func(node *new_list,int m) { node *bptr;int count=0,count1=0,count2=0; bptr=new_list;  while((bptr->next)!=NULL) { bptr=bptr->next; count1++;  } count2=count1-m+1; bptr=new_list; while((count2>0)) { bptr=bptr->next; count2--; }  int h=bptr->data; return h;   } int main() { node *list,*nptr,*tptr; int item,n,i; list=NULL;  cout<<"PLEASE.......Type how many nodes that you want "; cin>>n; for(i=1;i<=n;i++) { cout<<"Type your "<<i<<" node item "; cin>>item; nptr=new(node); nptr->data=item; nptr->next=NULL; if(list==NULL) { list=nptr; tptr=nptr; } else { tptr->next=nptr; tptr=nptr; } } tptr=list; for(i=1;i<=n;i++) { cout<<endl; cout<<tptr->data<<" "; tptr=tptr->next;  } cout<<endl; cout<<"Enter your node number from the tail in a linked list "; cin>>item;  int data_new=my_func(list,item);  cout<<" \n\n"<<item<<" element from the tail in a linked list= "<<data_new<<endl<<endl; return 0;    }	2014-12-10 11:53:12		
6749	krxlv	78	void printKthElementReverse(int nPos) { if(pHead == NULL) { std::cout<<"No Element Found at "<<nPos<<" position"; return; } int count = 0; stList* pCurr = pHead; stList* pKthElem = pHead; stList* pPrev = NULL; while(count < nPos) { pPrev = pKthElem; if(NULL == pKthElem) break; pKthElem = pKthElem->pNList; count++; }  if(pPrev == NULL || count < nPos) { std::cout<<"No Element Found at "<<nPos<<" position"; return; }  stList* pCurPrev = NULL; while(pPrev != NULL) { pCurPrev = pCurr; pPrev = pPrev->pNList; pCurr = pCurr->pNList; }  std::cout<<nPos<<" Element from Reverse is "<<pCurPrev->data; }	2014-12-10 11:53:12		
6750	tenuw	79	The question clearly states ' return an array of all possible mutations'. This means that both time AND space must be linear in the size of the output. The point is, what is the size of the output in terms of the input.  Lets just look at the worst-case complexity, since average case is hard to even define, let alone analyse. Say the input string is of size n. The worst case is that every character has a mapping. Lets also say that all mappings have arrays of the same size, m (that is, all arrays are the longest possible arrays for that mapping). Then the number of outputs we have is n^m, which is huge.  In simple terms I can't see any way to optimise this. However, you could return a data structure like this (for the given example):  [ [f, F, 4], [a], [b, B, 8] ]  ie an array of arrays, where every subarray is the corresponding character, together with its mapped mutations if there are any. You could then create an iterator that uses that data structure to produce the next mutated output string from each call to next().	2014-12-10 11:53:13		
6751	vanul	79	"Return an array" is most likely what the interviewee interpreted and not the actual question.	2014-12-10 11:53:13		
6752	eucmc	79	" Say the input string is of size n. The worst case is that every character has a mapping. Lets also say that all mappings have arrays of the same size, m (that is, all arrays are the longest possible arrays for that mapping). Then the number of outputs we have is n^m, which is huge. "  that's not true, you have to raplace at max 26 symbols(or 52, or how many different characters could be in input string) so complexity is 26 ^ m(where m is an average length of maping)	2014-12-10 11:53:13		
6753	ftfck	79	sorry m ^ 26	2014-12-10 11:53:13		
6754	eucmc	79	Treat is like an odometer: [3,1,3]. Start with [0,0,0] -> [1,0,0] -> [2,0,0] ->[0, 0, 1] -> [1,0,1] etc. (read from right to left instead left to right).  This little space (as compared to creating lists and appending).  Here is some python code:	2014-12-10 11:53:13		
6755	xhgls	79		2014-12-10 11:53:13		
6756	dkebi	79		2014-12-10 11:53:13		
6757	azmjc	79	output is	2014-12-10 11:53:13		
6758	dkebi	79		2014-12-10 11:53:13		
6759	jippy	79		2014-12-10 11:53:13		
6760	sgiwy	79	could you please explain, what is the time and space compexity of this solution??	2014-12-10 11:53:13		
6761	azmjc	79	@goutham: Space complexity is O(S) where S is the length of string. (In case of 'fab', S is 3).  Time complexity is linear in the output size (which is optimal).	2014-12-10 11:53:13		
6762	rdfeo	79	Note that using yield gives you a lazy iteration. You can actually print just the first 5 if you want.  In that case, space complexity is O(S) and time complexity in again linear in size of output (for print just the first 5).	2014-12-10 11:53:13		
6763	bjsiw	79	@goutham Time complexity is always expressed in terms of input size. If we express a problem like this in terms of output it's always linear and doesn't tell us much.  This is a string/sequence problem. So in this problem, ignoring letters that aren't in the hash map (since they don't change), there are n^m combinations of possible words, where n is the number of variable positions and m is the number of possible values for each. In other words the complexity is O(n^m), which is the expected complexity of generating all sequences of length m from n items. In this case it's 2^3 = 8 words.  However if the number of possible values is different for each position (e.g if "f" had m1 substitutes and "b" had m2), I think the complexity is O(n^(max(m1,m2))) but I'm not 100% certain.	2014-12-10 11:53:13		
6764	fowai	79	@barry, its 3*1*3 = 3^2 =9 not 2^3 = 8  and in other case it'll be O(m1*1*m2) complexity, no n there  given below working php code for this	2014-12-10 11:53:13		
6765	vanul	79		2014-12-10 11:53:13		
6766	mrjku	79		2014-12-10 11:53:13		
6767	fowai	79		2014-12-10 11:53:13		
6768	gilit	79		2014-12-10 11:53:13		
6769	zeice	79		2014-12-10 11:53:13		
6770	fowai	79		2014-12-10 11:53:13		
6771	vanul	79	Space complexity is size of output, which can be pretty huge.	2014-12-10 11:53:13		
6772	zeice	79	This 'solution' is wrong.	2014-12-10 11:53:13		
6773	admin	79		2014-12-10 11:53:13		
6774	tenuw	79		2014-12-10 11:53:13		
6775	qywrh	79	Space.....	2014-12-10 11:53:14		
6776	gilit	79	This is my solution, I think space complexity should be O(n), Since I use backtrack, time complexity is not very well.  My output sequence is different:fab faB fa8 Fab FaB Fa8 4ab 4aB 4a8  import java.util.ArrayList; import java.util.HashMap;  //Given a hashmap M which is a mapping of characters to arrays of substitute characters, //and an input string S, return an array of all possible mutations of S //(where any character in S can be substituted with one of its substitutes in M, if it exists).  public class Permute {  public static ArrayList<String> getMutation(String str, HashMap<Character, char[]> map){ ArrayList<String> result = new ArrayList<String>(); int lens = str.length(); if(lens == 0){ return result; } if(map.isEmpty()){ result.add(str); return result; } char[] mutation = new char[lens]; getMutation(str, map, result, mutation, 0); return result; }  public static void getMutation(String str, HashMap<Character, char[]> map, ArrayList<String> result, char[] mutation, int index){ if(index == str.length()){ String newItem = new String(mutation); result.add(newItem); return; }  char current = str.charAt(index); if(map.containsKey(current)){ char[] choice = map.get(current); for(int i = 0; i <= choice.length;i++){ if(i == 0){ mutation[index] = current; getMutation(str, map,result, mutation, index+1); } else{ mutation[index] = choice[i-1]; getMutation(str, map, result, mutation, index+1); } } } else{ mutation[index] = current; getMutation(str, map, result, mutation, index+1); } } public static void main(String[] args) { // TODO Auto-generated method stub String in = "fab"; char[] valueOne = new char[2]; char[] valueTwo = new char[2]; HashMap<Character, char[]> map = new HashMap<Character, char[]>(); valueOne[0] = 'F'; valueOne[1] = '4'; valueTwo[0] = 'B'; valueTwo[1] = '8'; map.put('f', valueOne); map.put('b', valueTwo); ArrayList<String> result = new ArrayList<String>(); result = getMutation(in, map); for(String str:result){ System.out.println(str); } } }	2014-12-10 11:53:14		
6777	rdfeo	79		2014-12-10 11:53:14		
6778	wbqzu	79		2014-12-10 11:53:14		
6779	zeice	79	The code above is JavaScript, run it in node.js	2014-12-10 11:53:14		
6780	zeice	79	Does anybody know the time complexity of this problem if "f" and "b" had a different number of substitutes?	2014-12-10 11:53:14		
6781	ftfck	79	My solution in Java. The time complexity is O(n^m) where n is the number of variable positions (in this case 2, f and b) and m is the number of possible values (in this case 3 for each, the letter + its substitutes).  The complexity is exponential but I don't believe we can improve on it since we are required to generate n^m output strings.	2014-12-10 11:53:14		
6782	sgiwy	79		2014-12-10 11:53:14		
6783	azmjc	79		2014-12-10 11:53:14		
6784	fowai	79	my two cents in python; i think time complexity would depend on both the size of the hashtable and the size of the input. space complexity is the same?	2014-12-10 11:53:14		
6785	mrjku	79		2014-12-10 11:53:14		
6786	gilit	79		2014-12-10 11:53:14		
6787	cfzie	79		2014-12-10 11:53:14		
6788	nwkeg	79		2014-12-10 11:53:14		
6789	dkebi	79	O(ans.count) time and O(ans.size) space complexity:	2014-12-10 11:53:14		
6790	mrjku	79		2014-12-10 11:53:14		
6791	ufdxg	79		2014-12-10 11:53:14		
6792	gilit	79	There is also a tricky solution with very good time and space complexities. We do not have any restrictions about output format of resultant word set, so it will be absolutely legal to output them as a trie. The main idea of algorithm is following: Given a source string and map of substitutions, let's construct a trie with a single word - source string:	2014-12-10 11:53:14		
6793	gilit	79		2014-12-10 11:53:14		
6794	huiqq	79		2014-12-10 11:53:14		
6795	fmzze	79	Now, lets iterate over trie nodes. If we see a node with a character that presents in a map, let's transform this node to a cuple of nodes with all possible substitutions for that character, i.e.	2014-12-10 11:53:14		
6796	nhibd	79		2014-12-10 11:53:14		
6797	nhibd	79		2014-12-10 11:53:14		
6798	cfzie	79	Applying this procedure to all nodes, we will get a trie with all possible substitutions, like	2014-12-10 11:53:14		
6799	fmzze	79		2014-12-10 11:53:14		
6800	azmjc	79		2014-12-10 11:53:14		
6801	qywrh	79	So that, in worst case, time and space complexity is O(n*k), where n is length of the string and k is length of longest array in the map of substitutions.	2014-12-10 11:53:14		
6802	fowai	79	This code will be ok.	2014-12-10 11:53:14		
6803	wbqzu	79		2014-12-10 11:53:14		
6804	zeice	79		2014-12-10 11:53:14		
6805	rrmeu	79		2014-12-10 11:53:14		
6806	bexbp	79		2014-12-10 11:53:14		
6807	ufdxg	79	Time is O(N) where N is input="fab", but how many operations we have to execute? In the worst case it is O(N*M), where M=max_length{{ 'F', '4' }, { 'B', '8' }, ...} so it is better to say that time is O(N*M).	2014-12-10 11:53:14		
6808	tenuw	79		2014-12-10 11:53:14		
6809	rdfeo	79		2014-12-10 11:53:14		
6810	bexbp	79	This is a variation of telephone words:	2014-12-10 11:53:15		
6811	xhgls	79		2014-12-10 11:53:15		
6812	tenuw	79		2014-12-10 11:53:15		
6813	bjsiw	80	Why not do a level order traversal?	2014-12-10 11:53:15		
6814	tenuw	80		2014-12-10 11:53:15		
6815	eucmc	80		2014-12-10 11:53:16		
6816	tenuw	80		2014-12-10 11:53:16		
6817	azmjc	80		2014-12-10 11:53:16		
6818	gilit	80	The above code returns extreme nodes at each level. But the program is expected to return alternate extreme nodes in each level. Below is the code with corrections.	2014-12-10 11:53:16		
6819	ftfck	80		2014-12-10 11:53:16		
6820	fowai	80		2014-12-10 11:53:16		
6821	admin	80	Same Idea, but more simple code - I guess -	2014-12-10 11:53:16		
6822	qywrh	80		2014-12-10 11:53:16		
6823	gilit	80		2014-12-10 11:53:16		
6824	huiqq	80	We can send an argument to indicate whether leftmost has to printed or the rightmost has to be printed. Nodes data will be printed if its lefts turn and the node is left most or if its not lefts turn and the node is right most node.  Also we need to handle a case where a node is leftMost node at that level but it doesnot have a left child, so the right child will become the leftmost, similarly for the rightMost case.	2014-12-10 11:53:16		
6825	sgiwy	80		2014-12-10 11:53:16		
6826	admin	80		2014-12-10 11:53:16		
6827	dgjji	80	Here in the main function the right side recursive function should be called first as root is considered to be left	2014-12-10 11:53:16		
6828	mrjku	80	How can there be a recursive solution in this case ? i do not understand the solution.	2014-12-10 11:53:16		
6829	azmjc	80	it is same as printing the first nodes in zig zag order .....	2014-12-10 11:53:16		
6830	eucmc	80	This can be easily solved using Zig-Zag level order traversal of the given tree.Use 2 stacks to do the zig zig level order traversal.  For More detail explanation just google "leetcode : printing-binary-tree-in-zig-zag-level". Below is a small working code for the same. TreeNode represents our Tree.	2014-12-10 11:53:16		
6831	gilit	80		2014-12-10 11:53:16		
6832	gilit	80		2014-12-10 11:53:16		
6833	rdfeo	80	Shall we consider the root as one of the extremes ...if yes then left extreme or right extreme?	2014-12-10 11:53:16		
6834	admin	80	As given in the example test case itself, consider root as the extreme left.	2014-12-10 11:53:16		
6835	xhgls	80		2014-12-10 11:53:16		
6836	nhibd	80		2014-12-10 11:53:16		
6837	nwkeg	80	i dont think this will work....	2014-12-10 11:53:16		
6838	dkebi	80	Hi..Here is my solution..but before using this function print the root node and then call its left child and right child in the main function	2014-12-10 11:53:16		
6839	dkebi	80		2014-12-10 11:53:16		
6840	ftfck	80		2014-12-10 11:53:16		
6841	rdfeo	80	}	2014-12-10 11:53:16		
6842	gilit	80	Sorry the above one had a bug..i think this would work but again print the root node in the main function itself...i have used BST to show the working	2014-12-10 11:53:17		
6843	tenuw	80		2014-12-10 11:53:17		
6844	eucmc	80		2014-12-10 11:53:17		
6845	rrmeu	80		2014-12-10 11:53:17		
6846	ufdxg	80		2014-12-10 11:53:17		
6847	dgjji	80	-Have an array to hold tree node pointers -copy root pointer at mid point of into array -------------10------------------------- -now replace existing tree node with its left and right if exists --------------5-11--------------------- -again replace existing tree node with its left and right if exists --------------9-20-15------------------- --------------14-25---------------------- -----------------30------------------------ -at each steps we can print tree node info value alternately	2014-12-10 11:53:17		
6848	cfzie	80	can we do it in O(n) complexity and without using extra memory?	2014-12-10 11:53:17		
6849	bjsiw	80		2014-12-10 11:53:17		
6850	wbqzu	80		2014-12-10 11:53:17		
6851	rdfeo	80	forget to reset levelPrinted = false inside if(temp.Value == null)	2014-12-10 11:53:17		
6852	vanul	80	Took me awhile to figure out that it was a Binary Tree and not a Binary Search Tree... irregardless, the solution works for both.	2014-12-10 11:53:17		
6853	huiqq	80		2014-12-10 11:53:17		
6854	krxlv	80		2014-12-10 11:53:17		
6855	admin	80	I think it is better to think about it as BFS. I got the level in each iteration in a queue. I use alternating "left" variable to view the first element in the leve; queue one time(left most), and last element the other time ( right most)	2014-12-10 11:53:17		
6856	ftfck	80		2014-12-10 11:53:17		
6857	rdfeo	80		2014-12-10 11:53:17		
6858	ftfck	80	TESTING	2014-12-10 11:53:17		
6859	xhgls	80		2014-12-10 11:53:17		
6860	azmjc	80		2014-12-10 11:53:17		
6861	xhgls	80		2014-12-10 11:53:17		
6862	ewigy	80		2014-12-10 11:53:17		
6863	xhgls	80	void ZigZacTraversal(struct btree *root) { struct btree *Stack1[20],*Stack2[20],*temp; int top1=-1,top2=-1,LeftToRight=1; int flag1=0,flag=0;  Stack1[++top1]=root;  while(top1>=0 || top2>=0) { if(LeftToRight) { while(top1>=0) { temp=Stack1[top1--]; if(flag==0){printf("%d ",temp->data); flag=1;}  if(temp->right) Stack2[++top2]=temp->right; if(temp->left) Stack2[++top2]=temp->left;    } printf("|"); flag=0; } else { while(top2>=0) { temp=Stack2[top2--]; if(flag1==0){printf("%d ",temp->data); flag1=1;}  if(temp->left) Stack1[++top1]=temp->left;  if(temp->right) Stack1[++top1]=temp->right; } printf("|"); flag1=0; } LeftToRight=1-LeftToRight; } }	2014-12-10 11:53:17		
6864	gilit	80		2014-12-10 11:53:17		
6865	jippy	80		2014-12-10 11:53:17		
6866	cfzie	80		2014-12-10 11:53:17		
6867	ethan	80		2014-12-10 11:53:17		
6868	huiqq	80		2014-12-10 11:53:17		
6869	jippy	80		2014-12-10 11:53:17		
6870	admin	80	Recursive and iterative versions written in Groovy. Both are O(n), but iterative is more efficient because there is less overhead.	2014-12-10 11:53:17		
6871	sqzqo	80		2014-12-10 11:53:17		
6872	ethan	80		2014-12-10 11:53:17		
6873	ewigy	80	void display_opposite_corner(BSTNode* root) { if(!root) return; cout<<root->key<<endl; int iCount=0; BSTNode* tempRight=root; BSTNode* tempLeft=root; while(iCount>=0 && tempRight->right && tempLeft->left) { tempLeft=tempLeft->left; tempRight=tempRight->right; if(iCount%2!=0) { cout<<tempLeft->key<<endl; } else { cout<<tempRight->key<<endl; } iCount++; } while(tempRight->right) { tempRight= tempRight->right; cout<<tempRight->key<<endl;  } while(tempLeft->left) { tempLeft=tempLeft->left; cout<<tempLeft->key<<endl;  }   }	2014-12-10 11:53:17		
6874	tenuw	81	Use 3 HashMaps: (1) First one keeps track of the length of the longest prefix consisting of a given character (2) Second one keeps track of the length of the longest suffix consisting of a given character (3) Third one keeps track of the TOTAL length of strings that consist entirely of a given character  So for {aa, aac, ba, aaa}: (1) First one has {a:2, b:1} (2) Second one has {c:1, a:1} (3) Third one has {a:5}  The algorithm consists of 2 steps: (1) Process each string and update the 3 HashMaps above. Also process the characters in the "middle", after dealing with the prefix & suffix. The characters in the middle matter too because it might actually contain the longest string consisting of the same character. (2) At the end, for each possible character, sum the counts returned by the 3 HashMaps and see which one is longest.  Code below. I tried cleaning it up already, but still kinda messy and not something I could have written on a whiteboard.	2014-12-10 11:53:19		
6875	ufdxg	81		2014-12-10 11:53:19		
6876	wbqzu	81		2014-12-10 11:53:19		
6877	rdfeo	81	@Sunny  Good one, +1 for you. Though I see you need to take care not to add the same string to both hashtable1 and hashtable2. For ex: a string of the form aaaaaaaaabaaaaaaaaa might have 'a' as the longest prefix as well as the longest suffix, but they cannot be permuted to form the longest contiguous sequence.	2014-12-10 11:53:19		
6878	vanul	81	will your algorithm return 5 or 3 for these?? ab,bba,bbccccca..ans should be 5	2014-12-10 11:53:19		
6879	eucmc	81	Dumbo - that's a good catch. I lost sight of cases like these after I cleaned up my code. And for this problem I really have a hard time cleaning up the code. Even this version isn't that clean. Would love to see a cleaner solution. Perhaps I will try again myself.  Amit - my algorithm should return 5 as it also processes the strings in the "middle". Unless there's a bug of course.	2014-12-10 11:53:19		
6880	sqzqo	81	I din't see your code, but in algo, you nowhere mentioned about traversing all strings. I thought You are only looking fr prefix and sufffix in the strings which contains multiple letters... If it processes character in the middle, it will be ok :)	2014-12-10 11:53:19		
6881	eucmc	81	How will you make sure that prefix and sufix are not from same string. wbu {aaabaaa, abb, ba }.. It seems that prefix and suffix will be from same string.	2014-12-10 11:53:19		
6882	jippy	81	I want to maintain two DS for each input string 1. HashMap with key (character) and value (it' occurance) 2. Sorted Array based on values Now compare previous input and current input 1. Get maximum possible longest sequence 2. The trick is if an input string is contains single character	2014-12-10 11:53:19		
6883	azmjc	81	Can you explain why the answer is what is shown? I don't understand the question.	2014-12-10 11:53:19		
6884	nwkeg	81	input = {aa, aac, ba} output = a,5 output in this case can be constructed by joining the three strings as baaaaac	2014-12-10 11:53:19		
6885	eucmc	81	If you join the strings of the array in any order you have to find the letter which is repeating continuously maximum number of time. Here maximum is a -3 abbaac	2014-12-10 11:53:19		
6886	ftfck	81	the given set of strings is [ ab, ba, aac ]  if you consider the permutation ba-aac, this has the longest running character sequence "a-aa", so the answer is 3	2014-12-10 11:53:19		
6887	qywrh	81	So you can permute the order of concatenation of the strings however you want, but the letters within each string cannot be permuted. The goal is to find the concatenation of the strings that maximizes the longest single-character run. That's the understanding I'm getting.	2014-12-10 11:53:19		
6888	fowai	81	For each aplphabet find max ending string,max starting string,only this aphabet strings. condition1 :maxending,max starting should not be only this alphabet strings condition2:if maxending,maxstarting is same string(find two more 2nd maxending,2nd max starting). Combine maxendingstring+all only alphabet strings+max starting string(Take care of not using any string more than once). For condition2; try Max(maxending+all anly this alpabet strings+2ndmax starting , 2nd max ending+all only this alphabets+max starting).  Find the longest among these strings.  Ex: aa,aac,ba For a:max ending is ba,only a is {aa},max starting is aac->ba+aa+aac=5 For b:max ending is '',only b is{},max b starting is ba ->''++""+ba = 1 similar for all aphabets  Answer is baaaaac.  Complexity o(m*n) where m is avg length of strings.	2014-12-10 11:53:19		
6889	tenuw	81	For each character, that is either the first char or the last char of any string, compute these two details: 1. Length of longest sequence beginning with this char 2. Length of longest sequence ending with this char If a string has same char as prefix and suffix only count the one which is longer.  Now for each character from above set, Compute the length by summing (1) + (2) above.  Pick the character with max sum, as answer.  INPUT: ab; ba; aac Algo: a - begString: aac, length=2 a - endString: ba, length=1; b - begString: ba, length =1; b - endString; ab, length=1; c - endString: aac, length=1;  for a, sum=2+1=3 for b, 1+1=2; for c, 1+INF=INF  Output: a [max length=3]  Complexity: O(n). Simply read each character of each string from beginning & ending till it matches with adjacent character and find the above lengths.  Edit: To address the case where max length seq is in the middle of a string, for each char - also keep track of longest length "inside" a string globally(across all strings). This can be easily done by using a map or such data structure.  Solution by Sunny above seems to be more complete & elaborative.	2014-12-10 11:53:19		
6890	azmjc	81	What about ab; ba; aac; aaaa; aaaa; azzzzzzzzzzzzzzzzzzzza (1) In this case, would the algorithm be able to consider using both "aaaa" to form the longest sequence? (2) And would the algorithm be able to detect that "zzzzzzzzzzzzzzzzzzzz" is actually the longest?	2014-12-10 11:53:20		
6891	dkebi	81	this doesnt address the case where some strings have all characters the same .. for example, if the given set of strings is [ab, bb, bbb, bbbb, ba]	2014-12-10 11:53:20		
6892	ewigy	81	I tried making a stack to test a single word. I inserted a new character in stack if the either the stack is empty or the old character is the same as this one. And emotied the stack if new character is different and checked if old character strring is greater than max string of repetitive characters.	2014-12-10 11:53:20		
6893	wbqzu	81		2014-12-10 11:53:20		
6894	dkebi	81		2014-12-10 11:53:20		
6895	fowai	81	Howerver every time the output is max character:';' and sequence length is 0. Please tell me what is wrong with the above...	2014-12-10 11:53:20		
6896	nhibd	81	A brute force yet simple solution, doing permutations and finding the longest sequences of chars, is provided on sites.google.com/site/spaceofjameschen/home/string/find-the-longest-running-sequence-of-a-character-among-all-possible-permutations-of-the-strings-in-the-array	2014-12-10 11:53:20		
6897	fowai	81	Maintain a map with <key, value> as <char, repetitions>.  While iterating over each word, populate a list of prefixes and another list of suffixes. Also, populate the repetitions map.  Again, iterate over both the lists and add the char and it's repetitions in the map, if the existing repetitions for that character does not exist in the map or if the repetitions are less than summation of suffix length+prefix length. While doing this make sure to avoid using the same word for calculating summation.	2014-12-10 11:53:20		
6898	bexbp	81		2014-12-10 11:53:20		
6899	ewigy	81		2014-12-10 11:53:20		
6900	bexbp	81	Append the input strings, then do the following on the resulting string:	2014-12-10 11:53:20		
6901	ftfck	81		2014-12-10 11:53:20		
6902	wbqzu	81		2014-12-10 11:53:20		
6903	azmjc	81	I forgot to include the "cnt=1" in the "else" part of the above code. My mistake!	2014-12-10 11:53:20		
6904	ewigy	81	I would do it in a simple yet very efficient manner:	2014-12-10 11:53:20		
6905	ufdxg	81		2014-12-10 11:53:20		
6906	admin	81		2014-12-10 11:53:20		
6907	wbqzu	81	Below is the complete working code for the above algorithm:	2014-12-10 11:53:20		
6908	vanul	81		2014-12-10 11:53:20		
6909	fowai	81		2014-12-10 11:53:20		
6910	nhibd	81	}	2014-12-10 11:53:20		
6911	ftfck	81	lol efficient	2014-12-10 11:53:20		
6912	fmzze	82	Weighted interval Scheduling Problem with each weght = length of the interval.	2014-12-10 11:53:21		
6913	wbqzu	82	Here is a DP approach. Arrange the tasks in some order (any order) Let M(i) denote the maximum work done using the first i tasks. We need to find the value of M(n). To do this let's say we need to calculate M(i+1) from M(i) If inserting (i + 1)th task in the previous max sequence increases the Max work spent, then change the sequence and include this (i+1)th task in the already existing sequence. If inserting (i + 1)th task in the previous max sequence is equal to the M(i) then keep both sequences. Therefore M(i) will not be a single sequence but there might be a list of tasks all with same max work value	2014-12-10 11:53:21		
6914	rdfeo	82	@Nomad  Nice approach, would you care to elaborate it a bit?	2014-12-10 11:53:21		
6915	nwkeg	82	This solution need sorted the items by the finish time.	2014-12-10 11:53:21		
6916	fowai	82	The above solution is a special case of Weighted interval Scheduling Problem with weight of each job as its interval as mentioned by @pranayhasan	2014-12-10 11:53:21		
6917	cfzie	82	This is exact replica of 'Avid TV watcher' problem. A very detailed code with explanation is present here:  bit.ly/1dztZFM	2014-12-10 11:53:21		
6918	azmjc	82	This is really a great solution.	2014-12-10 11:53:21		
6919	nwkeg	82	This, in its most general form, seems like a CSP, or SAT problem. I would go for the standard branch and prune/bound.  Each work Wi has a payoff of Ti. If two works overlap then they cannot be chosen together One way to formulate: Maximize T1 W1 + T2 W2 + .... + T5 W5 Subject to: not(W1 & W2) = true not(W2 & W3) = true not(W2 & W4) = true not(W2 & W5) = true not(W3 & W5) = true  This is a rough sloppy implementation without bounding.	2014-12-10 11:53:21		
6920	nwkeg	82		2014-12-10 11:53:21		
6921	dgjji	82		2014-12-10 11:53:21		
6922	zeice	82	You can add a bounding method to make the algorithm faster. This is usually obtained by relaxing the binary variables and solving the LP to obtain the upperbound. If the upper bound on payoff is less than best solution so far, our assumption for wk is wrong or there is no solution.	2014-12-10 11:53:21		
6923	sqzqo	82	Naive solutions: -------------------- a) Sort on the basis of starting time. If two Work have same start time, list the one with smaller end time first. b) In the sorted result, list all non conflicting schedules. c) For all non-conflicting schedules, find the total minutes/hours obtained. Choose the maximum of them.  For example 2: Sort (Start time) := W1 W4 W2 W6 W5 W3  List of non conflicting schedules: W1 W1 W2 W3 W1 W6 W3 W1 W3 (valid, but this can be avoided since other schedule having a work between W1 and W3 would yield higher output). W1 W5 W4 W2 W3 W4 W6 W3 W4 W5 and so on.  THe maximum of these is W1 W6 W3 with 6.5 hours.  Can someone suggest an optimization over this?	2014-12-10 11:53:21		
6924	sqzqo	82	1. Sort the work items by their start times. 2. Proceed the solution through backtracking. 3. At each stage, possible candidates are next item just after the last item, and all other work items overlapping with first item. 4. When all items are processed, compare them with max solution. If it is greater than Max, store this value in Max.	2014-12-10 11:53:21		
6925	bexbp	82		2014-12-10 11:53:21		
6926	nhibd	82		2014-12-10 11:53:21		
6927	plapd	82	Can you plz explain your implementation....	2014-12-10 11:53:21		
6928	ewigy	82	You could treat this problem like a directed graph, giving each edge weight a value equal to the minutes of work it takes to complete. While constructing the graph, if an end time is greater than a start time then that edge cannot exist.  Next identify the vertices that have no incoming paths. These will be the possible start nodes of any possible greatest path.  Then you can do a breadth first search through the graph starting at each possible START node and maintaining a longest path (biggest time) that is compared at the end of each BFS iteration. At the end, you simply reproduce the longest path and it's value.	2014-12-10 11:53:22		
6929	qywrh	82	I am curious about the question statement "maximum work minutes"... If it's finding maximum work minutes we can just simply do a Greedy Algorithm sorting by end time...  Algorithm: 1. Sort by end time of each work. 2. Start by getting the latest time, check this work's starting time 3. proceed to add the next work whose end time < then this work's starting time. 4. repeat  Since it's maximum number of MINUTES worked NOT maximum works done, we would have a possible solution that picks only one long work...But it seems to be right. Any suggestions?	2014-12-10 11:53:22		
6930	eucmc	82	Greedy won't work. You need to do it using DP. This is exact replica of 'Avid TV watcher' problem. A very detailed code with explanation is present here:  bit.ly/1dztZFM	2014-12-10 11:53:22		
6931	ethan	82	Looks very simple..  1. Sort the values. Lets we have sorted array Times[] 2. Take one more array to save SelectedTime[] 3. SelectedTime[0] = Times[0] 4. Loop on Times Start with 1 a. IF SelectedTime[SelectedTime.Count-1] overlap Times[i] AND Times[i];s total minutes > SelectedTime[SelectedTime.Count-1] b. THEN SelectedTime[SelectedTime.Count-1]= Times[i]; c. IF Not Overlap THEN SelectedTime[SelectedTime.Count]= Times[i]; here we are adding one more time.	2014-12-10 11:53:22		
6932	huiqq	82	Can it be modeled as 0/1 knapsack problem, where knapsack size is the end time and length of task as value?	2014-12-10 11:53:22		
6933	xhgls	82	Hi,  For me it sounds like a greedy approach:  Firstly sort all the works according to it's start time in an increasing order, then according to the finish time in an decreasing one. So what you do now: take the first event that appears, let's name the start time S(i) and finish time E(i). Now take the first event that S(i+1) > E(i). If there are several events starting at the same time take the one that E(i+1) has the largest value (because we are trying to find the longest time). Proceed till the end.	2014-12-10 11:53:22		
6934	rrmeu	82	Incorrect solution. Consider this:	2014-12-10 11:53:22		
6935	sqzqo	82		2014-12-10 11:53:22		
6936	huiqq	82		2014-12-10 11:53:22		
6937	krxlv	82	Yeah, you are right:) My bad:(	2014-12-10 11:53:22		
6938	plapd	82	is it not standard activity selection problem and will be solved by greedy?	2014-12-10 11:53:22		
6939	qywrh	82	@Hector, you are right. This can be done in O(n) using greedy approach. Although, DP solution is also available, it is O(n^2). However, we should sort the entries based on their finishing times and look for the compatible tasks that satisfy Start[m]>=Finish[i] and the m task to our list of accepted tasks.	2014-12-10 11:53:22		
6940	gilit	83	Build a balanced tree of the x-coordinates of the points(appearing only at leaf nodes) which will allow you to perform queries like getting the points in a given range [l, r].  Annotate each node of the tree with a balanced tree of the y-coordinates (called Y-trees) of the points in the leaf nodes of the subtree. Thus each range query [l,r] can be represented as a set of O(log n) Y-trees.  Building this structure takes O(n (log n)^2) time and O(n log n) space.  Now given a rectangle, you can query the S points that lie in the rectangle, in O( (log n)^2 + S) time. First run the range query of [l,r], the width of the rectangle to get O(log n) Y-Trees. Then run the range query of [bottom,top] (the height of the rectange) on each Y-Tree we got. This is O( (log n)^2 + S) total.  Since we do this for each rectangle, the total query time is O(n (log n)^2) (could potentially be faster is lot of points lie within a single rectangle...).  That said, this is too much for an interview, to come up with and write pseudo-code. Perhaps there is an easier method.  (btw, if I recollect correctly, this is the idea behind a orthogonal-range search tree).	2014-12-10 11:53:23		
6941	ufdxg	83	You seem to have good approach. I want to know how will you "annotate each node of the tree with a tree of the y-coordinates"?	2014-12-10 11:53:23		
6942	gilit	83	Does the following solve the problem in O(n log n)?  Sort the rectangles by the x-coordinate of the lower-left corner and remove those with this corner to the right of the point.  Sort the (remaining) rectangles by the x-coordinate of the upper-right corner and remove those with this corner to the left of the point.  Sort the (remaining) rectangles by the y-coordinate of the lower-left corner and remove those with this corner above the point.  Finally, sort the remaining rectangles by the y-coordinate of the upper-right corner and remove those with this corner below the point.  If there is nothing left, then no rectangle contains the point. Otherwise, the one left is as desired.	2014-12-10 11:53:23		
6943	fowai	83	I also suspect we can do it in nlgn. like secondary sort sort the R set on the basis of x1,x2,y1,y2 (x1<x2&&y1<y2)which are the edges of rectangle. to find each point in it, binary search on basis of x, y basically, if x>x2, right=mid-1; else if x<x1 left= mid +1; else { if y<y1, left=mid+1; else if x>y2 right=mid-1; else return it!}	2014-12-10 11:53:23		
6944	qywrh	83	It will be O( n * n * (log n) ) time for 'n' points in P.	2014-12-10 11:53:23		
6945	vanul	83	A simple brute force method would do the job in O(n*n) time.	2014-12-10 11:53:23		
6946	xhgls	83	It is not D&C algorithm	2014-12-10 11:53:23		
6947	krxlv	83	I think, this problem can be solved by KD Tree because all the rectangles are non-overlapping. We can split the set of rectangles in half by x and y axis alternatively and construct the tree.  The lookup algorithm would also be same as KDTree. This way you can construct the tree in O(nlogn) and lookup in O(logn).	2014-12-10 11:53:23		
6948	rrmeu	83	PLEASE? A KD-tree? They will be more than happy to see you implement one in pseudocode... BTW a KD-Tree has O(n) worst-case complexity.  What they were probably looking for is this. Sort all rectangles and points by their x and y coordinates into sorted sets Rx, Ry, Px and Py.  Then in each recursion level swap a bit which says whether to subdivide in X or Y direction. (This is just to make complexity analysis a whole heck of a lot easier)  You always use the middle element in the current subdivision of Rx, Ry, Px, Py as splitter to obtain the sets for the next subdivision.  The recursion terminates after log(n) steps when there is either none or one rectangle left. Then you check whether all points in the subdivided Px or Py are in there and add them to a result set.  The algorithm is at most O(n*log(n)^2) worst case... I have the proof on paper but it would be too tedious to carry it out here. Shouldn't be too hard ;).	2014-12-10 11:53:23		
6949	ftfck	83	Can you please upload this code/explain your approach more clearly	2014-12-10 11:53:23		
6950	wbqzu	83	still dont get it!, the solution i have is O(n2logn);	2014-12-10 11:53:23		
6951	admin	83	O(nlogn) solution here.  for every rectangle take their start x and end x, create object {x=>11, rectangle_uid = a, which=>start/end} and sort them by x. // O(nlogn) go though sorted array from origin till encountering vertex's x < our point's x , every start point encountered store in in hash, every end point encountered unset in hash. //O(n) for all start point left in hash, see if their reference rectangle satisfy y constraints. //O(n), average case will be lot more faster for this step.  time complexity O(nlogn), space O(n)  please give feedback on my solution	2014-12-10 11:53:23		
6952	mrjku	83	oh thats again O(n2logn) cosidering for every p	2014-12-10 11:53:23		
6953	bexbp	83	max O(n2) , cant be done in less than that	2014-12-10 11:53:23		
6954	rrmeu	83	found a mistake in the algo	2014-12-10 11:53:23		
6955	eucmc	83	how about a simpler approach of using divide of merge sort. keep sub dividing the set of rectangles till 1 rectangle remains. checking if a point is inside the rectangle is constant time operation. there is no need to combine as the result is unique rectangle. as a optimization , we can have global variable which says the search is complete. before we check for any inside condition for a rectangle we simply check if this variable is set. this will minimize the containment operation.	2014-12-10 11:53:23		
6956	jippy	83	To get O(n log n * log n) complexity it means that we have to solve the problem by doing a sorting and organizing an array as a tree , to be able to search next in log n time.  My idea is to sort and organize the array of rectangles creating a structure for each node to be formed of : min x , max x, min y, max y. Next search in Log n time for each point if it fits in a rectangle.  O(nlogn log n) time and O (length of the rectangle array)	2014-12-10 11:53:23		
6957	ftfck	83	This is too vague. More details please.	2014-12-10 11:53:23		
6958	rdfeo	83	For the set of rectangles, create 4 sorted arrays, each storing the BottomLeft (BL) coordinate, the TopRight (TR) coordinate & an ID for the rectangle. The 4 arrays are sorted one each for the below (and named accordingly) 1. BL x value - BLX 2. TR x value - TRX 3. BL y value - BLY 4. TR y value - TRY (thus far takes O(nlogn))	2014-12-10 11:53:23		
6959	fmzze	83		2014-12-10 11:53:23		
6960	ftfck	83		2014-12-10 11:53:23		
6961	tenuw	83	Now I have not written the intersection function, an approach like sort & compare first pair of lists, and the intersection with the next and so on, should lead to O(nlogn) to sort and O(n) to compare should work.	2014-12-10 11:53:23		
6962	dgjji	83		2014-12-10 11:53:23		
6963	ufdxg	83		2014-12-10 11:53:24		
6964	azmjc	84	We can use suffix tree to solve this problem. But can you write the necessary code in an interview on the blackboard correctly? That's difficult!!	2014-12-10 11:53:24		
6965	bjsiw	84	Longest common sub-string of strings S1, S2,.... Sn can be found as follows: 1. Build a generalized suffix tree for S1, S2,... Sn 2. Mark each internal node v by 1 (resp. 2, ... n) if the subtree below v contains a leaf for a suffix of S1 (resp. S2,... Sn) 3. Traverse the tree to find nodes marked by all 1, 2,...n and choose any u of them with a maximal string-depth 4. L(u) is a maximal common sub-string	2014-12-10 11:53:24		
6966	zeice	84	It's not so difficult if you are going with the O(n^2) time, O(n^2) space implementation of the suffix tree. The collapsed O(n) space suffix tree is a bit harder; to build it in O(n) time is even more.  I'd doubt they would require you to implement it with a linear time and space suffix tree. THAT would be quite difficult indeed.	2014-12-10 11:53:24		
6967	cfzie	84	1> If people already knows the len of each strings, sort the strings in the ascend order of the strings. 2> pick two strings from the list, build the suffix tree for each strings. 3> Based on the suffix tree of the shortest string, prune suffix tree based on the another suffix tree. 4> If the result tree is empty one, return NULL; 5> pick another string from the list if one exist, build suffix tree of that string, and go to 3. 6> If there is no more string in the list, return the longest path of the result tree as the result.	2014-12-10 11:53:24		
6968	ufdxg	84	Why to sort? Point #1 can be eliminated.	2014-12-10 11:53:24		
6969	eucmc	84	Another way to slice this is to do sort of a breadth-first search. First make a hash of all the common 2-grams across all the lists, pruning as you march down the lists. For each 2-gram, keep a cache of locations within each list. (If the list of 2-grams is empty, just have special case code to find a single character in all strings.)  Then when you go the 3-gram phase, start with all the 2-grams for the first list, and find their 3rd character. Let's say you start with ce and the first occurrence of ce in the first list is followed by x, giving you the 3-gram of cex. If "ex" is not in the map of 2-grams common to all lists, then you'll know that cex won't be in all lists either (for obvious reasons), so you can prune immediately. Otherwise, push it on to the list of working 3-grams, and then keep proceeding through the 2-grams for list one. In processing the second list, update the working list of 3-grams, then at the end, sweep all the 3-grams that only showed up in both of the first two lists. Keep continuing in this fashion until you can't extend any of the n-grams.	2014-12-10 11:53:24		
6970	azmjc	84		2014-12-10 11:53:25		
6971	fmzze	84		2014-12-10 11:53:25		
6972	vanul	84	/** * Returns the longest shortest substring (LCS) of two strings. * * @param aString First string. * @param bString Second string. * @return The longest common substring of aString and bString. */ public String longestSubstring(final String aString, final String bString) { // Get length of the 2 string final int m = aString.length(); final int n = bString.length();  // to ensure O(min(m,n)) space complexity // the biggest string should be the first parameter // so i swap them and try again if (n > m){ return longestSubstring(bString,aString); }  // Initialize the 2 array to the length of the longest string int maxLength = Math.min(m,n); int[] last = new int[maxLength]; int[] next = new int[maxLength]; StringBuffer result = new StringBuffer();   int len = 0; final char []a = aString.toCharArray(); final char []b = bString.toCharArray();  for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (a[i] == b[j]) { next[j] = 1 + (j - 1 >= 0 ? last[j - 1] : 0); if (next[j] > len) { len = next[j]; result.setLength(0); final int beginIndex = i - len + 1; final int endIndex = len + beginIndex; result.append(aString.subSequence(beginIndex, endIndex)); } } } System.arraycopy(next, 0, last, 0, maxLength); Arrays.fill(next, 0); } return result.toString(); }	2014-12-10 11:53:25		
6973	nwkeg	84	Working PHP solution	2014-12-10 11:53:25		
6974	qywrh	84		2014-12-10 11:53:25		
6975	ewigy	84		2014-12-10 11:53:25		
6976	eucmc	84	Say there are N strings.  (1) Construct a suffix tree with the first string. In each node of the suffix tree maintain a count, which will be initialized to zero. (2) Now search all the suffix strings of each string, and while searching increment the count of the suffix-tree-node if found. (3) Repeat step (2) for all the N-1 strings (except the first string). (4) Do DFS on the suffix tree and return the longest-string, where node is considered valid only if its count is equal to N-1.  Here is the C++ code ...	2014-12-10 11:53:25		
6977	wbqzu	84		2014-12-10 11:53:25		
6978	rrmeu	84		2014-12-10 11:53:25		
6979	fmzze	84	Output:  Longest common substring == ted	2014-12-10 11:53:25		
6980	dkebi	84	this will not work for below input char * input1 = "antedraon"; char * input2 = "rabelatedly"; char * input3 = "rabigotedlray"; char * input4 = "closerafistedly"; char * input5 = "coldtahearatedly";  expected output was ra..	2014-12-10 11:53:25		
6981	gilit	84	char * input1 = "antedraon"; char * input2 = "rabelatedly"; char * input3 = "rabigotedlray"; char * input4 = "closerafistedly"; char * input5 = "coldtahearatedly"; char * input6 = "indhaarate";  expected output 'ra'	2014-12-10 11:53:25		
6982	sqzqo	84	I think your algorithm will break if a word visits nodes in the suffix tree more than once. Like if your inputs are AB, ABAB and CXY the LCS should be ''. But I think your algorithm will return AB because the A->B node will have been visited three times: once when building the initial suffix tree and twice while searching the second string's suffixes. According to wikipedia, you build a suffix tree using all the words and then do a DFS and keep track of bit vector of words that are found below each node.  If you changed your algorithm so each node had a bit vector that got updated on traversals then it seems like it would work.	2014-12-10 11:53:25		
6983	rdfeo	84	1. For every char in the first string starting from position 0, do 2 - 4 below. 2. Find the same char in every other string. Keep their positions in a vector. If not found in any string, loop back to 1. 3. Keep moving the positions in every string until they do not match. Return the substring; 4. If the substr is longer than the max str, replace the max string with it 5. return max str.	2014-12-10 11:53:25		
6984	mrjku	84		2014-12-10 11:53:25		
6985	fowai	84		2014-12-10 11:53:25		
6986	huiqq	84		2014-12-10 11:53:25		
6987	nwkeg	84		2014-12-10 11:53:25		
6988	plapd	84	It accepts an array of string, the array should be sorted	2014-12-10 11:53:25		
6989	zeice	84	please provide ur answers barry!	2014-12-10 11:53:25		
6990	nwkeg	84	///	2014-12-10 11:53:25		
6991	wbqzu	84		2014-12-10 11:53:25		
6992	rdfeo	84		2014-12-10 11:53:25		
6993	ethan	84	\\\	2014-12-10 11:53:25		
6994	tenuw	85	An in-order, depth-first traversal of a binary search tree (which an AVL is by definition) produces a sorted list of all elements in O(n) time. Simply take the middle element of this list in order to retrieve the median.	2014-12-10 11:53:26		
6995	bexbp	85		2014-12-10 11:53:26		
6996	wbqzu	85		2014-12-10 11:53:26		
6997	tenuw	85	Some optimizations could be made as well; for example, if the tree maintains a count of its nodes, we could stop our traversal once we reach the middle element (the median).	2014-12-10 11:53:26		
6998	nhibd	85	Binary Search Tree is not AVL tree. An AVL tree can be implemented as Balanced BST.  This was a question asked to my friend 1 week ago by Google recruiter Q) Which one of these Data Structures have Log N traverse time  Red Black Tree Binary Search Tree Hash Table Array Directed Acyclic Graphs  He included BST in his answer which was wrong. Watch out for these differences in interviews.	2014-12-10 11:53:26		
6999	ftfck	85	Are you sure it's "traverse" time? Even for "retrieval" time, of course BST is not the answer since is doesn't have to be balanced. But a AVL tree has to be a BST, except it's self-balancing.	2014-12-10 11:53:26		
7000	nhibd	85	You are right, BST is not AVL and since BST could be unbalanced the search time of O(log n) can not be guaranteed in BST.  On the other hand AVL is a BST and it's almost balanced. So the answer to above question is "Red Black tree"  "mdc's" approach seems to be correct to find a median	2014-12-10 11:53:26		
7001	ewigy	85	For any balanced BST, maintain a count of number of nodes in its left sub-tree and number of nodes in right subtree + 1 (for itself). This can be maintained in constant time during insertion and deletion. Now finding a median is just finding the key with rank n/2 where n is total number of elements.  Time complexity - O(log n) in worst case. Space Complexity - O(1)	2014-12-10 11:53:26		
7002	bexbp	85	What's the explanation for the space complexity to be O(1)? Where are the n BST nodes held?	2014-12-10 11:53:26		
7003	vanul	85	n BST nodes are already given. It is O(1) extra space.	2014-12-10 11:53:26		
7004	azmjc	85	As mdc said, you should use in-order DFS to traverse tree from minimal value up to the bigger values.  For memory consumption optimization you can do following things: - maintain amount of added values to tree - calculate amount of values at tree before actually getting median value  After that you know total amount of values at tree and you can find median just like that (python):	2014-12-10 11:53:26		
7005	qywrh	85		2014-12-10 11:53:27		
7006	bexbp	85		2014-12-10 11:53:27		
7007	sgiwy	85	But the question is - why do we need balanced tree here? We can do that calculation for any BST.	2014-12-10 11:53:27		
7008	rdfeo	85	AVL tree with 2 modifications  1. Balance based on count of elements in left subtree and right 2. Balance all subtrees as well	2014-12-10 11:53:27		
7009	dgjji	85	Given 4 nodes, how do you construct such a tree?	2014-12-10 11:53:27		
7010	eucmc	85	I propose using 2 heaps - min-heap for the greater, and max-heap for the lesser. These heaps ensure O(1) in retrieving the minimal and maximal elements and O(logN) for insertion. When inserting new values, we use the minimal and maximal to of the heaps to choose and update the right median. We maintain balance (max diff of 1 between the heap sizes) by moving the minimal of the greater-heap, or the maximal of the lesser-heap to the opposite heap as needed. If the heaps are of same size, we can add the new value to either heap. The median is the root of the heap with the +1 size, or the average of both roots, in case the sizes are equal.	2014-12-10 11:53:27		
7011	zeice	85	- (Node *)medianWithRoot:(Node *)root { return root; }  .... it's balanced. Might off by one or two spots, but bleh...	2014-12-10 11:53:27		
7012	eucmc	85	To put it simply , I ve used Binary Search Tree (didn't add up the balancing -rotation) bottom line here is to traverse to capture all the value of the nodes here's java code	2014-12-10 11:53:27		
7013	qywrh	85		2014-12-10 11:53:27		
7014	plapd	85		2014-12-10 11:53:27		
7015	gilit	85	AVL trees are balanced height not count I'd go with the following: count left side, count right side, add 1 for the root and calculate tree size. O(n) calculate if the median is to the left or to the right by subtracting the right0count from the left-count and divide by 2. This will provide how many hops we should do and to which side.. O(k) - k is the imbalance count / 2 No additional memory usage  Cheers	2014-12-10 11:53:27		
7016	rrmeu	85	The root of an AVL tree has the balance factor -1, 0 or 1. If the balance factor is 0 the root's value is the median. If the balance factor is -1 the median is the average of the root's value and the maximum value of root's left subtree. If the balance factor is 1 the median is the average of root's value and the minimum of root's right subtree. Complexity is logarithmic in N.  If the AVL structure is adjusted to keep track of max and min values then finding the median can be done in constant time.  Updating the min & max values when inserting/deleting from the tree adds overhead that is (worse case) logarithmic. For each node the min value is the min value of left child, the max value is the max value of the right child.	2014-12-10 11:53:27		
7017	nhibd	85	No, it doesn't work. AVL tree are balanced based on just the height of the left subtree and right subtree. There could be a big difference between the actual number of nodes in the two subtree.  For example, assume left subtree is a full binary tree of height k and right subtree is a full binary tree of size k minus one leaf deleted for all the nodes in the second to last level. The balance factor is 1 but the difference between the nodes in the subtrees are huge.  AVL tree seem to do jack squat for reducing the order of finding median. You can use it to get a sorted order and find the median which is still going to be O(n) which is order equivalent to finding the median in an array in the first place.  Anyone knows anyway which actually reduces the order, please email me. I am really interested to know.	2014-12-10 11:53:27		
7018	zeice	85	I agree with Navid and that's why i subscribed to this question.  I would like to know: is the tree already full? or we fill in values  also do we have access to the node.balance method?  We can implement BST using AVL tree  Keep counts 1) elements larger than median 2) elements smaller than median  calculate the median for first two elements  for third element onwards keep the track of the counters. If the counters differ by more than 2 then you know the tree might be out of order  then maybe we can do something at that step  to prove the point AVL BST is not a good median holder see this example (insert into AVL BST with max diff = 1) 12 - 9 - 18 - 7- 10  This tree is still in balance ( the height differ by just 1 of left and right subtree of 12) but the median should be 10.	2014-12-10 11:53:27		
7019	bjsiw	85		2014-12-10 11:53:27		
7020	azmjc	85		2014-12-10 11:53:27		
7021	vanul	85	@navid, no, it's not correct. "right subtree is a full binary tree of size k minus one leaf deleted for all the nodes in the second to last level." cannot be an AVL tree. In an AVL tree, The height of the tree may grow only after you fill completely, as otherwise there should be two subtree whose heights differ by >1.	2014-12-10 11:53:27		
7022	ftfck	86	It can be solved with backtracking algorithm...Try to place values 1 after another in the array after checking that the condition is being satisfied and the array positions are available for this value to be placed. If a value could not be placed anywhere in the array try to backtrack and replace the position of the previous value.  In my simple test it did not work for n=5 and 6 etc...that means such an array could not be constructed for that value of n. Here is my java code	2014-12-10 11:53:28		
7023	tenuw	86		2014-12-10 11:53:28		
7024	wbqzu	86		2014-12-10 11:53:28		
7025	xhgls	86	Output: for N= 7 Array content is : 1 7 1 2 5 6 2 3 4 7 5 3 6 4	2014-12-10 11:53:28		
7026	bjsiw	86	There could be more than one array matching the requirement and we only need to find one. So we can make a great optimization to backtracing by placing the large value first, which has less possibilities: (1)as soon as we can not place the large value, we stop the search process. (2)by placing large value first we also cut off many search branches for smaller ones. As an example, when length = 16, following code is much faster than the above one.	2014-12-10 11:53:28		
7027	nwkeg	86		2014-12-10 11:53:28		
7028	eucmc	86		2014-12-10 11:53:28		
7029	sqzqo	86		2014-12-10 11:53:28		
7030	admin	86		2014-12-10 11:53:28		
7031	sgiwy	86	What is the algo?	2014-12-10 11:53:28		
7032	nwkeg	86	How did you come up with this?! I tried your solution and it only works for certain numbers: 3, 4, 7, 8, 11, 12. 13 and beyond takes too long for me to wait	2014-12-10 11:53:28		
7033	ewigy	86	also works (returns an answer quickly) for 15, 16, 19, 20, 23, 24, 27, 28, 31, 32, 35, 40, 43, 44. This is very weird. What is the meaning behind this sequence of numbers?	2014-12-10 11:53:28		
7034	sgiwy	86	It's a backtracking algorithm and sure it's not the most optimal one. Starting with placing the most restricted number (n) into a place and checking if the placing will work for the rest of numbers (n-1, n-2, etc..).  At any step, if the placement of next numbers failed in all possible positions, change the placement of the current number to the next available placement	2014-12-10 11:53:28		
7035	mrjku	86	The logic is to do it in one pass. while i will the position to store the no arr[i] + i +1 will be the position where the no will reappear next. Keep incrementing the seed value and divide by input bound when it exceed to circle back.	2014-12-10 11:53:28		
7036	mrjku	86		2014-12-10 11:53:28		
7037	bexbp	86		2014-12-10 11:53:28		
7038	rdfeo	86	package test.arr;  import java.util.Arrays;  public class Test1 {  public static boolean returnF= false;  public static void main(String[] args) { int n =40 ; int a[] = new int[2*n];  for(int i=n; i<=1;i-- ){ a[n] =0; }  fillNum(a,n);  System.out.println(Arrays.toString(a)); }  public static void fillNum(int[]a, int i) {  String iPos [] = calcPos(i, a.length); for (String pos : iPos) { if(returnF) return; clearI(a, i); String poss[]=pos.split(","); if(a[Integer.parseInt(poss[0])] ==0 && a[Integer.parseInt(poss[1])] ==0){ a[Integer.parseInt(poss[0])] = i; a[Integer.parseInt(poss[1])] =i; if(i==1) returnF = true; // System.out.println(Arrays.toString(a)); fillNum(a, i-1); }   }  }  public static void clearI(int a[], int i) { for(int j=0;j<a.length ; j++){ if(a[j]<=i) { a[j]=0; } } }  public static boolean findI(int a[], int i) { for(int j=0;j<a.length ; j++){ if(a[j]==i) { return true; } } return false; }  public static String[] calcPos(int num,int len) { String[] posArr = new String[len-(num+1)];  for(int i =0 ; i<posArr.length;i++){ posArr[i] = i + "," + (i+num+1) ; } return posArr; }  }	2014-12-10 11:53:28		
7039	ethan	86		2014-12-10 11:53:28		
7040	qywrh	86		2014-12-10 11:53:28		
7041	eucmc	86	I've noticed there are cases where more than one solution exists. This is a C++ approach that takes care of such cases:	2014-12-10 11:53:29		
7042	krxlv	86		2014-12-10 11:53:29		
7043	tenuw	86		2014-12-10 11:53:29		
7044	sqzqo	86	}	2014-12-10 11:53:29		
7045	sgiwy	86	Is this the interview question in reality? Because one SIMPLE solution can be just enumerate the numbers from 1 to n while keeping the distance between two duplicates to be zero. Eg: for N= 7 , I can give an array that contains 11223344556677. The distance between same values = 0.	2014-12-10 11:53:29		
7046	vanul	86	public static void main(String arg[]) { for (int n = 2; n < 1000; n++) { double[] r = new double[2 * n]; if (populate(n, r)) { System.out.println(n+" -> "+Arrays.toString(r)); } } }  public static boolean populate(int N, double r[]) { if (N == 0) { return true; }  for (int i = 0; i < r.length - N - 1; i++) { if (r[i] == 0 && r[i + N + 1] == 0) { r[i] = N; r[i + N + 1] = N; if (populate(N - 1, r)) { return true; } else { r[i] = 0; r[i + N + 1] = 0; } } }  return false; }  "C:\Program Files\Java\jdk1.8.0_20\bin\java" -Didea.launcher.port=7539 "-Didea.launcher.bin.path=C:\Program Files (x86)\JetBrains\IntelliJ IDEA 13.1\bin" -Dfile.encoding=UTF-8 -classpath "C:\Program Files\Java\jdk1.8.0_20\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_20\jre\lib\ext\zipfs.jar;C:\xfiles\out\production\xfiles;C:\work\simplejms\lib\log4j-1.2.16.jar;C:\Jama-1.0.3.jar;C:\Program Files (x86)\JetBrains\IntelliJ IDEA 13.1\lib\idea_rt.jar" com.intellij.rt.execution.application.AppMain quiz.MagicArray 3 -> [3.0, 1.0, 2.0, 1.0, 3.0, 2.0] 4 -> [4.0, 1.0, 3.0, 1.0, 2.0, 4.0, 3.0, 2.0] 7 -> [7.0, 3.0, 6.0, 2.0, 5.0, 3.0, 2.0, 4.0, 7.0, 6.0, 5.0, 1.0, 4.0, 1.0] 8 -> [8.0, 3.0, 7.0, 2.0, 6.0, 3.0, 2.0, 4.0, 5.0, 8.0, 7.0, 6.0, 4.0, 1.0, 5.0, 1.0] 11 -> [11.0, 6.0, 10.0, 2.0, 9.0, 3.0, 2.0, 8.0, 6.0, 3.0, 7.0, 5.0, 11.0, 10.0, 9.0, 4.0, 8.0, 5.0, 7.0, 1.0, 4.0, 1.0] 12 -> [12.0, 10.0, 11.0, 6.0, 4.0, 5.0, 9.0, 7.0, 8.0, 4.0, 6.0, 5.0, 10.0, 12.0, 11.0, 7.0, 9.0, 8.0, 3.0, 1.0, 2.0, 1.0, 3.0, 2.0]	2014-12-10 11:53:29		
7047	rrmeu	86	No algo, no explanation = -1.	2014-12-10 11:53:29		
7048	rdfeo	86		2014-12-10 11:53:29		
7049	huiqq	86		2014-12-10 11:53:29		
7050	fmzze	86	No algo, no explanation = -1.	2014-12-10 11:53:29		
7051	azmjc	87	doors with numbers 1, 4, 9 ... Basically door numbers which is a perfect square is the answer.	2014-12-10 11:53:30		
7052	plapd	87	Good one(+1 for you) and reason I see is that perfect square has odd number of factors. Since the doors were all initially closed, an even number of factors for a given door number closes it and the odd number of factors opens it.	2014-12-10 11:53:30		
7053	nwkeg	87	yeah, and the reason is only those numbers will be opened which will have odd numbers of factors, because only factors of the numbers are responsible to toggle the door and it should be odd to be opened.	2014-12-10 11:53:30		
7054	ftfck	87	Elements with odd number of unique factors including 1 will remain open (only the Square numbers will satisfy that condition)	2014-12-10 11:53:30		
7055	azmjc	87	Code to demonstrate what Vic said:	2014-12-10 11:53:30		
7056	sgiwy	87		2014-12-10 11:53:30		
7057	ethan	87		2014-12-10 11:53:30		
7058	xhgls	87	only 10 doors remain open perfect squares of 1,2,9,16,25,36,49,64,81,100 ..	2014-12-10 11:53:30		
7059	qywrh	87	done!	2014-12-10 11:53:30		
7060	mrjku	87		2014-12-10 11:53:30		
7061	nhibd	87		2014-12-10 11:53:30		
7062	fowai	87	//enjoyy	2014-12-10 11:53:30		
7063	ewigy	87		2014-12-10 11:53:30		
7064	ftfck	87		2014-12-10 11:53:30		
7065	bjsiw	87	A simple bit manipulation is enough instead of maintaining arrays.	2014-12-10 11:53:30		
7066	dkebi	87		2014-12-10 11:53:30		
7067	nwkeg	87		2014-12-10 11:53:30		
7068	gilit	87	If we start toggling from first element onward, then answer would be 1,4,9,........(if index of the array start from the 0)...	2014-12-10 11:53:30		
7069	rrmeu	87	1 4 9 16 25 36 49 64 81 100	2014-12-10 11:53:30		
7070	ftfck	87		2014-12-10 11:53:30		
7071	krxlv	87		2014-12-10 11:53:30		
7072	bjsiw	87		2014-12-10 11:53:30		
7073	zeice	87		2014-12-10 11:53:30		
7074	vanul	87	Only the 1st gate will remain open all others will be closed.	2014-12-10 11:53:30		
7075	xhgls	87	only 1st gate will remain open because the door toggle from 2nd to 100th	2014-12-10 11:53:30		
7076	fowai	87	only 1st gate will remain open because the door toggle from 2nd to 100th	2014-12-10 11:53:31		
7077	bexbp	87	close=1,open=0; initial state is 1 1 1 1 1 1... after first toggle :-0 0 0 0 0..... after second toggle(toggle every second element) :-0 1 0 1 0.... after third toggle :-0 1 1 0 0.... after fourth toggle :-0 1 1 1 0... after fifth toggle :-0 1 1 1 1  if we do so the answer would be, one gate left after all(100) the iterations.	2014-12-10 11:53:31		
7078	cfzie	88	How about this approach?  With 4 placed in units place, there are 3! permutations of 123 in thousandths, hundredths and tenths place. That means 4 occurs in units place 3! times.  Similarly 3 2 and 1 each occur in units place 3! times. The sum of all numbers in units place is therefore 3!(4 + 3 + 2 + 1) = 6 * 10 = 60.  The same value happens to occur in tenths, hundredths and thousandths place as well, except that it gets multiplied by a power of 10 according to its position.  So, the total should be 60 + 600 + 6000 + 60000 = 66660.	2014-12-10 11:53:32		
7079	krxlv	88	Yet another approach is to form pairs of numbers from 4!(=24) permutations. Pairing should happen in such a way that at a given position, the maximum digit of one number should match with the minimum digit of the other number, the second maximum digit should match with the second minimum and so on.. For ex:  Pair up 1234 with 4321, 2134 with 3421 etc. The sum of each of these pairs is equal to 5555 and we have 12 pairs out of the total 24 permutations.  5555 * 12 = 66660	2014-12-10 11:53:32		
7080	bexbp	88	A simple solution--  3!(4+3+2+1)(1+10+100+1000)..easy logic	2014-12-10 11:53:32		
7081	sqzqo	88	Awesome...........	2014-12-10 11:53:32		
7082	fmzze	88	Here we don't have to do actual calculation, else we will never get answer in written test. Think of this as mathematical + logical question. Lets say we have all permutation of 1234. It will be 4! = 24. Now if we look at each column of this list carefully, every number will appear for 6 time. 1234 1324 2134 2314 3124 3214 ...  Now if you just concentrate on 4th column, "4" is coming 6 times, same way if we list all number each number will come 6 time in 4th column. So sum of 4th column is (4*6 + 3*6 + 2*6 + 1*6) = 60.  Same way, for all other columns sum would be 60.  Now we are just one step far away from answer. And that is consider "carry". 4th column will give 6 as carry to 3rd columns, again in turn 3rd column will give 6 as carry to 2nd column and so on.  Therefore, final answer would be 66660.	2014-12-10 11:53:32		
7083	mrjku	88	Total no. of permutations = 4! = 24 Each digit 1,2,3 and 4 will occur exactly 6 times at each position. Sum of digits at each position = (1+2+3+4)*6 = 60 Total sum 60000 6000 600 60 --------- 66660 = Answer --------	2014-12-10 11:53:32		
7084	ftfck	88	Consider the unit's digit place,each of 4,3,2,1 appears 6 times each.So at the digit place ,this adds to (4+3+2+1)*6=60.Now 6 gets carried forward to the tens place.Similarly at ten's place,it adds to (4+3+2+1)*6+6(the carry)=66.Now again the 6 is carried forward till we get 66660.	2014-12-10 11:53:32		
7085	ewigy	88	Let assume we have n digits. Each of them will appears on i-th position n!/n times. So the general formula is : n!/n = 6 (1 + 2 + 3 + 4) * 6 * 4 = 240	2014-12-10 11:53:32		
7086	cfzie	88		2014-12-10 11:53:32		
7087	ufdxg	88		2014-12-10 11:53:32		
7088	huiqq	88	its 4! i.e 4*3*2*1=24 now if we pair the number like 1234+4321=5555 2134+3421=5555 in every case we come across 5555 therefore there will be 12 pairs hence 12*5555=66660	2014-12-10 11:53:32		
7089	xhgls	88	it can be done by finding all permutation of the given digits without rep, then add each numbers formed. there are totally 4! numbers to add.  Let number = 1234 let sum = 1234.  1. Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[k] < a[l]. Since k + 1 is such an index, l is well defined and satisfies k < l. 3. Swap a[k] with a[l]. 4. Reverse the sequence from a[k + 1] up to and including the final element a[n]. 5. sum = sum + newly formed number on step 4.	2014-12-10 11:53:32		
7090	eucmc	88	A simple solution--  3!(4+3+2+1)(1+10+100+1000)..easy logic	2014-12-10 11:53:32		
7091	mrjku	88		2014-12-10 11:53:32		
7092	fowai	88		2014-12-10 11:53:32		
7093	eucmc	89	Nice..!	2014-12-10 11:53:33		
7094	bexbp	90	Hash table wont be optimized by space... I think sorting is the technique, if we look for space optimization, and Hash table is the solution if time complexity is more improtant..	2014-12-10 11:53:34		
7095	jippy	90	if we are known the range in which numbers in a given array exists. then we can simply make the bucket for each no .. initially making the bucket value of each no is -1 taking a var Max_repetition =0 and we will traverse the whole array if any number is encounter corresponding number bucket is incremented . and each time of updation of bucket we will check the updated value to the max_repetition value and update accordingly  if range is not known . then we can sort d array in nlogn time and find max repetition.  if any bdy knows more optimal solution please add to it	2014-12-10 11:53:34		
7096	tenuw	90	your 1st sol doesnot seem to optimize space. second is better in terms of space but O(n log n) seems to very large.	2014-12-10 11:53:34		
7097	nhibd	90	a hash map can be used to store the values and if a collision occurs, increment the frequency counter. this can be done in O(n) both on time and space.	2014-12-10 11:53:34		
7098	krxlv	90	Hash table for time . BST for space ?	2014-12-10 11:53:34		
7099	gilit	90	sorting is not required. just counting of occurrence is sufficient	2014-12-10 11:53:34		
7100	zeice	90	if we sort the list, didn't we destroy the list?  if we really really care about space, we can only keep a number and counter, go throught the list N times, find the max occurrence.	2014-12-10 11:53:35		
7101	bexbp	90	Agreed	2014-12-10 11:53:35		
7102	dkebi	90		2014-12-10 11:53:35		
7103	eucmc	90		2014-12-10 11:53:35		
7104	plapd	90	will this work on [2,2,1,3,4]?	2014-12-10 11:53:35		
7105	ufdxg	91	No replies ????	2014-12-10 11:53:52		
7106	fmzze	91	brutal force solution. Start from sqroot of the number down to 2. Check if it is a prime number, if then done. Otherwise, find next smaller prime number. Needs O(N) though.	2014-12-10 11:53:52		
7107	dgjji	91	it fails for 143= 11*13 sqrt(143) =12.	2014-12-10 11:53:52		
7108	ufdxg	91	who told you sqrt(143) ==12	2014-12-10 11:53:52		
7109	zeice	91	void largestPrime(int N) { int i; for(i=2; i<=(int)sqrt((double)N); i++) { if(N % i == 0) {  largestPrime(N/i); return; }  } printf("%d ", N);  }	2014-12-10 11:53:52		
7110	rdfeo	91	void prime_factors(int n) { int t = sqrt(n) ,i;  for(i = 2 ; i<= t && n > 1 ;i++) while(n % i == 0){ printf("%d\t",i); n/= i; } if(n > 1) printf("%d", n); }	2014-12-10 11:53:52		
7111	krxlv	91	i<=(int)sqrt((double)N) should be i<=(int)2*sqrt((double)N) because this condition fails when N = 15, sqrt(15) is about 3.7, but 5 is still a factor.	2014-12-10 11:53:52		
7112	ftfck	92	shsf has a good solution. Do you need to have the second hash? Can't you remove already examined values from the hash as you go? Here's an example in C#:	2014-12-10 11:53:54		
7113	bexbp	92		2014-12-10 11:53:54		
7114	ftfck	92		2014-12-10 11:53:54		
7115	wbqzu	92	The google seems to ask a lot of graph related questions so maybe that's what they are looking for. The hash solution is easier to code.	2014-12-10 11:53:54		
7116	cfzie	92	As you said, second hash is not needed. Very good implementation..keep it up ..thanks	2014-12-10 11:53:54		
7117	admin	92	really good solution, good job.	2014-12-10 11:53:54		
7118	ewigy	92	How the complexity of the above algorithm/implementation is O(3n) => O(n); looks like its O(n^2)?	2014-12-10 11:53:54		
7119	rrmeu	92	@Jose Cuervo, shsf, elber.kam Since someone down voted without giving any reason, please test this array {5,4,3,2,1} and tell me what do you get? I am really thinking hard to understand the solution.	2014-12-10 11:53:54		
7120	mrjku	92	Go home Jose, you are drunk :-)	2014-12-10 11:53:54		
7121	nwkeg	92	i think instead of hash, you can also use bitset	2014-12-10 11:53:54		
7122	bjsiw	92	Sorting is an obvious solution with O(nlgn) time complexity. This can be solved using connected components of a graph in O(n) time and space complexity as discussed at question?id=19778663  The graph in this case is 'linear', with each node having at most 2 edges, and hence can be built in O(n) time. Finding connected components, and storing the maximal connected component, in this graph using DFS has O(n) time complexity. Hence overall complexity is O(n).  Java implementation given below. Provide the input as:  16 1 21 7 4 6 15 3 2 8 14 9 17 35 19 45 18 73 22 44 43 71 20 33	2014-12-10 11:53:54		
7123	mrjku	92		2014-12-10 11:53:54		
7124	dgjji	92		2014-12-10 11:53:54		
7125	azmjc	92	I think the solution with best run time O(n) is mentioned at stack overflow (answer by Grigor):	2014-12-10 11:53:54		
7126	ethan	92		2014-12-10 11:53:54		
7127	azmjc	92		2014-12-10 11:53:54		
7128	nhibd	92	Hello guys I have little bit problem in understanding the problem.  1,4 output because 1,2, 3, 4 exists; that's why ? could some1 please answer ? ;)	2014-12-10 11:53:54		
7129	azmjc	92	Yes, that is exactly why. [1,4] is the answer because 1,2,3,4 are on the list.	2014-12-10 11:53:54		
7130	ftfck	92	could anyone explain me the question? i am confused with how [1,4] will come!!1	2014-12-10 11:53:54		
7131	plapd	92	could anyone explain me the question? i am confused with how [1,4] will come!!1	2014-12-10 11:53:54		
7132	plapd	92	Vignesh,  The question is that in the given list, find the largest chunk of consecutive numbers. [1,4] is the answer because all consecutive inclusive elements (1,2,3 and 4) are in the given list and no other chunk is larger.	2014-12-10 11:53:54		
7133	eucmc	92	I Think sorting the array... and comparing all the conective elements will solve the proble, please correct me if i am wrong	2014-12-10 11:53:54		
7134	qywrh	92	Sorting takes too long. It takes like nlogn time. This onecan be solved in o(n) time. 2 possible ways I can think of. Using hash table or dynamic programming	2014-12-10 11:53:54		
7135	tenuw	92	@Anonymous: I'm curious on the DP and hash method.  Hash table, you need to store them, which would be O(n) * O(1) for the inserts, but you need to traverse the results.  DP has more promise, but I'm trying to come up with a good example. Since the order of the inputs doesn't matter (like strictly increasing subsequence), then you're still going to have to deal with *some* data structure to store the linkage information.  However, my DP background is weak, so I'm eager to learn.	2014-12-10 11:53:54		
7136	eucmc	92	Sorting is the most clean and efficient solution here as sorting numbers can always be assumed to be O(n) using radix sort and not O(n logn). Once sorted its straighfoward.	2014-12-10 11:53:54		
7137	zeice	92	You are absolutely right. Just wondering can it be done in linear time :)	2014-12-10 11:53:54		
7138	zeice	92	Sort the array O(nlogn) Then start from the beginning scanning the array for consecutive elements. Store the start and end index of the consecutive element sub-array and modify when a new larger sub-array is found. At the end return the start and end index of the larget sub-daary having consecutive elements. O(n) So final complexity = O(nlogn + n) = O(nlogn)	2014-12-10 11:53:54		
7139	plapd	92	could u please post the code for your algo..	2014-12-10 11:53:54		
7140	dkebi	92	Please let me know for errors or corner cases	2014-12-10 11:53:54		
7141	rdfeo	92		2014-12-10 11:53:54		
7142	admin	92		2014-12-10 11:53:54		
7143	gilit	92	But if that is then question does not seem clear ;) Still I can't believe ........... if so then my 1st question is this a Google Question ?  From the given input it seems that If I do swap across elements whenever I shall not find any suitable elements then I shall break.  1 is @ first position 2 is 7th position and 7 is 2nd position 3 is 4th position and 4 is 3rd position  I am not sure the pattern is always like this  If the pattern is not so then complexity is n + n = 2n First I shall take same sized array then I shall place elements on the basis of it's value Whenever placing the elements if the element is out of the range then skip it In second phase longest sequential array  I am not sure, anonymous says right ? ;) lolz	2014-12-10 11:53:54		
7144	huiqq	92	Answer 1 seems overly complicated. Simply sort the list, and the iterate through keeping track of what ranges your have seen.  Here is a simple mock up of this in MATLAB	2014-12-10 11:53:54		
7145	tenuw	92		2014-12-10 11:53:54		
7146	bexbp	92		2014-12-10 11:53:55		
7147	bjsiw	92	This should work in n*log(n) time complexity time just because of the sort function, else it is O(n) with O(n) space complexity as well	2014-12-10 11:53:55		
7148	dgjji	92	As mentioned by dumbo, it can be solved in linear time using connected graph. Other simple solution can be using two hash table, one to tell if next/previous integer exists not, other to take care of already processed continuous integers.	2014-12-10 11:53:55		
7149	eucmc	92	public class BiggestInterval { public static void main(String[] args) { int[] A = {1,7,4,6,3,10,2}; int[] endPoints = new int[2];//endpoints[0] stands for the  //left endpoint while endpoints[1] stands for the right point. Arrays.sort(A); int max = -1; for(int i=0; i<A.length;i++){ for(int j=i; j<A.length;j++){ if(A[j] - A[i]==j-i && j-i>max){ endPoints[0] = A[i]; endPoints[1] = A[j]; max = j-i; } } }  System.out.println("the biggest interval is: " + max ); System.out.println("the interval is : [" + endPoints[0] + ", " + endPoints[1]+"]");  } }	2014-12-10 11:53:55		
7150	ftfck	92	Here's a C# example. I've tested this against a single element array, an array containing all of the same elements, and against the sample posted above.	2014-12-10 11:53:55		
7151	eucmc	92		2014-12-10 11:53:55		
7152	rdfeo	92		2014-12-10 11:53:55		
7153	rrmeu	92	I think the question's example answer is [1, 4] meaning the straight begins with the value of 1 and runs for 4 consecutive values. This is a way to identify the subset { 1, 2, 3, 4 }.	2014-12-10 11:53:55		
7154	admin	92	Based on the solution from Stackoverflow (stackoverflow.com/a/17592550/538743), it can be done with hashtable in O(n)	2014-12-10 11:53:55		
7155	jippy	92		2014-12-10 11:53:55		
7156	fmzze	92		2014-12-10 11:53:55		
7157	rdfeo	92	Using hashset and claiming O(N) doesn't feel right. Sure, your loop runs in O(N) calling hash functions. But Hashset cannot guarantee O(1) due to collisions with large number of keys.	2014-12-10 11:53:55		
7158	nwkeg	92	One more implementation	2014-12-10 11:53:55		
7159	bexbp	92		2014-12-10 11:53:55		
7160	rrmeu	92		2014-12-10 11:53:55		
7161	zeice	92	One of the O(N) solutions, with HashSet:  public void biggestInterval2(Collection<Integer> is) { Set<Integer> all = new HashSet<Integer>(is); Set<Integer> visited = new HashSet<Integer>(); int bestStart = 0; int bestLen = 0; for(int i : is) { if(! visited.contains(i)) { visited.add(i); int start = i; while(all.contains(start - 1)) { start --; visited.add(start); } int end = i; while(all.contains(end + 1)) { end ++; visited.add(end); } int len = end - start + 1; if(len > bestLen) { bestStart = start; bestLen = len; } } } System.out.println("[" + bestStart + ", " + (bestStart + bestLen - 1) + "]"); }	2014-12-10 11:53:55		
7162	nwkeg	92	One of the O(N) solutions, with HashSet:	2014-12-10 11:53:55		
7163	admin	92		2014-12-10 11:53:55		
7164	qywrh	92		2014-12-10 11:53:55		
7165	eucmc	92	You can find my implementation below:  /* Given a list of integers, find out the biggest interval that has all its members in the given list. e.g. given list 1, 7, 4, 6, 3, 10, 2 then answer would be [1, 4]. Develop algorithm and write code for this. */  import java.util.BitSet;  public class LargestContiguousInterval {  public static void main(String[] args) { int[] arr = {1, 7, 4, 6, 3, 10, 2};  printLargestContInterval(arr); }  private static void printLargestContInterval(int[] arr) { BitSet bits = new BitSet();  for (int i = 0; i < arr.length; i++) { bits.set(arr[i]); }  // scan through the bit set int len = bits.length(); int count = 0; int maxCount = Integer.MIN_VALUE; int maxStart = -1; int start = -1;  for (int i = 0; i<len; i++) { if (bits.get(i)) { count++; if (start == -1) start = i; } else {  if (count > maxCount) { maxCount = count; maxStart = start;  }  start = -1; count = 0; } }  // print the max cont range in 'arr' System.out.println("[" + maxStart + " - " + (maxStart+maxCount-1) + "]"); } }   It uses the BitSet type from Java.	2014-12-10 11:53:55		
7166	ufdxg	92	#include<cstdio> #include<iostream> using namespace std; int main() { int no[100]={0},cnt=0,x,y,n,xf,yf,cntf=0; bool nohash[100]={false}; cout<<"enter the no of elements"<<endl; cin>>n; cout<<"enter the elements"<<endl; for(int i=0;i<n;i++) { cin>>no[i]; nohash[no[i]]=true; } for(int i=0;i<100;i++) { if(nohash[i]==true) {x=i; while(nohash[i]==true) { cnt++;i++; } y=i-1; } if(cnt>cntf) { cntf=cnt; xf=x; yf=y; } cnt=0; } cout<<"range is"<<xf<<"to"<<yf<<endl; } //an O(n) soln. using hash table	2014-12-10 11:53:55		
7167	dkebi	92		2014-12-10 11:53:55		
7168	sqzqo	92		2014-12-10 11:53:55		
7169	eucmc	92	I just tried differently.....!	2014-12-10 11:53:55		
7170	krxlv	92	A different approach: (space utilization: O(n), Time Complexity: O(n))  1) Make a binary search tree or any balanced tree out of the values in given array 2) Get the output of in-order of that tree (to get a sorted array) 3) Find max interval from this sorted array in O(n)	2014-12-10 11:53:55		
7171	huiqq	92		2014-12-10 11:53:55		
7172	azmjc	92		2014-12-10 11:53:55		
7173	nwkeg	92	}	2014-12-10 11:53:55		
7174	ewigy	92		2014-12-10 11:53:55		
7175	nwkeg	92		2014-12-10 11:53:55		
7176	sgiwy	92	Java Implementation using hashMap in time complexity O(n)...	2014-12-10 11:53:55		
7177	ftfck	92		2014-12-10 11:53:55		
7178	xhgls	92		2014-12-10 11:53:55		
7179	eucmc	92	public static String findMaxInterval(int[] arr){  if(arr == null || arr.length == 0){ throw new IllegalArgumentException("Array must not be empty"); }  Arrays.sort(arr);  String endResult = ""; int startIndex = 0; int endIndex = 0; int pass = 0;  int endMax = 0;  while(startIndex + pass < arr.length - 1){ pass++; endIndex = startIndex + pass; if(arr[startIndex] + pass == arr[endIndex]){ continue; } if(arr[startIndex] + pass != arr[endIndex]){ if(pass > endMax){ endMax = pass; endResult = "[" + Integer.toString(arr[startIndex]) + " , " + Integer.toString(arr[endIndex-1]) + "]"; } startIndex++; pass = 0; }   }  return endResult; }	2014-12-10 11:53:55		
7180	azmjc	92		2014-12-10 11:53:55		
7181	dgjji	92		2014-12-10 11:53:55		
7182	nwkeg	92	}	2014-12-10 11:53:55		
7183	bjsiw	93	we need delete the chars and move the remaining chars in the same iteration	2014-12-10 11:53:57		
7184	vanul	93		2014-12-10 11:53:57		
7185	huiqq	93		2014-12-10 11:53:57		
7186	sgiwy	93	before return deleted, we should also add:	2014-12-10 11:53:57		
7187	sqzqo	93		2014-12-10 11:53:57		
7188	sqzqo	93		2014-12-10 11:53:57		
7189	ewigy	93	Will it work with "aaaccc" sequence	2014-12-10 11:53:57		
7190	krxlv	93	@testjay: could you plz explain how will it work with abc.	2014-12-10 11:53:57		
7191	cfzie	93	Please ignore my previous comment...had misunderstood the question	2014-12-10 11:53:57		
7192	dgjji	93	Not working for many strings such as abac, adb, etc.	2014-12-10 11:53:57		
7193	admin	93	Check my solution... working perfect with all inputs.  public class removeacAndb { public static void main(String[] args) { int k = 0; int i = 0; String s = "acbadc"; char[] a = s.toCharArray();  while (i < a.length) { if (!(a[i] == 'a' && ((a[i + 1] == 'c') && i + 1 < a.length))) { if (a[i] != 'b') { a[k] = a[i]; k++; } } else i++; i++; } int p = 0; while (k > p) { System.out.print(a[p]); p++; } } }	2014-12-10 11:53:57		
7194	ufdxg	93	Potential bug in the program. program will crash for input "a" because of ( *(p+1) == 'c').	2014-12-10 11:53:57		
7195	dkebi	93	Wrote this python version of your code.	2014-12-10 11:53:57		
7196	rdfeo	93		2014-12-10 11:53:57		
7197	sqzqo	93		2014-12-10 11:53:57		
7198	fowai	93	It can be solved using two pointers thats it :-)	2014-12-10 11:53:57		
7199	eucmc	93		2014-12-10 11:53:57		
7200	eucmc	93		2014-12-10 11:53:57		
7201	nhibd	93	that's good	2014-12-10 11:53:57		
7202	tenuw	93	Great	2014-12-10 11:53:57		
7203	sqzqo	93	This seems to be fine for this specific problem, but we can't extend this solution to a generic solution using current approach.	2014-12-10 11:53:57		
7204	plapd	93	This has a trivial bug. Try input: 'c'. It will try to reference str[-1].	2014-12-10 11:53:57		
7205	ufdxg	93	Logic is simple: Take 2 pointers which initially points to the start of the array. Here first one represents the end of string without 'b' and 'ac' and first represents the current scan position. scan the array from the start to end if the current characters is 'b' or 'ac', increment only second pointer appropriately if the current characters is not 'b' and 'ac', swap characters pointed by two pointers and then increment both pointers. result will be the string from the start of the array to the location pointed by first pointer.	2014-12-10 11:53:57		
7206	fowai	93		2014-12-10 11:53:57		
7207	dgjji	93		2014-12-10 11:53:57		
7208	rrmeu	93	you have to replace them in-place with what? I think this too straight forward or am i missing something?	2014-12-10 11:53:57		
7209	rrmeu	93		2014-12-10 11:53:57		
7210	dgjji	93		2014-12-10 11:53:57		
7211	admin	93	Input : x a b c y  Start iteration : for 'x' : flag = 0 for 'a' : flag = 1 for 'b' : remove b and set flag = 0 for 'c' : nothing since flag is 0 for 'x' : nothing since flag is 0  Your output : xacy Desired Output : xy	2014-12-10 11:53:57		
7212	sqzqo	93	In the example in the question says abc-> ac NOT an empty array. for your input "x a b c y" the desired result would be "x a c y"	2014-12-10 11:53:57		
7213	jippy	93		2014-12-10 11:53:57		
7214	ewigy	93		2014-12-10 11:53:57		
7215	dgjji	93		2014-12-10 11:53:57		
7216	bexbp	93		2014-12-10 11:53:57		
7217	sgiwy	93		2014-12-10 11:53:57		
7218	dgjji	93		2014-12-10 11:53:57		
7219	azmjc	93	private static string ReplaceString(char[] toreplace) { int totalIndex = toreplace.Count(); int writeIndex = 1; if (toreplace[0] == 'b') { writeIndex = 0; }  for (int i = 1; i < totalIndex; ++i) { if (toreplace[i] == 'b') { continue; }  if (toreplace[i] == 'c') { if (toreplace[writeIndex - 1] == 'a') { writeIndex--; continue; } }  toreplace[writeIndex] = toreplace[i]; writeIndex++; }  return new string(toreplace, 0, writeIndex); }	2014-12-10 11:53:58		
7220	qywrh	93	Logic: -Traverse array -check each char for 'a' or 'b' -in case found 'b' delete it and continue traversing -in case found 'a' check for next char -in case after 'a' next char is not 'b' continue -in case after 'a' next char is 'b' check for this 'b' next char -in case after 'a' next char is 'b' and 'b's next char is not 'c' then delete 'b' and continue traversing - in case after 'a' next char is 'b' and 'b's next char is 'c' then delete 'abc' and continue traversing  conclusion: search for occurrence of 'a' or 'b' in case 'b' comes first delete it or check whether 'abc' pattern is there.... if yes.... delete it.	2014-12-10 11:53:58		
7221	ftfck	93	Doubt: if input is "abcd" then the output should "d" or "acd"	2014-12-10 11:53:58		
7222	sgiwy	93	as mentioned in qus:  Examples: abc -> ac ac->'' react->rt  it seems for i/p 'abcd' should be 'd'.... not sure... Question filler [jeso]'s input required...	2014-12-10 11:53:58		
7223	eucmc	93	I have similar doubt ...	2014-12-10 11:53:58		
7224	rdfeo	93	really?? with abc -> ac already given to you??  obviously, abcd -> acd holds true in current context.	2014-12-10 11:53:58		
7225	ethan	93	This is my efforts for to solve this problem.	2014-12-10 11:53:58		
7226	zeice	93		2014-12-10 11:53:58		
7227	xhgls	93		2014-12-10 11:53:58		
7228	tenuw	93		2014-12-10 11:53:58		
7229	dgjji	93		2014-12-10 11:53:58		
7230	sqzqo	93	As you are using stack this is not inplace.. Space complexity O(n)	2014-12-10 11:53:58		
7231	bjsiw	93	in Scala solution is simple 4-liner:	2014-12-10 11:53:58		
7232	ufdxg	93		2014-12-10 11:53:58		
7233	vanul	93		2014-12-10 11:53:58		
7234	eucmc	93	}	2014-12-10 11:53:58		
7235	bjsiw	93		2014-12-10 11:53:58		
7236	bjsiw	93		2014-12-10 11:53:58		
7237	krxlv	93	Shouldn't it be a while(input[i] == 'b') and then increment i inside?	2014-12-10 11:53:58		
7238	gilit	93	char *str = "aaabbcccbaxc"; std::vector<char> myVector;  for (int i = 0; i < strlen(str); i++) { if(str[i] == 'c') { if(!myVector.empty()) { if(myVector.back() == 'a') myVector.pop_back(); else myVector.push_back(str[i]); } } else if(str[i] != 'b') myVector.push_back(str[i]); }  int i; char *str2 = new char[myVector.size() + 1]; for ( i = 0; i<myVector.size(); i++) str2[i] = myVector[i]; str2[i] = '\0';	2014-12-10 11:53:58		
7239	ftfck	93		2014-12-10 11:53:58		
7240	mrjku	93		2014-12-10 11:53:58		
7241	xhgls	93	}	2014-12-10 11:53:58		
7242	ethan	93	I think this code should solve this problem..  public static String eliminate(String data){ char[] strArr = data.toCharArray(); int len = strArr.length; int i = 0 ; while(len>0){ if(strArr[i]=='b') strArr[i]= ' '; if( i<data.length() && strArr[i]== 'a' && strArr[i+1]=='c') strArr[i] = strArr[i+1] = ' '; i++; len--; }  return new String(strArr); }	2014-12-10 11:53:58		
7243	rdfeo	93	Pure c style	2014-12-10 11:53:58		
7244	nwkeg	93		2014-12-10 11:53:58		
7245	jippy	93		2014-12-10 11:53:58		
7246	fowai	93	this is my solution:	2014-12-10 11:53:58		
7247	rrmeu	93		2014-12-10 11:53:58		
7248	eucmc	93		2014-12-10 11:53:58		
7249	nhibd	93		2014-12-10 11:53:58		
7250	huiqq	93		2014-12-10 11:53:58		
7251	nhibd	93		2014-12-10 11:53:58		
7252	ftfck	93		2014-12-10 11:53:58		
7253	sqzqo	93	This can be achieved in O(n)  private String remove(String s) { StringBuilder temp = new StringBuilder(); int len = s.length();  for(int i=0;i<len;i++) { if((s.charAt(i) != 'b') && (s.charAt(i) != 'a')) { temp.append(s.charAt(i)); }  if(s.charAt(i) == 'a') { if(s.charAt(i+1) == 'c') { i++; } else { temp.append(s.charAt(i)); } } }  return temp.toString(); }	2014-12-10 11:53:58		
7254	huiqq	93	/*Eliminate all b and ac in an array of characters, you have to replace them in-place, and you are only allowed to iterate over the char array once.  Examples: abc -> ac ac->'' react->rt*/  #include<stdio.h> int move=0;  int checkOut(int aPt,char *str) { int i,x=0,j; for(i=aPt+1;i<strlen(str);i++) { if(str[i]=='b') x++; else if(str[i]=='a') { j=i; i=checkOut(i,str); printf("%d %s\n",aPt,str); if(str[j+1]=='c') { move+=2+x; str[j-x]=str[j+2]; } return i; } else if(str[i]=='c') { str[i-x]='c'; move+=x; return i; } else return i; } }  int main() { char str[50]; int i,j,x=0; scanf("%s",str); for(i=0;i<strlen(str);i++) { printf("%d %d %s\n",i,move,str); if(str[i]=='b') x++; else if(str[i]=='a') { j=i; i=checkOut(i,str); if(str[j+1]=='c') { move+=2+x; if(j+2!=strlen(str)) str[j-x]=str[j+2]; } } else if(str[i]=='c') { str[i-x]='c'; move+=x; } else str[i-move]=str[i]; } str[strlen(str)-move]='\0'; printf("%d %s\n",move,str); }	2014-12-10 11:53:58		
7255	krxlv	93	/*Eliminate all b and ac in an array of characters, you have to replace them in-place, and you are only allowed to iterate over the char array once.  Examples: abc -> ac ac->'' react->rt*/  #include<stdio.h> int move=0;  int checkOut(int aPt,char *str) { int i,x=0,j; for(i=aPt+1;i<strlen(str);i++) { if(str[i]=='b') x++; else if(str[i]=='a') { j=i; i=checkOut(i,str); printf("%d %s\n",aPt,str); if(str[j+1]=='c') { move+=2+x; str[j-x]=str[j+2]; } return i; } else if(str[i]=='c') { str[i-x]='c'; move+=x; return i; } else return i; } }  int main() { char str[50]; int i,j,x=0; scanf("%s",str); for(i=0;i<strlen(str);i++) { printf("%d %d %s\n",i,move,str); if(str[i]=='b') x++; else if(str[i]=='a') { j=i; i=checkOut(i,str); if(str[j+1]=='c') { move+=2+x; if(j+2!=strlen(str)) str[j-x]=str[j+2]; } } else if(str[i]=='c') { str[i-x]='c'; move+=x; } else str[i-move]=str[i]; } str[strlen(str)-move]='\0'; printf("%d %s\n",move,str); }	2014-12-10 11:53:58		
7256	mrjku	93	#include<stdio.h> { int i,j;  }	2014-12-10 11:53:58		
7257	huiqq	93		2014-12-10 11:53:58		
7258	jippy	93		2014-12-10 11:53:58		
7259	fmzze	93		2014-12-10 11:53:58		
7260	ewigy	93		2014-12-10 11:53:58		
7261	xhgls	93		2014-12-10 11:53:58		
7262	wbqzu	93		2014-12-10 11:53:58		
7263	ufdxg	93	public static void main(String[] args) {  char []arr = {'r','b','x','y','c','c','c'}; int j=-1; for(int i=0;i<arr.length;i++){ if(arr[i]=='b'){ // arr[j]=arr[i+1]; continue; } if(arr[i]=='c' && arr[j]=='a'){ j-=1; continue; } j+=1; arr[j]=arr[i]; } System.out.println("Final length is:"+(j+1)); for(int i=0;i<=j;i++){ System.out.print(arr[i]+","); } }	2014-12-10 11:53:58		
7264	sqzqo	93	This should work fine ...	2014-12-10 11:53:58		
7265	ftfck	93		2014-12-10 11:53:58		
7266	tenuw	93		2014-12-10 11:53:58		
7267	nwkeg	93	{{ i=0 c=0  while i <array.len if a[i]=b then i++ elseif a[i]=a and i+1<array.len and a[i+1]=c and then i=i+2 else { a[c]=a[i] c++ }  }	2014-12-10 11:53:58		
7268	eucmc	93		2014-12-10 11:53:58		
7269	dkebi	93		2014-12-10 11:53:58		
7270	admin	93	Best solution.. Easy one.	2014-12-10 11:53:58		
7271	ftfck	93	Nice code... Thanks Champ :)	2014-12-10 11:53:58		
7272	bexbp	93	Great Code	2014-12-10 11:53:58		
7273	rrmeu	93	I think we can use prime numbers for this one.	2014-12-10 11:53:58		
7274	plapd	93	use two pointer char * write and char * scan, write points to the position to write, whereas scan points to the position to scan.	2014-12-10 11:53:58		
7275	nwkeg	93		2014-12-10 11:53:58		
7276	wbqzu	93		2014-12-10 11:53:58		
7277	nhibd	93	I was thinking about different solutions but didn't find any one of them generic for all such problems, so writing this solution of mine. I am planning to use a TRIE tree. Will create an TRIE tree using all pairs which can be replaced like b -> "" and ac ->"". TRIE will be something like	2014-12-10 11:53:58		
7278	fmzze	93		2014-12-10 11:53:58		
7279	xhgls	93		2014-12-10 11:53:58		
7280	nhibd	93		2014-12-10 11:53:58		
7281	qywrh	93		2014-12-10 11:53:58		
7282	ewigy	93		2014-12-10 11:53:58		
7283	ufdxg	93		2014-12-10 11:53:58		
7284	tenuw	93		2014-12-10 11:53:58		
7285	tenuw	93		2014-12-10 11:53:58		
7286	huiqq	93		2014-12-10 11:53:59		
7287	bexbp	93		2014-12-10 11:53:59		
7288	admin	93	Now we will start with our main string which is rabct 1. start pointer points to r and tries to find it in TRIE tree's first node, but no such thing is there 2. Then increment pointer and move to a, which is present in tree. 3. Move to b and try to find b in child tree of a, but no such thing is there. In this case we need to move to next node to a, which is b. 4. Search b in tree and we find it, now as next node of b is null, means we have our b and delete it from tree. But now there exist a pattern which start before b, so once we find a pattern, we start from current node - (height of TRIE tree - 1), which is 2 in our case, so move back to (node was b at 3rd node - 2 height of tree -1) which is again a. 5. Search a in TRIE and we have it. 6. Move to next node which is c (as b is deleted), search for c, which is there so delete ac, then move back to r. 7. Check for r, then move ahead and check for t. Then we are done.  In this case we assumed that everything will end up in "", but we can replace it with some different value by putting it at last node of TRIE tree for each path. This way we can make this solution generic and independent of whatever is given to us. As per my understand, complexity is O(n^m) where n is number of pattern and m is length of test string  Please give your valuable feedback.	2014-12-10 11:53:59		
7289	sqzqo	93	here c is child of a.	2014-12-10 11:53:59		
7290	vanul	93	// Replacing ac and b with blank. Once done, splitting, merging and converting to char[] again.  for(int i=0,j=-1;i<arr.length;i++){ switch(arr[i]){ case 'a' : j=i; break; case 'c' : if(j!=-1){ arr[j--] = ' '; arr[i] = ' '; } break; case 'b' : arr[i] = ' '; break; default : j=-1; break;  } }  String result = ""; for(String s : (new String(arr).split(" "))) result = result + s;  arr = result.toCharArray();  for(char c : arr) System.out.print(c+" ");	2014-12-10 11:53:59		
7291	bexbp	93	hi, please check this piece of code. If there is any issue in this	2014-12-10 11:53:59		
7292	mrjku	93		2014-12-10 11:53:59		
7293	vanul	93		2014-12-10 11:53:59		
7294	ethan	93	void removeChars(char *src){ char *i = src, *j = src; while ((*i++ = *j++)) { if(*(j-1) == 'b') i--; if((i-src) >=2 && *(j-1) == 'c' && *(j-2) == 'a') i-=2; } }	2014-12-10 11:53:59		
7295	krxlv	93		2014-12-10 11:53:59		
7296	huiqq	93		2014-12-10 11:53:59		
7297	ftfck	93	Good 1.. :)	2014-12-10 11:53:59		
7298	vanul	93	Using in-place stack - this is the only right solution and it actually works!	2014-12-10 11:53:59		
7299	admin	93		2014-12-10 11:53:59		
7300	rrmeu	93		2014-12-10 11:53:59		
7301	jippy	93		2014-12-10 11:53:59		
7302	gilit	93		2014-12-10 11:53:59		
7303	plapd	93	Simple java implementation	2014-12-10 11:53:59		
7304	fowai	93		2014-12-10 11:53:59		
7305	mrjku	93		2014-12-10 11:53:59		
7306	tenuw	93	#include <iostream> using namespace std;  void stringFilter(char *str) { int i,j=0; for(i=0;str[i]!='\0';) { if(str[i] =='b'){ i++; continue; } else if(str[i]=='a' && str[i+1] == 'c'){ i+=2; continue; } str[j++] = str[i++]; if(j>1 && str[j-2]=='a' && str[j-1] == 'c') j-=2; } str[j] = '\0'; } int main() { char str1[] = "abbbbd"; stringFilter(str1); cout << str1 << endl;  char str2[] = "acbac"; stringFilter(str2); cout << str2 << endl;  char str3[] = "aaac"; stringFilter(str3); cout << str3 << endl;  char str4[] = "react"; stringFilter(str4); cout << str4 << endl;  char str5[] = "aa"; stringFilter(str5); cout << str5 << endl;  char str6[] = "ababaac"; stringFilter(str6); cout << str6 << endl;  char str7[] = "aacacc"; stringFilter(str7); cout << str7 << endl;  char str8[] = "aacaccd"; stringFilter(str8); cout << str8 << endl;  return 0; }	2014-12-10 11:53:59		
7307	fmzze	93	simple O(n) implementation #include <iostream> using namespace std;  void stringFilter(char *str) { int i,j=0; for(i=0;str[i]!='\0';) { if(str[i] =='b'){ i++; continue; } else if(str[i]=='a' && str[i+1] == 'c'){ i+=2; continue; } str[j++] = str[i++]; if(j>1 && str[j-2]=='a' && str[j-1] == 'c') j-=2; } str[j] = '\0'; } int main() { char str1[] = "abbbbd"; stringFilter(str1); cout << str1 << endl;  char str2[] = "acbac"; stringFilter(str2); cout << str2 << endl;  char str3[] = "aaac"; stringFilter(str3); cout << str3 << endl;  char str4[] = "react"; stringFilter(str4); cout << str4 << endl;  char str5[] = "aa"; stringFilter(str5); cout << str5 << endl;  char str6[] = "ababaac"; stringFilter(str6); cout << str6 << endl;  char str7[] = "aacacc"; stringFilter(str7); cout << str7 << endl;  char str8[] = "aacaccd"; stringFilter(str8); cout << str8 << endl;  return 0; }	2014-12-10 11:53:59		
7308	plapd	93	simple O(n) implementation #include <iostream> using namespace std;  void stringFilter(char *str) { int i,j=0; for(i=0;str[i]!='\0';) { if(str[i] =='b'){ i++; continue; } else if(str[i]=='a' && str[i+1] == 'c'){ i+=2; continue; } str[j++] = str[i++]; if(j>1 && str[j-2]=='a' && str[j-1] == 'c') j-=2; } str[j] = '\0'; } int main() { char str1[] = "abbbbd"; stringFilter(str1); cout << str1 << endl;  char str2[] = "acbac"; stringFilter(str2); cout << str2 << endl;  char str3[] = "aaac"; stringFilter(str3); cout << str3 << endl;  char str4[] = "react"; stringFilter(str4); cout << str4 << endl;  char str5[] = "aa"; stringFilter(str5); cout << str5 << endl;  char str6[] = "ababaac"; stringFilter(str6); cout << str6 << endl;  char str7[] = "aacacc"; stringFilter(str7); cout << str7 << endl;  char str8[] = "aacaccd"; stringFilter(str8); cout << str8 << endl;  return 0; }	2014-12-10 11:53:59		
7309	sgiwy	93		2014-12-10 11:53:59		
7310	fmzze	93		2014-12-10 11:53:59		
7311	vanul	93	In the first pass remove all 'b' Then in the second pass search for a 'c' and once you find a 'c' then go back and look for its immediate 'a' and found delete it.	2014-12-10 11:53:59		
7312	nwkeg	93	@dashdash you can't have second pass. "you are only allowed to iterate over the char array once."  @jeso is it react->ret or rt?	2014-12-10 11:53:59		
7313	eucmc	93	public String removeBandAC(String s) { String s = s.removeAll(s,"b"); s = s.removeAll(s,"ac"); return s; }	2014-12-10 11:53:59		
7314	ethan	94	I'm assuming numbers between 1 and N. Generate a random number X in the range 1..N-K.length. Then, process the K array while we haven't seen X numbers.	2014-12-10 11:54:01		
7315	wbqzu	94		2014-12-10 11:54:01		
7316	rrmeu	94		2014-12-10 11:54:01		
7317	mrjku	94	runtime O(K), O(1) space	2014-12-10 11:54:01		
7318	huiqq	94	I'm not sure this solution works:  Take N=6, so that we have [1,2,3,4,5,6] as our range of valid numbers. Take K=[1,2,3], so that K.length = 3 Suppose when drawing x uniformly from [1, N-K.length] (e.g., [1,3]) we draw a 1, so that x = 1.  First iteration: i=0, K[i]=1, x=1, last=0 (K[i]-last > x) = true, so we return x + last = 1  The return value 1 is in K. How can this be correct? Please let me know what I missed...	2014-12-10 11:54:01		
7319	azmjc	94	"(K[i]-last > x) = true"  No. x = 1, K[0] - last = 1 - 0 = 1 which is not > x. So the cycle will ignore all values in K and return 1 + K[2] = 1 + 3 = 4	2014-12-10 11:54:01		
7320	cfzie	94	Ahh... some how I still had the >= bug in my mind. Thank you.	2014-12-10 11:54:01		
7321	eucmc	94	yeah, it sucks that the edit/remove feature is gone :s	2014-12-10 11:54:01		
7322	cfzie	94	What does the uniform() method do? Never seen it before in Java..	2014-12-10 11:54:01		
7323	cfzie	94	What would happen if elements in K are larger than N? Then wouldn't the probability you're looking for be greater than N - k.length? Since some of the elements in k are not applicable.	2014-12-10 11:54:01		
7324	ufdxg	94	"uniform()" is just a pseudo-code used by the author of the question. i just reused it. as the comment says, it generates a random number uniformly between 1 and X  The question is not entirely clear, but it doesn't make much sense if the elements in K would be greater than N. i think "probability of generated number should be 1/(N-K.length)" would be impossible	2014-12-10 11:54:01		
7325	mrjku	94	K is a sorted array that contains numbers from 0 to N. It seems to me (from Justin's example) that you are assuming K contains the first k numbers. That's wrong.	2014-12-10 11:54:01		
7326	jippy	94	you misread my approach. that was just an example. K should just contain numbers between 0 and N	2014-12-10 11:54:01		
7327	nhibd	94	Sorry , but isn't it much more simple way coding your approach ?  int RandNum( int N , vector<int> k) { int jumps = 0 ; int i = 0; int num = uniform(N - k.size()); while ( i < k.size() && jumps + num >= k[i]) { ++jumps; ++i; } return jumps + num ; }	2014-12-10 11:54:01		
7328	rdfeo	94	My approach is as follow:  -Transform K such that K[i] = number of integers 0.. K[i] missing before K[i] in K[] -Generate a random number x = uniform(0... N-K.length-1) -Find y = number of numbers equal to or less than x in K[], using binary search. -return x+y  Time = O(K.length) Space = O(1) Working C code below	2014-12-10 11:54:01		
7329	dkebi	94		2014-12-10 11:54:01		
7330	fowai	94		2014-12-10 11:54:01		
7331	ufdxg	94	best solution	2014-12-10 11:54:01		
7332	eucmc	94	You can make time complexity O(log(K.length)) if you skip the following loop:	2014-12-10 11:54:01		
7333	qywrh	94		2014-12-10 11:54:01		
7334	nhibd	94		2014-12-10 11:54:01		
7335	dkebi	94	and replace all the array accesses in getIndexEqualOrLess (K[idx]) with (K[idx] - idx)	2014-12-10 11:54:01		
7336	ufdxg	94		2014-12-10 11:54:01		
7337	fmzze	94		2014-12-10 11:54:01		
7338	xhgls	94	Sorry for indentation (I use GNU style, which mixedly use tab and space); and it should be vector<int> & instead of vector<int>	2014-12-10 11:54:01		
7339	nhibd	94	+1. this is very clean and easy to understand.	2014-12-10 11:54:01		
7340	admin	94	Can some one please explain the logic?	2014-12-10 11:54:01		
7341	gilit	94	K [0, 2, 3, 4], N = 5; In this case, pos is 0/1+1, consider pos = 1+1 =2; run through while loop. in the end, l = 3. return value 2+3-1 = 4; but it's there in the K. Correct me if I am wrong.	2014-12-10 11:54:01		
7342	xhgls	94	you might try binary search to identify if the randint(1,N) you flipped was in K[ ], and if it is... you...	2014-12-10 11:54:01		
7343	jippy	94	TBH I don't really understand the question. To me it's underspecified.  I thought it meant probability is 1 / ( N - k ) where k is the number of elements of K[ ] in the range 1 ... N  But it says k=K.length.	2014-12-10 11:54:01		
7344	wbqzu	94	even we assume the numbers in K[ ] are a subset of {1,...,N} and then use uniform prob 1/(N-k) we should be fine.  But the questions has weird cases. Division by zero. K.length > N. And I don't even know what prob 1/(N-K.length) means in most cases.	2014-12-10 11:54:01		
7345	ewigy	94	from the example given in the question, what we want is to select one number in the interval [0, N) except the numbers in array K. Hence, there are N - K.length valid numbers.  Example: N = 10 and K = [2,3, 5, 8]. We should give a random number of the set [0, 1, 4, 6, 7, 10] with 1/6 probability	2014-12-10 11:54:01		
7346	dgjji	94	:) Your code is great and upvoted, but I have a problem with the question (and questioner).  It is not at clear what is to be returned. It is not at clear what happens if N=2 and K=[6, 4.5, 2] Or N=3, K=[1,2,3]  Or what "k is less than N" in the comments of his code mean.  Based on his question we can even get negative probabilities.	2014-12-10 11:54:01		
7347	dgjji	94	And I don't see any examples from him.  Just function signature, and constraints (not "objective" just constraints).  And some code with some comments that don't match the previous signature and constraints.	2014-12-10 11:54:01		
7348	rrmeu	94	I'm assuming numbers between 1 and N. Generate a random number X in the range 1..N-K.length. Then, process the K array while we haven't seen X numbers.	2014-12-10 11:54:01		
7349	gilit	94		2014-12-10 11:54:01		
7350	eucmc	94		2014-12-10 11:54:01		
7351	zeice	94	runtime O(K), O(1) space	2014-12-10 11:54:01		
7352	rrmeu	94	can't edit or remove the post. there's a little bug >= should be >. fixed below	2014-12-10 11:54:01		
7353	nwkeg	94	I'm assuming numbers between 1 and N. Generate a random number X in the range 1..N-K.length. Then, process the K array while we haven't seen X numbers.   public int randomNumber(int N, int[] K) { // K is sorted int x = uniform(N - K.length); // 1 .. N - K.length int last = 0 , i; for (i = 0; i < K.length; i++) { if (K[i] - last > x) return x + last; x -= (K[i] - last - 1); // we've seen K[i] - last - 1 valid numbers last = K[i]; } return x + K[ K.length-1 ]; } runtime O(K), O(1) space	2014-12-10 11:54:01		
7354	wbqzu	94	can't edit or delete. please ignore. correct post below	2014-12-10 11:54:01		
7355	nwkeg	94	This problem is an extension of standard reservoir sampling	2014-12-10 11:54:01		
7356	dgjji	94		2014-12-10 11:54:01		
7357	mrjku	94		2014-12-10 11:54:01		
7358	wbqzu	94	the signature is	2014-12-10 11:54:01		
7359	mrjku	94		2014-12-10 11:54:01		
7360	wbqzu	94		2014-12-10 11:54:01		
7361	nhibd	94	I think the trick is to get random number in range [0, N - K.length()] and if the random number is present in K, then you add random number's position in K to N - K.length().	2014-12-10 11:54:01		
7362	bexbp	94		2014-12-10 11:54:01		
7363	bjsiw	94		2014-12-10 11:54:01		
7364	mrjku	94	I think there exists cases where the above code produces invalid value: Let N= 1, 2, 3, 4 and K=1, 3, 4 Now, let assume that the randomly generated number is 1. Hence: rnd=1%(4-3)=1 such that pos=0 This results in a return value to be 4-3+0=1. However, 1 is an element of K. Please correct me if I am misinterpreting this solution.	2014-12-10 11:54:01		
7365	fowai	94		2014-12-10 11:54:01		
7366	ethan	94		2014-12-10 11:54:02		
7367	fowai	94	This solution doesn't take into account the possibility of duplicates in K. We can handle that in the beginning like how I handled the case where there's elements greater than N.	2014-12-10 11:54:02		
7368	krxlv	94	good one too	2014-12-10 11:54:02		
7369	bexbp	94	This seems to have an error. Here is another solution, along similar lines.  public static int getRandom(int n, int[] k) { int length = k.length; while (length > 0 && k[length - 1] > n) { length--; }  if (length >= n) { throw new IllegalArgumentException("Sample space of size 0"); }  int draw = new Random().nextInt(n - length);  System.out.println("draw=" + draw);  int current = -1; int j = 0; for (int i = 0; i <= draw; i++) { current++; while (j < length && k[j] < current) { j++; } while (j < length && k[j] == current) { current++; j++; } }  return current; }	2014-12-10 11:54:02		
7370	ftfck	94	I assume that each number in k is at most once, that size of k < n. The idea is to return the i-th allowed number where i is a random number in the interval 0, n - k.size().	2014-12-10 11:54:02		
7371	qywrh	94		2014-12-10 11:54:02		
7372	ufdxg	94		2014-12-10 11:54:02		
7373	sqzqo	94		2014-12-10 11:54:02		
7374	sqzqo	94		2014-12-10 11:54:02		
7375	sgiwy	94	I forgot the necessary index decreasing:	2014-12-10 11:54:02		
7376	ftfck	94		2014-12-10 11:54:02		
7377	ftfck	94		2014-12-10 11:54:02		
7378	ewigy	94	consider the following (in pseudo code):	2014-12-10 11:54:02		
7379	fowai	94		2014-12-10 11:54:02		
7380	cfzie	94		2014-12-10 11:54:02		
7381	gilit	94	space: O(1) - no arrays time: O(N) - because K is sorted, we can get all the numbers which are not in K by iterating on it, and find the missing numbers  Why does this works: * Assume that N=10, K=[0,1,2,5,7,8] , N-K.size = 4 * We iterate over the numbers: 3,4,6,9 * Let's calculate the probability for returning the number 3 (the first one): 1/(N-K+index) = 1/4 * Let's calculate the prob for returning the number 4 (the second one): We haven't returned 3 in the first round - the probability for that is: 3/4 We return the 4 in the second round: 1/(N-K-index) = 1/(10-6-1) = 1/3 Multiply the probs: 3/4 * 1/3 = 1/4 - same probability as the number 3 * You can continue with this method, and find out that all the numbers get the same probability	2014-12-10 11:54:02		
7382	jippy	94	I forgot the necessary index decreasing:	2014-12-10 11:54:02		
7383	cfzie	94		2014-12-10 11:54:02		
7384	xhgls	94		2014-12-10 11:54:02		
7385	bexbp	94		2014-12-10 11:54:02		
7386	sgiwy	94		2014-12-10 11:54:02		
7387	azmjc	94	Memory O(1) run-time O(n)	2014-12-10 11:54:02		
7388	zeice	94		2014-12-10 11:54:02		
7389	fmzze	94		2014-12-10 11:54:02		
7390	sqzqo	94		2014-12-10 11:54:02		
7391	rrmeu	94		2014-12-10 11:54:02		
7392	cfzie	94	The main idea is to find the Xth number that not appear in the k array:  int getrandom(int N, int k[], int length) { int x = uniform(N - length), count = k[0] - 1; for(int i = 0; i < length - 1; i++) { if(i == 0 && x <= count) { return x; } count += (k[i + 1] - k[i] - 1); if(x <= count) { return k[i + 1] - (count - x + 1); } } return k[length - 1] + x - count; }	2014-12-10 11:54:02		
7393	nwkeg	94		2014-12-10 11:54:02		
7394	mrjku	94		2014-12-10 11:54:02		
7395	ftfck	94		2014-12-10 11:54:02		
7396	mrjku	94		2014-12-10 11:54:02		
7397	ftfck	94	#include <iostream> #include <fstream> #include <vector> #include <stdlib.h> #include <time.h>  using namespace std;  int getRandom(int N, vector <int> K){  int L = N-K.size(); cout << L << endl; int random_num = rand()%L; cout << random_num << endl; K.push_back(N); int prv = 0 , i = 0 , sum = 0; if ( random_num < K[0] ) return random_num; while ( (i < K.size()) && (sum < random_num) ) { sum += K[i]-prv-1; prv = K[i]; i++; } i--; return (K[i]-sum+random_num-1); }  int main() { int N; cin >> N; vector <int> K; int M; cin >> M; for ( int i = 0 ; i < M ; i++ ) { int tmp; cin >> tmp; K.push_back(tmp); } cout << getRandom(N, K) << endl; return 0; }	2014-12-10 11:54:02		
7398	ethan	94	Here is the simple java solution using binary search:	2014-12-10 11:54:02		
7399	nwkeg	94		2014-12-10 11:54:02		
7400	sqzqo	94		2014-12-10 11:54:02		
7401	zeice	94	O(logK) time, O(1) space.	2014-12-10 11:54:02		
7402	admin	94		2014-12-10 11:54:02		
7403	rdfeo	94		2014-12-10 11:54:02		
7404	jippy	94	Solution:  Generate rnum = uniform(N) and then keep doing binary search till rnum does not belong in K. (python code)	2014-12-10 11:54:02		
7405	tenuw	94		2014-12-10 11:54:02		
7406	cfzie	94		2014-12-10 11:54:02		
7407	gilit	94	We should return K[i]. Pr{K[i]} - probability return K[i]. Pr{K[0]} = Pr{K[1]} = ... = Pr{K[K.length - 1]} (from constraints). But Pr{K[0]} + Pr{K[1]} + ... + Pr{K[K.length - 1]} = 1 (from probability theory) So Pr{K[i]} = 1/N for i = 0..K.lenght - 1. So the only valid N = 2*K.length.  Am I right? Or didn't understand the question?	2014-12-10 11:54:02		
7408	huiqq	94	No idea. The way question is stated you can even make the computer cry by calling function with K[ ] which has length == K.length	2014-12-10 11:54:02		
7409	fmzze	94	N==K.length*	2014-12-10 11:54:02		
7410	ethan	94	from the example given in the question, what we want is to select one number in the interval [0, N) except the numbers in array K. Hence, there are N - K.length valid numbers.  Example: N = 10 and K = [2,3, 5, 8]. We should give a random number of the set [0, 1, 4, 6, 7, 10] with 1/6 probability	2014-12-10 11:54:02		
7411	eucmc	94	int RandomNum(int N, int K[]) { int num = N-K_length; srand (time(NULL)); int ret = rand() % num; for(int i=0; i<K_length && K[i]<=ret; ++i,++ret); return ret;	2014-12-10 11:54:02		
7412	admin	95	EDIT: this is actually wrong, see anantpushkar009's comments for discussion  A key insight is that this problem is the same as unweighted interval scheduling, just around a circle. Consider two line segments l1 and l2 represented by the following points:  l1: (p1, p2) l2: (p3, p4)  The only way that these line segments intersect is if p2 is "further along" on the unit circle than p3 or p4 is "further along" on the unit circle than p1. An nice way to represent distance on the unit circle is radians, which we can get by taking the inverse tangent of each point! One subtlety is that we need to normalize the tangent to a certain range: I'll use 0 to 2pi. In python:	2014-12-10 11:54:04		
7413	sqzqo	95		2014-12-10 11:54:04		
7414	cfzie	95		2014-12-10 11:54:04		
7415	dkebi	95	Now that we have a "transformed" set of line segments, each with a start and finish angle, the problem is identical to the greedy algorithm for maximum interval scheduling. Sort all the line segments by order of finish angle, add each line segment one at a time and remove all conflicting line segments with each iteration. (see an algorithms textbook for a proof):	2014-12-10 11:54:04		
7416	dgjji	95		2014-12-10 11:54:04		
7417	fmzze	95		2014-12-10 11:54:04		
7418	tenuw	95	If you wanted the original line segments, you could also store the mappings in a hash table in the transforming step.  Time complexity is O(nlogn) for the sorting step in the greedy algorithm	2014-12-10 11:54:04		
7419	ethan	95	Though the idea seems nice but I see 2 problems:  1. Minor problem: Interval scheduling works because start<end for all interval. The question no where states that the lines will be given such that start point will subtend smaller angle than the end point wrt x-axis. You seem to have made no effort to ensure that start angle < end angle for all intervals (consider a line segment starting at 0.9,-0.436 and ending at 0.9,0.436: we would rather prefer the other way round for interval scheduling to work here, otherwise, we get stuck in an infinite loop). This can be easily fixed by sorting new_point before appending it to transformed.  2.Major problem: Consider the following example:	2014-12-10 11:54:04		
7420	nhibd	95		2014-12-10 11:54:04		
7421	bjsiw	95		2014-12-10 11:54:04		
7422	fowai	95	If I understand you correctly, you will end up returning: [ [30,150] , [190,300]], even if the answer is: [[60,320] , [120,200] , [220,310]].	2014-12-10 11:54:04		
7423	ufdxg	95	I think idea is okay, the only difference is that unlike a real segment on a 1-dimension line, the segment on a circle has its "extreme", just the like the above example, the [60 320] should not treated as it is, but a transformation to [320 420] since they are the same on a given circle. And after such a transformation, the algorithm would give the right answer.	2014-12-10 11:54:04		
7424	vanul	95	hi,  I was thinking of the same approach but instead with a different transformation: "projecting all the segment points to the ox axis"	2014-12-10 11:54:04		
7425	ufdxg	95	This idea builds up from the solution given by yoavzimmerman (by reducing the given problem to unweighted interval scheduling problem by using angles instead of points). The problem with that was, it failed because of cyclic nature of intervals. We can get through that in the following way: 1. If there exists an angle at which no line exists, ie, if there exists theta such that a ray from origin at theta wrt x-axis passes through no line, we rotate x-axis by angle theta. Now we no more have any cyclic nature in the intervals. 2. If the above does not exist, we choose a pair of lines that intersect, say l1 and l2. Both of these can not be together in a solution. So, we apply interval scheduling on L-l1 and L-l2 (both of these set will satisfy the condition#1) and return the max of these two.  To check existence of theta, run a line sweep algorithm[O(n)]. The rest can be done in nlogn time. So, total complexity nlogn.  EDIT : As in the worst case, every ray from origin might intersect O(n) number of lines, the worst case complexity will be O(n^2 * logn)	2014-12-10 11:54:04		
7426	krxlv	95	Good catch, completely missed that problem.  I think you're very close, but I'm still not convinced that there are always a pair of lines that you can remove to make two subsets that satisfy condition #1. What about an extremely dense line segment set such as the following? (excuse the crude drawing, but I think it gets the point across)  i.imgur.(com)/AbhWaQd.png  We could draw try picking a random ray from the origin, then running interval scheduling on L-l for every line segment l that intersects it, then taking the max. I think that breaks the time complexity to O(n^2logn) though.  Thoughts?	2014-12-10 11:54:04		
7427	admin	95	You are right, I cannot think of a way to eliminate the need to remove every line and run the algorithm separately .As in worst case we may not have any angle that intersects less than O(n) lines ,the worst case complexity will be O(n^2 * logn)	2014-12-10 11:54:04		
7428	ewigy	95	After remove the first line, we don't have a good reason to remove another one. It's hard to argue both of them should not be in the solution. So it's hard to remove every line.  Instead of selecting starting point, we can select starting segment. Select one segment, consider all the segment intersecting with it. If all the intersected neighbors are not in the solution, then it must be in the solution. So we need to try all the neighbors and itself as starting segment, and find the best solution.  To improve speed, we may want to start with a segment with small number of neighbor. But I'm not quite sure how difficult it is compared to the original question.	2014-12-10 11:54:04		
7429	plapd	95	Now that I think about it, isn't this the same as finding the "maximum independent set", which is NP-hard?  To see this, first represent the line segments as a graph instead. Let each line segment be a vertex, and let there be an edge between 2 vertices if the corresponding line segments intersect. Isn't the original problem of finding the maximum subset of L equivalent to finding the maximum subset of vertices such that they cover the whole graph, without any 2 vertices being adjacent?	2014-12-10 11:54:04		
7430	krxlv	95	(Just realized Anna's comment below also mentions largest independent set and that this is NP hard)  Whoever that votes down that solution should probably leave a reason why it's wrong.	2014-12-10 11:54:04		
7431	qywrh	95	Since "maximum independent set" can be reduced to what you just mentioned. Doesn't it make this also NP-hard?	2014-12-10 11:54:04		
7432	mrjku	95	The segments are not arbitrary. It may be a special case of the maximum independent set problem.	2014-12-10 11:54:04		
7433	ethan	95	@Starbucks: No, because NP-hardness is established by taking an NP-hard problem and reducing it to the current problem in poly-time. Reducing the current problem to an NP-hard problem proves nothing. In fact, the whole point of NP-complete problems is that any problem in NP can be reduced to them in poly-time, so it's completely unsurprising if you should find such a reduction.	2014-12-10 11:54:04		
7434	jippy	95	Isn't this what Starbucks just said? Reducing Max independent set to this?	2014-12-10 11:54:04		
7435	dgjji	95	I think this problem can be solved using Dynamic Programming with O(N^2) time and O(N^1) space. (BUT I CAN BE WRONG...)  Assume it takes constant time to determine whether 2 lines intersect or not.  Consider case where there are N lines and the maximum subset of N lines among which no lines intersect is S(N).  Now let's add the (N+1)th line. The maximum subset of (N+1) lines among which no lines intersect, i.e. S(N+1), can only fall into following 2 case: 1) The (N+1)th line is not in S(N+1). In this case, S(N+1)_case1 = S(N)  2) The (N+1)th line is in S(N+1). In this case, in N iterations, we find out the lines which will intersect with the (N+1)th line, denoted by I(N+1). Then we exclude above lines from S(N), which gives S(N+1)_case2 = S(N) + (N+1)th line - I(N+1).  Then, the final S(N+1) must be max(S(N+1)_case1, S(N+1)_case2).  In sum, for each line we need N iterations to find out I(N) and we need a length-N array to store S(N), hence O(N^2) run time complexity and O(N^1) space.	2014-12-10 11:54:04		
7436	jippy	95	Above algorithm needs revision because I failed to consider that S(N) may not be unique.	2014-12-10 11:54:04		
7437	eucmc	95	Consider 5 segments: 2 vertical and 3 horizontal. In other words, we have the following intersecting pairs: (1, 3) (1, 4) (1, 5) (2, 3) (2, 4) (2, 5)  According to this approach, I believe we will have: S(1) = {1} S(2) = {1, 2} S(3) = {1, 2} S(4) = {1, 2} S(5) = {1, 2}  So we would picked the 2 vertical ones instead of the 3 horizontal ones.  The equation for S(N+1)_case2 = S(N) + (N+1)th line - I(N+1) should raise a red flag, because basically it's adding 1 line but taking away potentially many. S(N+1)_case2 would only be greater than S(N+1)_case1 if the N+1 line doesn't intersect with any line in S(N). So this is basically a greedy algorithm.	2014-12-10 11:54:04		
7438	bexbp	95	I was wrong.	2014-12-10 11:54:04		
7439	bexbp	95	I don't quite get the point why there's no optimal substructure. Do you have a counter example to guruqu's DP solution?	2014-12-10 11:54:04		
7440	ftfck	95	If a line were to be in optimal solution, since no other line should cross such line in a valid solution, it separate all end-points into two disjoint sets (smaller sub-problem), hence feasible for a divide-and-conquer approach.	2014-12-10 11:54:04		
7441	rdfeo	95	Let the lines be L1, L2,L3, ..., Ln. One idea is to define the sub problem as D(i, j, k) = max # of non intersecting line segments between Li & Lj using { L1, L2, ..., Lk }, then  D(i, j, k) = 0 if Li and Lj intersects (can be O(1)) max(D(i, j, k-1), D(i, k, k-1)+D(j, k, k-1))  Let F(i, j) =- D(i, j, n)  then for each Li, we find max F(i, j) among all Lj's that are on one side of Li +max F(i, j) among all Lj's that are on the other side of Li  Do this for each Li, and record the max  O(N^3)	2014-12-10 11:54:04		
7442	rdfeo	95	After digesting the comments by guruqu & gen-y-s, here's how I understood the dynamic programming solution.  (1) First convert each point to some angle such that they can be sorted, while keeping track of which segments they correspond to - O(n) (2) Sort the angles - O(nlogn) (3) You should now end up with an array (eg. [5 2 3 4 2 1 4 3 5 1]). The numbers correspond to the line segments. (4) Note that in the example above, {534} is the solution. Also notice how the "longest non-contiguous palindrome" in the array is 5x34xx435. It should be easy to see that the numbers constituting the "longest non-contiguous palindrome" are actually the same line segments as the solution. (5) Finally, due to the cyclic nature, the array could have been shifted like [2 3 4 2 1 4 3 5 1 5] instead. To accommodate this, you actually need to find the 2 "longest non-contiguous palindromes" in the array. In this case they are 34xx43 and 5x5. So the solution is simply the line segments from the 2 "longest non-contiguous palindromes". (6) The optimal substructure should now be obvious. Basically DP[i][j] contains the optimal solution from point i to point j (inclusive). You then build the DP matrix starting from length 1 to 2n. At each step, set DP[i][j] = (arr[i] == arr[j] ? 1 : 0) + (max(DP[i][k] + DP[k+1][j]) for k=i to j-1). Populating this matrix requires O(n^3) time.  The algorithm takes O(n^3) time and O(n^2) space. Hope I haven't missed anything.	2014-12-10 11:54:04		
7443	cfzie	95	Recursive procedure: For each segment s do: [segment s had broken circle into two sectors, s1 and s2] run recursive procedure on segment set that fully fit in s1 and similarly with s2, sum them up and plus one for selected one. Select max sum from for loop and return  Note. in the second recursion and on, selected segment will be breaking current sector into 3 sectors, so sum up from 3 recurcsive procedures.  Time analizes:  T(n) = n * 3T(n/3) T(1) = 1  n^log n. Which is better than exponentional needed for straight forward solution to coloring problem.  Now, we can enhaunce solution to each sector with caching. There should be O(n^2) of such sectors, so the time complexity should be O(n^2) because all the time solving this we are filling each cache entry and once done, the rest will complete.	2014-12-10 11:54:04		
7444	jippy	95	As discussed earlier, convert to angles. Now, _if there is a point_ on the circle which does not belong to any segment, rotate the set so that it become 0. Now we've got a "movie scheduling problem" from Skiena's book, which is solved by selecting the interval with the leftmost right border, eliminating intersections and then repeting until all the intervals are considered. Should be n*log(n).  The next is a wild guess, haven't had time to think over yet: If there is _no such a point_, maybe something like this will work: rotate so that the smallest sector starts at 0, apply the algorithm, above; then revert angels (i.e. go clockwise), so that we start from another side of the smallest sector and go opposite direction; repeate the algorimth and choose the best of two results. If there are multiple minimums, we may repeat it for each, so it's n^2. (However, not sure still if this is accurate for border conditions)	2014-12-10 11:54:04		
7445	admin	95	Thank for bringing up movie scheduling problem. The way I see the difference, the movie that starts after other movie starts but finishes before is not conflicting. Therefore I say that we recurse into 3 time intervals: before start, during movie, after movie. With the exception of first step that breaks circle into two. And instead of removing I am interested in the set of segments that begin and end within current sector. You can take a look at my solution. I like yours a lot, just don't understand the need for rotation.	2014-12-10 11:54:04		
7446	dgjji	95	This problem is O(n^2) solvable take a point on the circle (0,1) say.. now for each line get the two angles formed from the two end points w.r.t x axis, say (alpha, beta) such that alpha<beta so for each line you will get these angles (a0,b0), (a1,b1), (a2,b2).... sort them on their first index(O(nlogn) and then find the largest non-decreasing sequence on the second index..O (n^2)	2014-12-10 11:54:04		
7447	ufdxg	95	the alpha beta are arranged to be alpha<beta by switching the two end points	2014-12-10 11:54:04		
7448	xhgls	95	This is actually a conceptually simple problem to solve.  Since the lines are all on the unit circle, each line bisects the circle into two halves. For example, a horizontal (-1,0 to 1,0) line bisects the circle into 0->180 and 181 -> 359 degrees.  All lines that will intersect with this one must have one vertex in the first half and one vertex in the second. In the previous example, suppose we have a line where one vertex is at angle 90. If the line intersects then the second vertex must be between 181 and 359, Otherwise, the line is conceptually on the top of the unit circle and will not intersect.  Once this comparison is found, we can build a simple n^2 algo to search for lines that don't intersect anything. We have to leave the intersected lines in because there may be another line further in the list that only intersects with this one.	2014-12-10 11:54:04		
7449	sgiwy	95	My solution is based on the same observation. Because each segment creates two disjoint subset of segments that don't intersect it, divide and conquer solution is easy. You are welcome to take a look.	2014-12-10 11:54:05		
7450	rdfeo	95	Observation : 2 lines(x1,y1), (x2,y2) intersect iff on the circle x2 comes between x1 and y1 or wise verse. Assume all the lines are maked as (x1,y1), (x2,y2).....(xn,yn)  1. start from any point on the circle and move along the circle(circumfrance) to come back to same point, along the path keep the sequence of xi's as they come in the path. 2. Now again do the same process in the opposite direction but this time keep track of sequence of yi's along the path. now you name 2 sequances one of xi's and other yi's  now find the maximum matching sequence for (xi's ,yi's ) which will give you subset of maximum lines without overlap.	2014-12-10 11:54:05		
7451	gilit	95	We can sort all endpoints by angle (y = sin(a), x = cos(a)). Then we can build a graph where vertices are lines,edges are intersections. It is possible to do in O(n). So now we need to find the largest independent set. It is NP hard. One of possible heuristics is to find the most low-degree vertex, add it to the set, delete it and its neighbours from the graph. Repeat until it is possible.	2014-12-10 11:54:05		
7452	krxlv	95	Dynamic Programming. Should be O(n^3) time and O(n^2) space. State would be two dimensional DP(i,j) standing for maximum segments that can fit into [i,j]. State transition would be base on first segment of optimal solution in range [i,j]. DP(i,j) = argmax_k (1+DP(k_start+1,k_end-1)+DP(k_end+1,j)), seg k that fits in [i,j]. Mind some boundary cases, and hopefully this is clear enough for you guys.	2014-12-10 11:54:05		
7453	krxlv	95		2014-12-10 11:54:05		
7454	sgiwy	95		2014-12-10 11:54:05		
7455	zeice	95	You said DP(i,j) = argmax_k (1+DP(k_start+1,k_end-1)+DP(k_end+1,j)) Why don't you add DP(i,k_start - 1) to this sum?	2014-12-10 11:54:05		
7456	plapd	95	Anyway if I understand you right and DP(i,j) is max number of line segments which endpoints are between i and j (endpoints are sorted by angle) then there is another recursion: DP(i,j) = max(DP(i,j-1), DP(i+1,j), line + DP(i+1,j-1)), where line is 1 if there is a line segment with endpoints in (i,j), 0 if there is no such line segment. It seems to give O(n^2) in time.	2014-12-10 11:54:05		
7457	dgjji	95	Your state transition is wrong. Consider 0,5 1,2 3,4	2014-12-10 11:54:05		
7458	bexbp	95	Wrt. Your first comment. Since transition is base on first optimal seg in range. We don't need to add DP(i,kstart-1) this won't change result but making transition graph complicated.	2014-12-10 11:54:05		
7459	eucmc	95	Solution using DP is correct, and it would be O(N^2) time and space: DP(i, j) = max(DP(i, j-1), DP(i+1, j), DP(i-1, j-1)+line(i,j))	2014-12-10 11:54:05		
7460	zeice	95	Does it pass this test case? 1,2 3,4 Since that DP transition will give answer of 1 instead of correct answer 2.	2014-12-10 11:54:05		
7461	zeice	95	DP(i,j)= max( DP(i, i+k)+ line(i,i+k) + DP(i+k, j) + line(i+k, j)) for eack k in 0..j-i	2014-12-10 11:54:05		
7462	fmzze	95	The recursive formula, which can be computed using dynamic programming:  S[i, j] = line[i, j] + max( S[i, k] + S[k, j]) for each k=i+1...j-1  where line[i, j] = 1 if there is a line from point i to point j, otherwise 0  computing this will take O(N^3) and use O(N^2) space, since we need to compute the matrix S which contains N^2 values, and each cell computation would take O(N) time since we need to apply max on up to N values.	2014-12-10 11:54:05		
7463	nhibd	95	solution in python:	2014-12-10 11:54:05		
7464	bexbp	95		2014-12-10 11:54:05		
7465	xhgls	95		2014-12-10 11:54:05		
7466	gilit	95	Thanks for your nice solution and code !!!	2014-12-10 11:54:05		
7467	qywrh	95	Not sure if this works (especially since it's quite simple), so let me know if you can find a counter-example. (1) For each segment, count how many times it intersects with the other segments - O(n^2) (2) Sort the segments by their number of intersections - O(nlogn) (3) Iterate through the segments and include each segment as long as it doesn't intersect any of the current ones - O(n)  So O(n^2) total.	2014-12-10 11:54:05		
7468	rdfeo	95	This example would be a counter? tinyurl.com/psnzxtv	2014-12-10 11:54:05		
7469	huiqq	95	Thanks. Now I don't have to struggle to prove it. Here's another counter-example I found: (1) A vertical line segment (2) Another vertical line segment (3) A horizontal line segment that intersects both (1) & (2) (4) Another horizontal line segment that intersects both (1) & (2) (5) A line segment that intersects (1)  In this case, the optimal solution would be (5), (3), (4) but my algorithm would probably have returned (5), (2).	2014-12-10 11:54:05		
7470	ftfck	95	:)	2014-12-10 11:54:05		
7471	huiqq	95	I think your answer is close. My step 3 was different: (3) Iterate through the segments (from segments with most intersections to fewest) and remove them until there are no longer any intersections.	2014-12-10 11:54:05		
7472	eucmc	95	With the same 5-segments example I had above, these are how many intersections each segment has: (1) 3 intersections (2) 2 intersections (3) 2 intersections (4) 2 intersections (5) 1 intersection  With your approach, we would first remove (1). Then depending on the ordering, we might remove (3) & (4), thus ending up with (5) & (2), as opposed to the optimal solution of (5), (3), (4).	2014-12-10 11:54:05		
7473	sqzqo	96	If we observe the 2D matrix[6][5], we have integer values as (intVal) : a -> 0 b -> 1 e -> 4 f -> 5 . . . z -> 25 ===================== Map these 1D values to 2D index values.  Let [ _i ] [ _j ] be current position of cursor on matrix.  Let i be a row_no and j be col_no. ROW = 6; COL = 5;  for any alphabet 'input', find [i][j] like this i = intVal(input) / COL; j = intVal(input) % COL;  now first move (i - _i) horizontal steps, then move (j - _j) vertical steps. This can be printed also. After reaching to [i][j], print '!' (OK button), then update values of [ _i ] [ _j ] equal to [i][j].	2014-12-10 11:54:06		
7474	rdfeo	96	My solution was very similar (same principle):	2014-12-10 11:54:06		
7475	fmzze	96		2014-12-10 11:54:06		
7476	fmzze	96		2014-12-10 11:54:06		
7477	zeice	96	Hi, in both of your solutions, the position of x and y (row, column of a char) is not correctly determined.  it should be: x = char / MAX_ROWS; y = char % MAX_COLUMNS;	2014-12-10 11:54:06		
7478	vanul	96	The problem is that when you are at [v, w, x, y], you cannot move down; and when you are at [z], you cannot move right	2014-12-10 11:54:06		
7479	ewigy	96	@Anonymous - so always do left/right first and then handle the special z case to go up first.	2014-12-10 11:54:06		
7480	gilit	96	Where can we assume the initial position of cursor?	2014-12-10 11:54:06		
7481	nwkeg	96	[0,0]	2014-12-10 11:54:06		
7482	wbqzu	96	The most optimal sequence I believe, though it was not enforced during the interview.	2014-12-10 11:54:06		
7483	ewigy	96		2014-12-10 11:54:06		
7484	jippy	96		2014-12-10 11:54:06		
7485	ethan	96		2014-12-10 11:54:06		
7486	rrmeu	96		2014-12-10 11:54:06		
7487	huiqq	96	There can be multiple sequences. Do they want all such path or anyone?	2014-12-10 11:54:06		
7488	xhgls	96	we can map each alphabet to a coordinate.....create a list of coordinates and then apply djikstra to get to the next alphabet.	2014-12-10 11:54:06		
7489	huiqq	96	I think there will also be a special case for letter 'z'. There is only "up" direction possible from that location.	2014-12-10 11:54:06		
7490	rrmeu	96	my approach 1. Maintain a hashtable which stores char --> address 2. As there is no diagonal moment possible, the shortest distance from the current point to the target would be moving horizontally till we reach the column containing the target and moving vertically to the row containing the target.(increase/decrease x and increase/decrease y) 3. print out the sequence while moving and print ! once you reach the target.	2014-12-10 11:54:06		
7491	ewigy	96		2014-12-10 11:54:06		
7492	wbqzu	96		2014-12-10 11:54:06		
7493	fowai	96	Sorry I made a type that messed up the positioning. I think this one should work	2014-12-10 11:54:06		
7494	fowai	96		2014-12-10 11:54:06		
7495	huiqq	96		2014-12-10 11:54:06		
7496	mrjku	96		2014-12-10 11:54:06		
7497	sqzqo	96		2014-12-10 11:54:06		
7498	nwkeg	96	}	2014-12-10 11:54:06		
7499	admin	96	whats the getMove returns y-->z 1Down,4Left but there down is not possible at Y i guess it first goes down but there is no down there right?  i guess u need to move left or right first then down or up  so you y-->z will give 4Left and 1Down	2014-12-10 11:54:06		
7500	nwkeg	96	refer to my earlier reply for the approach	2014-12-10 11:54:06		
7501	nhibd	96		2014-12-10 11:54:06		
7502	ethan	96		2014-12-10 11:54:06		
7503	jippy	96	}	2014-12-10 11:54:06		
7504	wbqzu	96	First , I will put all alphabets in a two dimensional array , say , alphabets[6][5] , thus , alphabets[0][0] becomes 'a' and so on. Now , I will create a hashmap for all 26 alphabets mapping there location on two dimension array . I can do that by creating a class say ,Coordinates , having two instance variables int row and int column . So , it can be written like this , Map<Character,Coordinate> keys = new HashMap<Character, Coordinate>; Coordinate aobj = new Coordinate(0,0); // create obj for 'a', with row =0 , col =0 keys.put('a',aobj);  Or , we can simply put two digit integer and later retrieve the column and row from unit place and tens place respectively.  Now , lets say we have to write sequence for a word say 'word' , By using hashmap we will find location of 'w' is 4,2 and location of o is 2, 4 Travelling from 4,2 to 2,4 can be done in various ways , one way is to first traverse the difference in rows vertically , if difference of first-second is positive then upwards otherwise downwards , in this case ,4- 2=2 so two rows upwards , similarly for the columns can be done.	2014-12-10 11:54:06		
7505	ufdxg	96	I think the qns is same as that of finding a word in a given 2-D array. Use recursion and whenever we recurr for up, left. right or down print "up - 'u', down 'd', left 'l', right 'r' and enter '!" accordingly as per the call. This will give the complete sequence of moves.	2014-12-10 11:54:06		
7506	nwkeg	96	In C# --------	2014-12-10 11:54:07		
7507	xhgls	96		2014-12-10 11:54:07		
7508	dgjji	96		2014-12-10 11:54:07		
7509	mrjku	96		2014-12-10 11:54:07		
7510	eucmc	96		2014-12-10 11:54:07		
7511	jippy	96		2014-12-10 11:54:07		
7512	krxlv	96		2014-12-10 11:54:07		
7513	sgiwy	96		2014-12-10 11:54:07		
7514	azmjc	96		2014-12-10 11:54:07		
7515	huiqq	96	#python # I do not use any array I simply calculate the location #I I assume we stat in the top left ('a') def cinst(c,p): nc=ord(c)-97 np=ord(p)-97 y=(nc/5)-(np/5) x=(nc%5)-(np%5) print "c=%s p=%s nc=%d np=%d x=%d y=%d"%(c,p,nc,np,x,y) if y>0: for i in range(abs(y)): print 'D' else: for i in range(abs(y)): print 'U' if x>0: for i in range(abs(x)): print 'R' else: for i in range(abs(x)): print 'L' print 'Enter'  def get_word_sec(word): p='a' for c in word: cinst(c,p) p=c	2014-12-10 11:54:07		
7516	vanul	96	The problem is that when you are at [v, w, x, y], you cannot move down; and when you are at [z], you cannot move right	2014-12-10 11:54:07		
7517	dkebi	96		2014-12-10 11:54:07		
7518	ethan	96		2014-12-10 11:54:07		
7519	dkebi	96	Position of a given letter 'w' in the matrix will be:	2014-12-10 11:54:07		
7520	ufdxg	96		2014-12-10 11:54:07		
7521	krxlv	96		2014-12-10 11:54:07		
7522	rrmeu	96	Get the difference of current 'i' and new 'i' calculated using above formula,	2014-12-10 11:54:07		
7523	admin	96		2014-12-10 11:54:07		
7524	rrmeu	96		2014-12-10 11:54:07		
7525	bexbp	96	From here it's simple,	2014-12-10 11:54:07		
7526	rdfeo	96		2014-12-10 11:54:07		
7527	cfzie	96		2014-12-10 11:54:07		
7528	zeice	96	#include <iostream> #include <vector> #include <string> #include <math.h> using namespace std;   string wordPressed(string input) { string output; pair<int, int> key_pos(0,0); for(int i=0;i<input.size();i++) { int x = (input[i]-'a')%5; int y = (input[i]-'a')/5; int move_x = x-key_pos.first; if(move_x<0) output.insert(output.end(), abs(move_x), 'i'); else if(move_x>0) output.insert(output.end(), abs(move_x), 'r');  int move_y = y-key_pos.second; if(move_y<0) output.insert(output.end(), abs(move_y), 'u'); else if(move_y>0) output.insert(output.end(), abs(move_y), 'd'); output.insert(output.end(), 1, '!'); key_pos = pair<int, int>(x,y); } return output; }   int main() { string output = wordPressed("kkndkkndk"); cout<<output; }	2014-12-10 11:54:07		
7529	krxlv	96		2014-12-10 11:54:07		
7530	wbqzu	96		2014-12-10 11:54:07		
7531	huiqq	96	}	2014-12-10 11:54:07		
7532	azmjc	96	Another similar version with the C code above  #include <stdio.h> #include <stdlib.h>  void print_path(int src, int dst){ while(src != dst){ if(src%5 < dst%5){ src ++; putchar('r'); } else if(src/5 < dst/5){ src +=5; putchar('d'); } else if(src%5 > dst%5){ src --; putchar('l'); } else if(src/5 > dst/5){ src -=5; putchar('u'); } }  putchar('!'); putchar('\n');  }  void main(int argc, char *argv[]){  char *x; if(argc < 2){ x = "test"; } else{ x = argv[1]; } int src = 0; int dst = 0; while(*x != '\0'){ putchar(*x); putchar(':'); dst = *x - 'a'; print_path(src, dst); src = dst; x ++; }  }	2014-12-10 11:54:07		
7533	rrmeu	96	Looks like a graph, with each letter being a node. And we need to find the path from one node to the other using breadth first search and the nodes being the subsequent letters. Meaning if have a word "hello", we need to find the following paths: 1. "h" to "e" 2. "e" to "l" 3. "l" to "o"  Each node may have up to 4 children.	2014-12-10 11:54:07		
7534	dkebi	96		2014-12-10 11:54:07		
7535	huiqq	96		2014-12-10 11:54:07		
7536	eucmc	96		2014-12-10 11:54:07		
7537	fowai	96		2014-12-10 11:54:07		
7538	ufdxg	96		2014-12-10 11:54:07		
7539	ethan	96		2014-12-10 11:54:07		
7540	bjsiw	96		2014-12-10 11:54:07		
7541	wbqzu	96		2014-12-10 11:54:07		
7542	nhibd	96	I thin the question is not very difficult, and here is the code and it is self-explanatory:	2014-12-10 11:54:07		
7543	nwkeg	96		2014-12-10 11:54:07		
7544	zeice	96		2014-12-10 11:54:07		
7545	ufdxg	96	Given the map is 6*5 , given any character , you can find out which row/col it resides in, in O(1)	2014-12-10 11:54:07		
7546	rrmeu	96		2014-12-10 11:54:07		
7547	fmzze	96		2014-12-10 11:54:07		
7548	ftfck	96	public class Solution(){ public String getAction(String str){ int len = str.length(); str = str.toLowerCase(); StringBuffer buf = new StringBuffer(); int x = 0 , y = 0; for(int i = 0 ; i < len ; i++){ int t = str.charAt(i) - 'a'; int row = t/5; int col = t%5; while(row > y) { buf.append('u'); y++; } while(row < y) { buf.append('d'); y--; } while(col > x) { buf.append('r'); x++; } while(col < x) { buf.append('l'); x--; } buf.append('!'); } return buf.toString(); } }	2014-12-10 11:54:07		
7549	vanul	96		2014-12-10 11:54:07		
7550	fowai	96		2014-12-10 11:54:07		
7551	dgjji	96	Btw, the above code is written in Python.	2014-12-10 11:54:07		
7552	azmjc	96		2014-12-10 11:54:07		
7553	ewigy	96		2014-12-10 11:54:07		
7554	vanul	96		2014-12-10 11:54:07		
7555	ewigy	96		2014-12-10 11:54:07		
7556	nwkeg	96		2014-12-10 11:54:07		
7557	ewigy	96		2014-12-10 11:54:07		
7558	krxlv	96		2014-12-10 11:54:07		
7559	tenuw	96		2014-12-10 11:54:07		
7560	wbqzu	96		2014-12-10 11:54:07		
7561	bexbp	96		2014-12-10 11:54:07		
7562	bexbp	96	explanation or code comments please!!	2014-12-10 11:54:07		
7563	sgiwy	96	@Rakesh, IMO, you understood the question wrong, the input here is a word, that needs to be typed and we need to generate the sequence of 'up/down/left/right/!' key press sequence.	2014-12-10 11:54:07		
7564	ftfck	97		2014-12-10 11:54:09		
7565	dgjji	97		2014-12-10 11:54:09		
7566	ethan	97	Time: O(n), Space: O(1), Correctness: can be proved by mathematical induction.	2014-12-10 11:54:09		
7567	tenuw	97		2014-12-10 11:54:09		
7568	cfzie	97	I also think above code is not correct. Test case - 100, 7,5,8,4,9 I think the position swap should base on one sorted array. So first sort the array, and then from index =1, and swap near two number.	2014-12-10 11:54:09		
7569	zeice	97		2014-12-10 11:54:09		
7570	ewigy	97	@Top Coder, pls give an example	2014-12-10 11:54:09		
7571	huiqq	97	This is correct, and as stated by Jason, induction can be used to prove it.	2014-12-10 11:54:09		
7572	huiqq	97	To elaborate a little.  Suppose you have rearranged a_1, a_2, .., a_k to have the property.  The claim is that given a_{k+1}, you either have to do nothing, or swap with the last element (in the rearranged version of a_1, a_2, ..., a_k) to get a valid rearrangement of a_1, a_2, ..., a_k, a_{k+1}.	2014-12-10 11:54:09		
7573	bjsiw	97	Try with the input provided with the question itself. It gives incorrect results.	2014-12-10 11:54:09		
7574	ethan	97	Hey in both the if check...you are performing the same operation...M i missing out something ?	2014-12-10 11:54:09		
7575	gilit	97	@TOpcoder:  3,7,5,8,4,9 is a perfectly valid ouput. Why does it have match the _sample_ output?	2014-12-10 11:54:09		
7576	nwkeg	97	Probably would not work for 4, 3, 2, 1	2014-12-10 11:54:09		
7577	qywrh	97	This code is giving correct outputs for all the inputs I tried: ideone(.)com(/)EjnCSV But I still don't get the logic :)	2014-12-10 11:54:09		
7578	ftfck	97	@bakwasscoder, you can prove the algorithm using mathematical induction.	2014-12-10 11:54:09		
7579	krxlv	97	doesn't work for this input 9,8,0,3,1,-3,-1	2014-12-10 11:54:09		
7580	azmjc	97	You can solve this in O(n) time by finding the median of the array in O(n) using quickselect or the median-of-medians algorithm, and then placing numbers less than the median (in any order) in even positions (for a 0-indexed array), and numbers greater than the median (in any order) in odd positions. For elements equal to the median, distribute them between both even and odd slots that remain after placing the other elements. The correctness of this approach follows from the observations that every constraint on the final output is of the form a[some_odd_index] >= a[some_even_index], and that this construction ensures all odd indexes are >= the median and all even indexes are <= the median, therefore guaranteeing that all odd indexes are >= all even indexes.	2014-12-10 11:54:09		
7581	qywrh	97	the logic seems okay. using the selection algorithm to find median in O(n) would work.	2014-12-10 11:54:09		
7582	sgiwy	97	Sort the array in ascending order  Array.sort(inputArray);  Once sorted traverse the array for modifications and swap every two elements in the following logic  for(i=1; i<inputArray.length-2; i=i+2) { int temp = inputArray[i]; inputArray[i] = inputArray[i+1] inputArray[i+1] = input Array[i] }  This will result the array in required output. Please correct me if I am wrong.	2014-12-10 11:54:09		
7583	qywrh	97	i think nice logic ...	2014-12-10 11:54:09		
7584	vanul	97	I think condition should be for(i=1; i<inputArray.length-1; i=i+2)	2014-12-10 11:54:09		
7585	krxlv	97	Also, For - last line should be inputArray[i+1] = temp	2014-12-10 11:54:09		
7586	xhgls	97	Also, For - last line should be inputArray[i+1] = temp	2014-12-10 11:54:09		
7587	vanul	97	Dinesh, Your logic might simple, but the total time complexity is high. For Sorting O(n log n) for swapping n/2 approximately. But Jason and few others solutions is O(n)	2014-12-10 11:54:09		
7588	ewigy	97	Dinesh,  Your logic might simple, but the total time complexity is high. For Sorting O(n log n) for swapping n/2 approximately. But Jason and few others solutions is O(n).	2014-12-10 11:54:09		
7589	dkebi	97		2014-12-10 11:54:09		
7590	xhgls	97		2014-12-10 11:54:09		
7591	dgjji	97	int []{3,4,5,7,8,9}; output 3 <= 9 >= 4 <= 8 >= 5 <= 7	2014-12-10 11:54:09		
7592	rdfeo	97	Little modification to the merge sort will work for this 1) Divide the input as we do in the merge sort 2) While merging use a variable which is incremented on every merge operation 3) Use ascending order condition for merging if it is even or descending order when it is odd	2014-12-10 11:54:09		
7593	admin	97		2014-12-10 11:54:09		
7594	mrjku	97		2014-12-10 11:54:09		
7595	dkebi	97	Python code	2014-12-10 11:54:09		
7596	admin	97		2014-12-10 11:54:09		
7597	tenuw	97		2014-12-10 11:54:09		
7598	qywrh	97		2014-12-10 11:54:09		
7599	mrjku	97		2014-12-10 11:54:09		
7600	qywrh	97	Incorrectness: can be proved by unit test. The output will be 3 7 5 8 4 9. Who are these people who voted for this answer?	2014-12-10 11:54:09		
7601	sgiwy	97	About which answer r u commenting ?	2014-12-10 11:54:10		
7602	mrjku	97	1.Sort the given Array to make Array A 2.Add elements in new Array(B) in this order (a)Take two iterators which points to beginning and end of Array A (b)Fill B with element from beginning and then element from end (c)increment beginning and decrement end (d)Repeat step 2(b) until beginning < end B is our required result(Elements in Alternative Order) Running time: O(n log n) So if the input Array is 3 5 7 8 4 9 Then A = 3 4 5 7 8 9 B = 3 9 4 8 5 7 which is our output	2014-12-10 11:54:10		
7603	gilit	97	1) arrange the array in ascending order. 2)in another array,copy the first element,and then simply swap the other elements in 2s pair(consequetive).  array:a1,a2,a3,a4,a5...(in ascending order) answer in a new array: a1,a3,a2,a5,a4,....so on...	2014-12-10 11:54:10		
7604	cfzie	97		2014-12-10 11:54:10		
7605	fmzze	97		2014-12-10 11:54:10		
7606	sgiwy	97	}	2014-12-10 11:54:10		
7607	sqzqo	97	Java Code  Complexity O(n)	2014-12-10 11:54:10		
7608	rdfeo	97		2014-12-10 11:54:10		
7609	dkebi	97		2014-12-10 11:54:10		
7610	vanul	97	Just one case for clarification about b1<=b2>=b3<=b4 >=b5 <= b6 >= b7 >=b8 and so on. Am I correct, that it is NOT required to have following additional rule: b1 <= b3 <= b5 <= b7 and so on b2 <= b4 <= b6 <= b8 and so on	2014-12-10 11:54:10		
7611	qywrh	97	O(nlogn) Sort first, then swap elements from 1...n-2 [a(0-n-1)] array	2014-12-10 11:54:10		
7612	rdfeo	97		2014-12-10 11:54:10		
7613	tenuw	97		2014-12-10 11:54:10		
7614	rdfeo	97	CONSOLE: =========  Enter the size 20 Enter values 2 5 4 3 1 8 7 9 34 56 71 12 28 90 76 43 31 98 67 76 The less great sort array is : 1 3 2 5 4 8 7 12 9 31 28 43 34 67 56 76 71 90 76 98	2014-12-10 11:54:10		
7615	nhibd	97		2014-12-10 11:54:10		
7616	tenuw	97		2014-12-10 11:54:10		
7617	dkebi	97	internal void AlternateSort(int[] input) { bool findLower = false; var len = input.Length; int temp = 0; if (input[0] < input[1]) { findLower = true; } else { findLower = false; }  for (int i = 1; i < len -1; i++) { int j = i + 1; if (input[i] < input[j] && findLower == true) { temp = input[i]; input[i] = input[j]; input[j] = temp; } else if (input[i] > input[j] && findLower == false) { temp = input[i]; input[i] = input[j]; input[j] = temp; }  findLower = !(findLower); }  foreach (int i in input) { Console.Write(i + " "); } }	2014-12-10 11:54:10		
7618	nwkeg	97	The idea is that while traversing the array, you maintain a flag that indicates whether a "less than" or a "greater than" comparison should succeed. If it does not succeed you swap the previous index with the current index.  This will be easier to understand through an example. Let's say we have the above array {3, 2, 6, 4, 9, 7, 1, 10, 8, 5}. We traverse the array starting at the second element (2), since we'll be comparing the current with the previous element. We also have to maintain the above mentioned flag, say a flag named lessThan which will be defaulted to true since our format definition indicates that we have to start from a less than sign. So we have our element "2" and previous element "3". Is element "3" less than element "2" ? No, then we swap the elements which results in the array {2, 3, 6, 4, 9, 7, 1, 10, 8, 5}. We also have to switch the lessThan flag and then go to the next index. Now the flag tells us that we have to use the "greater than" sign. Is element "3" greater than element "6" ? No, then swap the numbers. But wait, what happens to the previous comparison ? The second index has to stay greater than the first one, but note that this did get verified by the condition that we just imposed by comparing "6" with "3". "6" is greater than "3", which is greater than "2" - this means "6" is greater than "2", thus it's safe swapping "6" with "3". This results in {2, 6, 3, 4, 9, 7, 1, 10, 8, 5}. This goes on until the end of the array.	2014-12-10 11:54:10		
7619	vanul	97	public static int[] convertLessMore(int[] a, int n) { boolean less = true;  for (int i=1; i < n ; i++) { if (less) { if (a[i-1] > a[i]) { swap(a, i-1, i); } } else { if (a[i-1] < a[i]) { swap(a, i-1, i); } }  less = !less; }  return a; }	2014-12-10 11:54:10		
7620	bjsiw	97	1) Sort array 2) Iterate through array, inserting into output array alternating between head and tail of sorted array.  Time: O(nlogn) Space: O(n)	2014-12-10 11:54:10		
7621	jippy	97	Sort than pairwise swap elements.. (nlogn)	2014-12-10 11:54:10		
7622	nhibd	97	Eugene posting some theoretical mumbo jumbo again without any real coding or psuedocode.	2014-12-10 11:54:10		
7623	tenuw	97	You can write the code yourself if you know the approach. Developing the approach is the more interesting and more difficult aspect. Keep in mind also that my solution was the first posted on this page to reach O(n) time -- at the time I posted, every other solution involved a sort, and I came up with my solution by thinking about how I could avoid sorting. Turns out there's an easier way to avoid sorting as seen in Jason's answer.	2014-12-10 11:54:10		
7624	sgiwy	97	Varun Sharma is an idiot.	2014-12-10 11:54:10		
7625	ftfck	97	I'm fairly confident it's not really him, but rather someone impersonating him. I've spoken to Varun before and I doubt he'd make such comments.	2014-12-10 11:54:10		
7626	dkebi	98	A node might not be an ancestor to its nearest leaf node.	2014-12-10 11:54:13		
7627	dkebi	98		2014-12-10 11:54:13		
7628	fowai	98		2014-12-10 11:54:13		
7629	vanul	98	In the above case, the nearest leaf node to 2 is 3.  We want to traverse the tree using DFS, storing the minimum height and the closest descendant leaf at each node:	2014-12-10 11:54:13		
7630	eucmc	98		2014-12-10 11:54:13		
7631	nhibd	98		2014-12-10 11:54:13		
7632	ethan	98	Then starting from the given node, we want to go up to the root and check the path which is the shortest.  So in this case, nearest leaf to 2 is at distance min(3, 1+1) = 2  Suppose the tree looked something like:	2014-12-10 11:54:13		
7633	plapd	98		2014-12-10 11:54:13		
7634	dkebi	98		2014-12-10 11:54:13		
7635	ewigy	98	Then the leaf closest to NLRLLR would be the corresponding leaf node to min(hNLRLLR, 1+hNLRLL, 2+hNLRL, 3+hNLR, 4+hNL, 5+hN)  O(N) time, O(N) extra space	2014-12-10 11:54:13		
7636	azmjc	98	Sorry for the bad formatting.	2014-12-10 11:54:13		
7637	eucmc	98	The question should be asking for 'a' nearest leaf node, because there can be many leaf nodes 'nearest' to the given node. For ex: full binary trees, say of sizes, 1, 3, 7, 15 etc have all the leaf nodes at the same height from the root and all are the nearest.  As far as the solution is concerned, doing a level order traversal from the given node and printing out the first leaf encountered should solve the problem.	2014-12-10 11:54:13		
7638	bjsiw	98	I don't think that would work. The nearest leaf node can be above the given node as well. Even if it's not, a leaf node just 1 level below might be very far while a leaf node 2 levels below might just be 2 nodes away.	2014-12-10 11:54:13		
7639	ewigy	98	>> The nearest leaf node can be above the given node as well  I only thought a parent and ancestors could be above a given node, I appreciate your thinking of leaves being above.	2014-12-10 11:54:13		
7640	nwkeg	98	Also, I think we have different notions of "nearest". My understanding is that distance is the length of the shortest path between two nodes.  So if you have	2014-12-10 11:54:13		
7641	azmjc	98		2014-12-10 11:54:13		
7642	tenuw	98		2014-12-10 11:54:13		
7643	zeice	98	then the distance between 2 and 8, 9, 10, 11 is 2. The distance between 2 and 6, 7 is 3. Your approach will give the answer 6 or 7, which is wrong.	2014-12-10 11:54:13		
7644	wbqzu	98	@Erasmus...	2014-12-10 11:54:13		
7645	jippy	98		2014-12-10 11:54:13		
7646	gilit	98		2014-12-10 11:54:13		
7647	plapd	98	In the above tree: For node 'D', nearest leaf = 'H'. However, using level order traversal, the first leaf encountered would be 'E', which is at a distance of 2.	2014-12-10 11:54:13		
7648	vanul	98	consider the following tree. and the node is F  . A / \ B C / \ / \ D E F G / / \ H I J / \ K L / \ / \ M N O P  get the path from the node to root. (O(N)). This path(F->C->A) is necessary to build 2nd tree. break it into two trees. 1. F / \ I J / \ K L / \ / \ M N O P and, 2. F \ C / \ A G / B / \ D E / H Now get the height of both the tree, take the minimum. O(N) size and O(N) time	2014-12-10 11:54:13		
7649	jippy	98	consider the following tree. and the node is F	2014-12-10 11:54:13		
7650	admin	98		2014-12-10 11:54:13		
7651	ufdxg	98		2014-12-10 11:54:13		
7652	qywrh	98	get the path from the node to root. (O(N)). This path(F->C->A) is necessary to build 2nd tree. break it into two trees.	2014-12-10 11:54:13		
7653	dgjji	98		2014-12-10 11:54:13		
7654	zeice	98		2014-12-10 11:54:13		
7655	qywrh	98	Now get the height of both the tree, take the minimum. O(N) size and O(N) time	2014-12-10 11:54:13		
7656	azmjc	98	May be Dijkstra's algorithm will help.	2014-12-10 11:54:13		
7657	cfzie	98	I have simple approach for the above problem...which are as 1. Find the height of the tree...(considering leaf node can be on any height for more than one node) 2.Now Traverse at each level from i=0 to each height of the tree...	2014-12-10 11:54:13		
7658	dkebi	98		2014-12-10 11:54:13		
7659	cfzie	98		2014-12-10 11:54:13		
7660	azmjc	98	you are done  My code goes like this... in c++	2014-12-10 11:54:13		
7661	ewigy	98		2014-12-10 11:54:13		
7662	admin	98		2014-12-10 11:54:13		
7663	ewigy	98	A more simple code than above .... doing preorder traversal and keeping the lowest leaf position	2014-12-10 11:54:13		
7664	rrmeu	98		2014-12-10 11:54:14		
7665	dkebi	98		2014-12-10 11:54:14		
7666	fmzze	98	First, do In-order traversal and for each leaf node, maintain its height and get height of node-of-interest as well. You need to do it for all leaf nodes because you don't know where your node-of-interest lies. - O(N) Now, find minimum difference between height of node-of-interest and height of leaf node and print the leaf with min difference - O(N)	2014-12-10 11:54:14		
7667	mrjku	98	The term "nearest" is quite vague. It is unclear whether it means level-wise, or predecessor/ancestor of a given node in sorted order of the values of the nodes. Following code addresses the nearest when it is interpreted as successor node of a given node. It is an O(n) algorithm:	2014-12-10 11:54:14		
7668	qywrh	98		2014-12-10 11:54:14		
7669	huiqq	98		2014-12-10 11:54:14		
7670	jippy	98	It can be simply turned into "predecessor" case by swapping the greater than with less than checks. However, if "nearest" is considered as nearest at the same level, then we essentially search for the right node of a node in a given level. It is apparent that all right nodes would have NULL nearest in such a case. The following is to address the level-order nearest. It is an O(lg n) algorithm.	2014-12-10 11:54:14		
7671	vanul	98		2014-12-10 11:54:14		
7672	ftfck	98		2014-12-10 11:54:14		
7673	nwkeg	98	If we have the pointer to required node, why not use BFS to traverse down from that node? BFS finds the shortest path length-wise between 2 nodes in a graph, so it is guaranteed to find the closest leaf.	2014-12-10 11:54:14		
7674	eucmc	98	what about BFS?	2014-12-10 11:54:14		
7675	ethan	98	You don't have the parent pointers. How will you apply BFS ?	2014-12-10 11:54:14		
7676	cfzie	98	As mentioned before a closest leaf can be above the current node, so BFS will wprk only if you have the parent ponter for every node (and not only left and right).  If so we can: 1. Find the specific node to start from (using a simple traversal algorithm). 2. Use BFS to calculate the shortest path to every leaf while treating the tree as a graph (it has left, right and parent). 3. To optimize the solution we will keep track of the shortest path untill now and once a traversal is longer than that there is no need to continue down/up that path.  Step 1 takes O(nlogn) Step 2 will take an aditional (worst case) O(nlogn) so total of O(nlogn) - however notice that step 3 will make sure that we do not actually travese the entire tree.	2014-12-10 11:54:14		
7677	gilit	98	three cases we need to take care of 1.) if the node in question is root 2.) if node is not the rott 3.) node itself is the leaf  because we have second case we need to keep a track of the paths from root to all the leafs and then provide the solution base on these 2 sub cases if the path were node is identified is the shortest pat or the lowest root path to leaf + rootpath to node is the shortest path.  proposed alogrithm is O(N) to traverse all the leafs and O(N) space to keep the track of node paths for each DFS from root	2014-12-10 11:54:14		
7678	bjsiw	98	Let's call our node v.  1. First, make a copy of the tree, let's call it T' 2. Next, reroot T' in v - it takes O(n) time 3. Run BFS from v. First discovered leaf it's the closest leaf to the v  All take O(n) time and O(n) additional space.	2014-12-10 11:54:14		
7679	rdfeo	98	node *nearest(node *p){  if(p==NULL) return;  if(p->left) node *lc=nearest(p->left); if(p->right) node *rc=nearest(p->right);  if level(lc)<level(rc) return lc; }   // label levels of nodes using breadth first traversal	2014-12-10 11:54:14		
7680	qywrh	98	We can traverse the given tree in O(n) to store all the leaf nodes in a table. Then, we ca use these values to find the closest leaf node to a given node. Its worst case scenario is O(n).	2014-12-10 11:54:14		
7681	vanul	98		2014-12-10 11:54:14		
7682	admin	98		2014-12-10 11:54:14		
7683	krxlv	98	Start a BFS from the given node as source node. The first leaf node we encounter will be the nearest leaf.	2014-12-10 11:54:14		
7684	eucmc	98		2014-12-10 11:54:14		
7685	tenuw	98		2014-12-10 11:54:14		
7686	azmjc	98	A recursive procedure is possible.  A leaf closest to a node is that leaf which is closest to its left child and closer than closest leaf of its right child; or is closest to its right child and closer than closest leaf of its left child.  Assume we have a procedure which returns closest child of a root	2014-12-10 11:54:14		
7687	mrjku	98		2014-12-10 11:54:14		
7688	vanul	98		2014-12-10 11:54:14		
7689	huiqq	98	More improvement is possible, however idea is to find leaf closest to left child, leaf closest to right child and chose one of the leaves which is closer;	2014-12-10 11:54:14		
7690	rrmeu	99	It seems like a dynamic programming, you need to save s(k,m) which is the minimum sum you get from k stable and the horses of 1 to m.  The relation is  s(k,m) = min over all j's of s(k-1,i)+number of black horses in [j,m]* number of white horses in [j,m]  The solution seems to be O(kn^2) time and o(n) space (by windowing over the table). I am really interested if someone has a better solution with lower time complexity.	2014-12-10 11:54:24		
7691	qywrh	99	can u please eloborate your expression. for s(k,m)	2014-12-10 11:54:24		
7692	krxlv	99	We can prove that if there is a run of consecutive horses of the same color, it is always optimal to place them into the same stable. Suppose there is some arrangement of horses violating this constraint. Consider these two horses and their two respective stables. If one of the two stables has fewer horses of the opposite color, the function we're optimizing would be increased by having both horses there. If the two stables have equally many horses of the opposite color, transferring one of the horses to the other stable does not change the value of the function. Therefore, we need not consider breaking up consecutive runs of horses of the same color, and we can reduce the N in the O(K *N^2) runtime to just the number of runs of horses of the same color.	2014-12-10 11:54:24		
7693	vanul	99	Let the horses are numbered from 1 to n with total k stables. We will calculate C(i,j) which is the minimum sum of products for i stables and j horses. The recursive relation would be:  C(i, j) = min { P(k,j) + C(i-1, k-1) } where, i ranges from 1 to k j ranges from 1 to n k ranges from j to i P(k,j) is the product of black and white horses in range k to j, when put in one stable.	2014-12-10 11:54:25		
7694	vanul	99	Can somebody help me understand this problem with examples? I could not understand 3rd condition.	2014-12-10 11:54:25		
7695	ewigy	99		2014-12-10 11:54:25		
7696	fowai	99		2014-12-10 11:54:25		
7697	huiqq	99	If you can make sure in each stable, only one type of horse [black/white] is stored, then the product will be Zero. This will lead to total sum of products to Zero which will be minimal. One possible approach is the have white horse in odd locations and black in even locations.	2014-12-10 11:54:25		
7698	ufdxg	99	What constraint do we have about the number of horses of each type in the stables? If there is none, we can keep a single type of horse in each stable by satisfying the first two conditions. This will result the product in 3 to be zero, hence minimum.	2014-12-10 11:54:25		
7699	nhibd	99	I think the issue comes when you have many horses in frequently alternating colors and fewer stables.	2014-12-10 11:54:25		
7700	huiqq	100	After reading through a bunch of these "solutions", I realized there are 3 common mistakes people make. You might want to make sure that none of these applies to your solution before posting it.  (1) Order is important. In other words, you can't just check whether A & B form an anagram of C (2) If the next character in A & B both match that of C, you can't just automatically advance the position in either A or B and move on. Consider A="ca" and B="cb". Your solution should return true for both C="cacb" and C="cbca". (3) If the next character in A & B both match that of C, you can't just insert this character into a queue and try to use it up, then advance the position in both A & B. Consider A="ca", B="cb" and C="cabc". If you insert 'c' into the queue and advance the position in both A & B, you will be able to match the subsequent 'a' and 'b' incorrectly.	2014-12-10 11:54:35		
7701	vanul	100		2014-12-10 11:54:35		
7702	rrmeu	100		2014-12-10 11:54:35		
7703	eucmc	100	there is a online judge for this question on leetcode, your code fails	2014-12-10 11:54:35		
7704	azmjc	100	My code is as follows, it passes LeetCode online judge. The code can be optimized by putting more work done in recursive calls. I choose to write more code and invoke less recursive calls to save time.  The idea is to scan strings from left to right and invoke recursive calls when there is two possible cases (i.e., string a and string b has the same character). The choice to pass string index instead of copies of substrings greatly saves time. The use of cache to store results of subproblems is key to improve performance. The running time of the given example has decreased from 15s to 0.07s on my laptop when cache is used.	2014-12-10 11:54:35		
7705	dkebi	100		2014-12-10 11:54:35		
7706	jippy	100		2014-12-10 11:54:35		
7707	ftfck	100	leetcode.com/onlinejudge#question_97	2014-12-10 11:54:35		
7708	ewigy	100		2014-12-10 11:54:35		
7709	admin	100		2014-12-10 11:54:35		
7710	bexbp	100	This seems correct and follows the approach of generating the interleavings. But it might end up generating all the interleavings before returning the final result.	2014-12-10 11:54:35		
7711	qywrh	100	In that case we can add this code snippet in the beginning of definition of interleavedStrings function	2014-12-10 11:54:35		
7712	bexbp	100		2014-12-10 11:54:35		
7713	ufdxg	100		2014-12-10 11:54:35		
7714	qywrh	100	Does this run on O(n)?	2014-12-10 11:54:35		
7715	mrjku	100	@pranaymahajan even with this condition how would it save the worst case of generating all interleavings. Lets say the final interleaving would be the deciding factor for true or false for the given questions. still we would land back to square one.  what say?	2014-12-10 11:54:35		
7716	bexbp	100	@mr i think you are right	2014-12-10 11:54:35		
7717	fowai	100	pretty simple use an array of 26 length initialize it to zero u can use 257 length also but it depends the type of character set you are using read string a "+1" for every character similarly for every character in b.Now start reading string c do "-1" for every character on array if at any time the value in array goes below 0 while doing -1 then it is not interleaved,after doing this do check whether whole array is agail zero or not if not again not interleaved. actualyy this problem is that finding whether c is a permutation of string "a+b".	2014-12-10 11:54:35		
7718	bexbp	100	for interleaving order must be same.  One thing I want to ask interleave means the strlen(str3) = strlen(str2) + strlen(str1) with order maintained?? If any other letter is present that is present none of str1 and str2 will not be considered as interleave right?	2014-12-10 11:54:35		
7719	sqzqo	100		2014-12-10 11:54:35		
7720	sgiwy	100		2014-12-10 11:54:35		
7721	qywrh	100	The solution is right, but I don't think it's O(n) solution, since the algorithm generates all possible interleaved results.	2014-12-10 11:54:35		
7722	rdfeo	100	Yep. By constructing every possible interleaving the complexity is exponential.	2014-12-10 11:54:35		
7723	tenuw	100	let A and B be two strings and C be interleaved string.. take three pointers each pointing to start of each string. char * a,b,c; a->A b->B c->C  while(*c!='\0'){ if(*a==*c){a++;} if(*b==*c){b++;} c++; } if(*a=='\0' && *b=='\0') { it is interleaved. }	2014-12-10 11:54:35		
7724	wbqzu	100	we need more checks since a and b both might contain few common characters in them which would dismangle the parameters and return false even when it should return true.  e.g. A -> bac B -> acd C -> bacadc	2014-12-10 11:54:35		
7725	sgiwy	100	I think, else should be there after if statement to prevent the above condition mentioned by _mr.	2014-12-10 11:54:35		
7726	ufdxg	100	You can make a slight variation to solve the issue `mr` stated.	2014-12-10 11:54:35		
7727	zeice	100		2014-12-10 11:54:35		
7728	gilit	100		2014-12-10 11:54:35		
7729	sgiwy	100	pl help me to understand..if(*n && *p==*n) condition...what is the meaning of this condition 'if( *n'....what it is being evaluated to... and if(!(*p || *m || *n))...what are we checking here? how the condition is evaluated here.	2014-12-10 11:54:35		
7730	ufdxg	100	sorry..this is incorrect	2014-12-10 11:54:35		
7731	bexbp	100	if both A & B have unique characters i.e. if string A contains a char c then c is not repeated either in A or B, ditto for the chars in B, then add chars of A & B in a hashset and check whether there is a char in C which does not belong to this hashset if not then C is an interleaved string made from A & B. For repeating characters or for the general case hashmap can be used with character being the key and count being the value, add the characters of A & B into the hashmap incrementing their respective count, for chars from C find them in the map and decrement the respective counts, at any stage if there is a char in C which is not in the map or in the end there is any char in map whose count is non zero then C is not interleaved else it is.	2014-12-10 11:54:35		
7732	wbqzu	100	Dump the string A and B into map <char, int> where char is key and int is number of occurrence of char ,at the time of dumping the string A and B if duplicate key found increase the int value by 1. Once dumping is done scan the third string C and check into the map if value field found 0 for any char then its not interleaving or it is.  please give me your feedback.	2014-12-10 11:54:36		
7733	bjsiw	100	I don't think you considered the fact that the order of A,B should be preserved in C	2014-12-10 11:54:36		
7734	ewigy	100	bool interleavedstring(char * str1, char * str2, char * str3) { for (i = 0; i < strlen(str3); i++) if ( strchr(str1, str3(i)) == null or strchr(str2, str3(i)) == null) return false; /* the char i in str3 is not found either in str1 nor in str2 hence we can conclude that the string str3 is not interleaved with string str1 and str2*/ return ture: /* the string is interleaved */ }	2014-12-10 11:54:36		
7735	wbqzu	100	Keep three pointers, one for each string..Always move pointer of string C..Move pointer of either A or B if they match with element pointed by C..If they do not match return false..That means no interleaving..Move pointer of A or B whichever equal to char pointed by pointer of C..If pointer of C reached its end and pointer of A as well as B should reach its end..if they don't return false..else return true..	2014-12-10 11:54:36		
7736	bjsiw	100	Just combine the string and find	2014-12-10 11:54:36		
7737	xhgls	100		2014-12-10 11:54:36		
7738	azmjc	100		2014-12-10 11:54:36		
7739	dgjji	100	Interleaving could start from Either string A or string B so before scanning C, we need to decide which string will go first out of A and B.	2014-12-10 11:54:46		
7740	sgiwy	100	you didn't understand my solution it say that first I combine both A and B and make string 1 and then I am comparing with C ie string2...	2014-12-10 11:54:46		
7741	bexbp	100	Interleaved means the relative ordering of characters in the strings must be the same. This solution just checks whether all characters are present in the right numbers	2014-12-10 11:54:46		
7742	sgiwy	100	in charsTracker[str1[i] - 'a']-- , what will happen in brackets [str1[i]-'a']....i.e why r we doing like this	2014-12-10 11:54:46		
7743	xhgls	100	Did the interview say an O(n) solution was possible? Or did he just say, can you do better?	2014-12-10 11:54:46		
7744	dkebi	100		2014-12-10 11:54:46		
7745	zeice	100		2014-12-10 11:54:46		
7746	vanul	100	This solution passes ('abc' , 'abc' ,'aabbcc') but your second example should fail (result is 6 chars input total 7 chars) The solution also passes ('abc', 'abbc', 'ababcbc')  not sure it is O(n) though..	2014-12-10 11:54:46		
7747	sgiwy	100	using System; using System.Collections.Generic; using System.Linq; using System.Text;  namespace ConsoleApp {  class Program {    static void Main(string[] args) { bool flag = false; string str1 = Console.ReadLine(); string str2 = Console.ReadLine(); string str3 = Console.ReadLine(); int count = 0; string final = str1 + str2; for (int i = 0; i < final.Length; i++) { for (int j = 0; j < str3.Length; j++) { if (str3[j] == final[i]) { flag = false; count++; break; } else { flag = true; } }  if (flag) { Console.WriteLine("sorry no match..."); break; }  }  if (!flag) { Console.WriteLine("matched..."); }              } } }	2014-12-10 11:54:46		
7748	azmjc	100	Much simpler Java solution	2014-12-10 11:54:46		
7749	mrjku	100		2014-12-10 11:54:46		
7750	xhgls	100		2014-12-10 11:54:46		
7751	bjsiw	100	It looks correct. Remove recursion and try to do it using iterations. Then space complexity will reduce to o(1)	2014-12-10 11:54:46		
7752	jippy	100	I don't think this works.  This algorithm always takes chars from str1 if it looks like a match. But this can get us into trouble.  Suppose str1 is 'abx' and str2 is 'aby'. Suppose the third string is 'abyabx'. This should return True, but since your algorithm begins by feeding off of str1 instead of str2, it will return False.  Am I missing something?  (I have a proposed solution in the comments that uses recursive backtracking to handle the case of both strings locally matching.)	2014-12-10 11:54:46		
7753	ftfck	100	this is very simple code takes only O(n).	2014-12-10 11:54:46		
7754	gilit	100		2014-12-10 11:54:46		
7755	bjsiw	100		2014-12-10 11:54:46		
7756	nhibd	100	}	2014-12-10 11:54:46		
7757	ethan	100	This's is incorrect. how about A='aaa' B='ab' and C='abaaa' ? Ur solution would give false, which is clearly not the case	2014-12-10 11:54:46		
7758	zeice	100	Think this should work...have tried it on a few test cases and looks OK so far.	2014-12-10 11:54:46		
7759	nhibd	100		2014-12-10 11:54:46		
7760	fmzze	100		2014-12-10 11:54:46		
7761	bjsiw	100	def is_interleaved(astr, bstr, cstr): """Given three strings, a, b and c, check if c is interleaved from a and b. For example: a = "abcd", b = "xyz", c = "axbyzcd" => True. Give a O(n) algorithm""" ai = bi = 0 for ci in range(len(cstr)): if ai < len(astr) and cstr[ci] == astr[ai]: ai += 1 elif bi < len(bstr) and cstr[ci] == bstr[bi]: bi += 1 else: return False  return True	2014-12-10 11:54:46		
7762	krxlv	100	First, the interleave preserves relative order of the inputs; this greatly simplifies the problem:	2014-12-10 11:54:46		
7763	bjsiw	100		2014-12-10 11:54:46		
7764	nwkeg	100		2014-12-10 11:54:46		
7765	bjsiw	100		2014-12-10 11:54:46		
7766	tenuw	100		2014-12-10 11:54:46		
7767	admin	100	is ur sol. O(n^2) or O(2^n) ???	2014-12-10 11:54:46		
7768	krxlv	100	@jiangok2006 - is ur sol. O(n^2) or O(2^n) ???	2014-12-10 11:54:46		
7769	ftfck	100		2014-12-10 11:54:46		
7770	vanul	100		2014-12-10 11:54:46		
7771	qywrh	100	I think this should run in complexity =O(3n)~ O(n). But then it will i think depend on the length of the string how does this constant factor matters. Please suggest if it does not work for any test string.	2014-12-10 11:54:46		
7772	nwkeg	100	Why to create 2 maps just combine S1 and S2 and create a single map but first of check length of S1+S2 and S3 are same	2014-12-10 11:54:46		
7773	sqzqo	100	Order is also an important part in this question. It will unable to detect the order.	2014-12-10 11:54:46		
7774	admin	100	Mine sol solves it in O(n)	2014-12-10 11:54:46		
7775	fowai	100	1) Check the character count(A+B) and C 2) Take first character and last character in 'C' and then check it in one of the smallest string out of A and B. 3) Apply XOR operation to A+B and also apply to C and check the both values are true or false.	2014-12-10 11:54:46		
7776	azmjc	100	use hashmap to store the characters in a and b along with their indices. use another hashmap to store characters in c and their indices. for each character in c then, just retrieve the values and check whether the index of that character in a or b is lesser then or equal to the index in c. if it is so return true else return false here is the code	2014-12-10 11:54:46		
7777	nhibd	100		2014-12-10 11:54:46		
7778	jippy	100		2014-12-10 11:54:46		
7779	huiqq	100	It will take O(N)	2014-12-10 11:54:46		
7780	krxlv	100	Consider the strings are: ab, ab, abba  The indices are: a - 0, b - 1; a - 0, b - 1; a - 0,4, b - 1,2  Based on your logic, this comes out to be true, which it is not.	2014-12-10 11:54:47		
7781	tenuw	100	/// public static boolean isInterleaved(String A, String B, String C) { int a = 0; int b = 0; int c = 0; for(; c < C.length(); c++) { if(a < A.length() && C.charAt(c) == A.charAt(a)) { a++; } else if(b < B.length() && C.charAt(c) == B.charAt(b)){ b++; }else{ return false; } } return true; } \\\	2014-12-10 11:54:47		
7782	xhgls	100		2014-12-10 11:54:47		
7783	ufdxg	100		2014-12-10 11:54:47		
7784	qywrh	100		2014-12-10 11:54:47		
7785	eucmc	100		2014-12-10 11:54:47		
7786	huiqq	100	boolean isInterleaved(String a, String b, String c) { int a_index = 0; int b_index = 0;  for(int i = 0; i < c.length(); i++) { if(a_index < a.length() && a.charAt(a_index) == c.charAt(i)) { a_index++; continue; }  if(b_index < b.length() && b.charAt(b_index) == c.charAt(i)) { b_index++; continue; }  return false; }  return true; }	2014-12-10 11:54:47		
7787	krxlv	100	does not work if A and B have few common characters	2014-12-10 11:54:47		
7788	tenuw	100	My java solution: public boolean isInterleaved(String s1, String s2, String s3){ if(s1 == null || s2 == null || s3 ==null){ return false; }  if((s1+s2).length() != s3.length()){ return false; }  int j = 1; int k = 0; String sj = ""; String sk = ""; int len1 = s1.length(0 - 1; int len2 = s2.length() - 1; int len3 = s3.length() - 1; if((s1.charAt(0) == s3.charAt(0)) && (s1.charAt(len1) == s3.charAt(len3))){ sk = s2; sj = s1; } else if((s2.charAt(0) == s3.charAt(0)) && (s2.charAt(len1) == s3.charAt(len3))){ sk = s1; sj = s2; } else { return false; }  for(int i = 1; i < len3 -1; i++){ if(sk.charAt(k) == s3.charAt(i)){ k++; } else if(sj.charAt(j) == s3.charAt(i)) { j++; } else { return false; } } return true; }	2014-12-10 11:54:47		
7789	admin	100	Solution in Python. This uses recursive backtracking to handle the cases where there are local matches from str1 and str2, and we don't know which one to use before-hand. It it not O(n). Are there any solutions in these comments that are linear (and really work)?	2014-12-10 11:54:47		
7790	nhibd	100		2014-12-10 11:54:47		
7791	ftfck	100		2014-12-10 11:54:47		
7792	ftfck	100	simple O(n) algo. passes all test cases. algo: 1) traverse the COMBO once for each string(A and B) 2) if the char is in A make it null and move on the next char of A. 3)repeat for this for string B. 4) check if COMBO has been converted to null.  code:(in c++)	2014-12-10 11:54:47		
7793	rrmeu	100		2014-12-10 11:54:47		
7794	jippy	100		2014-12-10 11:54:47		
7795	plapd	100	I think we can solve this problem following three steps: First : check Histogram for a+b and c is the same O(N); Second: remove duplicate character from a,b,and c. E.G. "AAA" after remove duplicate "A" O(N) Third: check a and b is orderly contained in c O(N)	2014-12-10 11:54:47		
7796	rdfeo	100		2014-12-10 11:54:47		
7797	cfzie	100		2014-12-10 11:54:47		
7798	cfzie	100		2014-12-10 11:54:47		
7799	ewigy	100		2014-12-10 11:54:47		
7800	mrjku	100	#include<stdio.h> #include<string.h> int interl(char *A,char *B,char *C) { int l1 = strlen(A); int l2 = strlen(B); int l3 = strlen(C); if(l3 != (l1+l2)) return 0; while(*C != '\0') { if(*A != '\0' && *A == *C) A++; else if(*B != '\0' && *B == *C) B++; else return 0; C++; } return 1; } int main() { while(1){ char A[10],B[10],C[20]; scanf("%s%s%s",&A,&B,&C); interl(A,B,C)>0?printf("YES"):printf("NO");}  }	2014-12-10 11:54:47		
7801	qywrh	100		2014-12-10 11:54:47		
7802	jippy	100		2014-12-10 11:54:47		
7803	rdfeo	100	put the conflict one into a queue	2014-12-10 11:54:47		
7804	plapd	100	yeah.......ur right	2014-12-10 11:54:47		
7805	sqzqo	100	given string a, b and s, start from the beginning of them, if no conflict, shift. conflict: a[i] == b[j] == s[k], put this char into queue and continue.note: match the char in queue with s first	2014-12-10 11:54:47		
7806	xhgls	100	how about A = abc B = amn C = amnbca should be false, but your algo returns true...	2014-12-10 11:54:47		
7807	vanul	100		2014-12-10 11:54:47		
7808	rdfeo	100		2014-12-10 11:54:47		
7809	cfzie	100	a recursive method, not O(n) if conflict exists	2014-12-10 11:54:47		
7810	jippy	100	The following solution uses space l*m*n where l, m, n are respectively the lengths of the string A, B and C. It is a memoization based solution to the simplest recursive solution to the problem. The memoization leads to increased memory usage but keeps the run time polynomial.  Recursive algo : Let i,j,k be running pointers to the strings A, B and C respectively. Basically what the code does is try to match the character at the pointer location in C to the characters at the pointer locations in A and B. If a match is found then the respective pointers are moved forward.	2014-12-10 11:54:47		
7811	mrjku	100		2014-12-10 11:54:47		
7812	nhibd	100		2014-12-10 11:54:47		
7813	sqzqo	100	Invoking check_interleave(1,1,1) will give us the result.  For sake of clarity I have not checked for boundary conditions when we reach the end of a string. Now this code runs in worst case exponential time since it will check all possible interleavings. The way out of this is to maintain an array RES[l][m][n] which contain the results of the intermediate computations of check_interleave(.,.,.).  To use this array we initialize all its entries to some junk value say -1. Now when check_interleave is called at some location, say check_interleave(2,5,6), the code checks if RES[2][5][6] is set or not. If it is set to true/false then we simply use that result. If not then we compute the result and apart from using it, also store it in RES at the appropriate location.  The total runtime of this procedure is O(lmn) : since the procedure has been described in a top down fashion it might not be clear that the runtime is indeed polynomial. However a simple conversion of this routine to a dynamic programming solution will convince one of the runtime bounds.	2014-12-10 11:54:47		
7814	mrjku	100		2014-12-10 11:54:47		
7815	ufdxg	100		2014-12-10 11:54:47		
7816	xhgls	100	right approach but returns true for 'a','b','a'  here's how i wrote it:	2014-12-10 11:54:47		
7817	krxlv	100		2014-12-10 11:54:47		
7818	ewigy	100		2014-12-10 11:54:47		
7819	zeice	100		2014-12-10 11:54:47		
7820	sqzqo	100		2014-12-10 11:54:47		
7821	azmjc	100		2014-12-10 11:54:47		
7822	ethan	100		2014-12-10 11:54:47		
7823	rdfeo	100		2014-12-10 11:54:47		
7824	zeice	100		2014-12-10 11:54:47		
7825	ftfck	100	How come this was so complicated? Did I miss sth?	2014-12-10 11:54:47		
7826	wbqzu	100		2014-12-10 11:54:47		
7827	admin	100		2014-12-10 11:54:47		
7828	vanul	100	Sorry mistyped ... it should have been: break => return false; the last "return false" => "return true;"	2014-12-10 11:54:47		
7829	huiqq	100	Aggregate XOR of each character of a,b and c.	2014-12-10 11:54:47		
7830	fowai	100		2014-12-10 11:54:47		
7831	ethan	100		2014-12-10 11:54:48		
7832	zeice	100	Be simple ! using a temporary string	2014-12-10 11:54:48		
7833	cfzie	100		2014-12-10 11:54:48		
7834	bexbp	100		2014-12-10 11:54:48		
7835	krxlv	100		2014-12-10 11:54:48		
7836	plapd	100		2014-12-10 11:54:48		
7837	cfzie	100	}	2014-12-10 11:54:48		
7838	dkebi	100		2014-12-10 11:54:48		
7839	cfzie	100		2014-12-10 11:54:48		
7840	nwkeg	100	Combine both the strings (A+B) and sort it. Then sort string C. If both are equal, then yes else no.	2014-12-10 11:54:48		
7841	huiqq	100	sorting will take O(nlogn) time...question has asked for O(n) algo	2014-12-10 11:54:48		
7842	nhibd	100	sorting will change the relative order of the elements which is preserved in case of interleaving the 2 strings.  we just need to check 1) 2 strings are of equal length 2) the elements of str1 and str2 are in the same order in str3	2014-12-10 11:54:48		
7843	gilit	100		2014-12-10 11:54:48		
7844	dgjji	100		2014-12-10 11:54:48		
7845	dkebi	100		2014-12-10 11:54:48		
7846	jippy	100		2014-12-10 11:54:48		
7847	rrmeu	100	Solution:  The codes mentioned above will not work in case of common characters in both the strings.  When common characters are found, we shuld move with one possibility. The other possibility is stored on Stack, with the help of three index where we would resume.  When we are stuck finding no interleaving, we would pop the vales from stack, and resume.  When the stack is empty, and still we don't find interleaving, we declare "No interleaving." Hope this helps.	2014-12-10 11:54:48		
7848	ufdxg	100	I think the algorithm can be laid out as follows,  1. First check the length of the concatenation of the first and second string and the length of the third string is equal. if not return false.  2. Then check if all the characters in the concatenation is present in the third string. if all the characters are not present return false.  3. Check if the third string begins with either the first or the second string. If it does with either then the first and the second string is not interleaved.  Three simple checks all of O(n) time complexity.	2014-12-10 11:54:48		
7849	rdfeo	100	The application of the above 3 steps is not enough to check the interleaving of two string. Consider the following example- str1 = "acb", str2 = "def", str3 = "abcdef"  Although the above string combinations satisfies all the three conditions mentioned above, still, str3 is not the interleaved string combination for str1 and str2	2014-12-10 11:54:48		
7850	nhibd	100	What is the other conditions we need to apply here. what does interleaved mean?   Can you provide me some other sample inputs and outputs?	2014-12-10 11:54:48		
7851	gilit	100	@pranaymahajan  You are right, I overlooked it. After thinking a while it seems a good idea to confirm if the two strings are distinct, which they should be.	2014-12-10 11:54:48		
7852	azmjc	100	A very simple java code that takes O(N) and uses set	2014-12-10 11:54:48		
7853	ethan	100		2014-12-10 11:54:48		
7854	ewigy	100		2014-12-10 11:54:48		
7855	cfzie	100	Here is what I think: 1) First check length of A+B = C if true then 2) Decide which string A or B has First character in C, Both A and B are same then continue traversing C until we find Unique element. Hence we can find which string is the first one. 3) Now we know that string interleaving is starting from first string so we can continue scanning second and then first by taking turn.	2014-12-10 11:54:48		
7856	tenuw	100	How about taking two hash tables (one for together string1 and string2, and another for string3) of 26 size and incrementing the size of key when ever a char is found and then comparing both the tables if they have equal keys and values by using hashtable1.toString() == hashtable2.toString()  I am not sure about this. Just a different approach	2014-12-10 11:54:48		
7857	sgiwy	100	Hi i made this code in c and its working u can check it  #include<stdio.h> #include<string.h> int main() { char a[]="xyz"; char b[]="abc"; char c[]="axytbc" ; check(a,b,c);  getch(); return 0;  } int check(char *a,char *b, char *c) { int i=0,flag=1; while(i<strlen(c)) { if(*c==*a || *c==*b) { if(*c==*a) {*c++; *a++;} else {*c++; *b++;} i++; } else{ printf("NO"); flag=0; break;  } } if(flag==1) printf("yes");  }	2014-12-10 11:54:48		
7858	sqzqo	100		2014-12-10 11:54:48		
7859	sgiwy	100		2014-12-10 11:54:48		
7860	dkebi	100		2014-12-10 11:54:48		
7861	dgjji	100		2014-12-10 11:54:48		
7862	fmzze	100		2014-12-10 11:54:48		
7863	eucmc	100	tried this but it was incorrect output was:  ('abcd', 'xyz', 'axybczd') => false ('bac', 'acd', 'bacadc') => true ('abc' , 'abc' ,'aabbcc') => true ('abc', 'abbc', 'ababcc') => false	2014-12-10 11:54:48		
7864	sgiwy	101	Preprocess T so that we can answer queries of the following form:  - Given a character c and a position p, what is the smallest position j > p, such that c appears at position j in T (we allow p to be -1, assuming positions start at 0).  This can easily be done in O(n) preprocessing time (assuming 255 possible characters, linear time for each character) so that the queries can be answered in O(1) time.  Now for a given S we can use the above data structure (called DS below) as follows	2014-12-10 11:54:49		
7865	rdfeo	101		2014-12-10 11:54:49		
7866	azmjc	101		2014-12-10 11:54:49		
7867	gilit	101	Thus, for each string S, we only require O(|S|) time.	2014-12-10 11:54:49		
7868	admin	101	Yeah!	2014-12-10 11:54:49		
7869	bjsiw	101	DS.query has lower bound lglgT (like if DS is van emde boas at each character bucket) or lgT if you use balanced BST at each character bucket correct? Please advise subbu	2014-12-10 11:54:49		
7870	fmzze	101	or balanced BST at each character bucket can be sorted array (which do binary search on) to improve cache hits  lasthope, this was your idea right?  but I like subbu do it without specifying the actual DS/algorithm exactly so it give clean look from above nice one subbu	2014-12-10 11:54:49		
7871	tenuw	101	It is O(1), by just using a table, say Lookup[p,c].  This table, of size O(|T|) can be filled in O(|T|) time.  Basically a matrix of 256*|T| integers.  For example if string is ab  Then the matrix will look like (hope formatting goes through)	2014-12-10 11:54:50		
7872	eucmc	101		2014-12-10 11:54:50		
7873	nhibd	101		2014-12-10 11:54:50		
7874	cfzie	101	You can start by filling the row corresponding to |T| and work right to left.	2014-12-10 11:54:50		
7875	azmjc	101	-=, yes, nice clean implementation. Although I'm not sure how table access for query can be O(1).	2014-12-10 11:54:50		
7876	ftfck	101	Yeah I think the successor query (which is "DS.query" by subbu) has lower bound lglgT. Not sure if we can beat van embde boas (which match the very lower bound).  But the way lasthope thinking about it (which in bigO is lgT) is better for cache hits because he does binary search over static array instead of pointer based van emde boas (lglgT).  But I like subbu presenting it is as abstract DS.query, but maybe we rename it as DS.successor :)  Subbu how to do actual successor query in O(1) on your table of mostly -1 (sparse) ?	2014-12-10 11:54:50		
7877	rrmeu	101	@lasthope.  Constructing the table is O(|T|) time and query is O(1).  For example just for a single character, say 'h', you can fill its column in O(|T|) time by scanning through the string right to left.  Do this for each character (256) and you have the table.	2014-12-10 11:54:50		
7878	dkebi	101	@subbu, I understand that the table construction is O(T). But, if you want to find the lowest non -1 entry of 'h' (which is greater than p) in the table, you have a problem. You may have to pass through many values less than equal to p or simply -1 before you meet your criteria. Hope I'm making sense.	2014-12-10 11:54:50		
7879	sqzqo	101	In the table above column 'c' has all -1. Mistake there.  @lasthope/ -=. I hope you got why it is O(1).	2014-12-10 11:54:50		
7880	bjsiw	101	@lasthope.  Here is the code for a single character, which should explain what I am trying to say better.	2014-12-10 11:54:50		
7881	rrmeu	101		2014-12-10 11:54:50		
7882	dkebi	101		2014-12-10 11:54:50		
7883	zeice	101	in GetRow, in the end there is a	2014-12-10 11:54:50		
7884	plapd	101		2014-12-10 11:54:50		
7885	admin	101		2014-12-10 11:54:50		
7886	fmzze	101	which is missing.	2014-12-10 11:54:50		
7887	ewigy	101	Yeah it would seem lasthope's binary search is the divide and conquery improvement of the table idea.  We can discuss "per character buckets" (we put some DS at each character bucket - this part is same for all solutions we are discussing).  At a character bucket if we hang a sparse vector of length T with mostly -1, then worst case we might have to travel paths linear in T to find query. It seems O(T).  lasthope suggest converting the very same -1 sparse vector into an array of indices (sorted) to binary search on O(lgT).  or we can hang a van emde boas off each character bucket to do successor queries in O(lglgT).  Since Tmax is only 10M , lgTmax is 23, lglgTmax is 4  So the internal constants being smaller for binary search probably wins here.  I read somewhere the successor problem (for reasonable requirements for preprocessing times and space) has a lower bound O(lglgT) optimal query.	2014-12-10 11:54:50		
7888	sqzqo	101	@subbu, You are absolutely right. A table constructed this way will immediately point to where the next position is. Perfect.	2014-12-10 11:54:50		
7889	bexbp	101	subbu , lasthope  i am still blocked , help!  subbu can you post all code again in a new one because it seem you got the optimal solution so we can upvote that one and understand better?	2014-12-10 11:54:50		
7890	qywrh	101	@-=. I believe you are thinking of the case where the n integers come from a universe of size N, with N >> n, with Theta(N) space usage being prohibitively expensive.  That is not the case here. N = |T| here.  btw, the Omega(log log N) bound was just a conjecture that has been disproved.	2014-12-10 11:54:50		
7891	ufdxg	101	@-=, you have to understand how subbu is updating his table. table['c'][pos] is giving you the value	2014-12-10 11:54:50		
7892	fowai	101		2014-12-10 11:54:50		
7893	gilit	101		2014-12-10 11:54:50		
7894	eucmc	101	, which is exactly what you need to query.	2014-12-10 11:54:50		
7895	eucmc	101	p = pos :(	2014-12-10 11:54:50		
7896	gilit	101	Oh! So extra preprocessing to O(max_char*T) to reduce to O(1) query. Makes sense.  In Java this would be 64k*10M preprocessing worst case.  I understand all your amazing solutions. Unblocked thx lasthop subbu	2014-12-10 11:54:50		
7897	qywrh	101	Here is some quick C++, fully working (but not production quality), commentless code. (For explanation, there are a bunch of comments preceding).	2014-12-10 11:54:50		
7898	huiqq	101		2014-12-10 11:54:50		
7899	ufdxg	101		2014-12-10 11:54:50		
7900	zeice	101	1. Create a sorted array of the positions where char X is present in T. Do it for all possible chars X (assuming 256). 2. For each char Y in S, do a binary search over the sorted array created for char Y in the first step. Note the position where it is found. Next time we look for Y again, we have look beyond this position. 3. If we do not find a viable position for Y in the sorted array, return false.  Runs in O( |S| log |T| ).	2014-12-10 11:54:50		
7901	qywrh	101	On a second thought, using two indexes, one pointing to the current char in S another one pointing to the last matched char plus one in T, it can be done in O( |S| + |T| ) time.	2014-12-10 11:54:50		
7902	gilit	101	O(S + T) vs O(S logT) usually S is tiny compared to T ~ 10M	2014-12-10 11:54:50		
7903	bexbp	101	in that case O( S log T ) seems to be the better option.	2014-12-10 11:54:50		
7904	zeice	101	good sol.	2014-12-10 11:54:50		
7905	bexbp	101	So we can do this: An array or hash of all characters where each bucket is a van Embde Boa tree (keys are the indices where the character for that bucket shows up). Then as required we can do successor to find next index.  This should make it to O(S lglg T) which is nearly O(S) even with T as 10M	2014-12-10 11:54:50		
7906	cfzie	101	lasthope, preprocessing???	2014-12-10 11:54:50		
7907	rrmeu	101	This won't work.	2014-12-10 11:54:50		
7908	nwkeg	101	Oh no, van emde boas is for making tree access cache oblivious. It is not required here.  In step 1 we "pre-process" T so that array[X] holds the positions (sorted if you go from left to right) where char X appears in T. O( T )  Then for each char S_i = 'd' in S (processing chars one by one from left to right), do a binary search in array['d']. Lets say we find it in location l of array['d']. O( log T )  The trick is to remember the location l and next time when we look for 'd' again we have to search array['d'][ l+1: END]. If found we update l. There should be an last found position similar to 'l' for each char processed from S so far.  If the process doesn't fail we return true at the end. O( S log T )	2014-12-10 11:54:50		
7909	huiqq	101	can Anonymous explain why lasthope sol not good?	2014-12-10 11:54:50		
7910	plapd	101	The position that is the lower bound is common to all characters. So Step 2 in the description lasthope's algorithm can lead to wrong answers. No?	2014-12-10 11:54:50		
7911	qywrh	101	oops, sorry. there should be only one last matched position variable l. we have to search starting from l+1. please see the implementation by subhu below.	2014-12-10 11:54:50		
7912	xhgls	101	off by one error :) no worries	2014-12-10 11:54:50		
7913	zeice	101	@-=: No, it is not off-by-one. Step 2 talks about maintaining positions for each character, which actually gives wrong answers.	2014-12-10 11:54:50		
7914	plapd	101	There should have been a delete/edit option :-P. One last match position is all you need. btw, I think the O(1) lookup is very clever, subbu :)	2014-12-10 11:54:50		
7915	zeice	101	c'mon subbu , lasthope idea is good for large max-char also (the correct idea was hidden with some bugs that's all)	2014-12-10 11:54:50		
7916	azmjc	101	@-=. I am pretty sure lasthope had the correct solution in mind and it does indeed work for larger character sets. In fact, this is a good discussion to have with the interviewer! Even for smaller character set, it would be a good discussion. Classic tradeoff between time and space (256*T space + O(|S|) runtime vs |T| space + O(|S|log|T|) rutime).  But as written it is wrong, and it could actually be a common mistake made my many of the interview candidates, don't you think? No harm in calling it out.	2014-12-10 11:54:51		
7917	wbqzu	101	Yes yes. I made mistake because I had similar solution (using vanEmde) so when I read lasthope's I just skimmed it assumed he was doing similar (successor at each bucket with lgT).  All these discussions are correct, I think can overwhelm the interviewer no matter how interviewer complains. that is key to beating the interviewer, don't let him/her complain anything (always come back and say .. ok in that case if you don't care about preprocessing we can... ok in that case you complain about that so do it this way...)  Good job subbu I really like your original code without any DS.query implementation that way we can drop what we need for that part based on how interviewer complain	2014-12-10 11:54:51		
7918	rrmeu	101	Ignore my other code this one is better.	2014-12-10 11:54:51		
7919	ftfck	101		2014-12-10 11:54:51		
7920	qywrh	101		2014-12-10 11:54:51		
7921	dgjji	101	do following check for every Si.... input - T, pattern - Si	2014-12-10 11:54:51		
7922	azmjc	101		2014-12-10 11:54:51		
7923	cfzie	101		2014-12-10 11:54:51		
7924	plapd	101	Sorry the above code with HashMap is incomplete. Here is full code We can use memo dp to improve the algorithm.	2014-12-10 11:54:51		
7925	jippy	101		2014-12-10 11:54:51		
7926	tenuw	101		2014-12-10 11:54:51		
7927	ftfck	101	I will post visualization later	2014-12-10 11:54:51		
7928	rdfeo	101		2014-12-10 11:54:51		
7929	ethan	101		2014-12-10 11:54:51		
7930	wbqzu	101	Just use a BST to store T. Then you can modify inorder search on the BST using each Si to check for subsequence matching.	2014-12-10 11:54:51		
7931	admin	101	Great approach to have a character location map. Implemented the code with an IEqualityComparer parameter, just in case the interviewer wants to do this case insensitively.	2014-12-10 11:54:51		
7932	sgiwy	101		2014-12-10 11:54:51		
7933	wbqzu	101		2014-12-10 11:54:51		
7934	ftfck	101	It is standard algorithm, it is called Aho-Corasick tree.	2014-12-10 11:54:51		
7935	tenuw	101	Represent each string as a vector with counts of characters and use that to determine "sub-sequencesness".  Eg: "abbc" will be the vector [1,2,1,0,...,0] with the first entry corresponding to number of a's, second to number of b's etc.  Given abc, which will be [1,1,1,0,...] you check if each corresponding entry of target is <= the entry at the source vector.	2014-12-10 11:54:51		
7936	jippy	101	And vector can be represented as hashtable to reduce the number of entries to check.	2014-12-10 11:54:51		
7937	ufdxg	101	this is doing a subset check	2014-12-10 11:54:51		
7938	bexbp	101	-= is right. Order matters. Good catch -=.	2014-12-10 11:54:51		
7939	huiqq	101	Here is my solution in Java	2014-12-10 11:54:51		
7940	admin	101		2014-12-10 11:54:51		
7941	rdfeo	101		2014-12-10 11:54:51		
7942	ufdxg	101	I will post the visualization for this in another reply.	2014-12-10 11:54:51		
7943	dgjji	101	i am assuming strings are of ASCII character set. since ASCII has 256 charecters, declare an integer array of with 256. count each character presence. do the same by decrementing charecter occurance. if any position got -1, then its not the subset of the first string.	2014-12-10 11:54:51		
7944	bexbp	101	subsequence still has order involved  you are doing "subset" checking you can use this as a first level check though	2014-12-10 11:54:51		
7945	rdfeo	101	yes it required to be in order. we can use this for the initial check, weather we go further checking for this or not. once its successful we should proceed for sequence check.	2014-12-10 11:54:51		
7946	ftfck	101	Build a suffix tree of T then do subsequence queries of each S_i	2014-12-10 11:54:51		
7947	sqzqo	101	Suffix Tree cannot be used here	2014-12-10 11:54:51		
7948	fowai	101	Suffix tree is useful for finding sub-strings not sub-sequences. Won't work here.	2014-12-10 11:54:51		
7949	nwkeg	101	A greedy method should be OK, I think. The C++ code:	2014-12-10 11:54:51		
7950	gilit	101		2014-12-10 11:54:51		
7951	dgjji	101		2014-12-10 11:54:51		
7952	rrmeu	101	The space complexity is O(1); The time complexity is O(n), where n = length of T. Please correct me, if it's wrong.	2014-12-10 11:54:51		
7953	cfzie	101	ignore my BST idea pls subbu and lasthope solutions are best depending on different situations  rock on subbu!!!!!!!!1	2014-12-10 11:54:51		
7954	ewigy	101	Algorithms on Strings, Trees and Sequences by Gusfield has Anonymous/subbu/= solutions all variations.  all same people win the upvote  -Guest DS	2014-12-10 11:54:51		
7955	cfzie	101	Oh, fuck off. Troll.	2014-12-10 11:54:51		
7956	sqzqo	101	{fake ajeet, fake Varun, Anonymous that failed with first solution using hashing, =, fake subbu } all same person 100%  {lasthope} different person	2014-12-10 11:54:51		
7957	bexbp	101	you are a fool = is not part of any other set except {=}	2014-12-10 11:54:51		
7958	vanul	101	newbie here, but wth is this???	2014-12-10 11:54:51		
7959	gilit	101	@lasthope. You can safely ignore this/these idiot/idiots.	2014-12-10 11:54:51		
7960	sqzqo	101	{fake ajeet, fake Varun, Anonymous that failed with first solution using hashing, =, fake subbu } all same person 100%  {lasthope} different person	2014-12-10 11:54:51		
7961	vanul	101	{fake ajeet, fake Varun, Anonymous that failed with first solution using hashing, =, fake subbu } all same person 100%  {lasthope} different person who admit defeat in the end	2014-12-10 11:54:51		
7962	gilit	101	Stop EXPOSING yourself algos.	2014-12-10 11:54:51		
7963	bexbp	102	pre-process the entire dictionary and form a graph. Now start from the first word (source node) and do Breadth first search and you will get the shortest path from the source word to the target word.	2014-12-10 11:54:57		
7964	plapd	102	Oh sorry, didn't notice this, and posted a similar answer.	2014-12-10 11:54:57		
7965	ethan	102	Sorry once again!! LOL	2014-12-10 11:54:57		
7966	ftfck	102	One of the worst solution. LOL	2014-12-10 11:54:57		
7967	plapd	102	Data Structure : stack s; step1 :s<-push(DAMP) step2: w<-pop(s) if(w!=LIKE) go to step3 else return step3: push all word which are in dictionary and can be get after changing at single place of w into stack if it is not present and it wasn't pushed earlier. go to step 2	2014-12-10 11:54:57		
7968	bjsiw	102	Java Solution  Assuming the dictionary is a set of strings, make a HashSet<char[]> and implement a method to find the next change need that returns null if no possible change. Iterate through the char[] of the input, or you can also iterate while the char[] inputs are not equal.	2014-12-10 11:54:57		
7969	rrmeu	102		2014-12-10 11:54:57		
7970	wbqzu	102		2014-12-10 11:54:57		
7971	azmjc	102	Can't edit posts? Wow, well there are some simple errors in there such as	2014-12-10 11:54:57		
7972	cfzie	102		2014-12-10 11:54:57		
7973	zeice	102		2014-12-10 11:54:57		
7974	gilit	102	which should be	2014-12-10 11:54:57		
7975	rrmeu	102		2014-12-10 11:54:57		
7976	sgiwy	102		2014-12-10 11:54:57		
7977	sgiwy	102	I'm sure there is more, as I didn't put this through a compiler or anything, but you get the gist of things	2014-12-10 11:54:57		
7978	xhgls	102	@derp: You can edit the posts if you login.	2014-12-10 11:54:57		
7979	vanul	102	OK, here is a solution using BFS.  Note that I abstracted away things like dictionary representation and getting all the words that differ from the given word in just one character. There are several different ways to implement these and there's no point polluting the solution with unnecessary detail. Plus a few people before me have code snippets that could be used for that.  If you are really going read this, I'd suggest to paste the code into Visual Studio (or your favorite editor that has syntax highlighting).	2014-12-10 11:54:57		
7980	jippy	102		2014-12-10 11:54:57		
7981	sgiwy	102		2014-12-10 11:54:57		
7982	sgiwy	102	Which data structure is used to maintain the dictionary? or the words in the dictionary are just stored in a file?	2014-12-10 11:54:57		
7983	cfzie	102	A trie	2014-12-10 11:54:57		
7984	eucmc	102	From a graph out of the words, word A is adjacent to word B if replacing one character in one gives the other.  Now do a "double" breadth first search, starting a the source and the target. (i.e you start two independent BFS, one from source and one from target, stopping when they meet).	2014-12-10 11:54:57		
7985	plapd	102	From yur explanation i can get the distance between these two words , but how can i get all the legitimate words during the transformation?	2014-12-10 11:54:57		
7986	xhgls	102	That path gives the set of words. (the words are vertices in the graph).	2014-12-10 11:54:57		
7987	cfzie	102	Thanks for the reply. if you have a link for the dictionary representation as graph, please post it.. i just wanted to see how the nodes are connected..	2014-12-10 11:54:57		
7988	bjsiw	102	We can also run Dijkstras algorithm. Seems simpler than doing 2 BFS	2014-12-10 11:54:57		
7989	wbqzu	102	@Vikas, BFS is more quick, O(n), Dijkstra is O(n^2), because we don't need one node to all nodes, so BFS is enough	2014-12-10 11:54:57		
7990	dkebi	102	@remlostime , in which world are you living , who told you BFS is O(n) buddy. it is O(V+E) where E can be V^2 in worst case , so its n^2 only for a graph , for tree yes BFS is O(n)	2014-12-10 11:54:57		
7991	nhibd	102	def is_in_Dictionary(dic_word): <CODE TO CHECK WHTHER THE WORD IS IN DICTIONARY>  def find_cloneWord(w1, w2): for i in range(sw1) sw1_d = sw1 for j in range(sw2): sw2_d = sw2 sw2_d[j] = sw1_d[i] dic_word = ''.join(sw2_d) if is_in_Dictionary(dic_word) == 1: print dic_word num_words = num_words + 1 else: print "No Word in Dictionary"    #Main Function w1 = "DAMP" w2 = "LIKE"  sw1 = w1.strip() sw2 = w2.strip() num_words = 0	2014-12-10 11:54:57		
7992	tenuw	102	Data Structure : stack s; step1 :s<-push(DAMP) step2: w<-pop(s) if(w!=LIKE) go to step3 else return step3: push all word which are in dictionary and can be get after changing at single place of w into stack if it is not present and it wasn't pushed earlier. go to step 2	2014-12-10 11:54:57		
7993	sgiwy	102	2 solutions. First approach is the most scalable one: Approach 1:	2014-12-10 11:54:58		
7994	krxlv	102		2014-12-10 11:54:58		
7995	huiqq	102		2014-12-10 11:54:58		
7996	plapd	102	Approach 2:	2014-12-10 11:54:58		
7997	sqzqo	102		2014-12-10 11:54:58		
7998	tenuw	102		2014-12-10 11:54:58		
7999	qywrh	102	Epic_coder, could you explain approach 2 a bit more.	2014-12-10 11:54:58		
8000	nwkeg	102	Well in 1st approach you would start from DAMP and generate following in the first step: LAMP,DIMP,DAKP and DAME, and at the same time look up each of them in the dictionary, and proceed only with those nodes that exist in the dictionary. While in approach 1 you already know what words could be obtained with one replacement exist, so you don't have to generate n combinations and don't have to lookup each of them in the dictionary at each step because you have direct nodes that you can follow.	2014-12-10 11:54:58		
8001	fowai	102		2014-12-10 11:54:58		
8002	bexbp	102		2014-12-10 11:54:58		
8003	dgjji	102	This is a DFS problem.  Form a graph of all the words in the dictionary. Each word will be a node, and there will be edges between two words which differ by a character only. Now start from the source string, and find all paths to the target string. DFS.  If the question was to find the shortest path to the target, you'd use BFS.	2014-12-10 11:54:58		
8004	bexbp	102	Why do you assume we have to find all the paths?	2014-12-10 11:54:58		
8005	plapd	102	The question does not specify anything about the shortest path. It only asks us to find a path. There can be several such path. Hence, I said DFS. You could clarify this with the interviewer.	2014-12-10 11:54:58		
8006	dkebi	102	How would you efficiently create this graph?	2014-12-10 11:54:58		
8007	ftfck	102	If you create separate trees based on the number of characters, it would optimize the solution. As per my understanding the number of characters in input and output has to be same...so creating separate trees would help.	2014-12-10 11:54:58		
8008	plapd	102	Here's an implementation that does what I explained above. Exploring all paths. Maybe can be optimized further:	2014-12-10 11:54:58		
8009	ethan	102		2014-12-10 11:54:58		
8010	ewigy	102		2014-12-10 11:54:58		
8011	admin	102	^ Ignore the dummy vars, and other stuff, I just wrote this on top of something else I had lying around. But you get the idea.	2014-12-10 11:54:58		
8012	vanul	102	The problem could be modeled as a graph traversal (DFS or BFS), but in my opinion it's going to be complicated to implement.  My solution instead is:	2014-12-10 11:54:58		
8013	qywrh	102		2014-12-10 11:54:58		
8014	ftfck	102		2014-12-10 11:54:58		
8015	sqzqo	102	Essentially, given the starting string I explore sistematically all the valid paths.	2014-12-10 11:54:58		
8016	sqzqo	102	can u explian ur approach plz	2014-12-10 11:54:58		
8017	gilit	102	This doesn't handle the case when the first change of the only solution is to change a character not in the first index or the character in a position needs to be changed multiple times during the conversion.	2014-12-10 11:54:58		
8018	azmjc	102	Interesting idea but it would not work for any of the examples provided. The only paths that it produces are the ones where the position of the character being changed is increasing which restricts the choices considerably.	2014-12-10 11:54:58		
8019	gilit	102	claudio can u explain ur code plz	2014-12-10 11:54:58		
8020	admin	102	Why do you need count and changed?	2014-12-10 11:54:58		
8021	zeice	102		2014-12-10 11:54:58		
8022	azmjc	102		2014-12-10 11:54:58		
8023	krxlv	102	This doesn't handle the case when the first change of the only solution is to change one of the characters in source string to a character different to the character in the same position in destined string.	2014-12-10 11:54:58		
8024	gilit	102	I believe this would work	2014-12-10 11:54:58		
8025	bjsiw	102		2014-12-10 11:54:58		
8026	dgjji	102		2014-12-10 11:54:58		
8027	rrmeu	102	This doesn't handle the case when the first change of the only solution is to change one of the characters in source string to a character different to the character in the same position of destination string.	2014-12-10 11:54:58		
8028	azmjc	102	Why do you need count and changed?	2014-12-10 11:54:58		
8029	plapd	102	You can use Trie data structure and try finding all the paths. I am sorry if this solution is mentioned anywhere in this page.	2014-12-10 11:54:58		
8030	jippy	102	A few comments ...  DFS - you would run out of memory very quickly because the recursion tree can be as deep as the number of words of given length in the dictionary. Plus you'd need to remember which words you had already visited to avoid visiting them repatedly with different prefixes.  BFS - that seems to be the only reasonable solution. The difficult part is doing BFS efficiently using a reasoably clean code.  If you doing anything else, seemingly clever, make sure that your code works for the 2 examples. And please add some explanation/comments (@Sunny and others). Blasting code on the page without any explanation is not helping anybody.	2014-12-10 11:54:58		
8031	xhgls	102	Fast fastest solution that does not use graph for DFS. For dictionary with 120K words solution for EVERY input can be obtained in 0.12sec.	2014-12-10 11:54:58		
8032	ewigy	102		2014-12-10 11:54:58		
8033	azmjc	102		2014-12-10 11:54:58		
8034	dgjji	102	I wanted to say "my fastest solution" but have mistaken. The variants with graphs are much slower (from 0.2 to 7 seconds with non-constant speed).	2014-12-10 11:54:58		
8035	mrjku	102	Here's my DFS in Racket Scheme:	2014-12-10 11:54:58		
8036	sgiwy	102		2014-12-10 11:54:58		
8037	ufdxg	102		2014-12-10 11:54:59		
8038	krxlv	102	My C++ code here. Solved in DFS style, heavily depends on Boost and STL to shorten the code.  The input file:	2014-12-10 11:54:59		
8039	fmzze	102		2014-12-10 11:54:59		
8040	vanul	102		2014-12-10 11:54:59		
8041	mrjku	102	Here's the code:	2014-12-10 11:54:59		
8042	nhibd	102		2014-12-10 11:54:59		
8043	jippy	102		2014-12-10 11:54:59		
8044	krxlv	102	}	2014-12-10 11:54:59		
8045	cfzie	102	a.) Assume that we have a function that returns a list of words that differ from the given word by a single character. b.) The distance metric between two words is the number of characters that they differ in. c.) We can use a linked list to store the sequence of words that were found to help reach the destination.  Now, 1.) starting from the destination find 'all the words' that are at the distance of 1 from the 'current' word. 2.) Find the word from the list such that the sum of the distances of the word from the destination is closest to the distance between the source and the destination. 3.) If the list was empty before step 2.) then backtrack and regenerate the list for the previous word chosen and then choose another word fulfilling the criteria mentioned in step 2.) 4.) Repeat the above process till you reach a destination or till you cannot find another word in a list that you haven't visited. In which case there is no way you can reach the destination. I guess the time complexity of the above approach would be poor. But it can have an acceptable space complexity since you would be regenerating the lists if you backtrack. However, I think the approach should work, nonetheless.	2014-12-10 11:54:59		
8046	sqzqo	102	Don't use a generic BFS, use A* search. You use the edit distance of each candidate on the horizon to the target as the heuristic. That way you're not searching blindly with BFS. Maintain the dictionary in a trie that supports wildcard search (wildcard char matches any character, go down all branches).	2014-12-10 11:54:59		
8047	sqzqo	102	Everyone think about BFS or DFS. But I'm thinking A* search. As you have the whole dictionary you can preprocess the dictionary to have heuristics which assigns a value how many steps will need to transform string A into string B.	2014-12-10 11:54:59		
8048	zeice	102	Here is an excellent solution: algorithmproblems.blogspot.com/2013/01/travel-from-string-to-string.html	2014-12-10 11:54:59		
8049	plapd	102		2014-12-10 11:54:59		
8050	admin	102		2014-12-10 11:54:59		
8051	tenuw	102	it would be helpful for us if u could give the logic behind dict_contains( ) funcion...	2014-12-10 11:54:59		
8052	nwkeg	102	Please try to explain algorithm before posting the code..	2014-12-10 11:54:59		
8053	dkebi	102		2014-12-10 11:54:59		
8054	gilit	102		2014-12-10 11:54:59		
8055	krxlv	102	Corrections are highly appreciated. :)  -- A mistake is a crash-course in learning. --	2014-12-10 11:54:59		
8056	sgiwy	102	A java method to transform. As an interface use a small dictionary to check for the presence of the word.  Small dictionary in java --------------------------------- HashSet<String> dictionary = new HashSet<String>(); This is used by the method boolean isPresent(char[] input);  The transformation method in java -------------------------------------------------	2014-12-10 11:54:59		
8057	bexbp	102		2014-12-10 11:54:59		
8058	zeice	102		2014-12-10 11:54:59		
8059	fowai	102	This will not work if the only path available requires you to transform a character in source into a character that is not equal to the corresponding one in destination.	2014-12-10 11:54:59		
8060	huiqq	102	I think this piece of code might work  for (DICTIONARY words : EnumSet Range (words.CAT, words.DOG)) System.out.println(words);	2014-12-10 11:54:59		
8061	dgjji	102	this is my complete solution with a test case..	2014-12-10 11:54:59		
8062	cfzie	102		2014-12-10 11:54:59		
8063	xhgls	102		2014-12-10 11:54:59		
8064	ewigy	102	From what I can tell, there is absolutely no bactracking in your code. The test example works only because your dictionary is very small. It would not work in general case. I really cannot follow your code, but it seems that if you add "hat" to your dictionary, you will get stuck with no way of recovering.	2014-12-10 11:54:59		
8065	azmjc	102		2014-12-10 11:54:59		
8066	zeice	102		2014-12-10 11:54:59		
8067	bjsiw	102	I forgot to check new word to check from dictionary:). Can give more detailed example. Sorry	2014-12-10 11:54:59		
8068	azmjc	102		2014-12-10 11:54:59		
8069	azmjc	102		2014-12-10 11:54:59		
8070	ftfck	102		2014-12-10 11:54:59		
8071	rdfeo	102	Me too! What a coincidence. Now please stop it. You are causing people to downvote valid answers(IMO) out of spite.	2014-12-10 11:54:59		
8072	ethan	103	Let S = Sum(all numbers) / 2, the sum of the elements each array shall have. I suppose N is reasonably small, like N <= 40. One approach would be  Work with 2 halves A and B of the array independently: A from indices [0, N/2-1] and B from [N/2, N-1]. Generate all possible sums of elements in array A. Use N/2 hash tables, one for each number of elements of the subsets, and put the sum of a subset in the corresponding hash table. There are 2^(N/2) subsets of A, this takes O(N/2 * 2^(N/2)) time.  Then generate all possible sums of B. For each subset of B, with X elements and sum Z, check if there is a subset of A in the hash table for sizes N/2-X with sum S-Z. There are also 2^(N/2) subsets and each lookup in a hash table takes O(1).  So this takes total time O(N/2 * 2^(N/2)) and O(2^(N/2)) space. For N=40, N/2 = 20 and 2^20 is ~1 million which is usually ok.	2014-12-10 11:55:09		
8073	nwkeg	103	Here is an implementation in Java of Miguel Oliveira's ideas.	2014-12-10 11:55:09		
8074	ethan	103		2014-12-10 11:55:09		
8075	fmzze	103		2014-12-10 11:55:10		
8076	ftfck	103	You can use bitwise operations to simplify the code. Here's my implementation:	2014-12-10 11:55:10		
8077	admin	103		2014-12-10 11:55:10		
8078	ftfck	103		2014-12-10 11:55:10		
8079	zeice	103	I think this can be solved like this: 1) Average of both (n/2) blocks is same=> total is same 2) Total of both blocks = 1/2 * total of n number  => Add up all n numbers = T => find (n/2) numbers which add upto T/2 => the leftover will also add up to T/2 (obvious) we can use a DP for the above solution.. which is like the coin & sum problems	2014-12-10 11:55:10		
8080	ftfck	103	We can't use a DP as you are thinking. The constraint that the two halves should have the same sum is only true the first time we split the array.  Let A be the array s.t. sum(A) = n Let A1, A2 be the halves s.t. sum(A1) = sum(A2) = n/2 Let A11, A12 be any two halves of A1. It is not necessary for any such A11, A12 that sum(A11) = sum(A12)!  A DP solution might be possible, but certainly not this way!	2014-12-10 11:55:10		
8081	rrmeu	103	the DP i proposed is this a = { 1,2,3,4,5,6,7,8} find 4 elements in a which addupto 14 so you form a DP where you keep track of how many numbers you are using and whats the addition in above case F(1) = 1(1) => () count of numbers uses F(2) = 2(1) F(3) = 1,2 (2) or 3(1) F(4) = 1,3(2) F(5) = 1,4(2) or 2,3(2)  so you throw if the count gets more than 4 and keep moving forward	2014-12-10 11:55:10		
8082	wbqzu	103	@anotherguy, i think you misunderstood his post. he's not recursively spliting the parts of the array. This solution will work in a pseudo-polynomial time (depends on the size of the integers to have a feasible space complexity) but it is a bit tricky because you must be sure to be using only N/2 numbers to achieve T/2.	2014-12-10 11:55:10		
8083	bexbp	103	No guarantee that such a division is possible but using DP the logic would be something like this: - calculate total sum	2014-12-10 11:55:10		
8084	gilit	103		2014-12-10 11:55:10		
8085	fmzze	103		2014-12-10 11:55:10		
8086	bexbp	103	- Now maintain a Sum table/huge 1D array and set SumTbl[j] = False for all j<n and SumTbl[0] = True  - Now the trick here is that we maintain the running sum we have so far and set SumTbl[j]=True for the running sum. In addition to that, we need to set SumTbl[j + arr[i]] = True for all j< sum-arr[i]  So, the logic would be something like:	2014-12-10 11:55:10		
8087	plapd	103		2014-12-10 11:55:10		
8088	qywrh	103		2014-12-10 11:55:10		
8089	ftfck	103	Now, we dont really need to consider j from sum to 0, we could maintain a rightmost index R (initially set to 0 and set it o min (sum/2, j+arr[i]). So the logic would be R = 0; for (i=0; i<n;i++) { for (j=R; j>=0;j--) { if (SumTbl[j] !=False) { SumTbl[j+arr[i]] = True; } R = min(sum/2, R+arr[i]); } return SumTbl[R/2]	2014-12-10 11:55:10		
8090	fowai	103	Right! No guarantee that it is always possible. Consider the array [1,2]. This can't be divided into two sub-arrays of size 1 whose averages are equal.  As a preliminary response, the algorithm should first output whether or not such a partitioning is possible. If yes, then can print out the partitioned elements. And as far as the algorithm is considered, modifications to the DP solution of subset sum problem should work.	2014-12-10 11:55:10		
8091	ufdxg	103	I am sure it's tough one. Using subset sum problem we can say that there is a solution which exist, but generating numbers which constitutes these sub-arrays would be tough one, especially when considering no overlapping elements.	2014-12-10 11:55:10		
8092	zeice	103	I'm confused by this solution. If I follow the solution correctly, it does not work for these simple inputs:  1,-1 1,2  Here is the implementation in Java with tests:	2014-12-10 11:55:10		
8093	rdfeo	103		2014-12-10 11:55:10		
8094	jippy	103		2014-12-10 11:55:10		
8095	huiqq	103	@gudujarlson, You cannot convert  1,-1 1,2  into two arrays with same average. That's what Erasmus is saying.	2014-12-10 11:55:10		
8096	zeice	103	average equal, means sum equal. 1. iterate the array, calculate the sum of the array: Sigma 2. find a sub array with n/2 elements and the sum is Sigma/2  normally like a recusive solution for step 2, cost O((n/2)!) time.  Anyone can provide better solution?	2014-12-10 11:55:10		
8097	cfzie	103	That kind of approach can take N choose N/2 time instead of (N/2)!	2014-12-10 11:55:10		
8098	krxlv	103		2014-12-10 11:55:10		
8099	fmzze	103	both arrays must have the same amount of numbers, so it does here.	2014-12-10 11:55:10		
8100	mrjku	103	DP solution : 1. generate dp matrix upto K such that a) k has 2 true (means there are two pairs of subset whose sum is K b) check if two pairs are distinct and covering all elements of main set c) if false then repeat above two steps till k reaches a optimal sum(like totalsum/tota no of elements)	2014-12-10 11:55:10		
8101	rdfeo	103	1 sort the array. 2. Create two groups by picking elements in pairs but in alternate fashion. Assuming after sorting array is a[1]....a[n] gr1:(a[1],a[n]) (a[3], a[n-2]) so on gr2: (a[2], a[n-1])(a[4], a[n-3]) so on	2014-12-10 11:55:10		
8102	xhgls	103	that does not work as was already mentioned in this thread	2014-12-10 11:55:10		
8103	jippy	103	That will arrive at an approximate solution. After steps 1 and 2, next compare the sums of the two groups and swap of the first elements of each group (these elements are guaranteed to be the smallest). Compare the new sums. If the sums converged, repeat swap. Else, halt.	2014-12-10 11:55:10		
8104	wbqzu	103	Asked here before: change the question id in the above url to: 2622	2014-12-10 11:55:10		
8105	ftfck	103	There is a difference between two sub-parts and two sub-parts with equal number of elements.	2014-12-10 11:55:10		
8106	plapd	103	This can be done by using the subset sum algorithm where the target sum equals the half of total sum of array elements. In addition, we need to impose a limit on the permissible length of the selected sub-array so that it is equal to the half of the total number of elements in the array. Here's the code:	2014-12-10 11:55:10		
8107	bexbp	103		2014-12-10 11:55:10		
8108	fowai	103		2014-12-10 11:55:10		
8109	xhgls	103	n! mine one is on overall better as you try every combination possible, you can also do it like bunch of n/2 1's and n/2 0's and do the permutations and try all the combinations	2014-12-10 11:55:10		
8110	nhibd	103	First of all this is not possible for each and every data.  say, array has only 2 elements : 1,1000000  Whatever we do, we'll end up with 2 arrays with average 1 and 1000000 respectively.  If possible for a particular array, I think DP would be best approach	2014-12-10 11:55:10		
8111	bexbp	103	Can you give me solution to thiis array a[] = { 2,3,5,6,8} sum = 24 avg = 12 but no combination will give sum of 12	2014-12-10 11:55:10		
8112	krxlv	103	1.) Calculate sum of the array  requirement can now be broken in to finding sum/2 1.) calculate a recursive approach to the sum with an auxilary array to keep a track of element as a part of the sum 2.) Of all possible combinations print the one with length =n/2 of original array. dirty code for finding sum find sum(int []A , int [] Ix, int sum, int T, int n) { if(sum>T) return; if(sum==T) { if(Ix.length ==A.length /2) print (A,Ix,n); return; } for(int i = Ix[n] :i<A.lrngth;i++)  Ix[n+1]=i  findssum(A,IX,sum+A[i],n+1); }	2014-12-10 11:55:10		
8113	zeice	103	I think we can use DP. While finding the numbers for n/2 array I can store the indices. Since the array which we need to make is n/2 so the sum of all elements will be S such that 2S is the sum of main array in question.  Pseudocode  FindArray(A,Sum,a) be the function where A is the main array, Sum = Sum at any state, a be n/2 array which we need to fill	2014-12-10 11:55:10		
8114	wbqzu	103		2014-12-10 11:55:10		
8115	fowai	103		2014-12-10 11:55:11		
8116	eucmc	103	I don't understand why you people are assuming only positive number. Has anyone mentioned this question is valid for only positive numbers ?? What if it contains negative numbers ?	2014-12-10 11:55:11		
8117	nhibd	103	The approach I mentioned does not assume that. For the 0-1 knapsack approaches to work with negative numbers, you just need to add an offset to the numbers, so that all numbers become positive. (offset = - smallest_negative_number)	2014-12-10 11:55:11		
8118	rrmeu	103	But to divide an array in n/2,n/2 ,we have to have even size array?How about if array is of size 5 which is odd then 5/2,5/2 what ?	2014-12-10 11:55:11		
8119	sqzqo	103	import java.util.Stack;  public class Node {   public static void main(String[] args){  int arr[] = {1,2,3,4,5,6,7,8}; int sum = 0; int sum1=0; Stack<Integer> st = new Stack<Integer>(); for(int i=0;i<arr.length;i++){  sum += arr[i];  } out: for(int i=0;i<arr.length;i++){ sum1 = arr[i]; for(int j=i+1;j<arr.length;j++){  sum1 += arr[j];  if(sum1 == sum/2){ st.push(i); st.push(j); break out; } } } System.out.println(st); }  }	2014-12-10 11:55:11		
8120	jippy	103	Check out my solution :  "github.com/amitgoswami/ALGO_TRIALS/blob/dev/CommonAlgoQuestions/SubsetSumEqualNos/src/SubsetSumEqual.java"  it is a link add https as prefix	2014-12-10 11:55:11		
8121	nhibd	103	O(2^n) is pretty simple. I think this problem is "NP-complete".  Model: Solve the following integer equations over binary variables:	2014-12-10 11:55:11		
8122	rdfeo	103		2014-12-10 11:55:11		
8123	nwkeg	103		2014-12-10 11:55:11		
8124	ufdxg	103	Code in C++:	2014-12-10 11:55:11		
8125	krxlv	103		2014-12-10 11:55:11		
8126	bjsiw	103		2014-12-10 11:55:11		
8127	qywrh	103	For an input array	2014-12-10 11:55:11		
8128	admin	103		2014-12-10 11:55:11		
8129	ufdxg	103		2014-12-10 11:55:11		
8130	zeice	103	the output will be	2014-12-10 11:55:11		
8131	zeice	103		2014-12-10 11:55:11		
8132	mrjku	103		2014-12-10 11:55:11		
8133	bjsiw	103	Which is a solution, and not unique.	2014-12-10 11:55:11		
8134	mrjku	103		2014-12-10 11:55:11		
8135	ftfck	103		2014-12-10 11:55:11		
8136	ftfck	103	DP solution : 1. generate dp matrix upto K such that a) k has 2 true (means there are two pairs of subset whose sum is K b) check if two pairs are distinct and covering all elements of main set c) if false then repeat above two steps till k reaches a optimal sum(like totalsum/tota no of elements)	2014-12-10 11:55:11		
8137	ewigy	103	the above logic picking the elements in alternate fashion works	2014-12-10 11:55:11		
8138	sgiwy	103	import java.util.Arrays;  public class DevideEquel {  int[] array={4,4,6,7,7,6,3,3}; int n=array.length;    public static void main(String[] args) {  DevideEquel devideEquel=new DevideEquel(); Arrays.sort(devideEquel.array); int mid=(devideEquel.n-1)/2;   for(int i=0;i<=mid;i++) { for(int j=devideEquel.n-1;j>mid;j--) {  int temp=devideEquel.array[j]; devideEquel.array[j]=devideEquel.array[i]; devideEquel.array[i]=temp;  int left=0; int right=0;  for(int f=0;f<=mid;f++) {  left=left+devideEquel.array[f]; right=right+devideEquel.array[devideEquel.n-1-f];  } if(left==right){ System.out.print("left="+left); System.out.println(" right="+right); for(int y=0;y<devideEquel.n;y++) { System.out.print(" "+devideEquel.array[y]); } return; } } }   }  }	2014-12-10 11:55:11		
8139	sgiwy	103	The inteviewers took a famous problem (partition into 2 arrays of equal sum) and they modified it to "average"  But average of 2 equal sized lists being equal is the same as the sum of 2 equal sized lists being equal.  So this is the PARTITION PROBLEM. Please google it and study the wikipedia page.  This is one of those question where if you didn't know this problem before hand, you would either 1) Only do brute force bad solution 2) [Most keen people] Will get an incorrect greedy algorithm that seems to work  So those folks at Amazon were expecting you to know that average is same as sum and expected you to know the partition problem (not memorized, but know enough that greedy is wrong).	2014-12-10 11:55:11		
8140	gilit	103	this can be integer knapsack with size of sum/2 and weight of each item equals one	2014-12-10 11:55:11		
8141	bjsiw	103		2014-12-10 11:55:11		
8142	mrjku	103		2014-12-10 11:55:11		
8143	cfzie	103	Why can't we use following algorithm (haven't read comments intentionally) 1. Sort the array, complexity O(N*logN) in asc. order 2. Run through the array once (complexity is O(N)), ultimately it's gonna be O(N*logN)	2014-12-10 11:55:11		
8144	dkebi	103		2014-12-10 11:55:11		
8145	ethan	103		2014-12-10 11:55:11		
8146	admin	103	check the other posts with this kind of approach. it is wrong	2014-12-10 11:55:11		
8147	cfzie	103		2014-12-10 11:55:11		
8148	huiqq	103		2014-12-10 11:55:11		
8149	tenuw	103	Why? In my algorithm you get A1 | A2	2014-12-10 11:55:11		
8150	mrjku	103	1. 87 | 2. 87 | 30 3.87 | 30 30 4. 87 | 303030 5. 87 2 | 30 30 30 6. 87 2 1 | 30 30 30  What's wrong, huh?	2014-12-10 11:55:11		
8151	ufdxg	103	The only difference in your algorithm is that you take numbers in decreasing order. It's wrong by the same reason. It works for that example, but fails with examples like { 1, 20, 20, 20, 29, 30 } answer is {1, 29, 30} , {20,20,20} but your algorithm gives {30, 20, 1} and {29, 20, 20 } and negative numbers { -87, -30, -30, -30, -2 , -1 } you get 6. -1 -2 -30 -30 -30 -87 | <empty array>	2014-12-10 11:55:11		
8152	mrjku	103	I think that the sum of all the elements of the input array should be even, Steps: 1. Sort the array (number of elements in input array will always be even) 2. Will get 2 middle numbers. Put one in 1st output array and 2nd one in 2nd out put array. 3. Itrerate the input array from left side till the middle number alternatively put the elements in the out put arrays. like 0th position element in 1 st output array and 1st position element in 2nd out put array. 4. Irerate the right side of the input array reversly till mid of te inoput array and do the same.  Please let me know if this solution is feasible.  Thanks, ankur	2014-12-10 11:55:11		
8153	fowai	103	this kind of approach gives wrong answers. check the other posts	2014-12-10 11:55:11		
8154	bexbp	103		2014-12-10 11:55:11		
8155	plapd	103		2014-12-10 11:55:11		
8156	sqzqo	103	this is incorrect as explained in other posts in this thread	2014-12-10 11:55:11		
8157	sgiwy	103		2014-12-10 11:55:11		
8158	ftfck	103		2014-12-10 11:55:11		
8159	ftfck	103	this is incorrect as explained in other posts in this thread	2014-12-10 11:55:11		
8160	ewigy	103	Assuming the number of elements in the array is even and the sum of elements is also even.  1) Sort the array. 2) Use two variables. One to store the sum of elements at indexes that leave a remainder of 0 or 4 when divided by 4. The other to store the sum of elements at indexes that leave a remainder of 1 or 2 when divided by 4. 3) If the two variables are equal then the array can be divided into two halfs with equal sum.  TC : O(n)	2014-12-10 11:55:12		
8161	cfzie	103	You can't solve these kind of subset problems with greedy solutions. Simple counter example: {1, 2, 30, 30, 30, 87} var1 = 1 + 30 + 30 = 61 , var2 = 2 + 30 + 87 = 119 However there is a solution {1,2,87} and {30,30,30}	2014-12-10 11:55:12		
8162	cfzie	103		2014-12-10 11:55:12		
8163	tenuw	103		2014-12-10 11:55:12		
8164	dgjji	103	Let me know if somebody got a better approach.	2014-12-10 11:55:12		
8165	ufdxg	103	You can't use a greedy approach. See the example I gave earlier: {1, 2, 30, 30, 30, 87} array1 = {1, 30, 30} , array2 = {2, 30, 87} However there is a solution {1,2,87} and {30,30,30}	2014-12-10 11:55:12		
8166	dgjji	103		2014-12-10 11:55:12		
8167	zeice	103		2014-12-10 11:55:12		
8168	jippy	103	it may work but with small change. Sort in descending order	2014-12-10 11:55:12		
8169	zeice	103		2014-12-10 11:55:12		
8170	admin	103		2014-12-10 11:55:12		
8171	eucmc	103	The subset sum problem is NP Complete. If that worked, there would be a polynomial time algorithm for this problem and P = NP. Find a counter-example for that code, it will help you understand how that can't work.	2014-12-10 11:55:12		
8172	wbqzu	103	1 sort the array. 2. Create two groups by picking elements in pairs but in alternate fashion. Assuming after sorting array is a[1]....a[n] gr1:(a[1],a[n]) (a[3], a[n-2]) so on gr2: (a[2], a[n-1])(a[4], a[n-3]) so on	2014-12-10 11:55:12		
8173	jippy	103	{1, 2, 30, 30, 30, 87}	2014-12-10 11:55:12		
8174	cfzie	103	int[] val={1,3,8,4,5,6,7,8}; int lsum=val[0]; int rsum=val[val.length-1]; int i=0,j=0; for(i=1,j=val.length-2;;){ if(i==j+1){ break; } if(lsum>rsum){ rsum+=val[j]; j--; }else if(rsum>lsum){ lsum+=val[i]; i++; }else{ rsum+=val[j]; j--; lsum+=val[i]; i++; } }  if(lsum==rsum){ System.out.println("Found: [1,"+i+"]["+(i+1)+","+val.length+"]\tSum:"+lsum); }else{ System.out.println("Not Found"); }	2014-12-10 11:55:12		
8175	qywrh	104	If I am wrong, pls correct me. The time complexity is O(n);  I use a stack to reverse the whole sequence of the string then split them by space.  input: @"the boy ran"  output: @"eht yob nar"	2014-12-10 11:55:15		
8176	bjsiw	104		2014-12-10 11:55:15		
8177	nwkeg	104		2014-12-10 11:55:15		
8178	fowai	104	Your space complexity is pretty high - You are using stack and then a String[] etc. Can we do better?	2014-12-10 11:55:15		
8179	ufdxg	104		2014-12-10 11:55:15		
8180	wbqzu	104		2014-12-10 11:55:15		
8181	cfzie	104	It can be done inplace. In this case you have to traverse each word twice. 1) Find a word, reverse it. 2) skip all the spaces or keep it as those are.	2014-12-10 11:55:15		
8182	wbqzu	104	void reverseWords(String s) { int start, end; start = end = 0; int len = s.length();  while (start < length) { while ((start < length) && (s.charAt(start) == ' ')) start++; end = start; if (end < length) { while( end < lenght -1 && s.charAt(end + 1) != ' ') { end++; } }  if (start < end) reverseString(s, start, end); start = end+1; }  }  void reverseWord(String s, int start, int end) { while(start < end) { char c = s.charAt(end); s.set(end, s.charAt(start)); s.set(start, c); start++; end--; } }	2014-12-10 11:55:15		
8183	ewigy	104		2014-12-10 11:55:15		
8184	plapd	104		2014-12-10 11:55:15		
8185	rrmeu	104		2014-12-10 11:55:15		
8186	sqzqo	104		2014-12-10 11:55:15		
8187	fmzze	104		2014-12-10 11:55:15		
8188	xhgls	104		2014-12-10 11:55:15		
8189	eucmc	104	O(n) solution	2014-12-10 11:55:15		
8190	gilit	104	Need O(n) space to store word_list. I think the interviewer is looking for an in-place solution O(1) space. with index manipulation.	2014-12-10 11:55:15		
8191	sgiwy	104	string input = @"The boy run"; StringBuilder builder = new StringBuilder(); int i =0; string temp; bool isFirstInsert = true; while(i< input.length) { if(input[i] != ' ') { temp= input[i].ToString() + temp; } else { if(! isFirstInsert) { builder.append(" "); } builder.append(temp); temp =string.Empty; } i++; }  string output = builder.ToString();	2014-12-10 11:55:15		
8192	qywrh	104	Written with a hard-coded string, but can easily be modified to use arguments passed to the function	2014-12-10 11:55:15		
8193	nhibd	104		2014-12-10 11:55:15		
8194	huiqq	104		2014-12-10 11:55:15		
8195	eucmc	104	Complexity is O(n), and linear on the average length of a word. So if N, with N being the number of words, is larger then the complexity will be O(N), while if m, the average length of words, is larger than N then the complexity will be O(m)	2014-12-10 11:55:15		
8196	plapd	104	Looking at this, I can see where it might be N-squared due to the use of the string's += operator, which in C++ has an unspecified complexity but can be up to linear. I may rewrite this to use separate pointers that then swap through each word instead, but I like this solution for its readability.	2014-12-10 11:55:16		
8197	sqzqo	104	static Stack<String> stack;  public static String reverseString(String stringToReverse) { StringBuilder builder = new StringBuilder(); stack = new Stack<String>();  char[] charArray = stringToReverse.toCharArray();  for(char character : charArray) { stack.add(String.valueOf(character)); }  while(stack.size() >0) { builder.append(stack.pop()); }  String[] individualString = StringUtils.split(builder.toString());  StringBuilder returnString = new StringBuilder();  for(int i=individualString.length-1; i>=0 ; i--) { returnString.append(individualString[i]); returnString.append(" "); }  return returnString.toString(); }	2014-12-10 11:55:16		
8198	xhgls	104	void reverse(char sub_str[], int begin, int end) { char temp; while (begin < end) { temp = sub_str[begin]; sub_str[begin] = sub_str[end]; sub_str[end] = temp; begin++; end--; } }  void reverseWords(char str[], int N) { int begin = 0, end = 0;  while(end < N) { while (end != " " && end != '\0') { end++; } reverse(str, begin, end); // This simply reverses a string end++; begin = end; } } --- O(N) + O(N/2)	2014-12-10 11:55:16		
8199	nwkeg	104	You are including the space in the reverse, which is wrong.	2014-12-10 11:55:16		
8200	zeice	104		2014-12-10 11:55:16		
8201	rrmeu	104		2014-12-10 11:55:16		
8202	jippy	104	Solution in Objective-C leveraging categories. Worst case complexity is O(n + n/2) = O(n).  Tests first:	2014-12-10 11:55:16		
8203	fowai	104		2014-12-10 11:55:16		
8204	bexbp	104		2014-12-10 11:55:16		
8205	xhgls	104	Category header:	2014-12-10 11:55:16		
8206	huiqq	104		2014-12-10 11:55:16		
8207	nwkeg	104		2014-12-10 11:55:16		
8208	azmjc	104	Implementation:	2014-12-10 11:55:16		
8209	xhgls	104		2014-12-10 11:55:16		
8210	ufdxg	104		2014-12-10 11:55:16		
8211	ufdxg	104	The naive solution would be to split the string, then reverse each substring. Many responses claim this is `O(n)`, but this is incorrect. Splitting the string is `O(n)`. Reversing a string is `O(n)`. If a split produces `m` substrings, each of them must be reversed, which is `O(mn)`, or `O(n^2)`.  A more efficient solution is as follows:  1. Initialize `reversed`, an empty, mutable string, and `reversedIndex`, the index at which we will insert characters into the reversed string. 2. Iterate over the original string in reverse order. 3. For each character in the original string, check whether it is whitespace. 3a. If it is, put it at the beginning of `reversed`, and reset `reversedIndex` to 0. 3b. If it is not, insert it into `reversed` at the `reversedIndex`. Then increment `reversedIndex`.  Objective-C code follows:	2014-12-10 11:55:16		
8212	qywrh	104		2014-12-10 11:55:16		
8213	huiqq	104		2014-12-10 11:55:16		
8214	zeice	104	And here is the test:	2014-12-10 11:55:16		
8215	qywrh	104		2014-12-10 11:55:16		
8216	nwkeg	104		2014-12-10 11:55:16		
8217	wbqzu	104	You can improve the readability/maintainability of the code by replacing the call to `-isEqualToString:` with a category method. Also, you could add a method to `NSMutableString` that allows you to prepend a string to `reversed`, instead of using `+stringWithFormat:` like I did.	2014-12-10 11:55:16		
8218	zeice	104	Typo: in the tests, it should be `reversedWords`, not `cup_reversedWords`.	2014-12-10 11:55:16		
8219	rdfeo	104	The split solution is indeed O(n), with n be the total number of characters in the input string. Even though we have to do reverse word multiple times, each word reverse only scan it's own number of characters, which all adds up to n. The problem with split solution is extra storage, not time.	2014-12-10 11:55:16		
8220	zeice	104	public static void main(String args) { String str = "why so serious"; String[] arr = str.split(" "); StringBuffer stringBuffer = new StringBuffer(); for(String st : arr){ stringBuffer.append(reverseString(st)+ " "); } System.out.println(stringBuffer.toString().trim()); }  private static StringBuffer reverseString(String str) { StringBuffer buffer = new StringBuffer(str); return buffer.reverse(); }	2014-12-10 11:55:16		
8221	dgjji	104		2014-12-10 11:55:16		
8222	rrmeu	104		2014-12-10 11:55:16		
8223	wbqzu	104	public class Reverse {  private static String ReverseWord(String word) { int length = word.length();  int start = 0; int end = length - 1;  char[] charArr = word.toCharArray();  while(start < end) { char temp = word.charAt(start); charArr[start]= word.charAt(end); charArr[end] = temp;  start++; end--; }  return new String(charArr); }  private static String ReverseSentenceInPlace(String sentence) { String[] words = sentence.trim().split(" "); int index = 0;  for(String word : words) { words[index] = ReverseWord(word); index++; }  return Arrays.toString(words); }  public static void main(String[] args) { System.out.println(ReverseSentenceInPlace("the boy ran")); }  }	2014-12-10 11:55:16		
8224	bexbp	104	Maybe I am seeing this wrong, people writing tons of code for such a simple program. Well dont blame me because it is from the view point of a student who is learning java.	2014-12-10 11:55:16		
8225	ufdxg	104		2014-12-10 11:55:16		
8226	gilit	104		2014-12-10 11:55:16		
8227	nwkeg	104	}	2014-12-10 11:55:16		
8228	ewigy	104		2014-12-10 11:55:16		
8229	bjsiw	104		2014-12-10 11:55:16		
8230	ftfck	104		2014-12-10 11:55:16		
8231	ufdxg	104		2014-12-10 11:55:16		
8232	nwkeg	104	to get rid of extra white space!	2014-12-10 11:55:16		
8233	ethan	104		2014-12-10 11:55:16		
8234	sgiwy	104		2014-12-10 11:55:16		
8235	plapd	104	O(n) solution with the use of Stack and no extra loops	2014-12-10 11:55:16		
8236	fowai	104		2014-12-10 11:55:16		
8237	sgiwy	104		2014-12-10 11:55:16		
8238	cfzie	104	Small correction - Sorry it is O(n + k*m), where k is number of words and m is the average size of each word.	2014-12-10 11:55:16		
8239	mrjku	104	O(n + klogm) solution with the use of Stack, where k is number of words and m is the average size of each word.	2014-12-10 11:55:17		
8240	fmzze	104		2014-12-10 11:55:17		
8241	sqzqo	104		2014-12-10 11:55:17		
8242	bjsiw	104	Small correction - Sorry it is O(n + k*m)	2014-12-10 11:55:17		
8243	vanul	104		2014-12-10 11:55:17		
8244	nhibd	104		2014-12-10 11:55:17		
8245	xhgls	104	Ruby (not a developer language, I know, but it's what I need).	2014-12-10 11:55:17		
8246	dgjji	104		2014-12-10 11:55:17		
8247	eucmc	104		2014-12-10 11:55:17		
8248	ethan	104	O(N)	2014-12-10 11:55:17		
8249	ewigy	104		2014-12-10 11:55:17		
8250	azmjc	104		2014-12-10 11:55:17		
8251	fmzze	104	This is the most naive and easy solution given by me. I hope this is correct without any errors.	2014-12-10 11:55:17		
8252	qywrh	104	using the automatic NSString enumeration reverses the string itself.. this would be the function	2014-12-10 11:55:17		
8253	huiqq	104		2014-12-10 11:55:17		
8254	ftfck	104		2014-12-10 11:55:17		
8255	ftfck	104		2014-12-10 11:55:17		
8256	fowai	104		2014-12-10 11:55:17		
8257	bjsiw	104	public static void reverseString(String s){ char[] output = new char[s.length()]; for(int i=s.length()-1;i>=0;i--) output[s.length()-1-i]=s.charAt(i); String[] o = String.valueOf(output).split(" "); for(int i=0; i<o.length; i++){ if(i>0 && i<o.length) System.out.print(" "); System.out.print(o[o.length-1-i]); } System.out.println(); }  O(n)	2014-12-10 11:55:17		
8258	rrmeu	104	# reverse just words in a string def reverse_whole(mystr) i=0 while(i<mystr.size && mystr[i] == ' ') i+=1 end  while(i<mystr.size) j=i while(j<mystr.size && mystr[j]!=' ') j+=1 end reverse(mystr,i,j-1) i=j+1 end puts mystr end  #reverse a word def reverse(mystr,i,j) while(i<j) tmp = mystr[i] mystr[i] = mystr[j] mystr[j] = tmp i+=1 j-=1 end end   # Run Result reverse_whole(" the boy ran hello ") eht yob nar olleh	2014-12-10 11:55:17		
8259	ufdxg	104		2014-12-10 11:55:17		
8260	nwkeg	104		2014-12-10 11:55:17		
8261	fowai	104		2014-12-10 11:55:17		
8262	bexbp	104		2014-12-10 11:55:17		
8263	sgiwy	104		2014-12-10 11:55:17		
8264	krxlv	104		2014-12-10 11:55:17		
8265	cfzie	104	Time O(n), space O(1), if string were mutable in Java. Keep two indexes, one for word begin and the other for word end. Scan input character by character, when a space character is found, reverse the word between begin and end. Update the indexes and repeat the reverse work, until the end of input.	2014-12-10 11:55:17		
8266	plapd	104		2014-12-10 11:55:17		
8267	krxlv	104		2014-12-10 11:55:17		
8268	vanul	104		2014-12-10 11:55:17		
8269	qywrh	104		2014-12-10 11:55:17		
8270	zeice	104		2014-12-10 11:55:17		
8271	eucmc	104		2014-12-10 11:55:17		
8272	xhgls	104		2014-12-10 11:55:17		
8273	nwkeg	104		2014-12-10 11:55:17		
8274	jippy	104	Time Complexity: O(N)  Space Complexity: O(2) as this is not in place reverse.  private String reverseSentence(String sentence) { if (sentence == null || sentence.length() < 2) { return sentence; }  String result = ""; String buffer = ""; for (int index = 0; index < sentence.length(); index++) { if (sentence.charAt(index) == ' ') { result += buffer + ' '; buffer = ""; } else { buffer = sentence.charAt(index) + buffer; }  if (index == sentence.length() - 1) { result += buffer; } }  return result; }	2014-12-10 11:55:17		
8275	nwkeg	104	in C#	2014-12-10 11:55:17		
8276	mrjku	104		2014-12-10 11:55:17		
8277	jippy	104		2014-12-10 11:55:17		
8278	sqzqo	104	The time complexity is O(n) I am getting the first index of space character ' '. Once found I am reversing the word before space char. I am assuming the string input is "the boy ran" and neglecting @	2014-12-10 11:55:17		
8279	ftfck	104		2014-12-10 11:55:17		
8280	huiqq	104		2014-12-10 11:55:18		
8281	fmzze	104		2014-12-10 11:55:18		
8282	sqzqo	104		2014-12-10 11:55:18		
8283	mrjku	104		2014-12-10 11:55:18		
8284	nwkeg	104		2014-12-10 11:55:18		
8285	ftfck	104		2014-12-10 11:55:18		
8286	nhibd	104		2014-12-10 11:55:18		
8287	zeice	104		2014-12-10 11:55:18		
8288	rrmeu	104		2014-12-10 11:55:18		
8289	rdfeo	104	Inplace, O(1) memory , O(n) time code in C:	2014-12-10 11:55:18		
8290	huiqq	104		2014-12-10 11:55:18		
8291	nwkeg	104		2014-12-10 11:55:18		
8292	nwkeg	104	Another approach would be to use regex to split and reverse string.Code in python:	2014-12-10 11:55:18		
8293	mrjku	104		2014-12-10 11:55:18		
8294	cfzie	104		2014-12-10 11:55:18		
8295	cfzie	104		2014-12-10 11:55:18		
8296	admin	104		2014-12-10 11:55:18		
8297	bexbp	104	something like	2014-12-10 11:55:18		
8298	ethan	104		2014-12-10 11:55:18		
8299	zeice	104		2014-12-10 11:55:18		
8300	fmzze	104	order will be O(n) yes it has space complicity.	2014-12-10 11:55:18		
8301	qywrh	104	This is O(n^2) due to string concatenation being O(n)	2014-12-10 11:55:18		
8302	krxlv	104	its still single pass over input data.	2014-12-10 11:55:18		
8303	fowai	104		2014-12-10 11:55:18		
8304	mrjku	104		2014-12-10 11:55:18		
8305	gilit	104	u are reversing whole string not words	2014-12-10 11:55:18		
8306	nwkeg	104	@Keshav: My Bad, care to check now..??	2014-12-10 11:55:18		
8307	tenuw	105	There is an easier solution: void Test(int N, int k) { if (k > N) {return;}  for(int i = 0; i<10; i++) { if (k <= N) { cout<<k<<endl;  k *= 10; Test(N, k); k /= 10; k++; if (k%10 == 0) return; } } }  To call this use Test(25, 1), for example	2014-12-10 11:55:22		
8308	ufdxg	105	Good one!	2014-12-10 11:55:22		
8309	mrjku	105	like this one. nice and neat!	2014-12-10 11:55:22		
8310	nwkeg	105	Do you think this version is better or worse?  void Lexi2(int N, int k=1) { for(int i = 0; i<10 && k+i<N && (k!=1||i!=9); i++) { std::cout<<k+i<<", "; Lexi2(N, (k+i)*10); } }	2014-12-10 11:55:22		
8311	fowai	105		2014-12-10 11:55:22		
8312	zeice	105		2014-12-10 11:55:22		
8313	bexbp	105		2014-12-10 11:55:22		
8314	fowai	105		2014-12-10 11:55:22		
8315	sqzqo	105	I like this one. You are hired :D	2014-12-10 11:55:22		
8316	fowai	105	this code outputs 11 before 100 --- this is not correct	2014-12-10 11:55:22		
8317	plapd	105	can you give an example	2014-12-10 11:55:22		
8318	gilit	105	I've edited the question to provide an example.	2014-12-10 11:55:22		
8319	jippy	105	As my understanding the lexicographic order / dictionary order of numbers for the range 0 to 20 is  0 1 10 11 12 13 14 15 16 17 18 19 2 20 3 4 5 6 7 8 9  Correct me if I'm wrong...	2014-12-10 11:55:22		
8320	azmjc	105	* As per my understanding	2014-12-10 11:55:22		
8321	bjsiw	105	The only thing I can think is divide numbers by multiples of 10 and then compare each result by implementing some kind of compareTO	2014-12-10 11:55:22		
8322	nhibd	105	After lot of math and paper work here is the code in C# with inline comments  O(n) time and O(1) space complexity	2014-12-10 11:55:22		
8323	sgiwy	105		2014-12-10 11:55:22		
8324	ethan	105		2014-12-10 11:55:22		
8325	gilit	105	The above code gives you just the idea and it can be refactored more to reduce some Math.	2014-12-10 11:55:22		
8326	ewigy	105	#include <stdlib.h> #include <stdio.h> #include <iostream> void printHelper(int i, int range){ if (i>range) return; if (i != 0){ std::cout<<i<<std::endl; } int next = i*10; if (next <=range){ for (int k = 0;k<=9 & (next+k<=range);k++){ printHelper(next+k,range); } } } void printNumber(int N){ for (int i = 1;i<10;i++){ printHelper(i,N); } } int main(){ int N; std::cin>>N; printNumber(N); }  ~	2014-12-10 11:55:22		
8327	jippy	105	The algo will be like this:  Step 1: find out the no of digits(say n)  Step 2: for i=1 to n and digit is 1 a. i=1, print 1 b. i=2, print 10-19(next 10) c. i=3, print 100-199(next 10^(i-1))..  step 3: repeat the step 2 for digit 2 to 9 as well.. This will give us the proper result.	2014-12-10 11:55:22		
8328	plapd	105		2014-12-10 11:55:22		
8329	krxlv	105		2014-12-10 11:55:22		
8330	dkebi	105		2014-12-10 11:55:23		
8331	dgjji	105		2014-12-10 11:55:23		
8332	huiqq	105	Use Recursion to Print it out. The idea is before printing the next number, exhaust all the number with the current prefix. The solution will be simple like the following one.  Also the search should blindly start from 0 and end at 9. Because if you were asked for numbers from 15 to 999, the very first number to appear will be 100 which will be missed if we start from 15 to 99.	2014-12-10 11:55:23		
8333	zeice	105		2014-12-10 11:55:23		
8334	dgjji	105		2014-12-10 11:55:23		
8335	cfzie	105	MSD radix sort.	2014-12-10 11:55:23		
8336	bjsiw	105	public class PrintLexNumbers { public static int LIMIT = 100; /** * @param args */ public static void main(String[] args) {  boolean[] result = new boolean[LIMIT]; printLex(100, 1, result);  }  public static void printLex(int limit, int n, boolean[] result){  if(n>limit || result[n]) return; else{ result[n]=true; System.out.println(n); printLex(limit, n*10, result); } if(n <10 || n%10 == 0){ for(int i=1;i<10;i++){ printLex(limit, n+i, result); } }  }  }	2014-12-10 11:55:23		
8337	krxlv	105	C#:	2014-12-10 11:55:23		
8338	dkebi	105		2014-12-10 11:55:23		
8339	eucmc	105		2014-12-10 11:55:23		
8340	ethan	105	Another solution: the idea is to simply write a "lexicographic comparator" for integers and just pass that to the language's built-in sort function (code is F#)	2014-12-10 11:55:23		
8341	ftfck	105		2014-12-10 11:55:23		
8342	nwkeg	105		2014-12-10 11:55:23		
8343	eucmc	105	You asked for lexicographic order and don't want to convert it to character strings. But according to lexicographic order your example shows "one -> ten -> eleven and so on". Please edit your question : "Lexicographic order" seems pretty misleading. Your example tells what is the question.	2014-12-10 11:55:23		
8344	fmzze	105	// I just write the solution in JavaScript function list(n, m) { var i; for (i = n; i <= m && i < Math.floor((n + 10) / 10) * 10; i++) { console.log(i); if (i <= m) { list(i * 10, m); } } } list(1, 25);	2014-12-10 11:55:23		
8345	bexbp	105	Here is the complete and simplest solution in O(n log n) time and O(n) space. 1. Generate all the numbers from 1 to n. 2. Sort the numbers, use lexicographic order while comparing. 3. Print the sorted list.	2014-12-10 11:55:23		
8346	sgiwy	105		2014-12-10 11:55:23		
8347	cfzie	105		2014-12-10 11:55:23		
8348	ewigy	105		2014-12-10 11:55:23		
8349	dgjji	105		2014-12-10 11:55:23		
8350	huiqq	105	There's a part missing the above code. I am sorry for the mistake. Here's the correct version:	2014-12-10 11:55:23		
8351	nhibd	105		2014-12-10 11:55:23		
8352	rrmeu	105		2014-12-10 11:55:23		
8353	ftfck	105		2014-12-10 11:55:23		
8354	huiqq	105		2014-12-10 11:55:23		
8355	mrjku	105	import java.util.ArrayList;  public class LexiSort {  public static void main(String[] args){       ArrayList<Integer> al = new ArrayList<Integer>();   int[] a = {};  for(int j=1;j<=9;j++){  for(int k=1;k<25;k++) {  if(k%10 == j && k/10 == 0){  al.add(k);   }   else if(k/10 == j){  al.add(k);  }      } } //System.out.print(al.size()); for(int i=0;i<al.size();i++){   System.out.println(al.get(i));  }       } }	2014-12-10 11:55:23		
8356	rrmeu	105	Your code works but the code complexity is O(n^2)	2014-12-10 11:55:23		
8357	ewigy	105		2014-12-10 11:55:23		
8358	ewigy	105		2014-12-10 11:55:23		
8359	ftfck	105		2014-12-10 11:55:23		
8360	fmzze	105		2014-12-10 11:55:23		
8361	jippy	105	Use radix from msd to lsd and with each radix, put bucket according to the msd recently sorted.	2014-12-10 11:55:23		
8362	mrjku	105	Use DFS #include <iostream>  using namespace std;  void dfs(int seed, int n){ if(seed > n) return; cout<<seed<<endl; for(int i=0; i<=9; i++){ int newseed = seed * 10 + i; dfs(newseed, n); } }  void printlexico(int n){ if(n < 1) return; for(int i=1; i<=9; i++){ dfs(i, n); } }  int main() { printlexico(25);  return 0; }	2014-12-10 11:55:23		
8363	bexbp	105	Use DFS	2014-12-10 11:55:23		
8364	vanul	105		2014-12-10 11:55:23		
8365	ftfck	105		2014-12-10 11:55:23		
8366	gilit	105	A very easy Solution:  Can be used for general case For N=25:  void printLexi(int N) { int i=1,j=0,k=10; while(k<N) { cout<<i; j++; while(k/10 == i){cout<<k; j++ ; k++; } i++; } }	2014-12-10 11:55:23		
8367	bexbp	105		2014-12-10 11:55:23		
8368	rdfeo	105		2014-12-10 11:55:23		
8369	ewigy	105	A comparer for std::sort... Just call std::sort with it.	2014-12-10 11:55:23		
8370	fmzze	105		2014-12-10 11:55:23		
8371	nwkeg	105		2014-12-10 11:55:23		
8372	sqzqo	105		2014-12-10 11:55:23		
8373	ufdxg	105		2014-12-10 11:55:24		
8374	krxlv	105	void Print(int p, int n){ if(p > n) return; cout << p << endl; for(int i = 0; i <= 9; ++i){ if(p*10 + i <= n) Print(p*10+i,n); } if(p < 9) Print(p+1,n); }	2014-12-10 11:55:24		
8375	cfzie	105		2014-12-10 11:55:24		
8376	vanul	105		2014-12-10 11:55:24		
8377	rdfeo	105	}	2014-12-10 11:55:24		
8378	ufdxg	105		2014-12-10 11:55:24		
8379	dgjji	105		2014-12-10 11:55:24		
8380	sqzqo	105	}	2014-12-10 11:55:24		
8381	krxlv	105		2014-12-10 11:55:24		
8382	xhgls	105		2014-12-10 11:55:24		
8383	fmzze	105	GOOD ONE SIMPLE	2014-12-10 11:55:24		
8384	gilit	105	Here's my version	2014-12-10 11:55:24		
8385	azmjc	105		2014-12-10 11:55:24		
8386	admin	105		2014-12-10 11:55:24		
8387	rdfeo	105	Oh there is no need for that vector of vectors. I was trying something else earlier. Apologies	2014-12-10 11:55:24		
8388	jippy	105	in javascript	2014-12-10 11:55:24		
8389	rrmeu	105		2014-12-10 11:55:24		
8390	wbqzu	105		2014-12-10 11:55:24		
8391	ethan	105	oops.	2014-12-10 11:55:24		
8392	nwkeg	105		2014-12-10 11:55:24		
8393	fmzze	105		2014-12-10 11:55:24		
8394	huiqq	105	public static void printLexi(int n) { int x=0; for(int i=1;i<=9;i++) { x=i; System.out.println(x); x *=10; for(int z = 0;z<10;z++) { if((x<=n)) { System.out.println(x); x++; } else break; } } }	2014-12-10 11:55:24		
8395	jippy	105	jh	2014-12-10 11:55:24		
8396	jippy	105	void outVal(int target, int cur, vector<int>& res) { if(cur>target) return;  res.push_back(cur);  for(int i=0; i<=9; i++) outVal(target, cur*10+i, res); }  vector<int> outVal(int target) { vector<int> res;  for(int i=1; i<9; i++) outVal(target, i, res);  return res; }	2014-12-10 11:55:24		
8397	jippy	105		2014-12-10 11:55:24		
8398	ewigy	105		2014-12-10 11:55:24		
8399	zeice	105	What I would do is pretty simple: put those numbers into an array and sort it, but, instead of having the common order operator to make the swap, I'd do my own, which would be like these: Given two number, X and Y, we will find the smallests 10^powerX > X and 10^powerY > Y. After that, we would lower each of its 'power_i' to check each digit (coming from above back to 1) and check whether the actual value of every digit is the same; if it's not, we already find a difference, and only check who's bigger. If any of the numbers 'end' (by 'end' I mean we have arrived at the units) and we had no answer yet, we simply check who's greater, X or Y. I've done a code to explain better what I wanted.	2014-12-10 11:55:24		
8400	wbqzu	105		2014-12-10 11:55:24		
8401	fmzze	105		2014-12-10 11:55:24		
8402	nwkeg	105	function lex(n) { function print(m) { if (m > n) { return; } console.log(m); for (var i=0; i<=9; i++) { print(+(m+''+i)); } } for (var i=1; i<=9; i++) { print(i); } } lex(120);	2014-12-10 11:55:24		
8403	jippy	105		2014-12-10 11:55:24		
8404	rdfeo	105		2014-12-10 11:55:24		
8405	qywrh	105	some modification to above cod	2014-12-10 11:55:24		
8406	qywrh	105		2014-12-10 11:55:24		
8407	ewigy	105		2014-12-10 11:55:24		
8408	fmzze	105		2014-12-10 11:55:24		
8409	sgiwy	105		2014-12-10 11:55:24		
8410	vanul	105		2014-12-10 11:55:24		
8411	rdfeo	105		2014-12-10 11:55:24		
8412	bexbp	105	Goddamnit. I just realized that you can just initialize the divisor to 1 and the map before the main loop. So this little refactor will get rid of the if-else in the main loop.	2014-12-10 11:55:24		
8413	mrjku	105		2014-12-10 11:55:25		
8414	rdfeo	105		2014-12-10 11:55:25		
8415	zeice	106	rearrange them in the format of interval: [-1,1] [-4,6] ... then the problem becomes checking overlapping intervals. just sort them on the base of starting point and binary search each end point in the sorted list	2014-12-10 11:55:26		
8416	jippy	106	checking of overlapping intervals is not done using binary search. If we search the sorted list using the end point of the current disc, the range between this point and the starting point will contain discs that their start point is in that range, so they potentially intersect the current disc. But some of them may also end before the current disc end point, so they dont intersect the current disc. Therefore your algorithm is wrong, unless you check the end point of all the discs in the start-end range of the current disc, which will make this a O(n^2) time algorithm, just like the naive solution.	2014-12-10 11:55:26		
8417	xhgls	106	I believe his answer implied that we only consider discs that start below the current disc (which can be determined in constant time). Considering discs above would count each intersection twice.	2014-12-10 11:55:26		
8418	mrjku	106	Obviously his algorithm only considers discs that started before the current disc, since it's iterating on the list sorted by starting points. But from those discs, how does he find which discs end after the current disc's starting point (thus intersecting the current disc). There is no way (in this algorithm) to find these discs without scanning all the discs, which would make this o(n^2).	2014-12-10 11:55:26		
8419	bjsiw	106	Reread the question. Based on the question an intersection between 2 disk occurs if any points within (or on the edge) the disc is shared with any point within (or on the edge) of another disc. This is why he called it disc and not circle. Your concern only occurs if we would be interested in circumference intersection which is not the case here.	2014-12-10 11:55:26		
8420	eucmc	106	@gen-y-s The way I read it, he's iterating on the original list sorted by center, not the new list sorted by starting point. As he goes along the first list, he searches for intersecting discs in the second list. This process should take O(N log N).  Please look below for the elaboration I wrote yesterday, based on what I think he is saying.	2014-12-10 11:55:26		
8421	fowai	106	@Zythum, I now understand his algorithm - it's basically for each disc, to find all the discs that overlap it. @Barry, your explanation is not correct. The center of the disc is not relevant, only the top and bottom. Also, the order of the discs we iterate over doesn't matter in this algorithm. Therefore, it would work even if the original list wasn't ordered at all and you iterated over it to find the overlapping discs using the sorted list. This means that zyfo's algorithm doesn't require any extra storage if you sort the original list in-place.	2014-12-10 11:55:26		
8422	rrmeu	106	I agree the location of the center of the disc is irrelevant to determining overlap, but it's a useful way to index the discs for the purposes of iteration because it guarantees we can iterate in precisely O(N) time. Plus we receive the data this way.  Keeping the original list does require more space, but that is allowed by the problem.  It's possible my explanation is incorrect because it's hard to tell what the original poster was saying, but my solution is still correct. I think there is more than one correct way to iterate over of the discs...	2014-12-10 11:55:26		
8423	nhibd	106	Same idea as zyfo2's. The follwoing is my Java implementation with a simple test:	2014-12-10 11:55:26		
8424	jippy	106		2014-12-10 11:55:26		
8425	dkebi	106		2014-12-10 11:55:26		
8426	qywrh	106	@Alva0930 Can you please explain how this equals the number of overlapping discs?	2014-12-10 11:55:26		
8427	fmzze	106		2014-12-10 11:55:26		
8428	bjsiw	106		2014-12-10 11:55:26		
8429	eucmc	106	Thanks	2014-12-10 11:55:26		
8430	admin	106	I've been thinking about it, and I don't think any solution that uses a binary search to find the tops and/or bottoms of discs will guarantee a worst-case complexity of O(N log N). The problem is that a binary search has a complexity of O(N) in the case where all the tops (or bottoms) overlap. Multiply this by the iteration and we have a worst-case complexity of O(N^2) for any solution that uses this approach. :(  I'm starting to think that interval trees (see below) are the way to go.  http://en.wikipedia.org/wiki/Interval_tree	2014-12-10 11:55:26		
8431	cfzie	106		2014-12-10 11:55:26		
8432	cfzie	106		2014-12-10 11:55:26		
8433	fowai	106	These two lines are used to find how many begin points are less than or equal to the current end point. The following is the description of the return value of Arrays.binarySearch() in JavaDoc: Returns: index of the search key, if it is contained in the array; otherwise, (-(insertion point)- 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.	2014-12-10 11:55:26		
8434	ufdxg	106		2014-12-10 11:55:26		
8435	ewigy	106		2014-12-10 11:55:26		
8436	rdfeo	106	For a given disc(for example: A[2] = 2), we must subtract the begin points from disc on the left(for example: A[0] = 1 and A[1] = 5) to prevent double counting, and we alos need to subtract the disc itself(for example: A[2] = 2). The example I used is the example of original question. The following are the logs of execution. You may compare the logs with the result of the example of original question.	2014-12-10 11:55:26		
8437	vanul	106		2014-12-10 11:55:26		
8438	ethan	106		2014-12-10 11:55:26		
8439	ethan	106	BTW, the time complexity of my Java implementation is O(N logN).	2014-12-10 11:55:26		
8440	vanul	106	This solution occupies O(n) extra space and works in O(logn), Does it sound correct?:  I write down the max and min points of the circles and store them in an array using a data structure to identify the index of each point. Then, I sort them in nlogn.  Next I iterate through the array keeping note of circle starts and ends using a hashmap and whenver a circle ends, all the circles which are enveloping it add to the number of intersections. Hence, I add them up.	2014-12-10 11:55:26		
8441	rrmeu	106		2014-12-10 11:55:26		
8442	qywrh	106		2014-12-10 11:55:26		
8443	admin	106	First of all, you may not need to sort the index. Because, the index is already sorted. Here is the hint from the question " such that the I-th disc is centered on (0,I) "	2014-12-10 11:55:26		
8444	vanul	106	I am not sorting by the index but by the value so that I have a list of all starting and ending points of the circles which is my data structure B.	2014-12-10 11:55:26		
8445	krxlv	106	Could you explain what you mean by envelop? The question mentions disks that intersect, so there may be disks that are enveloped by others yet share no points. Am I missing something here?	2014-12-10 11:55:26		
8446	huiqq	106	You mean "works in O(n log n)" , not "O(log n)", right?	2014-12-10 11:55:27		
8447	fmzze	106	@barry The question specifies that an intersection between 2 circles, in this case, occurs if any point of the inner disk (not just the edge) is share with any other disk. @Kosuru This is the best solution around so far, a HashSet will do the map too, you are not really using that boolean value in the map.	2014-12-10 11:55:27		
8448	dgjji	106	Unfortunately looking up discs in a hash map while iterating through the list will have worst-case time of O(N^2 log N). Consider the case where ALL the discs are overlapping: they will all be in the same bucket so each lookup will take O(N)..  I do believe your algorithm has AVERAGE performance of O(N log N), though.	2014-12-10 11:55:27		
8449	zeice	106	Scratch that. They can't ALL be overlapping since they're evenly spaced.	2014-12-10 11:55:27		
8450	sgiwy	106	Unscratch that. If you're mapping on the start or end (not the center), they can all overlap.	2014-12-10 11:55:27		
8451	rrmeu	106	@Zythum42 its any shared point, thank you.	2014-12-10 11:55:27		
8452	ethan	106	Re-scratch that. :) I see you're using the center as your hash key. Looks good to me.  One nitpick: Arrays.sort() uses quicksort which has a worst-case complexity of O(N^2). Replacing it with mergesort or heapsort would fix that.	2014-12-10 11:55:27		
8453	ftfck	106	@Barry Add, Remove and Contains provide Constant O(1) time complexity on HashSet and HashMap. However, since there are no ordering in HashMap/Set, and say we are trying to find the top Key or something like that, this is where the complexity O(N) kicks in and this is where you will favor the usage of Trees. However, there's no such logic required in the above code, unless I am missing something.	2014-12-10 11:55:27		
8454	ethan	106	@Zythum42 Hash map operations only guarantee constant time with a perfect hash function and a big enough table. Worst-case is not constant, for example, if all the entries are identical.  However that is not an issue in this case (which is why I re-scratched my original argument).  I think we are making the same point, though. :)	2014-12-10 11:55:27		
8455	zeice	106	@Barry. Yep. Also I was under the impression that the sort method from Array Utils in Java will use the merge sort when you define your own comparator. Quicksort is used for primitive type for which no comparator definition is required... Would need to double check though.	2014-12-10 11:55:27		
8456	rdfeo	106	Sorry I was logged out.	2014-12-10 11:55:27		
8457	nhibd	106	@Barry : yep, missed the n in nlogn. @Zythum : thanks for the feedback. @Arthur: If there are two circles and one circle lies completely inside other, I used the word enveloping.	2014-12-10 11:55:27		
8458	dkebi	106	One small issue with code above: - when two discs have start and end point in same place the order of sorting is not defined, what may cause errors in counting the correct value of intersections. To resolve the problem we can simply fix comparator to return starting points befeore ending points.	2014-12-10 11:55:27		
8459	ethan	106	1. merge start / end of all intervals in ONE array, keeping a flag that marks whether it's a start or an end. 2. sort it. 3. scan the sorted array by updating two variables, i for open intervals and c for intersection count. - if we meet a start point, count+=i and i++ - if we meet an end point, i--.  There you go.  For the example in the question, we get a sorted array of the intervals and scan/update like this	2014-12-10 11:55:27		
8460	cfzie	106		2014-12-10 11:55:27		
8461	huiqq	106		2014-12-10 11:55:27		
8462	ftfck	106	Time complexity is O(NlgN) and space complexity is O(N).	2014-12-10 11:55:27		
8463	qywrh	106	a very intelligent solution i think... as the range of N and elements of A are given, we can sort in linear time and then scan the sorted list. Then it is possible to solve this problem in O(n) time complexity.	2014-12-10 11:55:27		
8464	ethan	106	I think it doesn't work for the following case: {100, 1}. (The answer should be 0.)	2014-12-10 11:55:27		
8465	sqzqo	106	Sorry, nevermind. It's OK since those are discs, not circles.	2014-12-10 11:55:27		
8466	rdfeo	106		2014-12-10 11:55:27		
8467	bjsiw	106		2014-12-10 11:55:27		
8468	sgiwy	106	How can the expected complexity (assuming the expectation is taken over the draw of random numbers in your algorithm and not some sort of a random draw of discs) be O(n log n), when the size of the output for some trivial cases is O(n^2)?	2014-12-10 11:55:27		
8469	xhgls	106	The question only asks for the number of intersecting circles. You don't have to print out which ones intersect.	2014-12-10 11:55:27		
8470	wbqzu	106	@eugene.yaravoi Excellent point. It is important to understand the difference between a "find all" and "count all" problem. The former usually has higher complexity.	2014-12-10 11:55:27		
8471	ewigy	106	Program:	2014-12-10 11:55:27		
8472	ftfck	106		2014-12-10 11:55:27		
8473	eucmc	106		2014-12-10 11:55:27		
8474	qywrh	106	Output:	2014-12-10 11:55:27		
8475	ftfck	106		2014-12-10 11:55:27		
8476	sgiwy	106		2014-12-10 11:55:27		
8477	azmjc	106	This solution is O(n^2). For example, you could have concentric circles. The upper bound would still be O(n) for the inner for-loop. Hence, O(n^2).	2014-12-10 11:55:27		
8478	ftfck	106	@Jack: I think the idea is to say the complexity is O(n log n + R) where R is the number of intersections. You're right that the number of intersections could be quadratic, but the idea is that this algorithm is reasonable if R is small.  It's true that the problem can be solved in O(n log n) overall, regardless of R.	2014-12-10 11:55:27		
8479	azmjc	106	use stl, and it is much more convenient:	2014-12-10 11:55:27		
8480	ethan	106		2014-12-10 11:55:27		
8481	qywrh	106		2014-12-10 11:55:27		
8482	ewigy	106	Use Interval trees. Search the page on Interval trees on Wikipedia.	2014-12-10 11:55:27		
8483	gilit	106	You can just solve this problem with an array and some sorting. Consider that the problem can be converted to a instance of a problem where we have a list of intervals and we ask how many pairs of intervals overlap.	2014-12-10 11:55:27		
8484	azmjc	106	My idea: a> Build an array containing left point and right point of each pixel. Each left point or right point consume on item in the array. Here is some extra trick, shift the original (left, right) ==> (left*2-1, right*2). The extra logic is making sure we can sort easily for the case that left value of some point is the same right value of some point (or even same point, in which its range is zero), in which case we need to be sure left value should be put before the right value(single point contact is till contact). And also we need to know if it is left /right value according to its value, easily. b> merge sort the array. We need to use merge sort because worse case of quicksort is bigger than O(nlogn). The array's len is 2N, (left +right), so the merge sort will have O(2NLOG(2N)), still O(NLOGN) c> Go through the sorted array, if it is left value, which means we found start of a new disk, so we can add preexisted disk number as total number of overlappled pair number and then increased of preexisted disk number. If it is right value, which means we found end of a new disk, we need to delete the preexisted disk number. d> This logic bellow does not care the number limiting issue. (such 10,000,000). Some extra logic could be added for that. e> Time complexity is O(NLOGN)+2N , still O(NLOGN). Space complexity, 2N for array, N for mergeSort, so still O(N).	2014-12-10 11:55:27		
8485	ufdxg	106	Here is my code:	2014-12-10 11:55:28		
8486	dkebi	106		2014-12-10 11:55:28		
8487	cfzie	106		2014-12-10 11:55:28		
8488	dgjji	106	The code has passed test of the example shown by the interview question, also some simple cases.	2014-12-10 11:55:28		
8489	mrjku	106	I like zyfo2's answer but it's a little terse so I'll offer my elaboration:  1. We are given a list of discs already sorted by the location of the center of disc. Create a second list of discs that is sorted by the location of the top of the disc. If we use mergesort, this operation will take O(N log N) in the worst case and O(N) space complexity in the worst case.  2. Iterate through the entire given list of discs. For every disc i, search the second list (sorted by top of disc) for the first disc whose top is located at or below the center of disc i. This is the first intersecting disk.  3. Then search for the last disc whose top is located at or above the bottom of disc i (computed as i+A[i]). This is the last intersecting disc. Both searches take O(log N) so we haven't increased the complexity.  4. The difference between the first and last disc (plus one) is the number of discs intersecting with disc i. Add this to a running total.  When we reach the end of the list, the running total will contain the solution. Note that since we are only looking for discs below disc i, we'll never count the same intersection twice.	2014-12-10 11:55:28		
8490	huiqq	106	Here's my solution: 1. Sort the circles by their bottom point (center - radius). 2. Initialize a min-heap that will be used to hold circles with their top point (center+radius) as key. 3. For each circle in the sorted list, compare its bottom value with the min circle on the heap, and pop from the heap all circles that their top point is lower than the current circle's bottom. The rmaining circles in the heap intersect the current circle, since their bottom point is lower than the current circle's bottom point, and their point is higher than the current circles bottom. So add the size of the heap to the count of intersecting circles. Push the current circle onto the heap. 4. Repeat step 3 for all the circles.	2014-12-10 11:55:28		
8491	wbqzu	106	Here's my solution: 1. Sort the circles by their bottom point (center - radius). 2. Initialize a min-heap that will be used to hold circles with their top point (center+radius) as key. 3. For each circle in the sorted list, compare its bottom value with the min circle on the heap, and pop from the heap all circles that their top point is lower than the current circle's bottom. The rmaining circles in the heap intersect the current circle, since their bottom point is lower than the current circle's bottom point, and their point is higher than the current circles bottom. So add the size of the heap to the count of intersecting circles. Push the current circle onto the heap. 4. Repeat step 3 for all the circles.	2014-12-10 11:55:28		
8492	xhgls	106		2014-12-10 11:55:28		
8493	bjsiw	106		2014-12-10 11:55:28		
8494	krxlv	106	I got a similar question on my Google interview... and blew it. I wish I had spent more time solving this problem. Ironically, I figured out the optimal solution the next day while walking my dog. It uses DP and goes like this:  1. Sort the discs by top 2. Keep a "meta-disc" in memory and initialize it to the first disc in the sorted list. The meta-disc represents the preceding series of discs that overlap. 3. Iterate through the sorted list, from disc 2 to disc n. 4. If the top of disc i is below the bottom of the meta disc (i.e. we found a gap) re-initialize the meta-disc to disc i and proceed to the next disc. 5. However if the top of disc i is within the meta-disc, it must overlap with one of the preceding discs and we increment the overlap count. 6. Also, if the bottom of disc i is below the bottom of the meta-disc, enlarge the meta-disc by setting it's bottom to the bottom of disc i.  The meta-disc is our DP subproblem-holder. It saves us from checking every disc or searching for particular discs.  The complexity is O(n log n) due to the sort. The iterations take O(n) and don't require a binary search so each iteration takes O(1).	2014-12-10 11:55:28		
8495	cfzie	106	how about this? Create another array of size N. Now for each point from 0 to N, find out how many discs reach that point. (So we init the array to 0 and for all discs d, we increment values from arr[d] to arr[d-radius(d)] and arr[d] to arr[d+radius(d)]. Now the number of overlaps at any point p = arr[p]C2 (arr[p] Choose 2).	2014-12-10 11:55:28		
8496	sqzqo	106	Can some one explain how A[0] and A[1] intersect?? A[0] spans from (-1,1), and A[1] goes from (-4,6). How can these two intersect when A[0] is completely inside A[1]	2014-12-10 11:55:28		
8497	nhibd	106	Two Arrays, one with starting, one with ending points. Sort both O N * log N Iterate on both count the number of intersections O N.   Uses exactly O(N) extra memory and O (n * log n ) computationally.	2014-12-10 11:55:28		
8498	nwkeg	106		2014-12-10 11:55:28		
8499	krxlv	106		2014-12-10 11:55:28		
8500	dkebi	106	Sounds like a programming contest question. Is it really google onsite question?	2014-12-10 11:55:28		
8501	ewigy	106	This solution has some drawbacks as mentioned by others. So, I remove it no to confuse anyone.	2014-12-10 11:55:28		
8502	tenuw	106	The worst case complexity is not O(NlogN), it is O(N^2). Consider the case in which A[i]=N for all i.	2014-12-10 11:55:28		
8503	xhgls	106	You forgot the fact that they are circles. The assumption that the circles starting from the points within the range of list[p].r will be the only ones who are intersecting is wrong. For example lets take a circle starting at (0,10) with radius 6 and another circle at (0,2) with radius 4. Now the point(0,2) does not come under the range of the circle at (0,10) but still if you notice they do intersect.	2014-12-10 11:55:28		
8504	xhgls	106		2014-12-10 11:55:28		
8505	azmjc	106		2014-12-10 11:55:28		
8506	ufdxg	106	The o/p for above program is 17.  When i change the inp[7] to a sorted array, the o/p is 21. This 21 is basically the sum of all elements of the inp[] array.  2,4,1,0,6,5,3 6,5,4,0,3,2,1 * * * *  The asterisks show the positions where sorted array element is higher than original element. Number of asterisks is 4.  Subtracting the number of astersiks from 21(sum of the array) gives 17.  I have tested it for few examples and seems to be fine.  So, sorting time complexity is nlogn, storing the sorted array has space complexity of n.	2014-12-10 11:55:28		
8507	fowai	106	can you explain?  what do you sort?	2014-12-10 11:55:28		
8508	plapd	106	The code i posted is bruteforce. That is just for testing my solution.  I mean to say  1. Add the elements of the input array (say input_arr) and store in int variable ctr. 2. Sort the input array and store in another array say sort_arr. 3. Loop through and find "for how many indices, sort_arr[i] >= input_arr[i]" In my previous comment, ive indicated this by asterisks. 4. Subtract the value of step 3 from int variable ctr.	2014-12-10 11:55:28		
8509	dkebi	107	Add the numbers bitwise mod 3. I guess too many people were just saying "XOR" without understanding properly.	2014-12-10 11:55:30		
8510	admin	107	Can you please explain?	2014-12-10 11:55:30		
8511	gilit	107	Don't think this works if your just saying do (sum of array) mod 3... say the sum is 93... Then (sum of array) mod 3 = 0 which leaves you with possabilities of 3,6,9.... or 94 gives you 1, 4, 7 ect....	2014-12-10 11:55:30		
8512	ftfck	107	*bitwise*	2014-12-10 11:55:30		
8513	sqzqo	107	I think will work if we'll be adding numbers in 3 digit system. For example [2,1,4,5,1,4,2,2,4,1] is equal to [02, 01, 11, 12, 01, 11, 02, 02, 11, 01] in 3 digit system. Adding them "bitwise 3" we'll get: 12 (1=4 mod 3 and 2 = 14 mod 3). (12)3 = (5)10. Implementation might be tricky however.	2014-12-10 11:55:30		
8514	azmjc	107	Not really. From StackOverflow:	2014-12-10 11:55:30		
8515	mrjku	107		2014-12-10 11:55:30		
8516	zeice	107		2014-12-10 11:55:30		
8517	xhgls	107	would u pls give d link of the post on stackoverflow? Or, explain it briefly. Thnx.	2014-12-10 11:55:30		
8518	fmzze	107	@anonymous, I compiled and tested your Stackoverflow code and it works fine. This very very good answer.	2014-12-10 11:55:30		
8519	plapd	107		2014-12-10 11:55:30		
8520	dgjji	107		2014-12-10 11:55:30		
8521	ufdxg	107	Another masterpiece of bitwise manipulation-based solution. Seems this is the best answer for this problem. Would would take the courage to explain it for others? Thanks.	2014-12-10 11:55:30		
8522	cfzie	107	i'm pretty sure u don't need "3 digit system" here. simple binary will do	2014-12-10 11:55:30		
8523	gilit	107	Explanation for siva.sai.2020's code.  The code works in similar line with the question of "finding the element which appears once in an array - containing other elements each appearing twice". Solution is to XOR all the elements and you get the answer.  Basically, it makes use of the fact that x^x = 0. So all paired elements get XOR'd and vanish leaving the lonely element. Since XOR operation is associative, commutative.. it does not matter in what fashion elements appear in array, we still get the answer.  Now, in the current question - if we apply the above idea, it will not work because - we got to have every unique element appearing even number of times. So instead of getting the answer, we will end up getting XOR of all unique elements which is not what we want.  To rectify this mistake, the code makes use of 2 variables. ones - At any point of time, this variable holds XOR of all the elements which have appeared "only" once. twos - At any point of time, this variable holds XOR of all the elements which have appeared "only" twice.  So if at any point time, 1. A new number appears - It gets XOR'd to the variable "ones". 2. A number gets repeated(appears twice) - It is removed from "ones" and XOR'd to the variable "twice". 3. A number appears for the third time - It gets removed from both "ones" and "twice".  The final answer we want is the value present in "ones" - coz, it holds the unique element.  So if we explain how steps 1 to 3 happens in the code, we are done. Before explaining above 3 steps, lets look at last three lines of the code,  not_threes = ~(ones & twos) ones & = not_threes twos & = not_threes  All it does is, common 1's between "ones" and "twos" are converted to zero.  For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order).  Explanation for step 1 ------------------------ Lets say a new element(x) appears. CURRENT SITUATION - Both variables - "ones" and "twos" has not recorded "x".  Observe the statement "twos| = ones & x". Since bit representation of "x" is not present in "ones", AND condition yields nothing. So "twos" does not get bit representation of "x". But, in next step "ones ^= x" - "ones" ends up adding bits of "x". Thus new element gets recorded in "ones" but not in "twos".  The last 3 lines of code as explained already, converts common 1's b/w "ones" and "twos" to zeros. Since as of now, only "ones" has "x" and not "twos" - last 3 lines does nothing.  Explanation for step 2. ------------------------ Lets say an element(x) appears twice. CURRENT SITUATION - "ones" has recorded "x" but not "twos".  Now due to the statement, "twos| = ones & x" - "twos" ends up getting bits of x. But due to the statement, "ones ^ = x" - "ones" removes "x" from its binary representation.  Again, last 3 lines of code does nothing. So ultimately, "twos" ends up getting bits of "x" and "ones" ends up losing bits of "x".  Explanation for step 3. ------------------------- Lets say an element(x) appears for the third time. CURRENT SITUATION - "ones" does not have bit representation of "x" but "twos" has.  Though "ones & x" does not yield nothing .. "twos" by itself has bit representation of "x". So after this statement, "two" has bit representation of "x". Due to "ones^=x", after this step, "one" also ends up getting bit representation of "x".  Now last 3 lines of code removes common 1's of "ones" and "twos" - which is the bit representation of "x". Thus both "ones" and "twos" ends up losing bit representation of "x".  1st example ------------ 2, 2, 2, 4  After first iteration, ones = 2, twos = 0 After second iteration, ones = 0, twos = 2 After third iteration, ones = 0, twos = 0 After fourth iteration, ones = 4, twos = 0  2nd example ------------ 4, 2, 2, 2  After first iteration, ones = 4, twos = 0 After second iteration, ones = 6, twos = 0 After third iteration, ones = 4, twos = 2 After fourth iteration, ones = 4, twos = 0  Explanation becomes much more complicated when there are more elements in the array in mixed up fashion. But again due to associativity of XOR operation - We actually end up getting answer.	2014-12-10 11:55:30		
8524	zeice	107	The original 3-based method can also work, this is one implementation. The complexity can be O(nlog{m}) in the worst case where m is the largest element. Actually it's not too bad when the elements are all integers.	2014-12-10 11:55:30		
8525	admin	107		2014-12-10 11:55:31		
8526	plapd	107		2014-12-10 11:55:31		
8527	eucmc	107	The problem is, it could only work when all the elements are positive...	2014-12-10 11:55:31		
8528	gilit	107	Nice try. However, I don't think siva.sai.2020's code is right. Somebody try this one. On my machine, it does not work.	2014-12-10 11:55:31		
8529	ftfck	107		2014-12-10 11:55:31		
8530	mrjku	107		2014-12-10 11:55:31		
8531	plapd	107	@mirokuneal: Thanks a lot for finding this bug. Well.. I just tried to understand and explain siva's code so i apologize if there is anything wrong in the explanation.  Again after spending few hours, hopefully i have got the correct version.  for (int i = 0; i < 10; i++) { x = B[i]; twos ^= ones & x; ones ^= x; not_threes = ~(ones & twos); ones &= not_threes; twos &= not_threes; }	2014-12-10 11:55:31		
8532	jippy	107	Sorry its still wrong! plz ignore above comment.	2014-12-10 11:55:31		
8533	cfzie	107	@micro The code is working. The problem is you have given more than 10 elements, you need to change the value 10 in the for loop  @rama, the original code is working..	2014-12-10 11:55:31		
8534	bexbp	107	@rama I don't know if you fully understand the code, though you gave a very long explanation. You are trying to give wrong answers. The original code by siva is working perfectly. Don't try to give some wrong answers. Both try to change the value (10 to 13) in the for loop, the code will work perfectly...	2014-12-10 11:55:31		
8535	plapd	107	Yes Rama's explanation is wrong. The ones and twos don't hold elements that appeared once or twice. They hold bits that appeared once or twice. Then the algorithm is easy to understand. If a bit is already in ones, add it to twos; XOR will add this bit to ones if it's not there or remove this bit from ones if it's already there; If a bit is in both ones and twos, remove it from ones and twos. When finished, ones contains the bits that only appeared 3*n+1 times, which are the bits for the element that only appeared once. This is really a masterpiece.	2014-12-10 11:55:31		
8536	jippy	107	Thanks for explanation. I am so stupid forgeting the length of the array.	2014-12-10 11:55:31		
8537	zeice	107	A simpler explanation: The StackOverflow code came from /questions/5208343/find-a-special-number-in-an-array but it is not explained much there.  Consider the simpler case in which every array element appears twice except for the one unique element. Because x XOR x = 0 and 0 XOR x = x, and XOR is associative and commutative, you can XOR all the elements together, the pairs will all cancel out to 0 and what remains will be the unique element's value.  In this problem the challenge is to find a logical operator, call it FOO that will cancel out three occurrences of the same value. That is, you want an associative and commutative function FOO such that  x FOO x FOO x = 0 and 0 FOO x = x  You can do that with FOO being addition mod 3 as long as you do it separately on each bit. You lose information doing addition mod 3 on numbers bigger than 2.  There is a problem that the result of addition mod 3 might be the value 2 which takes two bits for the result. You have to add the bits mod 3 keeping a two bit accumulator for each bit of the values you are adding. You can do that using two integer variables for the accumulators, one named "ones" for the low order bit and the other named "twos".  The code show here finds the sum of items mod 3 separately for each bit, keeping the low order bit of the results in "ones" and the second bit of the results in "twos". The code uses logical bit operations to do the addition, then sets the two bit results to 0 if they are both 1 (changing 3 to 0 because it is mod 3 addition).  You could probably save a line or two of code by writing an equivalent logical expression for calculating ones and twos as functions of the current value of ones, twos, and item, but each time I tried it I made some silly mistake. Describing it as addition mod two and using the explicit check for clearing the result 3 to 0 makes the code easier to read and less likely to have an error.	2014-12-10 11:55:31		
8538	eucmc	107	Explanation for siva.sai.2020's code.  The code works in similar line with the question of "finding the element which appears once in an array - containing other elements each appearing twice". Solution is to XOR all the elements and you get the answer.  Basically, it makes use of the fact that x^x = 0. So all paired elements get XOR'd and vanish leaving the lonely element. Since XOR operation is associative, commutative.. it does not matter in what fashion elements appear in array, we still get the answer.  Now, in the current question - if we apply the above idea, it will not work because - we got to have every unique element appearing even number of times. So instead of getting the answer, we will end up getting XOR of all unique elements which is not what we want.  To rectify this mistake, the code makes use of 2 variables. ones - At any point of time, this variable holds XOR of all the elements which have appeared "only" once. twos - At any point of time, this variable holds XOR of all the elements which have appeared "only" twice.  So if at any point time, 1. A new number appears - It gets XOR'd to the variable "ones". 2. A number gets repeated(appears twice) - It is removed from "ones" and XOR'd to the variable "twice". 3. A number appears for the third time - It gets removed from both "ones" and "twice".  The final answer we want is the value present in "ones" - coz, it holds the unique element.  So if we explain how steps 1 to 3 happens in the code, we are done. Before explaining above 3 steps, lets look at last three lines of the code,  not_threes = ~(ones & twos) ones & = not_threes twos & = not_threes  All it does is, common 1's between "ones" and "twos" are converted to zero.  For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order).   Explanation for step 1 ------------------------ Lets say a new element(x) appears. CURRENT SITUATION - Both variables - "ones" and "twos" has not recorded "x".  Observe the statement "twos| = ones & x". Since bit representation of "x" is not present in "ones", AND condition yields nothing. So "twos" does not get bit representation of "x". But, in next step "ones ^= x" - "ones" ends up adding bits of "x". Thus new element gets recorded in "ones" but not in "twos".  The last 3 lines of code as explained already, converts common 1's b/w "ones" and "twos" to zeros. Since as of now, only "ones" has "x" and not "twos" - last 3 lines does nothing.    Explanation for step 2. ------------------------ Lets say an element(x) appears twice. CURRENT SITUATION - "ones" has recorded "x" but not "twos".  Now due to the statement, "twos| = ones & x" - "twos" ends up getting bits of x. But due to the statement, "ones ^ = x" - "ones" removes "x" from its binary representation.  Again, last 3 lines of code does nothing. So ultimately, "twos" ends up getting bits of "x" and "ones" ends up losing bits of "x".    Explanation for step 3. ------------------------- Lets say an element(x) appears for the third time. CURRENT SITUATION - "ones" does not have bit representation of "x" but "twos" has.  Though "ones & x" does not yield nothing .. "twos" by itself has bit representation of "x". So after this statement, "two" has bit representation of "x". Due to "ones^=x", after this step, "one" also ends up getting bit representation of "x".  Now last 3 lines of code removes common 1's of "ones" and "twos" - which is the bit representation of "x". Thus both "ones" and "twos" ends up losing bit representation of "x".    1st example ------------ 2, 2, 2, 4  After first iteration, ones = 2, twos = 0 After second iteration, ones = 0, twos = 2 After third iteration, ones = 0, twos = 0 After fourth iteration, ones = 4, twos = 0  2nd example ------------ 4, 2, 2, 2  After first iteration, ones = 4, twos = 0 After second iteration, ones = 6, twos = 0 After third iteration, ones = 4, twos = 2 After fourth iteration, ones = 4, twos = 0   Explanation becomes much more complicated when there are more elements in the array in mixed up fashion. But again due to associativity of XOR operation - We actually end up getting answer.	2014-12-10 11:55:31		
8539	dgjji	107	Highly appreciate for such a detailed explanation of an intricate (but, smart) solution!	2014-12-10 11:55:31		
8540	admin	107	This does not work say when the unique number is obtained from ORing the other numbers. Example: {1,4,5,1,1,4,4} does not give you the right result	2014-12-10 11:55:31		
8541	plapd	107	Sort the array but in this case time complexity will be n*log(n).	2014-12-10 11:55:31		
8542	ethan	107	Can you please explain?	2014-12-10 11:55:31		
8543	nwkeg	107	Sort the array, Find i for which a[i-1] != a[i] != a[i+1]	2014-12-10 11:55:31		
8544	admin	107	Sounds like that works but don't know if it is most efficient... can't think of better though... this should be a[i-1] != a[i] OR a[i] != a[i+1] as the above only hold true for the middle number of every set of 3 in the array.	2014-12-10 11:55:31		
8545	zeice	107	you can use hash.. with value from 1 to n and key as the the elements of array.	2014-12-10 11:55:31		
8546	dkebi	107	I guess they have clearly mentioned do not use any extra memory. So i would with the solution as to sort the array and check if a[i] == a[i+2] and continue if yes, else return the element.	2014-12-10 11:55:31		
8547	wbqzu	107	Using memory: use hash table to store frequency. average complexity O(n), worst case O(n^2).  W/O memory: sorting, and checking if a[i-1] != a[i+1] for i = 1 to n-2, assuming 0 index array	2014-12-10 11:55:31		
8548	dkebi	107	Using hashtable will make the freq table in O(n) plus we have to iterate once more to find the lowest freq elem. So the worst case will be O(n)+O(n). Doing merge sort and finding the elem complexity may be lower.	2014-12-10 11:55:31		
8549	fowai	107	@Upt: unless you can define a perfect hashing, how could you convince that worst case time is O(n). What happened if you've a hash function that maps half of the inputs to a single index of hash table. In that case, assume it's a linked list of size O(n). Whenever you'd update the frequency of an element in that list, it'd be O(n) time - that leads O(n^2) worst case complexity for hashing.	2014-12-10 11:55:31		
8550	nwkeg	107	I agree. I assumed that the hashing is perfect as it is done for the ints in this problem which is not so difficult.	2014-12-10 11:55:31		
8551	nwkeg	107	1. Do a partition. 1. if number of elements on the both sides are exactly divisible by 3 then Pivoted element is the required number. 2. At least one side of pivoted element will be divisible by 3. So take the other side and perform step 1.  Space Complexity - constant, Time Complexity is o(n), but array will get destroyed.	2014-12-10 11:55:31		
8552	fmzze	107	really...  3,3,3,6,6,6,9  In this case answer should be 9. But if your pivot is 6 then also it will satisfy ur condition....	2014-12-10 11:55:31		
8553	mrjku	107	You have to modify Partition as numbers are duplicated here so in this example 3,3,3,6,6,6,9 if 6 is pivoted element it will return index of last 6. So 3,3,3,6,6,6 will be one side while 9 will be other side.	2014-12-10 11:55:31		
8554	wbqzu	107	Check the solution here on stackoverflow stackoverflow /questions/2497470/given-an-array-of-integers-where-some-numbers-repeat-1-time-some-numbers-repeat	2014-12-10 11:55:31		
8555	krxlv	107	public static void main(String[] args) { int B[] = {1,1,1,3,3,3,4,4,4,5,5,5,6,6,6,7,8,8,8,9,9,9}; for(int i=0;i<B.length-2; i=i+3){ if(B[i]!=B[i+1] || B[i+1]!=B[i+2]){ n = B[i]; break; } } if(n==0) System.out.println("Unique no. - " + B[B.length-1]); else System.out.println("Unique no. - " + n);  }	2014-12-10 11:55:31		
8556	rdfeo	107	You need to sort the array first...	2014-12-10 11:55:31		
8557	mrjku	107	HashMap solution:  int B[] = {1,1,1,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,11,11,11,44,44,44,46}; HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>(); for(int i=0; i<B.length;i++){ if(hm.containsKey(B[i])){ hm.put(B[i], hm.get(B[i])+1); }else{ hm.put(B[i],1); } } Iterator itr = hm.entrySet().iterator(); while(itr.hasNext()){ Map.Entry pairs = (Map.Entry)itr.next(); if((Integer)pairs.getValue() == 1){ System.out.println("Hash Operation - Unique no. - "+pairs.getKey()); break; }  }	2014-12-10 11:55:31		
8558	rrmeu	107	Here, no need to sort array	2014-12-10 11:55:31		
8559	rrmeu	107	You are welcome!	2014-12-10 11:55:31		
8560	fowai	107	Explanation for step 1 ------------------------ Lets say a new element(x) appears. CURRENT SITUATION - Both variables - "ones" and "twos" has not recorded "x".  Observe the statement "twos| = ones & x". Since bit representation of "x" is not present in "ones", AND condition yields nothing. So "twos" does not get bit representation of "x".    @Rama B: if you consider the sequence 6,2,2,2  After 6 is considered, we have ones=6, twos=0 next comes 2, while doing twos|= ones & x, the and yields 6&2=2 contrary to your statement that the and yields nothing when a new number(this case 2) arrives. Even though the ultimate result comes out to be correct in this sequence also, but looking for an explanation how the correction occurs?	2014-12-10 11:55:31		
8561	zeice	107	Is the range of numbers in the array known to us ?	2014-12-10 11:55:31		
8562	rrmeu	107	No need of sorting..... .... int SUM=0, a[]={..........}; // for(i=0;i<SIZE;i++) // SIZE=size of an array { SUM+=a[i]; } for(i=0;i<SIZE;i++) { if ( (SUM + 2x)%3==0 && x==a[i] ) return x; }   complexity=O(n)..	2014-12-10 11:55:31		
8563	mrjku	107		2014-12-10 11:55:32		
8564	krxlv	107		2014-12-10 11:55:32		
8565	rrmeu	107		2014-12-10 11:55:32		
8566	fowai	107		2014-12-10 11:55:32		
8567	azmjc	107	bitwise and easier to be understandable	2014-12-10 11:55:32		
8568	fmzze	107		2014-12-10 11:55:32		
8569	dgjji	107		2014-12-10 11:55:32		
8570	azmjc	107	I've jus ACed the same problem in leetcode. Here is my code:	2014-12-10 11:55:32		
8571	sqzqo	107		2014-12-10 11:55:32		
8572	nhibd	107		2014-12-10 11:55:32		
8573	ewigy	107	} Basically used the top answer strategy, adding numbers up bitwise, mod 3 get the bit for the single one. Time complexity O(n), space complexity O(1);	2014-12-10 11:55:32		
8574	jippy	107	Algo:- new element - > xor with 'ones' element repeated twice - > remove from 'ones' and xor with 'twos' element repeated thrice -> remove from both 'ones' and 'twos' return ones  code:- public int singleNumber(int[] A) { int ones = 0, twos = 0; for(int i = 0; i < A.length; i++){ ones = (ones ^ A[i]) & ~twos; twos = (twos ^ A[i]) & ~ones; } return ones;	2014-12-10 11:55:32		
8575	vanul	107	Algo:- new element - > xor with 'ones' element repeated twice - > remove from 'ones' and xor with 'twos' element repeated thrice -> remove from 'twos' return ones  code:-	2014-12-10 11:55:32		
8576	fowai	107		2014-12-10 11:55:32		
8577	mrjku	107		2014-12-10 11:55:32		
8578	sgiwy	107	I found it pretty complicated to understand the above logic when elements were scattered eg 4,3,4,3,4. I found the solution 2 by geeksforgeeks simpler to understand for people like me. "geeksforgeeks.org/find-the-element-that-appears-once/"  Explanation directly from geekForGeeks Let us consider the example array {5, 5, 5, 8}. The 101, 101, 101, 1000 Sum of first bits%3 = (1 + 1 + 1 + 0)%3 = 0; Sum of second bits%3 = (0 + 0 + 0 + 0)%0 = 0; Sum of third bits%3 = (1 + 1 + 1 + 0)%3 = 0; Sum of fourth bits%3 = (1)%3 = 1;	2014-12-10 11:55:32		
8579	bexbp	107		2014-12-10 11:55:32		
8580	sgiwy	107		2014-12-10 11:55:32		
8581	jippy	107	1. Brute Force - O(n^2) - No extra memory 2. Sort - O(nlogn) - No extra Memory 3. Hash - O(n) - Extra Memory 4. XOR - O(n) - No Extra Memory  for eg. [2,1,4,5,1,4,2,2,4,1]=>5 steps: 1. XOR all elements, that will give unique sum say X Unique Sum,X= 2^1^4^5^1^4^2^2^4^1 = 1+2+4+5=12 2. Calculate total sum, Y = 26 3. Ans Z = (Y-(X*3))/2= (26-(12*3))/2= 5  enjoy!!	2014-12-10 11:55:32		
8582	rrmeu	107	Smart people work with XOR stuff for this type of problems without knowing properly what the operation does indeed!  XORing 3, 6 and 9 does NOT result in 3 + 6 + 9 = 18, it gives (11) ^ (110) ^ (1001) = (1100) = 12. Now, ask yourself why it gives 12, NOT 18? Then you'd learn what XOR operation does indeed.	2014-12-10 11:55:32		
8583	ewigy	107	I got what the XOR does but I am interested that how this equation (Y-(X*3))/2 is derived. Please help me to understand this.	2014-12-10 11:55:32		
8584	ethan	107	Let x be sum of all numbers occurring 3 times and y be no which is occurring once, A be sum of all unique nos in the array and B be sum of all nos in the array, then following conditions hold good  3x + y = B x + y = A (You get A by XOR all elements)  A = a[0]^a[1]....^a[n] solving for y gives y = (3A - B)/2	2014-12-10 11:55:32		
8585	nhibd	107	steps: 1. XOR all elements, that will give unique sum say X Unique Sum,X= 2^1^4^5^1^4^2^2^4^1 = 1^2^4^5=12 ????  I can not get it. It IS NOT SUM!!	2014-12-10 11:55:32		
8586	rrmeu	107	static void Main(string[] args) { int[] arr = { 1,4,2,1,4,2,1,2,4,5}; int unique = FindUnique(arr); Console.WriteLine(unique); Console.ReadLine(); } public static int FindUnique(int[] arr) { int once = 0; int twice = 0; int Threes; int x = 0;  for (int i = 0; i < 10; i++) { x = arr[i]; twice |= once & x; //add it to twice if it exists in once once ^= x; //it exists in once, remove it, otherwise, add it Threes = once & twice; //if x is in once and twice, add it to Threes. // and thus once &= ~Threes; //remove x from once twice &= ~Threes; //remove x from twice } return once; }	2014-12-10 11:55:32		
8587	nwkeg	108	Hash <char, firstseenindex> for each string.  The encoding of first seenindices shud match.  E.g. Foo and app both encode to 011 Abcd and hole both encode to 0123  Hate and hell do not match As encodings are 0123 and 0122  Shud work.	2014-12-10 11:55:34		
8588	bjsiw	108	Urik beat me to it. Working python code:	2014-12-10 11:55:35		
8589	admin	108		2014-12-10 11:55:35		
8590	sqzqo	108		2014-12-10 11:55:35		
8591	gilit	108	@Urik Very smart solution. Here is my implementation in python for your solution.	2014-12-10 11:55:35		
8592	zeice	108		2014-12-10 11:55:35		
8593	qywrh	108		2014-12-10 11:55:35		
8594	rdfeo	108	Hi Urik,  how would your solution actually work for "ofo" and "app"? The encoding would be 010 and 011 which is different. However, the 2 o's can be mapped to the 2 p's and the f to the a.	2014-12-10 11:55:35		
8595	jippy	108	nastra is right. Plain encoding would not work. use two arrays A1 & A2 of size 26(to be precise, the size of the alphabet). The indices would represent the characters of the alphabet and the values would represent their occurrence count.  The arrays should be initialized to 0 and when a character is encountered, the counter for that character should be incremented.  Sort the arrays now and check that counts of both the arrays match. If they match, then the strings are isomorphic, otherwise, they are not.	2014-12-10 11:55:35		
8596	eucmc	108	match the character occurence. ofo or foo-- 1 & 2 app or ppa--1 & 2 so isomorphic ofoxxxy--1,1,2,3 applllz--1,1,2,3 so isomorphic. if there is single instances of each characters in both string then isomorphic.	2014-12-10 11:55:35		
8597	krxlv	108	@Erasmus Brilliant solution.  @@@@@@@ Nice example for Erasmus' solution.	2014-12-10 11:55:35		
8598	rdfeo	108	Good sol but you can just keep Hash<char, char> for each string. If the mapping already exists and is different then the old one return false.	2014-12-10 11:55:35		
8599	bjsiw	108	@nastra don't u notice that the ordering of the second should be the same as first word. in your case, ofo, app has different orderings. and I think if we can ignore ordering, this problem is too simple, it's just like a modification of permutation, where use different character to replace original.  my solution:	2014-12-10 11:55:35		
8600	gilit	108		2014-12-10 11:55:35		
8601	tenuw	108		2014-12-10 11:55:35		
8602	fowai	108		2014-12-10 11:55:35		
8603	xhgls	108		2014-12-10 11:55:35		
8604	ufdxg	108	#include<iostream> #include<string.h> using namespace std; int main() { int flag=0; string a="app1111p"; string b="21q3333q"; //cout<<a<<b; if(a.length()!=b.length()) { cout<<"sorry ASS"<<endl; flag=1; } int hashmap[256]={0}; for(int i=0;i<a.length();i++) { if(hashmap[a[i]]==0) { hashmap[a[i]]=int(b[i]); //cout<<a[i]<<hashmap[a[i]]<<endl;; }else if((hashmap[a[i]])==int(b[i])) { //cout<<"good to go"<<endl;; }else if ((hashmap[a[i]])!=b[i]) { //cout<<"sorry Ass"<<endl; flag=1; break; } } if(!flag) cout<<"true"; else cout<<"false"; }	2014-12-10 11:55:35		
8605	dgjji	108	Satisfies al conditions!!!!	2014-12-10 11:55:35		
8606	azmjc	108	Lol cute debugging code  +1. Assuming no bugs. This is best way for two strings.	2014-12-10 11:55:35		
8607	vanul	108	Does not work if first string is axy and second tree is boo	2014-12-10 11:55:35		
8608	vanul	108	can you explain why axy and boo are isomorphic?  seems like it works	2014-12-10 11:55:35		
8609	azmjc	108		2014-12-10 11:55:35		
8610	ufdxg	108		2014-12-10 11:55:35		
8611	fowai	108	hey, check the input "axy" "boo" it should return false.	2014-12-10 11:55:35		
8612	azmjc	108		2014-12-10 11:55:35		
8613	rrmeu	108		2014-12-10 11:55:35		
8614	fmzze	108	// fixed a bug	2014-12-10 11:55:35		
8615	rrmeu	108	Your solution runs in O(n^2) because map.containsValue() searches the entire map every time.	2014-12-10 11:55:35		
8616	rdfeo	108	just make the character in second string as the key, since key is unique, but value is not, thus you can make sure for that key, the value should always be same.	2014-12-10 11:55:35		
8617	zeice	108		2014-12-10 11:55:35		
8618	plapd	108		2014-12-10 11:55:35		
8619	mrjku	108	Xiaoma318's code won't work for axx->bow	2014-12-10 11:55:35		
8620	nhibd	108	@techpanja : I think it should be  if (!characterMap.containsKey(input1.charAt(i) || !characterMap.containsKey(input2.charAt(i))  && will not work for input sample "turtle" and "tletur" like mentioned in the question itself.	2014-12-10 11:55:35		
8621	krxlv	108	package com.test;  import java.util.HashMap; import java.util.Map;   public class Isomorphic {   public static boolean isIsomorphic1(String s1, String s2){ if(s1.length() != s2.length()) return false; else if(s1.length()==1) return true; else { Map<Character,Integer> map1 = new HashMap<Character, Integer>(); StringBuffer encodingString1 = new StringBuffer(); Map<Character,Integer> map2 = new HashMap<Character, Integer>(); StringBuffer encodingString2 = new StringBuffer(); for(int i=0;i<s1.length();i++){ if(!map1.containsKey(s1.charAt(i))){ map1.put(s1.charAt(i), i); } encodingString1.append(map1.get(s1.charAt(i)));  if(!map2.containsKey(s2.charAt(i))){ map2.put(s2.charAt(i), i); } encodingString2.append(map2.get(s2.charAt(i))); } return encodingString1.toString().equals(encodingString2.toString()); } } public static void main(String[] args) {  String s1 = "ab"; String s2 = "ca"; System.out.println(isIsomorphic1(s1, s2)); }  }	2014-12-10 11:55:35		
8622	eucmc	108	+1 for leo...check almost all condition.	2014-12-10 11:55:35		
8623	plapd	108	public static boolean findIsomophric(String a, String b){ //length doesn't match if (a.length() != b.length()){ return false; }  HashMap<Character,Character> bucket = new HashMap<Character,Character>();  for (int i=0; i<a.length(); i++){ if (bucket.containsKey(a.charAt(i))){ if (b.charAt(i)!=bucket.get(a.charAt(i))){ return false; } } else if (bucket.containsKey(b.charAt(i))){ if (a.charAt(i)!=bucket.get(b.charAt(i))){ return false; } } else{ // add both ways bucket.put(a.charAt(i), b.charAt(i)); bucket.put(b.charAt(i), a.charAt(i)); } } return true; }	2014-12-10 11:55:35		
8624	fowai	108	I created my own class and used a map-based approach.  I build maps for both strings and check if they are equivalent.	2014-12-10 11:55:36		
8625	tenuw	108		2014-12-10 11:55:36		
8626	bjsiw	108		2014-12-10 11:55:36		
8627	jippy	108	Can be easily solved using a map and a set. Map for maintaining the characters of string1 mapped to string2, and a set to track the characters of string2 which have been mapped before.	2014-12-10 11:55:36		
8628	admin	108		2014-12-10 11:55:36		
8629	ftfck	108		2014-12-10 11:55:36		
8630	rrmeu	108		2014-12-10 11:55:36		
8631	ufdxg	108		2014-12-10 11:55:36		
8632	bjsiw	108	O(n lg n) depending on the sort used.	2014-12-10 11:55:36		
8633	ftfck	108	I used two hashmaps, one to keep track if we already changed the mapping of a letter once and the other to keep track of the mappings. Runtime O(n), space O(n)  {{ public boolean isIsomorphic(String s1, String s2) { if(s1.length() != s2.length()) return false;  HashMap <Character, Boolean> used = new HashMap<Character, Boolean>(); HashMap <Character, Character> map = new HashMap <Character, Character>();  for (int i = 0; i < s1.length(); i++) { if(!map.containsKey(s1.charAt(i))) { map.put(s1.charAt(i), s1.charAt(i)); used.put(s1.charAt(i), false); } }  for (int j = 0; j < s1.length();j++){ if(s1.charAt(j) != s2.charAt(j)) { if(used.get(s1.charAt(j)) == true && map.get(s1.charAt(j)) != s2.charAt(j)) return false; else { map.put(s1.charAt(j), s2.charAt(j)); used.put(s1.charAt(j), true); } } } return true; }    }}	2014-12-10 11:55:36		
8634	dkebi	108		2014-12-10 11:55:36		
8635	nwkeg	108		2014-12-10 11:55:36		
8636	xhgls	108	Use runtime encoding. It doesn't matter what the characters are, just that the occurrences of each are the same in the same position. Leveraging f#'s value equality of lists you can do an O(n) pass	2014-12-10 11:55:36		
8637	nhibd	108		2014-12-10 11:55:36		
8638	xhgls	108		2014-12-10 11:55:36		
8639	dgjji	108	You can also lazy evaluate the whole thing to shortcircuit if you encounter a set of letters that no longer map	2014-12-10 11:55:36		
8640	tenuw	108		2014-12-10 11:55:36		
8641	rrmeu	108		2014-12-10 11:55:36		
8642	gilit	108	Not quite, cause the case "aba" and "dcc" doesn't work, but if you sorted the isomoph function then the comparison would work	2014-12-10 11:55:36		
8643	rrmeu	108	Here is Simple Solution:	2014-12-10 11:55:36		
8644	mrjku	108		2014-12-10 11:55:36		
8645	jippy	108		2014-12-10 11:55:36		
8646	rdfeo	108		2014-12-10 11:55:36		
8647	fowai	108		2014-12-10 11:55:36		
8648	eucmc	108	public boolean isOmorphic(String str1, String str2){ if(str1.length() != str2.length()){ return false; } if(str1.length() == 0){ return true; }  HashMap<Character, Character> map = new HashMap<Character, Character>();  for(int i=0; i<str1.length(); i++){ if(map.containsKey(str1.charAt(i))){ if(map.get(str1.charAt(i)) != str2.charAt(i)){ return false; } else{ continue; } }else{ map.put(str1.charAt(i), str2.charAt(i)); } } return true; }	2014-12-10 11:55:36		
8649	rdfeo	108		2014-12-10 11:55:36		
8650	bexbp	108		2014-12-10 11:55:36		
8651	nhibd	108	I don't know wheter I'am being stupid again. Can't the following code work?	2014-12-10 11:55:36		
8652	ewigy	108		2014-12-10 11:55:36		
8653	xhgls	108		2014-12-10 11:55:36		
8654	huiqq	108		2014-12-10 11:55:36		
8655	bexbp	108		2014-12-10 11:55:36		
8656	tenuw	108		2014-12-10 11:55:36		
8657	cfzie	108		2014-12-10 11:55:36		
8658	sqzqo	108	This solution, unless i'm misinterpreting the problem also works. and runs in O(n) time using an addition data struct (a hashset)	2014-12-10 11:55:36		
8659	rrmeu	108		2014-12-10 11:55:36		
8660	dgjji	108		2014-12-10 11:55:37		
8661	azmjc	108		2014-12-10 11:55:37		
8662	fowai	108		2014-12-10 11:55:37		
8663	sgiwy	108	#include<stdio.h> #include<string.h> char ascii[26]; int main(int argc, char **argv) { char *str1 = "turtle"; char *str2 = "tletur"; int len = strlen(str1); while (len--) { if (ascii[str1[len]-'a']) { if (ascii[str1[len]-'a'] != str2[len]-'a') break; } else ascii[str1[len]-'a'] = (str2[len]-'a'); } if (len == 0xFFFFFFFF) printf ("ISOMORPHIC"); else printf ("NOT ISOMORPHIC"); return (0); }	2014-12-10 11:55:37		
8664	plapd	108	Simplistic solution in Ruby?	2014-12-10 11:55:37		
8665	ewigy	108		2014-12-10 11:55:37		
8666	mrjku	108		2014-12-10 11:55:37		
8667	ethan	108	isomorphs?("foo","app") => true  isomorphs?("turtle","tletur") => true  isomorphs?("foo","bar") => false	2014-12-10 11:55:37		
8668	ethan	108	public static boolean isomorphic(String s1, String s2){ if(s1==null || s2==null || s1.length()!=s2.length()) return false;  int[] c1=new int[26]; int[] c2=new int[26]; Arrays.fill(c1,0); Arrays.fill(c2,0);  for(int i=0;i<s1.length();i++){ int index1=s1.charAt(i)-97; int index2=s2.charAt(i)-97; if(c1[index1]==0 && c2[index2]==0) { c1[index1]=s2.charAt(i); c2[index2]=s1.charAt(i); }else if(c1[index1]!=0 && c2[index2]!=0){ if(c1[index1]!=s2.charAt(i) || c2[index2]!=s1.charAt(i)) return false; }else return false; }  return true; }	2014-12-10 11:55:37		
8669	gilit	108	Here's a simpler solution, check it out and do comment if any flaw  #include<conio.h> #include<iostream> #include<string.h> using namespace std; int main() { //isomorphic words char str1[20],str2[20],str3[20],letter1,letter2; int len1,len2,i=0,j; gets(str1); gets(str2); strcpy(str3,str2); len1=strlen(str1); len2=strlen(str2); if(len1!=len2) cout<<"not isomorphic"; else { while(i<len1) { letter1=str1[i]; letter2=str2[i]; //replace all letter2 in str2 by letter1 for(j=0;j<len1;j++) if(str3[j]==letter2) str2[j]=letter1; i++; } } if(strcmp(str1,str2)==0) cout<<"isomorphic"; else cout<<"not isomorphic"; getch(); return(0); }	2014-12-10 11:55:37		
8670	dkebi	108	public class Isomorph {  public static void main(String[] args) { Scanner scanner = new Scanner(System.in);  String first = scanner.next(); String second = scanner.next();  char[] firstCharArray = first.toCharArray(); char[] secondCharArray = second.toCharArray();  if (firstCharArray.length == secondCharArray.length) {  int[] firstNumberArray = convertToNumberArray(firstCharArray); int[] secondNumberArray = convertToNumberArray(secondCharArray); System.out.println("firstNumberArray " + Arrays.toString(firstNumberArray) ); System.out.println("secondNumberArray " + Arrays.toString(secondNumberArray) );  if (Arrays.equals(firstNumberArray, secondNumberArray)) { System.out.println(true); } else { System.out.println(false); }  } else { System.out.println(false); }  }  private static int[] convertToNumberArray(char[] charArray) { int[] numberArray = new int[charArray.length]; Map<String,Integer> hashMap = new HashMap<String, Integer>();  for (int i = 0; i < charArray.length; i++) { String character = String.valueOf(charArray[i]); if (hashMap.containsKey(character)) { int number = hashMap.get(character); numberArray[i] = number; } else { hashMap.put(character, i); numberArray[i] = i; } }  return numberArray; }  }	2014-12-10 11:55:37		
8671	fowai	108	{{ public static boolean isStringIsoMorphic(String str1, String str2){ if(str1.length()!=str2.length()) return false; int len=str1.length(); //declaring two arrays to keep count of position of each char encountered int[] str1arr = new int[256]; Arrays.fill(str1arr, -1); int[] str2arr = new int[256]; Arrays.fill(str2arr, -1); for(int i=0;i<len;i++){ if(str1arr[str1.charAt(i)]==-1){ if(str2arr[str2.charAt(i)]!=-1){ return false; }else{ str1arr[str1.charAt(i)]=i; str2arr[str2.charAt(i)]=i; }  }else{ // if char in first string has already occurred somewhere // then look for the char present at same index in str2 previous occurance System.out.println(str1arr[str1.charAt(i)]); System.out.println(str2arr[str2.charAt(i)]); if(str1arr[str1.charAt(i)]!=str2arr[str2.charAt(i)]) return false; } }  return true; } }}	2014-12-10 11:55:37		
8672	fmzze	108		2014-12-10 11:55:37		
8673	sqzqo	108		2014-12-10 11:55:37		
8674	qywrh	108		2014-12-10 11:55:37		
8675	ewigy	108		2014-12-10 11:55:37		
8676	ewigy	108	}	2014-12-10 11:55:37		
8677	sgiwy	108	Think in terms of a substitution cipher. String1 is the input, we apply a cipher and we get the string2. The problem is can we find a substitution cipher or in other words, are the strings isomorphic.  To check if two stings are isomorphic, one would not have keep counts. Below O(1) space implementation(bitVector implementation) that works for alphabets.	2014-12-10 11:55:37		
8678	ewigy	108		2014-12-10 11:55:37		
8679	mrjku	108		2014-12-10 11:55:37		
8680	rdfeo	108	use hashmap to form one-to-one relationship btw 2 chars	2014-12-10 11:55:37		
8681	ftfck	108		2014-12-10 11:55:37		
8682	rdfeo	108		2014-12-10 11:55:37		
8683	tenuw	108	Use two hash maps. One to track character mapping from string a to string b. The other to track character mapping from string b to string a. Time O(n), space O(2*n)	2014-12-10 11:55:37		
8684	fmzze	108		2014-12-10 11:55:37		
8685	nwkeg	108		2014-12-10 11:55:37		
8686	tenuw	108	simple c++ code :)  #include<iostream> #include<conio.h> #define MAX 100 #include<string.h> using namespace std; int isomorphic(string s,string t) { int i,j,count=0; int n=s.length(); char ch[26]; for(i=0;i<26;i++) ch[i]=48; int f[26]={0}; for(i=0;i<n;i++) { if(ch[s[i]-97]=='0' && f[t[i]-97]==0) { ch[s[i]-97]=t[i]; f[t[i]-97]=1; count++; } else { if(t[i]==ch[s[i]-97]) { count++; } } } if(count==n) return 1; else return 0; }  int main() { string s,t; cin>>s>>t; int r=isomorphic(s,t); cout<<r; getch(); }	2014-12-10 11:55:37		
8687	nwkeg	108		2014-12-10 11:55:37		
8688	krxlv	108		2014-12-10 11:55:37		
8689	sgiwy	108		2014-12-10 11:55:37		
8690	plapd	109	Manacher's algorithm can be modified to get an O(n) time solution.	2014-12-10 11:55:39		
8691	cfzie	109	That is to find the longest palindrome substring. This question cannot be solved in linear time!	2014-12-10 11:55:39		
8692	bjsiw	109	When finding the longest palindrome substring, we've already gotten the longest possible palindrome using each character as pivot, simply sum them up.	2014-12-10 11:55:39		
8693	rrmeu	109		2014-12-10 11:55:39		
8694	xhgls	109		2014-12-10 11:55:39		
8695	rrmeu	109	The solution seems reasonable but it tooks O(n^3) I think we can reduce it to O(n^2) if we utilize the following property S[i,j] is palin if S[i-1,j+1] is palin and S[i]==S[j]	2014-12-10 11:55:39		
8696	tenuw	109	A simpler approach, O(N2) time and O(1) space:	2014-12-10 11:55:39		
8697	ethan	109		2014-12-10 11:55:39		
8698	fmzze	109		2014-12-10 11:55:39		
8699	fowai	109	Also, we can reduce amount of code and cycles duplicating if we will perform both odd and even check simultaneously:	2014-12-10 11:55:39		
8700	rrmeu	109		2014-12-10 11:55:39		
8701	azmjc	109		2014-12-10 11:55:39		
8702	cfzie	109	This is a O(n) time solution solved recursively but has space complexity	2014-12-10 11:55:39		
8703	admin	109		2014-12-10 11:55:39		
8704	rdfeo	109		2014-12-10 11:55:39		
8705	wbqzu	109	alexandrfox's union is wrong, use case "abaa", your code will return 7. Cause your code views "abaa" as a Palindrome string when comparing only first and last 'a'.	2014-12-10 11:55:39		
8706	admin	109	let the sting of length(n) the for each char index x we check(assuming it is the center element in palindrone) that for i<x<j till there is a palindrone (max comparison n/2) if index char[x] ==char[ x--] ||char[x]==char[x++] then we need to do another search assuming length of palin is even x is one of the mid elements another (n/2) comparison at max now if we know [i,j] the limits of palindrone with x as the centre element then number of palinds = summation of over all elements( if(j-i == even)? (j-i) /2 : (j-j+3)/2) complexity = n*(3n/2) = n^2  As i read more on this , this is similar to Manacher's algorithm which can construct[i,j] in linear time and also inserts # to make sure all palin substring are odd length .. so yes the complexity can be reduced to O(n)  O(n) solution	2014-12-10 11:55:39		
8707	ufdxg	109		2014-12-10 11:55:39		
8708	qywrh	109		2014-12-10 11:55:40		
8709	admin	109	First solutions that comes to mind:  C++:	2014-12-10 11:55:40		
8710	bexbp	109		2014-12-10 11:55:40		
8711	jippy	109		2014-12-10 11:55:40		
8712	bexbp	109		2014-12-10 11:55:40		
8713	krxlv	109		2014-12-10 11:55:40		
8714	rrmeu	109	I print all the palindromes the ranther than calculate the count if replace the print statement with count increase, the time complexity should be O(n^2)	2014-12-10 11:55:40		
8715	azmjc	109	The solution to this problem may base on the dynamic programming approach to palindrom finding (google it, as there is plenty of implementation). Then when we have a table P[i][j] and it's value is greater than zero, we know the value between i and j in the original string is a palindrom, so we may print it. The solution would be O(n^2).	2014-12-10 11:55:40		
8716	sgiwy	109	Ajeet stop voting down my code. Your code stinks.	2014-12-10 11:55:40		
8717	fowai	109		2014-12-10 11:55:40		
8718	vanul	109		2014-12-10 11:55:40		
8719	ufdxg	109	package com.egain.platform.module.kb.workflow;  public class NumberOfParliments {  /** * @param args */ public static void main(String[] args) { System.out.println(findNumberOfPalindromes("abbc")); }  public static int findNumberOfPalindromes(String a) {  int sum = 0; if (a.length() > 0) { char c = a.charAt(0); for (int i = 0; i < a.length(); i++) { if (a.charAt(i) == c) { if (isPalindrome(a.substring(0, i + 1))) { sum = sum + 1; }  }  }  return sum = sum + findNumberOfPalindromes(a.substring(1)); }  return 0;  }  private static boolean isPalindrome(String s) {  if (s.length() == 1) { return true; } else if (s.length() > 1) { boolean bool = s.charAt(0) == s.charAt(s.length() - 1); return bool && isPalindrome(s.substring(1, s.length() - 1)); } else return true;  } }	2014-12-10 11:55:40		
8720	fmzze	109	package com.egain.platform.module.kb.workflow;  public class NumberOfParliments {  /** * @param args */ public static void main(String[] args) { System.out.println(findNumberOfPalindromes("abbc")); }  public static int findNumberOfPalindromes(String a) {  int sum = 0; if (a.length() > 0) { char c = a.charAt(0); for (int i = 0; i < a.length(); i++) { if (a.charAt(i) == c) { if (isPalindrome(a.substring(0, i + 1))) { sum = sum + 1; }  }  }  return sum = sum + findNumberOfPalindromes(a.substring(1)); }  return 0;  }  private static boolean isPalindrome(String s) {  if (s.length() == 1) { return true; } else if (s.length() > 1) { boolean bool = s.charAt(0) == s.charAt(s.length() - 1); return bool && isPalindrome(s.substring(1, s.length() - 1)); } else return true;  } }	2014-12-10 11:55:40		
8721	krxlv	109	{{ import java.util.ArrayList; import java.util.List;  import org.junit.Assert; import org.junit.Test;   public class Palindromes {  public int countPal(String str){ int count = 0; for(int i=0; i<str.length(); i++){ for(int j=i+1; j<=str.length(); j++){ String term = str.substring(i, j); if(isPal(term)){ count++; } } } return count; }  public boolean isPal(String t){ StringBuilder rev = new StringBuilder(); char[] chars = t.toCharArray(); for(int i=chars.length-1; i>=0; i--){ rev.append(chars[i]); } return t.equals(rev.toString()); }  @Test public void testCountPal(){ Assert.assertEquals(6, countPal("abba")); Assert.assertEquals(1, countPal("b")); Assert.assertEquals(3, countPal("bb")); Assert.assertEquals(6, countPal("bbab")); Assert.assertEquals(6, countPal("aacc")); }  @Test public void testIsPal(){ Assert.assertTrue(isPal("abba")); Assert.assertTrue(isPal("aa")); Assert.assertTrue(isPal("a")); Assert.assertFalse(isPal("ac")); }  } }}	2014-12-10 11:55:40		
8722	krxlv	109		2014-12-10 11:55:40		
8723	bexbp	109		2014-12-10 11:55:40		
8724	huiqq	109	this my working code, written in c	2014-12-10 11:55:40		
8725	eucmc	109		2014-12-10 11:55:40		
8726	ufdxg	109		2014-12-10 11:55:40		
8727	azmjc	109	1 #include<stdio.h> 2 3 int main(void) 4 { 5 char str[100]; 6 int i, m, n, len, Count; 7 8 scanf("%s", str); 9 10 len = 0; 11 while(str[len]) 12 len++; 13 14 Count = 0; 15 16 for(i = 0; i < len - 1; i++) 17 { 18 m = i; 19 n = i + 1; 20 21 while(m >= 0 || n < len) 22 { 23 if(str[m--] == str[n++]) 24 Count++; 25 else 26 break; 27 } 28 } 29 30 printf("%d\n", Count); 31 32 return 0; 33 }	2014-12-10 11:55:40		
8728	plapd	109	Expand along every possible center n-1 spaces and n-2 characters and traverse along both directions to see if characters on both the sides are equal. Total time is O(n2). Example a|b|c|b|a|d space centers are given by | symbol and character centers will be b,c,b,a.. Another algorithm is also possible in O(n) time, called manacher's algorithm. It is available on leetcode.com	2014-12-10 11:55:40		
8729	ufdxg	109	This problem can be resolved using dynamic programming.	2014-12-10 11:55:40		
8730	krxlv	109		2014-12-10 11:55:40		
8731	krxlv	109		2014-12-10 11:55:40		
8732	mrjku	109	Dynamic programming : O(n2) in time and O(n) in space. Count separately palindromes depending on their lengths' parities.  Java :	2014-12-10 11:55:40		
8733	jippy	109		2014-12-10 11:55:40		
8734	rdfeo	109		2014-12-10 11:55:40		
8735	cfzie	109	If the string is S and its reverse is S', consider the set of all suffixes of S and all suffixes of S'. For each suffix of S, append a special character $ to the end. For each suffix of S', append a special character # to the end. Now build the trie corresponding to this set of suffixes. In this tree, every node that has both special symbols as children corresponds to a palindromic substring of S (namely, that string obtained by concatenating the edges of the unique path from the node to the root of the tree).  There is a (very clever) algorithm for building a suffix tree in linear time.	2014-12-10 11:55:40		
8736	eucmc	109		2014-12-10 11:55:40		
8737	fowai	109		2014-12-10 11:55:40		
8738	plapd	109	Not the best thing ever, but here is a python implementation in a very simple manner:	2014-12-10 11:55:40		
8739	krxlv	109		2014-12-10 11:55:40		
8740	huiqq	109		2014-12-10 11:55:40		
8741	cfzie	109	This solution should be an order faster than your O(n**3) solution since this has O(n**2) time complexity	2014-12-10 11:55:40		
8742	jippy	109	I could be solved using dynamic programming algorithm and extend the idea of given by shuaixin.david.  We will use this recurrence relation P(i,j) = true if the string is palindrome between index i and j. P(i,j) = P(i+1,j-1) As a base case we to calculate all of the palindromes with length 1(for odd case) and 2(for even case). So, we will calculate P(i,i) and P(i,i+1) for all i. Now, we will calculate the P(i,j) with growing difference between j. So, we will calculate P(i)(i+2) then P(i)(i+3) in this manner. For all the P(i,j) we get true we will increment the count and return the count which is the all the substring palindromes possible.	2014-12-10 11:55:40		
8743	admin	109	This solution has a time complexity of O(n^2) and space complexity of O(n^2).	2014-12-10 11:55:41		
8744	ftfck	109	Seriously they ask DP in phone screen? I think it's stupid, basically it asks do you know Manachers algorithm, if you know it, you know it, if you don't, there's no way you can figure that out by yourself in a 45mins phone interview. I guess they already decided they don't want to before the phone interview if they ask you this question.	2014-12-10 11:55:41		
8745	plapd	109	Yes. I'm serious. Actually you never have 45 minutes to figure out the solution. I think you may have maximum 2-3 minutes. In addition, you cannot just thinking during these valued minutes as usual in a real situation. You need talk through about what is in your mind :) Therefore I asked whether the brute-force algorithm is ok for them.. The rest 40 minutes you need to write the code. Anyway, Actually I think almost all the algorithm questions are the same. You need to know at least a really similar algorithm or set of the known algorithms which you need to modify and apply in the proper order. Anytime you can get such questions I usually don't like when only one question is asked. If multiple short questions are asked then they can measure your knowledge in better way. Just imagine if you have 1 question like here in FB compared with 30 different questions. It's unlikely if you are good then you cannot answer 20-25 questions. But there is big chance to fail on one question. If they want to see real code they can ask 10-15 questions and a really basic algorithm to code. In other side if somebody could tell you the solution after 1 minute then it's unlikely that they would fail on the rest 40 minutes coding.. When I do interview I want to find the weak points of the candidates. if I realize that he knows the answer I think it would waste of time to listen the good solution during 40 minutes :) Anyway this is me and I don't work for Facebook :))	2014-12-10 11:55:41		
8746	rdfeo	109	Seriously they ask DP in phone screen? I think it's stupid, basically it asks do you know Manachers algorithm, if you know it, you know it, if you don't, there's no way you can figure that out by yourself in a 45mins phone interview. I guess they already decided they don't want to before the phone interview if they ask you this question.	2014-12-10 11:55:41		
8747	gilit	109	Seriously they ask DP in phone screen? I think it's stupid, basically it asks do you know Manachers algorithm, if you know it, you know it, if you don't, there's no way you can figure that out by yourself in a 45mins phone interview. I guess they already decided they don't want to before the phone interview if they ask you this question.	2014-12-10 11:55:41		
8748	rrmeu	109	Seriously they ask DP in phone screen? I think it's stupid, basically it asks do you know Manachers algorithm, if you know it, you know it, if you don't, there's no way you can figure that out by yourself in a 45mins phone interview. I guess they already decided they don't want to before the phone interview if they ask you this question.	2014-12-10 11:55:41		
8749	bexbp	109	N^2, C#	2014-12-10 11:55:41		
8750	sgiwy	109		2014-12-10 11:55:41		
8751	krxlv	109		2014-12-10 11:55:41		
8752	fmzze	109		2014-12-10 11:55:41		
8753	ewigy	109		2014-12-10 11:55:41		
8754	mrjku	109		2014-12-10 11:55:41		
8755	fmzze	109		2014-12-10 11:55:41		
8756	ewigy	109		2014-12-10 11:55:41		
8757	nwkeg	109		2014-12-10 11:55:41		
8758	admin	109	Oh.. the question is to calculate the total number... you can just increment a global variable or make printPal return the total number of palindromes found so far.	2014-12-10 11:55:41		
8759	rdfeo	109	for above code ::: Complexity = O(n^2 * (k)) k= average length of string i think they will be satisfied with this complexity..   i would rather go to each letter and look at its left and right till a palind is there and add them up so for abba a = 1 b -> b, = 1 b -> b = 1 a - > a = 1 4 odd lenghts  for even length only consider if two adjacent characters are same abba bb - >bb, abba 2even length strings  num_palins = 6  this will be testing way less number of substrings as the total number of non-palin substring it will try is O(2n) as it stops at first non-palin substring  in case all substrings are palin it will have same complexity as above solution	2014-12-10 11:55:41		
8760	dkebi	109		2014-12-10 11:55:41		
8761	bjsiw	109		2014-12-10 11:55:41		
8762	ufdxg	109	Solution in plain C:	2014-12-10 11:55:41		
8763	jippy	109		2014-12-10 11:55:41		
8764	sgiwy	109		2014-12-10 11:55:41		
8765	plapd	109		2014-12-10 11:55:41		
8766	rrmeu	109		2014-12-10 11:55:41		
8767	jippy	109	Easy Java Solution::  String[] s = "AmanaplanacanalPanama".split(""); for (int i = 1; i < s.length / 2; i++) { int l = s.length-i; if (s[i].equalsIgnoreCase(s[l])) System.out.println("Machhed "+i+" "+ l+" "+s[i]+" "+s[l]); else System.out.println("Failed"); }	2014-12-10 11:55:41		
8768	jippy	109		2014-12-10 11:55:41		
8769	sqzqo	109		2014-12-10 11:55:41		
8770	bjsiw	109	public int Question1(string palindrom){  int count = 0;  for (int i = 0; i < palindrom.Length; i++) { //int length = pallArr.Length - i; for (int j = 1; j <= palindrom.Length - i; j++) { //if (pallArr[i] == pallArr[j])  string pal = palindrom.Substring(i, j); if (IsPalindrom(pal)) { count++; Console.WriteLine(pal); } }  }  return count; }  public bool IsPalindrom(string str) {  bool isPalindrom = true;  int startInd = 0; int endInd = str.Length-1;  for (int i = startInd; i < endInd; i++) {  if (str[startInd] != str[endInd]) { isPalindrom = false; return isPalindrom; }  startInd++; endInd--; }  return isPalindrom; }	2014-12-10 11:55:41		
8771	ftfck	109	This is c# codes and works perfect.	2014-12-10 11:55:41		
8772	plapd	109	Recursive with memoization for backtracking/pruning trees.	2014-12-10 11:55:41		
8773	qywrh	109		2014-12-10 11:55:41		
8774	wbqzu	109		2014-12-10 11:55:41		
8775	nhibd	109		2014-12-10 11:55:41		
8776	qywrh	109		2014-12-10 11:55:41		
8777	azmjc	109	This is O(n+p) solution where p is the number of palindromes	2014-12-10 11:55:41		
8778	plapd	109		2014-12-10 11:55:41		
8779	qywrh	109		2014-12-10 11:55:41		
8780	azmjc	109	Why are checking if (s.charAt(i)==s.charAt(i+1)) and if (s.charAt(i)==s.charAt(i+2))? Does not look like a correct solution	2014-12-10 11:55:42		
8781	ftfck	109	Agree to Joe kidd, should use dynamic programming.  Java code: public static int numOfPalin(String s) { boolean[][] dp = new boolean[s.length()][s.length()]; int count = 0; for (int i = s.length() - 1; i >= 0; i--) { for (int j = i; j < s.length(); j++) {  if (j - i < 2 && s.charAt(i) == s.charAt(j)) dp[i][j] = true; if (i < s.length() - 1 && j > 0 && dp[i + 1][j - 1] && s.charAt(i) == s.charAt(j)) dp[i][j] = true; if (dp[i][j]) { count++; } } }  return count; }	2014-12-10 11:55:42		
8782	qywrh	109	did you test this? the filling does not seem to be correct	2014-12-10 11:55:42		
8783	jippy	110	We can implement this as a variation of the longest common subsequence in O(n^2), using dynamic programming. In the general problem, given two strings, 'a' and 'b', we find the longest common subsequence by computing a matrix M of size len(a)* len(b) defined as follows: M[ i ][ j ] is the value of the longest common subsequence between the strings "a0...ai" and "b0...bj". In particular, if a[ i ] == b[ j ], then M[ i ][ j ] = max (1 + M[ i-1 ][ j-1], M[ i - 1 ][ j ], M[ i ][ j-1 ]) , otherwise M[ i ][ j ] = max (M[ i - 1 ][ j ], M[ i ][ j-1 ]). The value of longest common subsequence is therefore M[ len(a) -1 ][ len(b) - 1].  Now we can modify the longest_common_subsequence(a, a) to find the value of the longest repeated subsequence in a by excluding the cases when i == j, (which we know are always equal in this case). Here is the code in python:	2014-12-10 11:55:50		
8784	jippy	110		2014-12-10 11:55:50		
8785	dkebi	110		2014-12-10 11:55:50		
8786	ethan	110	and, to test it:	2014-12-10 11:55:50		
8787	qywrh	110		2014-12-10 11:55:50		
8788	mrjku	110		2014-12-10 11:55:50		
8789	dkebi	110	What do you mean when you say "The value of the longest common subsequence is therefore..."  Using your algorithm when I look at the result "M" of 'ababab' I get the following:	2014-12-10 11:55:50		
8790	admin	110		2014-12-10 11:55:50		
8791	gilit	110		2014-12-10 11:55:50		
8792	sqzqo	110	M[5][5] is 4. What is 4? 4 what?	2014-12-10 11:55:50		
8793	ftfck	110	#include<iostream> map <char,vector<int> >listE;   bool check(vector<int> a,vector<int> b) { if(a==b) return false; if(a.size()!=b.size())return false; for(unsigned int ii=0;ii<a.size();ii++) { if(a[ii]>b[ii])return false; } return true; }   void printer(char s) { vector<int>a;a=listE[s];cout<<"\n Array \n"; for(unsigned int ii=0;ii<a.size();ii++)cout<<"\t"<<a[ii]; }  void removeDup(string s,string &s1) { for(unsigned int ii=0;ii<s.size();ii++) { if(s1.find(s[ii])!=string::npos)continue; s1+=s[ii]; } } /* if(check(listE[sin[ii]],listE[sin[ii+1]])){cout<<"\n Success:"<<sin[ii]<<"\t"<<sin[ii+1];} else {cout<<"\n Not Success:"<<sin[ii]<<"\t"<<sin[ii];} */  bool looper(int ii,int jj,string sin) { if(check(listE[sin[ii]],listE[sin[jj]])) { cout<<"\n Success:"<<sin[ii]<<"\t"<<sin[jj]; for(unsigned int kk=ii+1;kk<sin.size();kk++) { looper(jj,kk,sin);  } }  else {cout<<"\n Not Success:"<<sin[ii]<<"\t"<<sin[jj];return false;} return true;  }  int main() { string s="abcdabacbc";string sin;   for(unsigned int ii=0;ii<s.size();ii++) { listE[s[ii]].push_back(ii); } removeDup(s,sin);  for(unsigned int ii=0;ii<sin.size()-1;ii++) { for(unsigned int jj=ii+1;ii<sin.size()-1;jj++) { cout<<"\n-----------\n"; looper(ii,jj,sin); } } }	2014-12-10 11:55:50		
8794	plapd	110	How about dp, saving first matching index, reusing dp array, space - o(n), time - o(n2):	2014-12-10 11:55:50		
8795	huiqq	110		2014-12-10 11:55:50		
8796	jippy	110		2014-12-10 11:55:50		
8797	fowai	110	}	2014-12-10 11:55:50		
8798	admin	110	They are in the form of ascii value, traverse thru the string and store the index value when it matches with the same value in the string. Now check for the value between two indexes found and if its repeated after the second index.	2014-12-10 11:55:50		
8799	bexbp	110		2014-12-10 11:55:50		
8800	dkebi	110		2014-12-10 11:55:50		
8801	bjsiw	110		2014-12-10 11:55:51		
8802	vanul	110		2014-12-10 11:55:51		
8803	qywrh	110	}	2014-12-10 11:55:51		
8804	plapd	110		2014-12-10 11:55:51		
8805	rdfeo	110		2014-12-10 11:55:51		
8806	plapd	110	My solution is just take all the subsets and see if they are unique. Obviously the code doesn't work for "abba" as mentioned by the author of the post. I am not sure why abba is not valid. It has ab at two places {1,2} and {1,3} with b following a. So it's valid I guess.  However, if it is invalid, then I can store the indices that joined together to form the subset and then when comparing if there is repetition, I will check if the indices(first) in the two cases are same or not. For instance in the example string "abba", the first ab will have indices {1,2}, the second ab will have indices {1,3}. Since the first indices are same. I will regard them as different.  Has anyone better solution than this? Please let me know	2014-12-10 11:55:51		
8807	qywrh	110		2014-12-10 11:55:51		
8808	tenuw	110		2014-12-10 11:55:51		
8809	dkebi	110	The complexity should be O(n^2)	2014-12-10 11:55:51		
8810	ufdxg	110	It's a goo solution but i think you should have if(ii1 < ij1 && ii2 < ij2 && ii2 > ij1) instead of if(ii1 < ij1 && ii2 < ij2) to account for something like "aabb"	2014-12-10 11:55:51		
8811	azmjc	110	bool hasSubseq(string const &hSub) { int hash[26][26]; memset(hash, 0, sizeof(hash)); int sz = hSub.size();  for(int i = 0; i < sz - 1; i++) for(int j = i + 1; j < sz; j++) hash[hSub[i] - 'a'][hSub[j] - 'a']++;   for(int i = 0; i < 26; i++) { for(int j = 0; j < 26; j++) { if(hash[i][j] >= 3) return true; } } return false; }	2014-12-10 11:55:51		
8812	nwkeg	110		2014-12-10 11:55:51		
8813	ewigy	110		2014-12-10 11:55:51		
8814	nhibd	110	My solution uses regex.	2014-12-10 11:55:51		
8815	nhibd	110		2014-12-10 11:55:51		
8816	admin	110		2014-12-10 11:55:51		
8817	plapd	110	This question is very detailed, and that gives us the proper hint on handling this. The fact that the sequence can be dis-joined (not required to be continuous) allows us to utilize some neat tricks to keep run time and space complexity somewhat controlled. The size complexity of my solution is O(n) as it will require additional data structures that could be equal to the size of the original string plus the size of the known alphabet we are working with. The absolute worst case run-time would be O(n^2) in the event the character string was entered in alphabetical order and then reverse alphabetical order. This is unlikely to happen, but must be considered. Note that we will typically get better run time that this due to our ability to track unique characters by virtue of the Set interface. This will limit the number of full string scans to only those characters that actually have a duplicate, and will only do the full string scan one time for each possible duplicate.  Here is my coded Java solution with comments:	2014-12-10 11:55:51		
8818	bexbp	110		2014-12-10 11:55:51		
8819	fowai	110		2014-12-10 11:55:51		
8820	qywrh	110	Note that this function could be further customized to accommodate the passing in of different alphabets to ensure modularity and re-usability, but for the sake of simplicity I have assumed an ASCII char set.	2014-12-10 11:55:51		
8821	dgjji	110	I think this may fail against the case of "aabac". You only tested for the case where the second start is adjacent to the first one. Further, the second start is added to seq, which is incorrect.	2014-12-10 11:55:51		
8822	dgjji	110	"a" and "b" are used generically as any two distinct chars below.  If the question is asking for a binary output, the problem could be reduced to find a pattern of "abab" in any sebsequence. If found, the algorithm could break immediately.  Preprocessing: eliminate all unique chars, and put repeating chars in a hashmap (e.g. pos["a"] = [1,2,3]).  For each unordered pair in hahsmap, if any pos["a"][1]<pos["b"][1] and pos["a"][2]<pos["b"][-1], return True; Return false  Space O(n) (ignoring hashmap overhead) Time O(r^2) where r are number of repeating chars.  Note that each pair testing only takes O(1), the pair is unordered because if "abab" doesn't exist, "baba" can't exists. We can safely use the first positions of a pair, because if the repeating sequence exists not using them, there are two cases: the first positions agree with the sequence order, we can switch to them, the first positions are reversed, so there must be something like "b....a....abab", so we are able to find "baba" anyway.	2014-12-10 11:55:51		
8823	ethan	110	"For each unordered pair in hahsmap, if any pos["a"][1]<pos["b"][1] and pos["a"][2]<pos["b"][-1], return True; Return false "  should be pos["a"][1] < pos["b"][-2] and pos["a"][2] < pos["b"][-1]	2014-12-10 11:55:51		
8824	ewigy	110	I made a mistake above. The check takes log(n) using a binary search such that b[0]<a[j]<b[-1] where 1<=j<a.size(). The O(1) check is buggy in some cases. and i don't think pos["a"][1] < pos["b"][-2] and pos["a"][2] < pos["b"][-1] is correct	2014-12-10 11:55:51		
8825	zeice	110	Well I think it is easy to prove that my check is correct. But it is hard for me to prove in English. The simple idea is for 'a', 'b' (ordered), there are only two cases : .. a .. b .. a .. b .. or .. a .. a .. b .. b .. If a string as such two pairs, we replace two 'a' with the first two 'a', it still work. If we replace two 'b' with the last two 'b', it still work.  You can see my solution several comments above.	2014-12-10 11:55:51		
8826	ftfck	110		2014-12-10 11:55:51		
8827	fmzze	110		2014-12-10 11:55:51		
8828	bexbp	110	Hi, I'm afraid the premise on the first comment may not be true: "aaa" is a valid sequence for the purpose of the exercise	2014-12-10 11:55:51		
8829	zeice	110	This solution works O(n) time and O(n) memory. It can be trimmed to use O(1) memory as well. The trick is that if you remove the non repeated characters, the remaining should be palindrome (if it is not then for sure there is a repeated). Also even if it is palindrome with odd length you have to check that the middle letter is not different from its left or right.  You can count the letter and check for palndrom in O(n).  Step 1: Scan the string to count the number of each letter. (mean while if the count of any letter is 4 or more, we already find a repetition of two character, the same character followed by itself and return YES) If no character is repeated, return NO.  Step 2: Scan second time and append each letter that has been repeated (using the count array from the first step) to a new string (let say a StringBuilder)  Step 3: If the new string is not palindrom, return YES. else if newString.length() is odd and the middle is different from one previous return YES.  return NO.	2014-12-10 11:55:51		
8830	rdfeo	110	What about input "aabbc"? It should return false, But your step 2 gives "aabb", which is not a palindrome, and your step 3 gives true;	2014-12-10 11:55:51		
8831	jippy	110		2014-12-10 11:55:51		
8832	xhgls	110		2014-12-10 11:55:51		
8833	wbqzu	110	}	2014-12-10 11:55:51		
8834	jippy	110		2014-12-10 11:55:51		
8835	eucmc	110		2014-12-10 11:55:51		
8836	gilit	110	First we write a couple of helper functions (one to get all the subsequences of a certain length in a string and one to get a dictionary with the frequencies of elements in a list):	2014-12-10 11:55:51		
8837	ewigy	110		2014-12-10 11:55:52		
8838	zeice	110		2014-12-10 11:55:52		
8839	plapd	110	Combining these two, we write the main function. We want to know the frequency of the given subsequence in the list of all subsequences in s of length len(subsequence). If said frequency > 1, then the subsequence repeats in s.	2014-12-10 11:55:52		
8840	cfzie	110		2014-12-10 11:55:52		
8841	eucmc	110		2014-12-10 11:55:52		
8842	ethan	110	Testing:	2014-12-10 11:55:52		
8843	azmjc	110		2014-12-10 11:55:52		
8844	fowai	110		2014-12-10 11:55:52		
8845	gilit	110	O(n) match any pattern of char add chars in map , from the string remove all the non repeated char you will end up with string compare char neighbors if they are different it is subseq if not try to remove the noise see how many char/pattern you have detect the false positive and ignore it.  here is the solution	2014-12-10 11:55:52		
8846	xhgls	110		2014-12-10 11:55:52		
8847	sqzqo	110		2014-12-10 11:55:52		
8848	zeice	110	1. have unordered_map<char, vector<int>> to have index of each character 2. iterate through the unordered_map and for every character which is having more than one index entry i.e. repeated, see if both indices > 0 or both indices < original string.size - 1. If it is then just grab the first or last char and this one and return that as the repeating subsequence. the thing is that if we have a repeating char and it is not at the start or at the end, there has to be some other char which can prefix or suffix the repeating char to form the repeating subsequence. This is O(n) assuming you use unordered_map and just iterate through all repeating char indices only once.  e.g. abcb => has repeating char b => {1, 3} and both indices are > 0, so ab is repeating subsequence. aba => repeating char a => {0, 2}, both are not > 0 neither are they less than size - 1 and hence it does not have a repeating subsequence abac => repeating char a => {0, 2} here both are < size - 1 so subsequence repeating is ac	2014-12-10 11:55:52		
8849	vanul	110	only two chars in a string for example, we want to find whether "ab" is repeat if the index of last "b" is after the index of 2nd "a" and the index of second last is after the index of 1st "a", "ab" is repeated. We can enumerate every different two-chars-string. Time complexity O(N) Memory O(N)	2014-12-10 11:55:52		
8850	dgjji	110		2014-12-10 11:55:52		
8851	ewigy	110		2014-12-10 11:55:52		
8852	qywrh	110	Since Question itself says. Check for every pair. My approach is take every out every pair store in hashmap along with index it uses and then look for if there exist same pair with different indices.  For eg:- abab 1. ab in hashmap {{ab-> 0-1}} here key is ab and 0-1 is indices range 2. aa in hash map {{aa-> 0-2}} 3. ab in hash map. here you will see it is already in in hashmap. and if you look at the value it has same index as current index so we ignore this pair. 4. ba in hashmap {{ba->1-2 }} 5. bb in hashmap {{bb-> 1-3}} 6. ab here we again find it in hashmap. so we check if both indices differ they do. we found our solution.	2014-12-10 11:55:52		
8853	azmjc	110		2014-12-10 11:55:52		
8854	dkebi	110		2014-12-10 11:55:52		
8855	fowai	110		2014-12-10 11:55:52		
8856	ethan	110		2014-12-10 11:55:52		
8857	cfzie	110	it contains an extra loop. this is the corrected one:	2014-12-10 11:55:52		
8858	tenuw	110		2014-12-10 11:55:52		
8859	rdfeo	110		2014-12-10 11:55:52		
8860	huiqq	110		2014-12-10 11:55:52		
8861	fmzze	110		2014-12-10 11:55:52		
8862	xhgls	110		2014-12-10 11:55:52		
8863	fmzze	110		2014-12-10 11:55:52		
8864	xhgls	110	Find the appear postion "First", "second" and "third". And compare the value between ("First", "second") and ("second", "third"). Do they repeat or not!	2014-12-10 11:55:52		
8865	vanul	110		2014-12-10 11:55:52		
8866	ethan	110		2014-12-10 11:55:52		
8867	ftfck	110	static boolean find(String string, int startingIndex) { if (startingIndex > string.length() - 1) return false; int secondIndex = string.indexOf(string.charAt(startingIndex), startingIndex + 1); if (secondIndex != -1) { for (int i =1 ; i < secondIndex; i++) { if (checkIfAvailable(string, string.charAt(startingIndex + i), secondIndex + 1)) { return true; } } } else { return find(string, startingIndex + 1); } return false; }  static boolean checkIfAvailable(String string, char ch, int index) { return string.indexOf(ch, index) != -1; }	2014-12-10 11:55:52		
8868	rdfeo	110		2014-12-10 11:55:52		
8869	mrjku	110		2014-12-10 11:55:52		
8870	dgjji	110		2014-12-10 11:55:52		
8871	ethan	110		2014-12-10 11:55:52		
8872	eucmc	110	This code works perfectly fine.	2014-12-10 11:55:52		
8873	plapd	110		2014-12-10 11:55:52		
8874	ewigy	110		2014-12-10 11:55:53		
8875	ewigy	110		2014-12-10 11:55:54		
8876	eucmc	110		2014-12-10 11:55:54		
8877	vanul	110	A linear solution is implemented: Here is the pseudo-code: - Detect each character's appearance. Return true, if any appears more than twice - Strip out all characters that appear only once. - Check if the rest string is palindrome. If yes, return false otherwise return true.  More details and explanation please refer to: cpluspluslearning-petert.blogspot.co.uk/2014/11/data-structure-and-algorithm-detect.html	2014-12-10 11:55:54		
8878	azmjc	110		2014-12-10 11:55:54		
8879	fmzze	110		2014-12-10 11:55:54		
8880	cfzie	110	A minor bug:	2014-12-10 11:55:54		
8881	mrjku	110		2014-12-10 11:55:54		
8882	vanul	110		2014-12-10 11:55:54		
8883	sgiwy	110	to	2014-12-10 11:55:54		
8884	xhgls	110		2014-12-10 11:55:54		
8885	wbqzu	110		2014-12-10 11:55:54		
8886	fmzze	110	At least two different characters after strip out the characters that appears only once.	2014-12-10 11:55:54		
8887	rrmeu	110	Simple regex expression:	2014-12-10 11:55:54		
8888	jippy	110		2014-12-10 11:55:54		
8889	krxlv	110		2014-12-10 11:55:54		
8890	gilit	110	Forms two capture groups of one letter each, and sees if they reappear in the same order later on.	2014-12-10 11:55:54		
8891	ftfck	110	you can combine suffix trees and DP together:	2014-12-10 11:55:54		
8892	dkebi	110		2014-12-10 11:55:54		
8893	fowai	110		2014-12-10 11:55:54		
8894	rdfeo	110	Using a modification of Longest Common Subsequence algorithm we can solve it the following way:	2014-12-10 11:55:55		
8895	gilit	110		2014-12-10 11:55:55		
8896	eucmc	110		2014-12-10 11:55:55		
8897	ethan	110	Using a modification of Longest Common Subsequence algorithm we can solve it the following way:	2014-12-10 11:55:55		
8898	cfzie	110		2014-12-10 11:55:55		
8899	eucmc	110		2014-12-10 11:55:55		
8900	azmjc	110	The idea is to basically find the longest comment subsequence (LCS) in s1 and s2 where s1 = s[0 ... i] and s2 = s[j ... k] where 0 <= i < j <= k.	2014-12-10 11:55:55		
8901	dgjji	110	This solution does not works for "xxyy". Because it find nothing but "xy" was repeated as the two characters doesn't need to be contiguous!	2014-12-10 11:55:55		
8902	krxlv	111	First, we need to realize that the number of sstrings of size N is 25^N - at each step, we can pick any of the 25 different letters than the last one. Then we can apply dynamic programming knowing the current index and the previous letter used.  Say we have "bcd". Pick 'a' for the first letter - since it's smaller than the first letter 'b', we sum the number of sstrings of size 2 (2 remaining characters). Do this for all letters less than the given letter at index i because all subsequent strings are lexicographically smaller. After this step, add the number of sstrings with the same first 'i' letters as the given string.	2014-12-10 11:55:56		
8903	cfzie	111		2014-12-10 11:55:56		
8904	rdfeo	111		2014-12-10 11:55:56		
8905	nhibd	111	I could not understand why will you pick 'a' as it is not present in input string 'bcd' ?	2014-12-10 11:55:56		
8906	eucmc	111	We don't need to use only the letters of the input string. The problem asks for *all* sstrings lexicographically smaller or equal than the input. Example "aba" or "abc" are 2 of 653 sstrings smaller or equal than "bcd"	2014-12-10 11:55:56		
8907	xhgls	111	DP here is redundant. You can just calculate the result in this way:	2014-12-10 11:55:56		
8908	gilit	111		2014-12-10 11:55:56		
8909	ewigy	111		2014-12-10 11:55:56		
8910	fowai	111	@Zuzu, that code is incorrect. See the other post with test cases	2014-12-10 11:55:56		
8911	cfzie	111	Similarly to what Zuzu mentioned, I don't think you need DP as there are no overlapping problems, furthermore, you can substitute your for loop for a simple multiplication:	2014-12-10 11:55:56		
8912	ftfck	111		2014-12-10 11:55:56		
8913	krxlv	111		2014-12-10 11:55:56		
8914	gilit	111	I think this is your same solution except I only use backtracking without DP:	2014-12-10 11:55:56		
8915	bjsiw	111		2014-12-10 11:55:56		
8916	ewigy	111		2014-12-10 11:55:56		
8917	qywrh	111	@Miguel Oliveira Can you explain what exactly dp[i][j] means? Thanks a lot!	2014-12-10 11:55:56		
8918	azmjc	111	I think my code is much simpler than yours and it is working fine :)	2014-12-10 11:55:56		
8919	huiqq	111		2014-12-10 11:55:56		
8920	qywrh	111		2014-12-10 11:55:56		
8921	rrmeu	111	I am not taking care of the modulo thing but logic is correct	2014-12-10 11:55:56		
8922	huiqq	111	For e.g. passed string is 'bcd', then 1- 1(a)*25(b-z)*25(a,c-z) plus 2- 1(b)*1(a)*25(b-z) plus 3- 1(b)*1(c)*3(a,b,d) = 653  Similar idea is used here. During, each sstring generation, I have checked whether it's all it's previous chars are bounded or not. By bounded, I mean that the char at current index is same as passed string char at that index. So, if all previous chars are bounded so current char cannot go beyond the passed string char at current index else it can have any 25 chars.	2014-12-10 11:55:57		
8923	ewigy	111		2014-12-10 11:55:57		
8924	vanul	111		2014-12-10 11:55:57		
8925	jippy	111	Duplicate question - previously posted at question?id=23869663  An approach to solve this would be to:  0. Maintain a counter variable. 1. Check if the given string itself is an SString. If yes, increment the counter 2. Start at the rightmost character 3. Decrement the value of the current character 4. Check if the character >= 'a' and the character to the left is the same as the current character. 4a. If they are the same decrement the value of the current character 4b. If they are different, increment the value of the counter by 25^(Length_of_string - i) 5. Decrement i 6. Repeat steps 2 to 5 until i >=0  An implementation in java goes like below...	2014-12-10 11:55:57		
8926	krxlv	111		2014-12-10 11:55:57		
8927	ewigy	111		2014-12-10 11:55:57		
8928	plapd	111	As I told you on the other question, this code is incorrect. Examples: Answer to "ccc" is 291, your code gives 294 Answer to "ddd" is 941, your code gives 944 Answer to "abbc" is 25, your code gives 26 Answer to "zzzzz" is 665, your code gives 796	2014-12-10 11:55:57		
8929	gilit	111	@ Miguel , Answer to "ccc" is 294 Answer to "ddd" is 945 Answer to "abbc" is 27 (use pencil and piece of paper) Answer to "zzzzz" is 797  And there are some my tests: Answer to "ab" is 1 Answer to "ba" is 26 Answer to "abab" is 1 Answer to "abccba" is 757  And here is my working code/solution:	2014-12-10 11:55:57		
8930	ewigy	111		2014-12-10 11:55:57		
8931	dkebi	111		2014-12-10 11:55:57		
8932	sqzqo	111	@Zuzu, it's easy to check by hand or even by brute force that the answer to "abbc" is 25. It's the strings "abab", "abac", "abad".. "abaz".	2014-12-10 11:55:57		
8933	wbqzu	111	This ain't an optimization problem and hence no need of Dynamic Programming. A few loops with simple tricks can do the job.  An approach to solve this would be to:  0. Maintain a counter variable. 1. Check if the given string itself is an SString. If yes, increment the counter 2. Start at the rightmost character 3. Decrement the value of the current character 4. Check if the character >= 'a' and the character to the left is the same as the current character. 4a. If they are the same decrement the value of the current character 4b. If they are different, increment the value of the counter by 25^(Length_of_string - i) 5. Decrement i 6. Repeat steps 2 to 5 until i >=0  A less bloated implementation in java goes like below.	2014-12-10 11:55:57		
8934	wbqzu	111		2014-12-10 11:55:57		
8935	nhibd	111		2014-12-10 11:55:57		
8936	dkebi	111	A few test cases: Answer to "ccc" is 291, your code gives 294 Answer to "ddd" is 941, your code gives 944 Answer to "abbc" is 25, your code gives 26 Answer to "zzzzz" is 665, your code gives 796	2014-12-10 11:55:57		
8937	ewigy	111	@Miguel  Thanks for the test cases, I have blatantly missed the case of having 3 or more consecutive characters that are same. Either I need to refine my idea to handle such test cases or accept DP paradigm as the way to go! Thanks again!	2014-12-10 11:55:57		
8938	eucmc	111	@Apostle Just add a condition that when you get two consecutive same characters in the input string, break, because no more sstring will be possible. e.g.: for ccc keep first character can be a/b. so you have total: 2* 25^2 now fix first as c, second character can be a/b, so total string : 2*25 now fix c at second location too.... so you have "cc" and so no more sstrings are possible now..... that means you got total of 2*25^2 + 2*25=1400  1400 modulo 1009=291. Voila!!	2014-12-10 11:55:57		
8939	tenuw	111	@Miguel Oliveira The answer to zzzzz is 142? Shouldn't it be (25^5 + 25^4) that is 665?	2014-12-10 11:55:57		
8940	qywrh	111	Yes, it's 665, i prefer to put it as 26*25^4. My code also gives 665, I made a mistake putting the 142.  i edited the post	2014-12-10 11:55:57		
8941	dgjji	111		2014-12-10 11:55:57		
8942	zeice	111		2014-12-10 11:55:57		
8943	ufdxg	111	import java.lang.*; public class face { public static void main(String[] args){ int result = countNumber("bcd"); System.out.print(result); }  public static int countNumber(String s){ if(s == null || s.equals("")){ return 0; }  int result = countNumberCore(s, 0, s.length() - 1, 0, false); return result; }  public static int countNumberCore(String s, int start, int end, int sum, boolean sameChar){ if(sameChar == true){ return sum; } if(start == end){ return sum + (s.charAt(start) - 'a'); } char before = '\0'; if(start != 0){ before = s.charAt(start - 1); }  if(before == '\0' || s.charAt(start) < before){ int difference = s.charAt(start) - 'a'; sum = countSubfunction(difference, start, end, sum);  } else if(s.charAt(start) > before) { int difference = s.charAt(start) - 'a' - 1; sum = countSubfunction(difference, start, end, sum); } else{ sameChar = true; int difference = s.charAt(start) - 'a'; sum = countSubfunction(difference, start, end, sum);  }  return countNumberCore(s, start + 1, end, sum, sameChar); } public static int countSubfunction(int difference, int start, int end, int sum){ for(int i = difference; i > 0; i--){ int tempSum = 1; for(int j = start + 1; j <= end; j++){ tempSum = (tempSum * 25) % 1009; } sum += tempSum; } return sum % 1009; } }	2014-12-10 11:55:57		
8944	krxlv	111		2014-12-10 11:55:57		
8945	nwkeg	111		2014-12-10 11:55:57		
8946	rdfeo	111		2014-12-10 11:55:57		
8947	nwkeg	111		2014-12-10 11:55:57		
8948	fowai	111		2014-12-10 11:55:57		
8949	fmzze	111		2014-12-10 11:55:57		
8950	nhibd	111	}	2014-12-10 11:55:57		
8951	ewigy	111	#include <iostream> #include <stdio.h> #include <string> #include <cmath> #define mod 1009 using namespace std; int main() { string s; int count=0,l,m,k; cin>>s; l=s.length(); for( k=1;k<l && s[k]!=s[k-1];k++); if(k==l) { k=l-1; count+=1; } for(int i=0;i<=k;i++) { m=s[i]-'a'; if(i!=0) if(s[i]>s[i-1]) m=m-1; count+=(m*int(pow(25.0,l-i-1)))% mod; } printf("%d",count); return 0;  }	2014-12-10 11:55:57		
8952	krxlv	111		2014-12-10 11:55:57		
8953	qywrh	111		2014-12-10 11:55:57		
8954	dgjji	111	Add modulus operator in main : val=val%1009;	2014-12-10 11:55:57		
8955	vanul	111		2014-12-10 11:55:58		
8956	cfzie	111		2014-12-10 11:55:58		
8957	fmzze	111		2014-12-10 11:55:58		
8958	admin	111		2014-12-10 11:55:58		
8959	fmzze	111	Got same problem in my Facebook coding test today. The above code passed all the test cases (sample as well as hidden/advanced ones)	2014-12-10 11:55:58		
8960	cfzie	111	If the input is just 'a', then your code returns 0. It should be 1 as the string 'a' is also a valid sstring. Please correct me if I am wrong.	2014-12-10 11:55:58		
8961	bjsiw	111	@Anon No, my code returns 1 only, which is the correct answer. On input "a", my code would enter the following if condition	2014-12-10 11:55:58		
8962	eucmc	111		2014-12-10 11:55:58		
8963	ethan	111		2014-12-10 11:55:58		
8964	krxlv	111	and further enter the first if statement -	2014-12-10 11:55:58		
8965	mrjku	111		2014-12-10 11:55:58		
8966	sgiwy	111		2014-12-10 11:55:58		
8967	ftfck	111	and return 'a'-'a'+1=1	2014-12-10 11:55:58		
8968	wbqzu	111	Working perfect for every test case.	2014-12-10 11:55:58		
8969	nhibd	111		2014-12-10 11:55:58		
8970	ufdxg	111		2014-12-10 11:55:58		
8971	ftfck	111	LOL. Just look at the code above your answer by sc.shobhit (me). Uncannny similarity :\  It feels good that my code proved to be useful for you but atleast don't repost exactly same version.	2014-12-10 11:55:58		
8972	gilit	111		2014-12-10 11:55:58		
8973	admin	111		2014-12-10 11:55:58		
8974	rrmeu	111		2014-12-10 11:55:58		
8975	ewigy	111		2014-12-10 11:55:58		
8976	huiqq	111		2014-12-10 11:55:58		
8977	ethan	111		2014-12-10 11:55:58		
8978	plapd	111		2014-12-10 11:55:58		
8979	dgjji	111		2014-12-10 11:55:58		
8980	fowai	111	I'd go for dynamic programming	2014-12-10 11:55:58		
8981	sqzqo	111		2014-12-10 11:55:58		
8982	fmzze	111		2014-12-10 11:55:58		
8983	ethan	111	Here is the concept..   Let the given string be STRING. In the input string, S is the first character. There are total 6 characters and 4 of them are smaller than S. So there can be 4 * 5! smaller strings where first character is smaller than S, like following,  Rank = 4*5! + 4*4! + 3*3! + 1*2! + 1*1! + 0*0! = 597  Since the value of rank starts from 1, the final rank = 1 + 597 = 598  Refer geeksforgeeks	2014-12-10 11:55:58		
8984	azmjc	111		2014-12-10 11:55:58		
8985	bexbp	111		2014-12-10 11:55:58		
8986	tenuw	111	Did you test this? This doesn't even answer the sample "bcd" -> 653, your code gives 731	2014-12-10 11:55:58		
8987	ftfck	111	bc{a-d} -> 4 b{a-b}{a-z} ->2*26 = 52 a{a-z}{a-z} -> 26*26 = 676 so total # of strings should be 4 + 52 + 676 = 732.. how the ans is 653 .. explain !!	2014-12-10 11:55:59		
8988	tenuw	111	"A string is called sstring if it consists of lowercase english letters and no two of its consecutive characters are the same."	2014-12-10 11:55:59		
8989	krxlv	111	int b =1; int ret = 1; for (int i=s.size()-1; i>0; i--) { if (s[i] >= s[i-1]) { ret += b * (s[i] - 'a' - 1); } else { ret += b * (s[i] - 'a'); } b * = 25; } return ret;	2014-12-10 11:55:59		
8990	bexbp	111	This is wrong. For example, for "bbb" your code returns 1 and the answer is 650 (a[a-z][a-z])	2014-12-10 11:55:59		
8991	huiqq	111		2014-12-10 11:55:59		
8992	sgiwy	111		2014-12-10 11:55:59		
8993	vanul	111	I got the 653 for "bcd".	2014-12-10 11:55:59		
8994	vanul	111	Your interpretation of question is incorrect. You seem to have interpreted the question as "A string is called sstring if it consists of lowercase english letters and no two of characters are the same." You have overlooked the term CONSEQUTIVE CHARACTERS.  Adding few more checks in your code does the job. Also, the first check of {{ if(str.lenght()>26) return 0; }} has to be removed as only CONSEQUTIVE CHARACTERS are not allowed.  Would post the working code soon	2014-12-10 11:55:59		
8995	gilit	112	The code prints all forms without duplicates. This question (solution) is in "Cracking the coding interview" Book.	2014-12-10 11:56:09		
8996	ewigy	112		2014-12-10 11:56:09		
8997	qywrh	112		2014-12-10 11:56:09		
8998	fmzze	112	output: ((())) (()()) (())() ()(()) ()()()	2014-12-10 11:56:09		
8999	jippy	112	C version:	2014-12-10 11:56:09		
9000	sqzqo	112		2014-12-10 11:56:09		
9001	jippy	112		2014-12-10 11:56:09		
9002	jippy	112	first call need be print(s, 1, 0); or else can't recursive...	2014-12-10 11:56:09		
9003	rdfeo	112	Recursive version.  Keep track of how many open and close brackets are remaining.  Also keep track of number of open - number of closed used so far (called the balance_factor).  Python code:	2014-12-10 11:56:09		
9004	ftfck	112		2014-12-10 11:56:09		
9005	rdfeo	112		2014-12-10 11:56:10		
9006	tenuw	112	output	2014-12-10 11:56:10		
9007	eucmc	112		2014-12-10 11:56:10		
9008	sgiwy	112		2014-12-10 11:56:10		
9009	nhibd	112	balance_factor = num_close - num_open  so we don't exactly need to pass that around. Makes it easier to read though.	2014-12-10 11:56:10		
9010	rdfeo	112	And here is the same code using generators (note that will multiply time complexity by n or n^2, depending on implementation).	2014-12-10 11:56:10		
9011	zeice	112		2014-12-10 11:56:10		
9012	ewigy	112		2014-12-10 11:56:10		
9013	ethan	112	The code above looks correct. I am still posting the java version I wrote using a similar approach. The recursive implementation is in fact dynamic programming.	2014-12-10 11:56:12		
9014	sqzqo	112		2014-12-10 11:56:12		
9015	eucmc	112		2014-12-10 11:56:12		
9016	krxlv	112	Sample usage:	2014-12-10 11:56:12		
9017	plapd	112		2014-12-10 11:56:12		
9018	rrmeu	112		2014-12-10 11:56:12		
9019	qywrh	112	Output:	2014-12-10 11:56:12		
9020	cfzie	112		2014-12-10 11:56:12		
9021	sqzqo	112		2014-12-10 11:56:12		
9022	fmzze	112	Problem with this is the huge space usage (which is not the case with the python solution above).	2014-12-10 11:56:12		
9023	vanul	112	(And that is something the interviewer will be worried about).	2014-12-10 11:56:12		
9024	nwkeg	112	Of course, since there is probably a super-polynomial number of terms. I could as well print the sequence out instead of adding it to the list. Either way, writing it to console does not resolve the space problem.	2014-12-10 11:56:12		
9025	rdfeo	112	The total number is Catalan number (call it C_n).  And no, space usage being O(n) and that is relevant.  For example, instead of printing it, all I would have to do is yield it (a python feature for creating generators).  Now I have a generator which can do something similar to hasNext(), next() of Java. It would use only O(n) space, and can be used to print out only the first 1000 arragements or 10000 or whatever. The space usage will remain O(n) irrespective of how many times you do a next.  The fact that I am printing it is not any indication that the space usage will be Omega(C_n).  Of course, now that I look at your solution more carefully, you don't really need to use that much space and our solutions are quite similar. So actually that is not a problem with your solution and can potentially be converted into a hasNext, next generator using O(n) space.	2014-12-10 11:56:12		
9026	sgiwy	112	See update to my answer using generators.	2014-12-10 11:56:12		
9027	nwkeg	112	Thanks for the reference to Cn and generators in python. I guess I see your point. I believe one way to modify my implementation to work as a generator is to store the state after each call (e.g., sequence and the last value of "N" and "nClose" before finding a new sequence).	2014-12-10 11:56:12		
9028	nhibd	112		2014-12-10 11:56:12		
9029	azmjc	112		2014-12-10 11:56:12		
9030	dgjji	112	Python code below:	2014-12-10 11:56:12		
9031	jippy	112		2014-12-10 11:56:12		
9032	cfzie	112		2014-12-10 11:56:12		
9033	jippy	112		2014-12-10 11:56:12		
9034	nhibd	112		2014-12-10 11:56:13		
9035	azmjc	112	nice one	2014-12-10 11:56:13		
9036	nhibd	112	Another C Program using "BackTracking"	2014-12-10 11:56:13		
9037	ftfck	112		2014-12-10 11:56:13		
9038	bexbp	112		2014-12-10 11:56:13		
9039	ufdxg	112		2014-12-10 11:56:13		
9040	qywrh	112		2014-12-10 11:56:13		
9041	nhibd	112	Call it like generateValidParanthesis(4, "");	2014-12-10 11:56:13		
9042	plapd	112	I've came with similar solution in Objective-C, but then have realised that it doesn't generate `(())(())` when n equals 4. Probably your code also doesn't handle this case...	2014-12-10 11:56:13		
9043	dgjji	112	Haha,how about this bit-flipping solution 1.define an int , i1, with n length bit initialized to 0 2.flip i1 to acquire i2 3. Starting from i2 , you read the two ints bit by bit, print a left paran for a set bit and a right paran for an unset. 4. Increment i1, if the highest bit is still 0, print a line separator and loop back to step 2	2014-12-10 11:56:13		
9044	bjsiw	112	Can you explain more? What do you do in step 4 "if the highest bit is not 0"?	2014-12-10 11:56:13		
9045	ethan	112	Haha,how about this bit-flipping solution 1.define an int , i1, with n length bit initialized to 0 2.flip i1 to acquire i2 3. Starting from i2 , you read the two ints bit by bit, print a left paran for a set bit and a right paran for an unset. 4. Increment i1, if the highest bit is still 0, print a line separator and loop back to step 2	2014-12-10 11:56:13		
9046	rrmeu	112	Another C++ version	2014-12-10 11:56:13		
9047	nhibd	112		2014-12-10 11:56:13		
9048	bexbp	112		2014-12-10 11:56:13		
9049	ethan	112		2014-12-10 11:56:13		
9050	fowai	112		2014-12-10 11:56:13		
9051	krxlv	112		2014-12-10 11:56:13		
9052	vanul	112		2014-12-10 11:56:13		
9053	tenuw	112	output: (((()))) ((()())) ((())()) ((()))() (()(())) (()()()) (()())() (())(()) (())()() ()((())) ()(()()) ()(())() ()()(()) ()()()()	2014-12-10 11:56:13		
9054	zeice	112	anyone knows the complexity?	2014-12-10 11:56:13		
9055	qywrh	112	2^n exponential..since at every 2n places there are 2 choices to be made.	2014-12-10 11:56:13		
9056	ethan	112	The total number is the nth Catalan number: (2n Choose n)/(n+1).  The compexity of this is Theta(4^n/n^(1.5))  @shivkalra: There aren't 2 choices at every step. It could be any of 0, 1 or 2 choices.	2014-12-10 11:56:13		
9057	dkebi	112	shivkalra1 was close  he used a different n in this problem there are 2n parentheses  so 2^(2n) is number of possible parentheses without regard to balancing them  which is 4^n  so it is O(4^n)  But Subbu have tighter bound for it by dividing by n^1.5, which is basically adjusting for only including balanced results.	2014-12-10 11:56:13		
9058	rdfeo	112		2014-12-10 11:56:13		
9059	rdfeo	112		2014-12-10 11:56:13		
9060	nhibd	112		2014-12-10 11:56:13		
9061	bjsiw	112		2014-12-10 11:56:13		
9062	rdfeo	112	unittest which really does not do any testing?	2014-12-10 11:56:13		
9063	vanul	112		2014-12-10 11:56:13		
9064	xhgls	112		2014-12-10 11:56:13		
9065	mrjku	112		2014-12-10 11:56:13		
9066	bjsiw	112		2014-12-10 11:56:13		
9067	fowai	112	<?php  function printParanthesis(array $str,$index,$num,$open,$close) { if($open == $close && $open == $num) { echo implode("",$str)."\n"; return; }  if($open < $num) { $str[$index]='('; printParanthesis($str,$index+1,$num,$open+1,$close); }  if($open > $close) { $str[$index]=')'; printParanthesis($str,$index+1,$num,$open,$close+1); } }  //main $str = array(); $n = trim(fgets(STDIN)); printParanthesis($str,0,$n,0,0);	2014-12-10 11:56:14		
9068	mrjku	112		2014-12-10 11:56:14		
9069	ufdxg	112		2014-12-10 11:56:14		
9070	sqzqo	112		2014-12-10 11:56:14		
9071	sqzqo	112		2014-12-10 11:56:14		
9072	rdfeo	112	The following algorithm uses the recursive formula to generate Catalan Numbers.	2014-12-10 11:56:14		
9073	bjsiw	112		2014-12-10 11:56:14		
9074	sqzqo	112		2014-12-10 11:56:14		
9075	mrjku	112	This one uses grammar to generate	2014-12-10 11:56:14		
9076	mrjku	112		2014-12-10 11:56:14		
9077	nhibd	112		2014-12-10 11:56:14		
9078	fowai	112	Ruby 2.0.0 implementation using a binary tree	2014-12-10 11:56:14		
9079	tenuw	112		2014-12-10 11:56:14		
9080	plapd	112		2014-12-10 11:56:14		
9081	zeice	112		2014-12-10 11:56:14		
9082	zeice	112		2014-12-10 11:56:14		
9083	rrmeu	112		2014-12-10 11:56:14		
9084	gilit	112		2014-12-10 11:56:14		
9085	xhgls	112	C++ Solution:  #include<iostream> using namespace std; int n; void f(int o,int c,string t){ if(o==n && c==n){cout<<t<<"\n";} else{ if(o+1<=n && o+1-c>=0){f(o+1,c,t+'(');} if(c+1<=n && o-c-1>=0){f(o,c+1,t+')');} } } int main(){ cin>>n;cout<<"\n\n"; string t;f(0,0,t); }  However this is a recursive solution.. I'm wondering if we can use memorization to solve it for a better time complexity...	2014-12-10 11:56:14		
9086	krxlv	112	Python recursive implementation	2014-12-10 11:56:14		
9087	bexbp	112		2014-12-10 11:56:14		
9088	cfzie	112		2014-12-10 11:56:14		
9089	dgjji	112	In the following {...} means "a set of the elements ..." where S = {...}, s is a string S + s means the set of each of elements of S concatenated with s s + S means the set of s concatenated with each of the elements of S s1 + S + s2 means the s1 concatenated with each of the elements of S concatenated with s2  For n = 0 we have S0 == {} For n = 1 we have S1 == {()} For n > 1 we have Sk == {Sk-1 + (), () + Sk-1, ( + Sk-1 + )}  This is very easy to write in Scala as follows:	2014-12-10 11:56:14		
9090	sgiwy	112		2014-12-10 11:56:14		
9091	fowai	112		2014-12-10 11:56:14		
9092	rrmeu	112	To pretty print the results is similarly simply:	2014-12-10 11:56:14		
9093	plapd	112		2014-12-10 11:56:14		
9094	fowai	112		2014-12-10 11:56:14		
9095	bjsiw	112	For example:	2014-12-10 11:56:14		
9096	cfzie	112		2014-12-10 11:56:14		
9097	bjsiw	112		2014-12-10 11:56:14		
9098	huiqq	112		2014-12-10 11:56:14		
9099	tenuw	112		2014-12-10 11:56:14		
9100	rrmeu	113	Example  String str1= ABCDEFGHIJKLMNOPQR String str2= DBCAXGFHTRQPONMKL  1. Find all the possible window from str1 and str2 Possible windows from Str1=[ABCD,FGH,KLMNOPQR] Possible windows from Str2=[DBCA,GFH,RQPONMKL]  2. Sort each window in either asc/dsc order Possible windows from Str1=[ABCD,FGH,KLMNOPQR] Possible windows from Str2=[ABCD,FGH,KLMNOPQR]  3. Pick up all the windows from Str2 (Order by Descending Size Order) and one by one check, if it exist as a substring of any of the Str1 window.  In this case max window of str2 KLMNOPQR will match, hence no need to iterate further	2014-12-10 11:56:16		
9101	fmzze	113	Updating step 2 Do not sort the window, directly go to step 3	2014-12-10 11:56:16		
9102	qywrh	113	Repeat step 3 for both the String window	2014-12-10 11:56:16		
9103	wbqzu	113	Good one Ashish....	2014-12-10 11:56:16		
9104	dkebi	113	how to find window itself?	2014-12-10 11:56:16		
9105	rrmeu	113	@Anonymous. Right question. You have to try all the possible N^2 combinations. of windows. See my implementation below:	2014-12-10 11:56:16		
9106	wbqzu	113	Are they mutated patterns or permuted patterns? Please define what a mutated pattern is.	2014-12-10 11:56:16		
9107	dkebi	113	mutated patterns	2014-12-10 11:56:16		
9108	eucmc	113	a muted pattern is that you can exchange the poations of the characters in the string in the sample given above ABCD A<>D & B<>C so result is DCBA	2014-12-10 11:56:16		
9109	azmjc	113	bag[i,j]=for(k=i->j)bag[i.k]&&bag[k,j]&&(bag[i,k] have one edge common with bag[k,j] )	2014-12-10 11:56:16		
9110	plapd	113	Adding to the above answer--3.Once the match is broken you can print out the consecutive match	2014-12-10 11:56:16		
9111	rdfeo	113	Since you are looking for sequences, I do not think sorting will give you the right answer!	2014-12-10 11:56:16		
9112	ethan	113		2014-12-10 11:56:16		
9113	nhibd	113		2014-12-10 11:56:16		
9114	sqzqo	113	1. For both of the input strings S1 and S2, for all their N^2 substrings with beginIndex = i & endIndex = j, compute their integral values V1 and V2 just by summing up their charAt(k) values. [i<=k<=j] 2. Compare V1 and V2. If they are equal, sort the substrings S1.substring(i,j) and S2.substring(i,j) and compare if they are equal. 3. Save (i,j) that contains the maxlength substring and print it.  Full java implementation is given below. Provide in the console, the input strings one after the other. Eg: SKANDAPURANAGAJUTA GARUDAAANURPJUJUGA	2014-12-10 11:56:16		
9115	rrmeu	113		2014-12-10 11:56:16		
9116	jippy	113		2014-12-10 11:56:16		
9117	sqzqo	113	Wrong!! if (cmpStrVal(k,l) && compareStr(k,l) && (l-k+1) You are assuming that the strings will appear in the same place from k to l, which may not be the case always.	2014-12-10 11:56:16		
9118	qywrh	113	Based on two Strings (InputA and InputB) - create two Sets or ordered sequences.  Once I have two Sets of ordered sequences find the intersection. I'm using BST to build by ordered sequence since I still need to find the possible sequences. As I build the sequence I also expand the BST and essentially reset it once I'm working on the next set of sequences.	2014-12-10 11:56:16		
9119	vanul	113		2014-12-10 11:56:16		
9120	tenuw	113		2014-12-10 11:56:16		
9121	sqzqo	113		2014-12-10 11:56:16		
9122	rdfeo	113		2014-12-10 11:56:16		
9123	ewigy	113	If I get the question right, the following would work. 1. Sort the characters in both the string O(n log n). 2. Use two pointers(strPtr1 and strPtr2) pointing to start of the string, in a loop of 1..N. Store the windows in an array. And later find the greatest from windows array. O(n) If string1 char is > string2 char if(window>0){windows[arr++] = window; window = 0 }; str2ptr++; continue; If string1 char == string2 char window++ strPtr1++;str2ptr++; continue; if string1 char < string2 char if(window>0){windows[arr++] = window; window = 0 }; strPtr1++; continue;  n log n + n	2014-12-10 11:56:16		
9124	sgiwy	113	Can someone please explain what does this means "Patterns can be mutated"	2014-12-10 11:56:16		
9125	rrmeu	113	Whatever "mutated" means, this approach should solve it: 1. Create a hashtable H1 out of the first string: key = char (i.e. "a", "b", etc); value = position in the string (1, 2, etc.) 2. Create another hashset S2 out of the second string by iterating over it and taking values matching from H1 (i.e. for the given example it would be: 4,2,3,1,6,7). 3. Go over S2 and find the longest consecutive sequence of numbers by removing each next number and its neighbors left and right . For the given example that would be 4,2,3,1 or 6,7 => 4,2,3,1	2014-12-10 11:56:16		
9126	admin	113	I think that following approach should work.  1. call a function int cmp(str a,str b) to compare strings a,b which return max common len. 2. inside function: a. set all flags of string a' characters to 1. alen=strlen(a); b. iterate on b till it is not null. I check b' ith charactor's flag. if its set increment count if count == alen return count continue. (maintain a start variable for b string). II if some flag is not set -> make that chat NULL and recursive call to our function with strings role reversed and b being only this portion from last cmp(&b[start],a) III store this returned value and maintain a max_len variable to be returned.  above example a=ABCDEFG, b=DBCAPFG first char in b not to match P so call (DBCA,ABCDEFG) - returns 4 as all initial 4 match full string calls again (FG,ABCDEFG) A is not set , shall not call with null. puts null at BCDE and calls (FG,FG) return 2. return 4 to main func.  1 more example dbpcalm, bdacemp e is not set in str b-> calls (bdac,dbpcalm) p is not set in str b-> calls (db,bdac) returns 2 l is not set -> (ca,bdac) -> will finally return 2 next calls (mp,dbpcalm) which finally will return 1 answer max(2,1) 2	2014-12-10 11:56:17		
9127	wbqzu	113		2014-12-10 11:56:17		
9128	gilit	113		2014-12-10 11:56:17		
9129	gilit	113	Whoops- need to return int on that not char*	2014-12-10 11:56:17		
9130	wbqzu	113	1) Convert substrings to sums 2) Compare sums 3) Sort subString 4) Compare subStrings	2014-12-10 11:56:17		
9131	dkebi	113		2014-12-10 11:56:17		
9132	rdfeo	113		2014-12-10 11:56:17		
9133	ethan	113		2014-12-10 11:56:17		
9134	wbqzu	113		2014-12-10 11:56:17		
9135	krxlv	113		2014-12-10 11:56:17		
9136	fowai	113		2014-12-10 11:56:17		
9137	fowai	113	A solution in Python. It's not the fastest solution, but it's pretty straighforward to code	2014-12-10 11:56:17		
9138	plapd	113		2014-12-10 11:56:17		
9139	vanul	113		2014-12-10 11:56:17		
9140	ufdxg	113	One Idea can be to find the character in seq2 which is not present in seq1. It means this is the place before which we have finished one range and after which well start another range. Lets rephrase the logic. Find the first character in seq2 which is not present in seq1. Now get seq2 string before this non-matching character (and previous non-matching, if present). The number of characters in this cut string are the matching window. Do this till the end and return the maximum matching window value.  Complexity: For each character in seq2, we are matching if it is present in seq1 or not. So n characters of seq2 will be machted with m characters of seq1 making complexity as O(n*m).  Issues: How to deal duplicate characters in seq2? Depends over the interviewer's view otherwise a simple check for duplicate will do the job.	2014-12-10 11:56:17		
9141	ethan	113		2014-12-10 11:56:17		
9142	azmjc	113		2014-12-10 11:56:17		
9143	rdfeo	113	1.Sort strings in alphabetical order first. 2.Use two pointers and compare each alphabet one by one and if match is found place it in a array.	2014-12-10 11:56:17		
9144	rdfeo	113	what if the two strings are: ABCDEFG DBCPFGA  Would your solution return "ABCD"	2014-12-10 11:56:17		
9145	zeice	113	Continuing on from Anonymous's test case, in general if there are intervening characters which break the window, this algorithm as I would understand it would seem to give the wrong answer since it does not at all consider the position of the characters.  In the simplest case, for: axb bya it would return ab (since the sorted strings are abx and aby) even though this won't work since these windows would include x in the first case and y in the second.	2014-12-10 11:56:17		
9146	dkebi	113	Here is a simple code with Recursion	2014-12-10 11:56:17		
9147	nwkeg	113		2014-12-10 11:56:17		
9148	bexbp	113		2014-12-10 11:56:17		
9149	cfzie	113	Sorry Wrong post!!!	2014-12-10 11:56:17		
9150	dkebi	113	You can delete this post if you want to. That would avoid confusion to others.	2014-12-10 11:56:17		
9151	rdfeo	113	String str1= ABCDEFGHIJKLMNOPQR String str2= DBCAXGFHTRQPONMKL  All the position which are not matching character of str2  X=4 T=8  max index of String =17  17-8=9(RQPONMKL)-1 = 8 (Window Size) 8-4=4 (GFH) -1 =3(Window Size) 4-0=4 (DBCA)=4(Window Size)  max(8,3,4) = 8 Answer  Please validate above solution.  Thanks	2014-12-10 11:56:17		
9152	krxlv	113	What if we have repeated char in strings? What if seq1= ABCDEFGHI and seq2= BAHPG? ans should be 2 as only AB abd BA are matching in both string, H should not be countable I guess...	2014-12-10 11:56:17		
9153	gilit	113	Yes, above solutiin is not correct	2014-12-10 11:56:17		
9154	cfzie	113	@PKT read the question the two strings must be of equal length N	2014-12-10 11:56:17		
9155	ethan	113	I thinkk the best solution is ordered windows. Here is the python code	2014-12-10 11:56:17		
9156	tenuw	113		2014-12-10 11:56:17		
9157	tenuw	113		2014-12-10 11:56:17		
9158	mrjku	113	seq1 = ABCDEFGH seq2 = DACBPHQRFGH  sort seq2, and maintain pointers to original positions A->2 B->4 C->3 D->1 F->9 G->10 H->6,11 P->5 Q->7 R->8  scan seq1, and for each match, store the index values at appropriate positions  index- > 4 1 3 2 0 8 0 0 6 7 8  sort subarrays between 0's  1 2 3 4 0 8 0 0 6 7 8  longest sequence willl give the answer ...	2014-12-10 11:56:17		
9159	azmjc	113	How the index comes out to be 41320800678..plz can u explain it in detail	2014-12-10 11:56:18		
9160	zeice	113	Since both the sequences are of equal length,  a. Start with the complete sequence, sort and check for equlity b. if not equal, sort and check the sub-sequence of 0 to n-1 and check for equality  As soon as two patterns match, then that is the longest sequence matching.	2014-12-10 11:56:18		
9161	admin	113	String str1= ABCDDFGHHJKLMNOPQR  Above solution also work if we have repetative character in the string. str1.contans("KLMNOPQR")--> true	2014-12-10 11:56:18		
9162	jippy	114		2014-12-10 11:56:18		
9163	tenuw	114		2014-12-10 11:56:18		
9164	ftfck	114	ur code is working fine...	2014-12-10 11:56:19		
9165	jippy	114	the sequence is strictly increasing	2014-12-10 11:56:19		
9166	wbqzu	114	Hi All  This is just a slightly different take on the merge routine in merge sort. It does not require recursion nor does it require dynamic programming. It is implemented iteratively, with the efficiency being O(n+m), where n and m are the sizes of the two arrays.  The basic idea is as follows: 1) Let A and B denote the two arrays 2) Let idx1 be the current index of the array A, and let idx2 be the current index of array B 3) While the element at the current index of A (i.e. A[idx1]) is less then the element at the current index of B (B[idx2]) increment idx1, and add each element to a running total (call it sumA) 4) Now that A[idx1] > B[idx2], increment idx2 of B until B[idx2] is not less than A[idx1], and also add it to a running total (call it sumB) 5) If at this point, A[idx1] is equal to B[idx2], we have found our intersection point. So add the maximum of sumA and sumB i.e. max(sumA,sumB) to the totalresult. Set sumA and sumB to zero, and repeat the whole process until all the elements in A and B have been examined.  The code for the above is as follows:	2014-12-10 11:56:19		
9167	admin	114		2014-12-10 11:56:19		
9168	vanul	114		2014-12-10 11:56:19		
9169	xhgls	114	This works fine for me	2014-12-10 11:56:19		
9170	ftfck	114		2014-12-10 11:56:19		
9171	eucmc	114		2014-12-10 11:56:19		
9172	nhibd	114	Tested with two test cases provided in code.	2014-12-10 11:56:19		
9173	zeice	114	Good Solution.	2014-12-10 11:56:19		
9174	huiqq	114	The code won't work, if you replace 100 (last num in arr2) with number greater than 122 ( sum of 60, 62 last two numbers of arr1).	2014-12-10 11:56:19		
9175	sgiwy	114	This will not work if the intersection indexes are at different places.like in your second case answer should be 30 but as per your sol it is coming as 29 because you are assuming to start from arr1[0] i.e. 2 but I can start from arr2[0] i.e. 1 also. This is because in while loop you should maintain two indexes one for arr1 and other for arr2.	2014-12-10 11:56:19		
9176	tenuw	114	Let A[0..n-1] and B[0..m-1] are two arrays. Segments of A or B = set of subarrays between two intersection points including subarray before first intersection point and subarray after last intersection point. So if there are K intersection points then we have (K+1) segments each of A and B. Iterate over all segments, if segment of A has greater sum then choose it else choose segment of B. We can iterate over segments in O(m+n) time.	2014-12-10 11:56:19		
9177	wbqzu	114		2014-12-10 11:56:19		
9178	jippy	114		2014-12-10 11:56:19		
9179	qywrh	114	Hope this helps:	2014-12-10 11:56:19		
9180	nwkeg	114		2014-12-10 11:56:19		
9181	plapd	114		2014-12-10 11:56:19		
9182	ewigy	114	Your code is incorrect. Can you give any test case for which you think mine will not work.	2014-12-10 11:56:19		
9183	cfzie	114	your code fails for the given test case... a[]= 3 5 7 9 20 25 30 40 55 56 57 60 62 b[]= 1 4 7 11 14 25 44 47 55 57 100 output:918 expected output:450	2014-12-10 11:56:19		
9184	gilit	114	Now it's fine.	2014-12-10 11:56:19		
9185	tenuw	114	have u tested it against the given test case... it is still giving wrong answer..	2014-12-10 11:56:19		
9186	vanul	114	Fixed.	2014-12-10 11:56:19		
9187	ethan	114	Recursive Approach to Solve this  Algorithm: 1. whenever the program encounters an intersection point, it goes 2 ways and return the corresponding sums. 2. We will get the maximum sum of these and then add the intersection point and return it.	2014-12-10 11:56:19		
9188	ethan	114		2014-12-10 11:56:19		
9189	nhibd	114		2014-12-10 11:56:19		
9190	cfzie	114	your code is correct.. but don't u think that it is showing overlapping subproblems property.. u can optimise this by using dp..	2014-12-10 11:56:19		
9191	sgiwy	114	your code is based on the assumption that sum of numbers in the first array uptill first intersection point is largerthan sum of numbers in the second array up till first intersection point.If first and second arrays are interchanged it no longer gives the correct answer	2014-12-10 11:56:20		
9192	sqzqo	114	Here is a O(n) solution	2014-12-10 11:56:20		
9193	ethan	114		2014-12-10 11:56:20		
9194	ufdxg	114		2014-12-10 11:56:20		
9195	xhgls	114	My first post. It seems recursive works here. I define a func max_sum to compute the max sum beginning from index n. the func returns two max values, one for starting at first array, the other for starting at second. I print out the optimal sequence in reverse order at the first column of the output, and the sum at the second column. The last row gives the total optimal sum.  p.s. I saw others use two indices i and j for two arrays, while I use one. Can anyone show me the difference? Thanks.	2014-12-10 11:56:20		
9196	rrmeu	114		2014-12-10 11:56:20		
9197	gilit	114		2014-12-10 11:56:20		
9198	xhgls	114	My proposal in Java.	2014-12-10 11:56:20		
9199	zeice	114		2014-12-10 11:56:20		
9200	krxlv	114		2014-12-10 11:56:20		
9201	azmjc	114	Here is solution on D:	2014-12-10 11:56:20		
9202	dgjji	114		2014-12-10 11:56:20		
9203	bjsiw	114		2014-12-10 11:56:20		
9204	zeice	114	Output: Best Path:[3, 5, 7, 9, 20, 25, 44, 47, 55, 56, 57, 60, 62] Total Sum:450	2014-12-10 11:56:20		
9205	qywrh	114	int main() { int i=0,j=0; int m=0,n=0; int sum=0; int sum_a=0,sum_b=0; int[] a = [3, 5, 7, 9, 20, 25, 30, 40, 55, 56, 57, 60, 62]; int[] b = [1, 4, 7, 11, 14, 25, 44, 47, 55, 57, 100];  while( i<a.length && j<b.length) { if(a[m]!=b[n]) { sum_a+=a[m]; sum_b+=b[n]; m++; n++; }  else if(a[m]==b[n]) sum= a[m]+max(sum_a,sum_b); }   return sum; }	2014-12-10 11:56:20		
9206	krxlv	114	Forgot to add " i++ and j++ " after sum=a[m]+max(); statement	2014-12-10 11:56:20		
9207	huiqq	114	I modified the codes from the first answer a little bit and this should work.  private static int max (int a, int b) { if (a > b) return a; else return b; }  public static void CalLargest(int [] a, int [] b) { int sum_subarray_a = 0; int sum_subarray_b = 0; int max_sum = 0; int i = 0; int j = 0; int temp = 0;  while ( i < a.length - 1 && j < b.length - 1 ) { sum_subarray_b += b[j]; j++; sum_subarray_a += a[i]; i++; if(a[i] == b[j]) { max_sum += max(sum_subarray_a, sum_subarray_b); sum_subarray_a = sum_subarray_b = 0; temp = i; } } sum_subarray_a = sum_subarray_b = 0; for (int k = temp; k < a.length; k++) { sum_subarray_a += a[k]; } for (int l = temp; l < b.length; l++) { sum_subarray_b += b[l]; }  max_sum += max(sum_subarray_a, sum_subarray_b);  System.out.println("Max Sum is : " + max_sum);  }	2014-12-10 11:56:20		
9208	ewigy	114		2014-12-10 11:56:20		
9209	qywrh	114		2014-12-10 11:56:20		
9210	plapd	114	}	2014-12-10 11:56:20		
9211	ewigy	114		2014-12-10 11:56:20		
9212	nwkeg	114		2014-12-10 11:56:20		
9213	tenuw	114	Try this Java Code:-  public static void main(String[] args) { int[] arr1 = new int[] { 3, 5, 7, 9, 20, 25, 30, 40, 55, 56, 57, 60, 62 }; int[] arr2 = new int[] { 1, 4, 7, 11, 14, 25, 44, 47, 55, 57, 100 }; ArrayList<Integer> sum1 = new ArrayList<Integer>(); int s = 0, mainSum = 0, intersectionsum = 0, k = 0;  for (int i = 0; i < arr1.length; i++) { int n1 = arr1[i]; s += n1; for (int j = 0; j < arr2.length; j++) { int n2 = arr2[j]; if(n1 < n2) break; if(n1==n2) { intersectionsum+= n1; sum1.add(s - n1); s = 0; } } } sum1.add(s); s = 0; for (int i = 0; i < arr2.length; i++) { int n1 = arr2[i]; s += n1; for (int j = 0; j < arr1.length; j++) { int n2 = arr1[j]; if(n1 < n2) break; if(n1==n2) { mainSum += (sum1.get(k)>(s - n1))?sum1.get(k):(s - n1); ++k; s = 0; } } } mainSum += (sum1.get(k)>s)?sum1.get(k):s; mainSum += intersectionsum; System.out.println(mainSum); }	2014-12-10 11:56:20		
9214	ufdxg	114	Move along each path by comparing the values at each point. Increment the path with the lowest value and add the value to the path's sum. When you reach an intersection point, compare the sums of the paths up to this point and add the largest sum to the total sum.	2014-12-10 11:56:20		
9215	admin	114		2014-12-10 11:56:20		
9216	rdfeo	114		2014-12-10 11:56:20		
9217	admin	114		2014-12-10 11:56:20		
9218	dgjji	114		2014-12-10 11:56:20		
9219	dkebi	114		2014-12-10 11:56:20		
9220	fmzze	114		2014-12-10 11:56:20		
9221	cfzie	114		2014-12-10 11:56:20		
9222	ftfck	114		2014-12-10 11:56:20		
9223	dkebi	114	public static int getMax(int[] s1, int[] s2, int counter, ref string route) { if (counter > s1.Length - 1) return 0; route += ", " + s1[counter].ToString(); if (counter == s1.Length - 1) return s1[counter];  //Console.WriteLine(", " + s1[counter].ToString()); string r1 = route; string r2 = route; var sum1 = s1[counter] + getMax(s1, s2, counter + 1, ref r1); int sum2 = 0; if (counter <= s2.Length - 1 && s1[counter] == s2[counter]) { sum2 = s1[counter] + getMax(s2, s1, counter + 1,ref r2);  //Console.WriteLine((sum1 > sum2)? r1: r2); //Console.WriteLine((sum1 > sum2)? sum1: sum2); } return (sum1 > sum2)? sum1 : sum2; }	2014-12-10 11:56:21		
9224	plapd	114		2014-12-10 11:56:21		
9225	ufdxg	114		2014-12-10 11:56:21		
9226	xhgls	114		2014-12-10 11:56:21		
9227	azmjc	114		2014-12-10 11:56:21		
9228	sqzqo	114	public static int sol2(int[] arr1, int[] arr2) { Map<Integer,Integer> map = new HashMap<Integer, Integer>(); int temp = 0; for(int i : arr1) { temp+=i; map.put(i,temp); //max values with respect to 0 } int totalsum = 0; temp = 0; int prevIntersectionVal = 0; for(int i : arr2) { temp+=i; Integer val = map.get(i); if(val != null) { int ins1 = val - prevIntersectionVal; prevIntersectionVal = val; if(temp > ins1) totalsum+=temp; else totalsum+=ins1; temp = 0; } } int lastSum = map.get(arr1[arr1.length-1]) - prevIntersectionVal; totalsum+= lastSum > temp ? lastSum : temp; return totalsum; }	2014-12-10 11:56:21		
9229	azmjc	114		2014-12-10 11:56:21		
9230	ufdxg	114		2014-12-10 11:56:21		
9231	bexbp	114		2014-12-10 11:56:21		
9232	nhibd	114		2014-12-10 11:56:21		
9233	vanul	114	@redM0nk: this does not work because a and b are advancing at the same pace, but the intersection could happen somewhere eles in the arrays. for example index 10 could be equal to index 20 of the other array!!!	2014-12-10 11:56:21		
9234	fowai	114	Need a little clarification: How can we know that a particular element is an Intersection point ?? Is there any rule like every 3th element is an intersection point?? Or do we have to find out manually??	2014-12-10 11:56:21		
9235	dgjji	114		2014-12-10 11:56:21		
9236	bexbp	114		2014-12-10 11:56:21		
9237	wbqzu	114	This function returns: - empty array in no intersections occurred in the input arrays - array with one item - the value of the first occurred intersection:	2014-12-10 11:56:21		
9238	admin	114		2014-12-10 11:56:21		
9239	wbqzu	114		2014-12-10 11:56:21		
9240	azmjc	115		2014-12-10 11:56:22		
9241	dgjji	115		2014-12-10 11:56:22		
9242	krxlv	115	No one mentioned any O(1) space constraint. Even with that constraint, this is not best in terms of number of swaps.	2014-12-10 11:56:22		
9243	plapd	115		2014-12-10 11:56:22		
9244	mrjku	115		2014-12-10 11:56:22		
9245	wbqzu	115	We can still do in place , you are consuming more memory here	2014-12-10 11:56:22		
9246	tenuw	115		2014-12-10 11:56:22		
9247	zeice	115		2014-12-10 11:56:22		
9248	sqzqo	115	} // IN-PLACE	2014-12-10 11:56:22		
9249	gilit	115	C++ implementation with O(n) time and O(1) space using tail recursion.	2014-12-10 11:56:22		
9250	ftfck	115		2014-12-10 11:56:22		
9251	ufdxg	115		2014-12-10 11:56:22		
9252	fowai	115	Good algorithm!  But if the size of the given array is very huge, like 1000000, and under the worst situation, like this rotate_right(arr, sizeof(arr)/sizeof(arr[0]), 1);  how to solve the stack overflow problem?	2014-12-10 11:56:22		
9253	jippy	115	@yuxiaohui78 There's no stack overflow problem with this algorithm. The rotate_right function uses tail recursion, so this is optimized as a regular loop by the compiler, preventing the use of stack for each call. You can use an array of any size (limited by the maximum value of size_t) and it will work.	2014-12-10 11:56:22		
9254	rrmeu	115	Thanks for Diego Giagio's explanation. I used the compiling parameter -O2, it works.	2014-12-10 11:56:22		
9255	huiqq	115		2014-12-10 11:56:23		
9256	fmzze	115		2014-12-10 11:56:23		
9257	xhgls	115	Explanation: temp array is A + A. And temp.length = 2*A.length. e.g. A = [4,3,2,5] then temp = [4,3,2,5,4,3,2,5]. Now select the array between (including) (shifts - 1) and including shifts - 1 + A.length - 1.	2014-12-10 11:56:23		
9258	cfzie	115	The catch is to do it in place. No use of temporary array.	2014-12-10 11:56:23		
9259	ufdxg	115		2014-12-10 11:56:23		
9260	jippy	115		2014-12-10 11:56:23		
9261	nwkeg	115	Worst case len^2 operations (when n is len)	2014-12-10 11:56:23		
9262	xhgls	115	Then you compromise the running time. And the running time would be O(shift * (array.length - 1)).	2014-12-10 11:56:23		
9263	bjsiw	115	With a temp buffer of size n (or within a larger permanent buffer assigned to this task) we can:  N copies of last n elem. Of array into temp. A.len-N copies of array's first elements from very front to very end. Copy N elements from temp to start of array.  In total (a.len+N) writes.	2014-12-10 11:56:23		
9264	admin	115	for N is the size of the array and n < N/2 the following would work	2014-12-10 11:56:23		
9265	nwkeg	115		2014-12-10 11:56:23		
9266	ufdxg	115		2014-12-10 11:56:23		
9267	bjsiw	115	}	2014-12-10 11:56:23		
9268	ethan	115		2014-12-10 11:56:23		
9269	ewigy	115		2014-12-10 11:56:23		
9270	krxlv	115	When shift is greater than size of the array then this code in the swap function result in a ArrayIndexOutOfBound or segmentation fault.	2014-12-10 11:56:23		
9271	cfzie	115		2014-12-10 11:56:23		
9272	krxlv	115		2014-12-10 11:56:23		
9273	zeice	115	}	2014-12-10 11:56:23		
9274	dgjji	115	It fails for arrays of even number size a = {1,2,3,4} shiftArray(a, 2); a={1,2,1,4}	2014-12-10 11:56:23		
9275	nwkeg	115	best sol would be if a swap gets minimized and in one shot the elements gets reolcation to right position. for example : if we have array of size 6 and 4 shifts has to be done then a[(i+s)%n] = a[i] a[0] =a[4] a[4] = a[2] a[2] =a[0] and so on  number of actual shift s = k % n  for( i=0 ; i < n/3 ; i++) { temp = a[i]; for(j=1; j < 4 ; j++) {  next = ( i + j*s)%n //swap the contents of a[next] and temp temp1 = a[next] a[next] = temp temp = temp1 } }	2014-12-10 11:56:23		
9276	xhgls	115	O(N) time, O(N) space... determine new position in array for bucket, move into temporary array, determine for next bucket etc...	2014-12-10 11:56:23		
9277	fmzze	115		2014-12-10 11:56:23		
9278	krxlv	115		2014-12-10 11:56:23		
9279	nwkeg	115	}	2014-12-10 11:56:23		
9280	rdfeo	115	The O(N) time and O(1) space looks optimal for small tables	2014-12-10 11:56:23		
9281	ewigy	115		2014-12-10 11:56:23		
9282	ethan	115		2014-12-10 11:56:23		
9283	azmjc	115	but it's actually very bad for very large tables and relatively large n. Why? Because if n*sizeof(int) is larger than CPU cache this algo would generate only random memory accesses which can kill any algo. The modulo operation is expensive as well.	2014-12-10 11:56:23		
9284	tenuw	115		2014-12-10 11:56:23		
9285	rdfeo	115		2014-12-10 11:56:23		
9286	rdfeo	115	#include <iostream> #include <stdio.h>  #define S 5  void show(int* w, int size) { printf("-------------\n"); for (int e = 0; e < size; ++e) printf("%d \n", w[e]); }  int main() { int tab[S] = { 1, 2, 3, 4, 5 };  int shift = 2; int* w = new int[shift]; for (int k = 0; k < shift; ++k) w[k] = tab[S - k - 1];  show(w, 2);  int tmp = S - shift - 1; int dek = S - 1; for (int z = tmp; z >= 0; --z) tab[dek--] = tab[z];  int k = 0; for (int e = shift - 1; e >= 0; --e) tab[k++] = w[e];  show(tab, 5);  system("pause"); return 0; }	2014-12-10 11:56:23		
9287	ufdxg	115		2014-12-10 11:56:24		
9288	qywrh	115		2014-12-10 11:56:24		
9289	ethan	115		2014-12-10 11:56:24		
9290	eucmc	115		2014-12-10 11:56:24		
9291	mrjku	115	Too good :)	2014-12-10 11:56:24		
9292	qywrh	115	It fails for arrays of even number size a = {1,2,3,4} shiftArray(a, 2); gives a={3,2,1,4} while the actual answer is {3,4,1,2}	2014-12-10 11:56:24		
9293	mrjku	115	How about this  run a while loop for length of array. shift first element to n after copying a[n]th element to a local variable(k). Now k will be copied to n1=(n+n)%len. Similarly copy the existing element of the array and put the shifted element.	2014-12-10 11:56:24		
9294	vanul	115		2014-12-10 11:56:24		
9295	dgjji	115		2014-12-10 11:56:24		
9296	eucmc	115		2014-12-10 11:56:24		
9297	fmzze	115		2014-12-10 11:56:24		
9298	dgjji	115		2014-12-10 11:56:24		
9299	sqzqo	115		2014-12-10 11:56:24		
9300	sqzqo	115		2014-12-10 11:56:24		
9301	mrjku	115		2014-12-10 11:56:24		
9302	rdfeo	115	c++  #include <memory.h>  static void shiftArray(int shift, int arr[], int length ) { int *tmp = new int[length]; memcpy(tmp, arr + (length-shift), sizeof(int)*shift); memcpy(arr + shift, arr, sizeof(int)*(length-shift)); memcpy(arr, tmp, sizeof(int)*shift); }  int main(int argc, char* argv[]) { int arr[] = {1,2,3,4,5,6,7,8,9}; shiftArray(3, arr, sizeof(arr)/sizeof(*arr)); return 0; }	2014-12-10 11:56:24		
9303	plapd	115	private static void CircularRightShiftForArrayOfIntegers(int[] inputArray, int shift) { int[] outputArray = new int[inputArray.Length]; int i = 0;  while (i != inputArray.Length) { if (i + shift == inputArray.Length) { shift = -i; }  outputArray[i + shift] = inputArray[i];  i++; }  Console.WriteLine(string.Join(" ", outputArray)); }	2014-12-10 11:56:24		
9304	dkebi	115		2014-12-10 11:56:24		
9305	jippy	115		2014-12-10 11:56:24		
9306	fowai	115	public void circle(int n) {  int j = -1; int[] aInt = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int[] aInt1 = new int[aInt.Length]; for (int i = n; i < aInt.Length ; i = i + 1) { j++; aInt1[j] = aInt[i]; } for (int i = 0; i < n; i = i + 1) { aInt1[aInt.Length - n + i] = aInt[i]; } }	2014-12-10 11:56:24		
9307	ftfck	115	public void circle(int n) {  int j = -1; int[] aInt = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int[] aInt1 = new int[aInt.Length]; for (int i = n; i < aInt.Length ; i = i + 1) { j++; aInt1[j] = aInt[i]; } for (int i = 0; i < n; i = i + 1) { aInt1[aInt.Length - n + i] = aInt[i]; } }	2014-12-10 11:56:24		
9308	nhibd	115	How about this: jump with step n, e.g. starting from index 0, n, 2*n, .... and swap their values. Do that n times with starting points in n first elements. O(N) time, O(1) memory.	2014-12-10 11:56:24		
9309	qywrh	115		2014-12-10 11:56:24		
9310	zeice	115		2014-12-10 11:56:24		
9311	huiqq	115		2014-12-10 11:56:24		
9312	ufdxg	115		2014-12-10 11:56:24		
9313	mrjku	115	github.com/techpanja/interviewproblems/tree/master/src/arrays/circularshiftintarray	2014-12-10 11:56:24		
9314	qywrh	115	int count =0,i=0,prev=arr[0],newInd,temp; while(count<n){ count++; newInd = (i+shift)%n; temp = arr[newInd]; arr[newInd] = prev; prev = temp; i = newInd; }	2014-12-10 11:56:24		
9315	cfzie	115		2014-12-10 11:56:24		
9316	krxlv	115	Ima let you finish, but Anonymous is the best troll.	2014-12-10 11:56:24		
9317	zeice	116	Topological sort.	2014-12-10 11:56:26		
9318	admin	116	What if there is a cycle?	2014-12-10 11:56:26		
9319	ethan	116	If there's no assumption about the number of times you visited each place then it may not be possible to reconstruct your journey.  For instance, suppose your journey was as follows: a --> b --> c --> a --> d --> f --> a  Tickets: (a,b), (b,c), (c,a), (a,d), (d,f), (f,a)  You know your end point is a, how do you know which one of the following journeys was yours? 1. a --> b --> c --> a --> d --> e --> a 2. a --> d --> e --> a --> b --> c --> a	2014-12-10 11:56:26		
9320	ufdxg	116	If there is loop, more than one solution. We should first start with no loop situation.	2014-12-10 11:56:26		
9321	sgiwy	116	Observation from the info provided in question: 1. If I do not remember the order in which I visited these places, than off course i dont remember the starting location. 2. But I know my current location - end of my journey. 3. End place of one journey is starting place for another journey.  So on the basis of these observation here is my algorithm:	2014-12-10 11:56:26		
9322	dkebi	116		2014-12-10 11:56:26		
9323	admin	116		2014-12-10 11:56:26		
9324	ethan	116	The worst case complexity to build a ticket hashmap is O(N^2), because in the worst case hashmap degrades to a linked list.	2014-12-10 11:56:26		
9325	sgiwy	116	@Iuri Covalisin  Yes. But that is easily avoidable (at least for strings) .. after selecting a good hashing approach.	2014-12-10 11:56:26		
9326	eucmc	116	Good one Ajeet. Complexity of this algo is O(n); Because, theoretically, we can say HashMap's complexity is amortized O(1) Not O(n);	2014-12-10 11:56:26		
9327	vanul	116	Nope, this will not work.  Correct me, if I am wrong. You are blindly making an assumption that a place has been visited just once.	2014-12-10 11:56:26		
9328	bexbp	116	@ mindless monk Yes you are right I am assuming that all places visited once. There is no info about number of visits .. so i am giving solution if a place is visited once.	2014-12-10 11:56:26		
9329	xhgls	116	BFS with end location as source node and the path with all the tickets (edges) would be the order of visited places?	2014-12-10 11:56:26		
9330	fowai	116	Euler path	2014-12-10 11:56:26		
9331	jippy	116	We can construct possible paths if and only if:  * there is at most one vertex with in-degree != out-degree * if such a vertex exists, then in-degree = out-degree - 1  If the above holds and no vertex has out-degree > 1, then we can construct the path.  Otherwise, to find the exact path from all possible paths, then for any vertex v of out-degree > 1 there must be at most one path from v that contains a cycle. If any such vertex violates this principle, then we cannot determine which of the possible paths is the correct one.	2014-12-10 11:56:26		
9332	nhibd	116	Assuming that the all the travels was made by airplanes, I think it's possible build the following solution: -> Build a graph G: where each city visited is a vertex and there a edge between each pair of cities that are in a travel ticket. Obviously G is a directed graph. -> If the graph don't have cycles then is possible reconstruct the trip by a topological sort procedure. -> Otherwise, it's impossible reconstruct the certain path.	2014-12-10 11:56:26		
9333	azmjc	116	Not having any cycles is a sufficient condition for not being able to reconstruct the journey but it's not a necessary one.  For instance, suppose your journey was: a --> b --> c --> a. The graph has a circle but knowing that the end point is "a", it is possible to reconstruct the journey even though there is a cycle in the graph.	2014-12-10 11:56:26		
9334	nhibd	116	JUST if there are knowing about end point or start point.	2014-12-10 11:56:26		
9335	tenuw	116	Having a cycle is not necessarily a problem. consider these trips:  a->b, b->c, c->b  There is a cycle (b->c->b), but the only possible route is (a->b->c->b). In this case you don't even have a definite end point, but since there is only one possible start point (a), you can still deduce the route.  However knowing the either the start or end point does not mean all cycles are allowed. In this case you can't deduce the trip: a->b, b->c, c->b, b->d, d->b  There are 2 possible routes: (a->b->c->b->d->b) and (a->b->d->b->c->b)	2014-12-10 11:56:26		
9336	fmzze	116		2014-12-10 11:56:26		
9337	ftfck	116		2014-12-10 11:56:27		
9338	cfzie	116	In case there are multiple visits to the same destination, we should use "multimap" since "map" only accepts unique key values.	2014-12-10 11:56:27		
9339	krxlv	116	if you visit same destination (i.e. you go to city X to transfer more than 1 time), you cant really know the order anymore. (because i.e first time is X->Y and second time is X->Z you cant tell the order )	2014-12-10 11:56:27		
9340	krxlv	116	First create hash map having destination as a key, pass current location (trip destination), hashmap and reference to path vector. The total complexity is O(N^2) where N is number of tickets and square time is spent while creating a hashmap, while the method itself has O(N + 1) complexity:	2014-12-10 11:56:27		
9341	fmzze	116		2014-12-10 11:56:27		
9342	ethan	116		2014-12-10 11:56:27		
9343	gilit	116	Constructing the graph starting from the final location. Then the problem is of finding the vertex cover. Here we can also consider the possibility that one city is visited twice. But in this case the answer may not be unique.	2014-12-10 11:56:27		
9344	rrmeu	116		2014-12-10 11:56:27		
9345	fowai	116		2014-12-10 11:56:27		
9346	qywrh	116	Ticket from one city to the other is an edge.  Given a bunch of edges, the question asks you to tell if there exists a path such that you visit each edge exactly once. In other words, a Eulerian Path.  Below is the necessary and sufficient condition for a Eulerian path in directed graphs. (Source: Wikipedia) A directed graph has an Eulerian trail if and only if at most one vertex has (out-degree)  (in-degree) = 1, at most one vertex has (in-degree)  (out-degree) = 1, every other vertex has equal in-degree and out-degree, and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.  This however is a necessary condition but not sufficient. Existence of a Eulerian path can actually be deduced from common sense. If you haven't left every city you have been to except for the one you are currently in, you wouldn't end up where you are.  But we are looking for one and only one Eulerian path to exist, which is possible only if every vertex has an indegree and outdegree of at most 2.	2014-12-10 11:56:27		
9347	ufdxg	116	You have to do topological sorting for Euler circuit duhhhhhhhhhhhhhh	2014-12-10 11:56:27		
9348	rrmeu	116	Assuming you don't know where you are:	2014-12-10 11:56:27		
9349	huiqq	116		2014-12-10 11:56:27		
9350	gilit	116		2014-12-10 11:56:27		
9351	nhibd	116	mistake, it should be:  * start node A is one with in-degree(A) = out-degree(A) - 1, * end node B is one with in-degree(B) = out-degree(B) + 1	2014-12-10 11:56:27		
9352	ethan	116	import java.util.ArrayList; import java.util.HashMap; import java.util.Map;  public class AirplaneTktProblem { Map<String, Tkt> tripMap = new HashMap<String, Tkt>();  public static void main(String[] args) { ArrayList<Tkt> tktList = new ArrayList<Tkt>(); AirplaneTktProblem atp = new AirplaneTktProblem();  }  // make a Arraylist of tkt which is a departure and destination pair  // input it public void inputTrip(ArrayList<Tkt> tktList) { for (Tkt t : tktList) { tripMap.put(t.to, t); } }  // traverse the first tkt and traverse the end of the trip public Tkt traverseToTheFirstTkt(ArrayList<Tkt> tktList) { Tkt firstTkt = tktList.get(1);  while (tripMap.get(firstTkt.from) != null) { firstTkt = tripMap.get(firstTkt.from); } return firstTkt; }  // traverse the begining of the trip using the last tkt public void BuildTheTrip(ArrayList<Tkt> tktList) { inputTrip(tktList); Tkt Firsttkt = traverseToTheFirstTkt(tktList); tktList.clear(); tktList.add(Firsttkt); while (tripMap.get(Firsttkt.from) != null) { tktList.add(tripMap.get(Firsttkt.from)); } }  class Tkt { private final String from; private final String to;  public Tkt(String departure, String arrival) { super(); this.from = departure; this.to = arrival; }  } }	2014-12-10 11:56:27		
9353	ewigy	116		2014-12-10 11:56:27		
9354	ewigy	116		2014-12-10 11:56:27		
9355	gilit	116		2014-12-10 11:56:27		
9356	xhgls	116		2014-12-10 11:56:27		
9357	krxlv	116	The code stands on two premises: 1) There is only one starting point, i.e. it's not a forest 2) The route is not circulated	2014-12-10 11:56:27		
9358	dkebi	116		2014-12-10 11:56:27		
9359	ftfck	116		2014-12-10 11:56:27		
9360	fmzze	116	yes... start with the place i am currently...match it with the ticket...and then i get my preceeding location...so on	2014-12-10 11:56:27		
9361	fowai	116	I remember this question was once asked in a "Long Contest" on codechef.com. Here is how I solved it.  You need an Associative Array (most suitably a HashMap) to solve this problem. Suppose each ticket is of the form "A->B" (means the ticket from 'A' to destination 'B'). Example input: F->G B->C E->F C->D D->E A->B Output: A->B->C->D->E->F->G	2014-12-10 11:56:27		
9362	bjsiw	116		2014-12-10 11:56:27		
9363	rdfeo	116		2014-12-10 11:56:27		
9364	nwkeg	116	This only works if the same city isn't visited more than once during the itinerary. To solve without this assumption, you need to find an Euler tour of the graph representing the travel (there may be multiple possible itineraries if a city can be visited more than once, though, as EulGam05 mentioned).	2014-12-10 11:56:27		
9365	ufdxg	116	Hey eugene! are you the same guy who appears among the toppers list on codechef? I'm a fan :)	2014-12-10 11:56:27		
9366	wbqzu	116	Construct directed graph with places as nodes and directed edge between two place v1,v2 if v1 was start loaction in some ticket and v2 was destination in the same ticket.Now use topological sorting algorithm.	2014-12-10 11:56:27		
9367	tenuw	116	Another approach, If beyond source and destination info there are date-time info in tickets: -> Sort the tickets registers by increasing date-time -> Build the trip by sorted tickets.	2014-12-10 11:56:28		
9368	fowai	116		2014-12-10 11:56:28		
9369	gilit	116		2014-12-10 11:56:28		
9370	admin	116	"Each ticket contains *just* the start location and the end location"	2014-12-10 11:56:28		
9371	cfzie	116	Even if the interviewer did allow you to use this information, you'd need to account for different time zones.	2014-12-10 11:56:28		
9372	dgjji	116	If ask me... then: The question is: "Could you reconstruct your journey?" So the answer is: If there are no cycles -> yes, otherwise it could be reconstructed but without guarantee that order is the same.	2014-12-10 11:56:28		
9373	nwkeg	116	A sorting problem	2014-12-10 11:56:28		
9374	qywrh	117	You can use stack, start pushing each character from input string till you not hit close parenthesis. When you hit close parenthesis, start pop the element till you not hit open parenthesis. If the immediate pop hit open parenthesis than that is duplicate parenthesis. Note: this algo will fail, if one put false parenthesis in string like: () .... Code as:	2014-12-10 11:56:29		
9375	tenuw	117		2014-12-10 11:56:29		
9376	wbqzu	117		2014-12-10 11:56:29		
9377	rrmeu	117	will it work for - (a+(b)) -	2014-12-10 11:56:29		
9378	fmzze	117	question?id=5067220493271040	2014-12-10 11:56:29		
9379	huiqq	117		2014-12-10 11:56:29		
9380	vanul	117		2014-12-10 11:56:29		
9381	bjsiw	117		2014-12-10 11:56:29		
9382	nhibd	117		2014-12-10 11:56:29		
9383	fowai	117	Hi,can you describe what "duplicate" here means? I am understanding it means more than one ")" or "(" or "}" or "{"	2014-12-10 11:56:29		
9384	bexbp	117	duplicate parenthesis means: ((c+d)) here () is extra which is duplicate. here only required (c+d) but due to duplicate parenthesis, you will find ((c+d)) ... So, you have to find such duplicate parenthesis ...	2014-12-10 11:56:29		
9385	eucmc	117		2014-12-10 11:56:29		
9386	eucmc	117		2014-12-10 11:56:29		
9387	mrjku	117	If white spaces are removed, then for any two pairs of parenthesis in the expression, there are 5 kinds of cases we need to take care of: 1.((exp)) such as ((a+b)) 2.(exp(exp)) such as (a-(b+c)) 3.((exp)exp) such as ((a+b)*c) 4.(exp(exp)exp) such as (a/(b-c)+d) 5.(exp)exp(exp) such as (a+b)/(c*d) Only the first kind has redundant outside parenthesis, so all we need to do is find out the ocurrances of two pairs of parenthesis like the first kind. Following is code in C++11:	2014-12-10 11:56:29		
9388	nhibd	117		2014-12-10 11:56:29		
9389	ftfck	117		2014-12-10 11:56:29		
9390	ufdxg	117	time complexity O(n), space complexity O(n)	2014-12-10 11:56:29		
9391	bjsiw	117	a naive approach is traverse the string, left to right, for occurrence of )) and replace then with some unicode char(which is not part of string). Traverse again in string from right to left to find occurrence of (( again replacing consequent pair with same unicode. Then we can just check the balance using a stack. If its balanced we have duplicates. let me know loopholes, as I am not entirely sure about this approach	2014-12-10 11:56:29		
9392	ufdxg	117	From my understanding of the question, regexp are much more easier and should do too. Or am I ignoring something?	2014-12-10 11:56:29		
9393	ethan	117		2014-12-10 11:56:29		
9394	mrjku	117		2014-12-10 11:56:29		
9395	wbqzu	117	Looks interesting solution but there is some catch.  For String "(( a + b ) + (( c + d )) + e)" o/p should be ((a + b) + ( c + d ) + e ) but, your code gives o/p = (a + b) + ( c + d ) + e )	2014-12-10 11:56:29		
9396	sgiwy	117	expressionString = (( a + b ) + (( c + d )))  Step1 : In the expression look for "((" and store in a string - subStr Step2: Look for the next occurrence of ')' and store its index Step3: Look for the character at index+1 if(expressionString.charAt(index+1) == ')'){ print("expression contains duplicate parenthesis "); break; } else{ subStr = " "; }	2014-12-10 11:56:30		
9397	sgiwy	117	@Miral and @Sehs - For finding duplicate parenthesis... this simple means your statement would be having "((" i.e., two starting parenthesis... once you find this.. find the next closing parenthesis.. ')' and if the next character in the string is also ')' then this means duplicate parenthesis exist...	2014-12-10 11:56:30		
9398	dkebi	117	Tried that already, it wont work for this: (((a+b)+c))	2014-12-10 11:56:30		
9399	sgiwy	117	@Miral - Sorry that was a big miss-  Considered two examples Eg1 - ((a+b)+((c+d))) eg2 - (((a+b) + cc))  and I changed my algo to-  Step 1 - Store the index of '(' in an 'opening_paren' array from the expression. Step 2 - On occurrence of ')' store its index in a 'closing_paren' array and now check for the next index and if the next index is also ')' then calculate the difference in indexes and if the last two elements of both array have difference in index as 1 then it means duplicate.  Lets see the below example - eg1- (((a+b) + c)) opening_paren 0 1 2  closing_paren 6 and 7 index is not ')' i remove 2 and 6 from the list opening_paren 0 1  closing_paren 9 10  Now as we can see the difference between indexes is 1 on both the arrays which would lead to duplicate parenthesis.	2014-12-10 11:56:30		
9400	bjsiw	117		2014-12-10 11:56:30		
9401	cfzie	117		2014-12-10 11:56:30		
9402	wbqzu	117		2014-12-10 11:56:30		
9403	fowai	117		2014-12-10 11:56:30		
9404	dgjji	117	}	2014-12-10 11:56:30		
9405	plapd	117		2014-12-10 11:56:30		
9406	ethan	117		2014-12-10 11:56:30		
9407	mrjku	117	}	2014-12-10 11:56:30		
9408	zeice	117	There's a duplicate version of this question, could not post a link to the original post since careercup.com does not allow links in comments but the Question ID is 12011927.  Here's my version in C#:	2014-12-10 11:56:30		
9409	gilit	117		2014-12-10 11:56:30		
9410	huiqq	117		2014-12-10 11:56:30		
9411	wbqzu	117		2014-12-10 11:56:30		
9412	xhgls	117		2014-12-10 11:56:30		
9413	qywrh	117		2014-12-10 11:56:30		
9414	vanul	117		2014-12-10 11:56:30		
9415	vanul	117	((a+b)) in this example one operator is there so there should be only one open braces should present, ((a)) in this case zero, ((a*b)+(a-b)) in this case three.  So just find out the count of open braces and number of operators.If they equal no duplicates, if not duplicates are present. if it is wrong please correct me. thanks.	2014-12-10 11:56:30		
9416	ethan	117	@Srinivas -  There can be any expression which includes multiplication.  For eg. - ((a+b)((c+d)+e))  In this expression we have 3 operators and 4 opening braces and also doesn't include any duplicates. And according to your algo it would fail.	2014-12-10 11:56:30		
9417	rdfeo	117	push the open parenthesis and the operators and check the top element on seeing a closing parenthesis. If it is open one we have duplicate.	2014-12-10 11:56:30		
9418	plapd	117		2014-12-10 11:56:30		
9419	eucmc	117		2014-12-10 11:56:30		
9420	ftfck	117	Here is a working version in Python.	2014-12-10 11:56:30		
9421	zeice	117		2014-12-10 11:56:30		
9422	sqzqo	117		2014-12-10 11:56:30		
9423	bexbp	117	Step 1: Run through the code Step 2: Search for the brackets Step 3: search for a '( )' pair Step 3a: If there is another opening bracket just before '(' and if there is a closing bracket just after ')' ;then there is a duplicate Step 3b : Else; replace the section '(.....)' by some characters say 'XYZ..'. Step 4: Repeat from step 3 until u reach the outermost bracket .  Am i correct??	2014-12-10 11:56:30		
9424	fmzze	117		2014-12-10 11:56:30		
9425	ftfck	117		2014-12-10 11:56:30		
9426	rrmeu	117	Hi,  Here is my implementation with Java.  I assumed that :  1. Given expression is valid, which means all open brackets are closed. 2. Given expression can not be null. 3. Given expression does not contain negatives. (-a + b) negative a is not possible.  Here is the main class :	2014-12-10 11:56:30		
9427	xhgls	117		2014-12-10 11:56:31		
9428	wbqzu	117		2014-12-10 11:56:31		
9429	cfzie	117	I tested this implementation with these cases :  (testing more than one case in a test is not practical, but I preferred to keep simple for this page)	2014-12-10 11:56:31		
9430	ewigy	117		2014-12-10 11:56:31		
9431	bjsiw	117		2014-12-10 11:56:31		
9432	gilit	117	It is a good implementation for removing useless brackets, but you do not answer the problem.	2014-12-10 11:56:31		
9433	zeice	117		2014-12-10 11:56:31		
9434	azmjc	117		2014-12-10 11:56:31		
9435	rrmeu	117	Here is the algorithm and implementation in Objective-C Stacks is implemented using NSMutableArray 1.if ( --> check if lastObject in ORStacks is ( ; then append ( to String or push ( to ORStacks 2.if operator/operand append to String 3.if ) --> check if lastObject in ORStacks is ( ;then push ) to String,pop ORStacks if ORStacks is not empty;else move to the next one	2014-12-10 11:56:31		
9436	ftfck	117		2014-12-10 11:56:31		
9437	jippy	117		2014-12-10 11:56:31		
9438	qywrh	117		2014-12-10 11:56:31		
9439	vanul	117		2014-12-10 11:56:31		
9440	wbqzu	117	As far as I understand this is parenthesis matching problem: 1- If you just want to check if all parenthesis are matching, you can do that in O(n) time and O(1) space. Loop over all chars in the string, whenever you find "(" increase a counter and whenever you find ")" decrease the counter and the final result must equal to 0. Here is a sample C# code:	2014-12-10 11:56:31		
9441	ftfck	117		2014-12-10 11:56:31		
9442	rdfeo	117		2014-12-10 11:56:31		
9443	sqzqo	117	2- If you want the index of all unmatched parenthesis, you need two stacks: one for opening '(' (say S1) and one for unmatched closing ')' (Say S2). Whenever you find an opening ( you add its index to the stack S1, whenever you find a closing ')' you remove the top element from S1, if S1 was already empty (unmatched closing tag), then add index of ')' to S2. Here is a sample code	2014-12-10 11:56:31		
9444	sgiwy	117		2014-12-10 11:56:31		
9445	ethan	117		2014-12-10 11:56:31		
9446	nhibd	117	This will take O(n) time and worst case of O(n) space (if all parenthesis are opening or closing)	2014-12-10 11:56:31		
9447	zeice	117	he didn't say it was a parenthesis matching problem. he said the requirement is to find duplicate paranetheses such as in the example he gave... a simpler example:  ((a))	2014-12-10 11:56:31		
9448	eucmc	117	@jbweimar: So,I assume your example will return true?	2014-12-10 11:56:31		
9449	gilit	117	-1, because correct answer but not for this question.	2014-12-10 11:56:31		
9450	ufdxg	117	Thanks!	2014-12-10 11:56:31		
9451	krxlv	117	@Miral and @Sehs - For finding duplicate parenthesis... this simple means your statement would be having "((" i.e., two starting parenthesis... once you find this.. find the next closing parenthesis.. ')' and if the next character in the string is also ')' then this means duplicate parenthesis exist...	2014-12-10 11:56:31		
9452	fmzze	118	for n=1, its one way for n=2, its 2 ways for n=3, its 3 ways for n=4, its 5 ways for n=5, its 8 ways for n=6, its 13 ways, so on  It is a fibonacci series... f(n) = f(n-1) + f(n-2)	2014-12-10 11:56:32		
9453	gilit	118	It is the Fibolasic Problem F(n)=F(n-1)+F(n-2)	2014-12-10 11:56:32		
9454	zeice	118	Indeed.  W(n) = W(n-1) + W(n-2) where W(1)=1 W(2)=2  Number of ways to reach nth floor=Number of ways to reach (n-1)th floor (take 1 step after reaching n-1th floor) or Number of ways to reach nth floor=Number of ways to reach (n-2)th floor (take 2-step after reaching n-2th floor)	2014-12-10 11:56:32		
9455	bjsiw	118	The solution is analogous to the linear equation in 2 variable. a+2b=n, n known, 0<a<=n, 0<b<=n/2 a can take (n+1) places, b can take (n/2+1) Total cases = (n+1) * (n/2+1)  Please comment	2014-12-10 11:56:32		
9456	ewigy	118	to reach on floor it may go with one step or two step , so person has to choices.  lets take small example. if person wants to reach on 5th floor from ground then how many ways he can reach.  to reach ground to first floor - 2 ways ( one step or two step ) to reach first to second floor - 2 ways ( one step or two step ) to reach second to third floor - 2 ways ( one step or two step ) to reach third to forth floor - 2 ways ( one step or two step ) to reach forth to five floor - 2 ways ( one step or two step )  to total way = 2*2*2*2*2 similar case for n = 2*2*2......n = 2 power of n	2014-12-10 11:56:32		
9457	huiqq	118	Hi Deepak, But check the case with reaching 3rd floor: you have only 3 cases: first, take all one steps second, take a one step initially and followed by a two step third, take a two step initially and followed by a one step  thats all... Please correct me if am wrong..	2014-12-10 11:56:32		
9458	ewigy	118	Hi You forgot one case: Take all 2 steps. And thus that makes this as 4 steps Actually the solution above by Deepak is correct. Here in your example for two floors we are having 2*2 = 4 steps.	2014-12-10 11:56:32		
9459	rrmeu	118	how can u reach floor three by taking two 2 steps??	2014-12-10 11:56:32		
9460	bjsiw	118	how can u reach floor 3 by taking two 2 steps??	2014-12-10 11:56:32		
9461	bexbp	118	it's 2 to the power of (n - 1). To get to the 3 rd floor from the first floor you need 4 ways	2014-12-10 11:56:33		
9462	xhgls	118	Well, I am not sure if I am reading too much in the question, but it says N floors and not N steps. So to get to the 1st floor, either you can take 1 or 2 steps, so you would require X: 1 steps and Y: 2 steps.. so to get to the Nth floor you need NX + NY steps and Y steps = 2X thus, you need 3NX steps or 1.5NY steps... i duno.. please correct me if I am wrong..	2014-12-10 11:56:33		
9463	dkebi	118	dear Sn, I think it seeems from Q that to reach a particular floor he can go 1 0r 2 step . so his step size should be same. But you can take it otherwise too as you have taken. Good!	2014-12-10 11:56:33		
9464	rrmeu	118	Dear Sn,  If you require X number of 1-steps and Y number of 2-steps , then Y < X . Hence, X = 2Y So, to reach the nth floor, you need 3NY or 1.5NX steps.	2014-12-10 11:56:33		
9465	rrmeu	118	This is a permutation / combination problem. (rather only permutation)...We need to find the number of ways to reach the nth floor with 1 or 2 steps at a time.  So, if n=6, we can have 1 + 1 + 1 + ... 1 + 2 + 1 + ... and so on..  Draw a tree and u could see that at each level, there is a node for either 2 or 1. Chk the current sum at each node. Its hence a recursive program with the following DS;  struct StepNode { int curr_sum; int *arr // if they want the type of combinations };	2014-12-10 11:56:33		
9466	azmjc	118	Number of integral solution for the below mention Linear Equation in two variable a+2b=n, n known, 0<a<=n, 0<b<=n/2 a= n-2b; (1) n >= n-2b >=0 implies 0<=b<=n/2 Total Integral solution for (1) equation is (n-2b+1-1)C(1-1) = n-2b; Now, b varies from 0 to n/2 Summation : i = 0 to n/2 , n-2i n*(n+2)/2 - n(n+2)/4 = n*(n+2)/2	2014-12-10 11:56:33		
9467	jippy	118	Number of integral solution for the below mention Linear Equation in two variable a+2b=n, n known, 0<a<=n, 0<b<=n/2 a= n-2b; (1) n >= n-2b >=0 implies 0<=b<=n/2 Total Integral solution for (1) equation is (n-2b+1-1)C(1-1) = n-2b; Now, b varies from 0 to n/2 Summation : i = 0 to n/2 , n-2i n*(n+2)/2 - n(n+2)/4 = n*(n+2)/4	2014-12-10 11:56:33		
9468	ufdxg	118	DP :  step(n) { 1 + max(step(n-1),step(n-2)) }	2014-12-10 11:56:33		
9469	sgiwy	118	As per the question, we are required to find out TOTAL NUMBER OF DIFFERENT WAYS to reach from 1st floor to Nth Floor. We are not calculating the total number of STEPs needed to reach the Nth floor. Hence this question becomes a permutation & combination problem.  The correct answer should be power(2, n-1). "Deepak Garg" has explained it and "Anonymous" has corrected it.  Solutions (a+2b = n) and fibonacci numbers are not correct.  Fibonacci Number Solution :  From Floor 1 to Floor 3 : a. (1,1,1) b. (1,2) c. (2,1)  Total number of ways is 3. In this solution, only (a) is correct. In (b) & (c) we are not even traversing 3 floors.  Hence solutin of fibonacci numbers does not work.  We can come up with similar arguments for linear equation solution.	2014-12-10 11:56:33		
9470	krxlv	118	power(2, n-1) fails. Say n = 4 the possible combinations are 1234 134 124 234 24 power(2, n-1) gives you 8	2014-12-10 11:56:33		
9471	wbqzu	118	What I understand from the problem stmt, to reach 1 floor if there are 'm' steps, person can take 1 or 2 steps at a time to reach 1st floor. Thus for 'n' floors, there are total 'nm' steps. If a person takes 1 step throughout, then he will be climbing 'nm' steps to reach nth floor, while if he takes 2 steps at a time, he will have to climb 'nm/2' steps. Thus total no. of ways to climb nth floor are 'nm - nm/2' = 'nm/2'. Correct me if I am wrong.	2014-12-10 11:56:33		
9472	tenuw	118	I was wrong. Each of the 'nm/2' steps can be taken as 1 step or 2 steps. Thus 2 ^ (nm/2) possible ways to climb.	2014-12-10 11:56:33		
9473	ewigy	118	well somebody here needs to check their algorithm before declaring it as a solution. Like check the fact that the answer can be ODD so IT ISNT 2^ANYTHING!!!!!!!!!!!!11	2014-12-10 11:56:33		
9474	nwkeg	118	{well somebody here needs to check their algorithm before declaring it as a solution. Like check the fact that the answer can be ODD so IT ISNT 2^ANYTHING!!!!!!!!!!!!}	2014-12-10 11:56:33		
9475	mrjku	118	It looks to me that there are two possible interpretations of this:  Q1) Taking 1 or 2 steps, how many ways to reach the nth step? A) Fibonacci.  Q2) Taking 1 or 2 steps to next floor, how many ways to reach the nth floor? A) Power of 2. Two ways to reach next floor.  Interpretation 2 does not really make sense in terms of a puzzle (or real life... 1 or 2 steps and you are already up one floor!?), but that is what the original poster seems to have written. Yet another case of bad problem statement.  IMO, the original poster goofed up and intended Q1 all along.	2014-12-10 11:56:33		
9476	ethan	118	Ppl, Isn't some data missing in this question? Say, the number of steps to climb up one floor perhaps. ie No.of steps/floor. This data is required to answer the question the way it is worded.	2014-12-10 11:56:33		
9477	gilit	118	I guess the answer might be Summation from b=0 to b=n/2 of (n-b)!/a!b!  The number of steps/floor should not matter. ( assume there are k steps/floor , so total steps now are n*k=m. So instead of n now we have m, butthe problem remains same)  Let's consider this: We need to climb n steps, using a number of 1 steps and b number of 2 steps. so a*1 + b*2=n a+2b=n  ok, now given a value of n, above equation can be satisfied by many possible value pairs (a,b).  Let's consider one such pair. For this particular pair, how many possible ways are there to reach n? Let's take an example? if n=5, a=3 and b=1 the question is how many possible ways can I arrange 3 one's and 1 two? this is typical combination/permutation problem with standard formula answer (n-b)!/a!b!  so given a value pair a and b, there are (n-b)!/a!b! ways to reach step n. so the second part is, how many such value pairs are possible? and for each such value pair calculate (n-b)!/a!b!.  not as lengthy as an explaination as I would like. but hth.	2014-12-10 11:56:33		
9478	fowai	118	I have no idea what the fuss is all about. It is a simple Fibbonacci series.  f(n) = f(n-1) + f(n-2)  You can reach the nth floor either from n-1 st floor or directly from n-2 nd floor. so total ways to reach nth floor = ways to reach n-1 st floor + ways to reach n-2 nd floor.	2014-12-10 11:56:33		
9479	eucmc	118		2014-12-10 11:56:33		
9480	bexbp	118		2014-12-10 11:56:33		
9481	plapd	118	It is a simple Fibbonacci series.  f(n) = f(n-1) + f(n-2)+2 where f(x) indicate how many u can go to x th floor.. You can reach the nth floor either from n-1 st floor or directly from n-2 nd floor. so total ways to reach nth floor = ways to reach n-1 st floor + ways to reach n-2 nd floor.	2014-12-10 11:56:33		
9482	admin	118	after reaching n-1th floor there is only one way to reach nth floor;after reaching (n-2)th floor there are 2 ways to reach the nth floor...hence total 3 ways  f(n)=f(n-1)+f(n-2)+3  please tell me if that is wrong ?	2014-12-10 11:56:33		
9483	rdfeo	118	Adhi, it is exactly fibonacci series.  reason is 1. if n = 1, reaching 1st floor is only one way (in one step) so f(1) = 1 2. if n = 2, reaching 2nd floor is two ways (take two steps one a time or take two steps once) so f(2) = 2  f(3) = f(2) + f(1)...  f(n) = f(n-1) + f(n-2)  perfectly fibonacci series.	2014-12-10 11:56:33		
9484	jippy	118	Surprising to see how many people got this question wrong! It is really simple if you just think about it....  In order to go up one floor (N=1), there are 2 ways (1 step or 2 steps) in order to go two floors (N=2), There are 4 ways (11,12,21,22 steps) in order to go three floors (N=3), There are 8 ways (111,121,211,221,112,122,212,222) so there are 2^N posibilities. If someone starts on the 1st floor, there are 2^8 = 256 possibilities. If someone starts from the basement, there are 2^9 = 512 possibilities.	2014-12-10 11:56:33		
9485	dgjji	118	i think question is not about going to n floor it is going to nth stair so if i want to go to 3rd stair with 121 combination i will be on 4th what answer needed is number of ways this can be achieved	2014-12-10 11:56:33		
9486	admin	118	Can any buddy give me a complete code actually i have to submit assignment of shell on monday so dont want to waste time for this program simple my question has modified fibbonaci instead of 1 ,2 i have 1 , 2 , 3 no of stairs that i can climb together.	2014-12-10 11:56:33		
9487	wbqzu	118	I viewed it as generating strings from length n/2 (just "2"s) to n (just "1"s) and came up with that formula (use as query term in wolframalpha.com to display):	2014-12-10 11:56:33		
9488	ewigy	118		2014-12-10 11:56:33		
9489	dgjji	118		2014-12-10 11:56:33		
9490	mrjku	118	Explanation: For n=6 stories I can go "222" (l = 3 = n/2), "111111" (l = n = 6), "2211" (l = 4 = n/2 + 1), "2121", "2112", "1212", ..., "21111" (l = 5 = n/2 + 2), ..., "11112". In each String of length l (which can go from n/2 to n -- 3 to 6 in the example) i can "choose" only (n - l) possitions to take 2 steps at once. In the example: (3 choose 3) + (4 choose 2) + (5 choose 1) + (6 choose 0) = 13  I read that it is the fibonacci series, but seriously -- how could one come up with this based on that question?!?	2014-12-10 11:56:33		
9491	wbqzu	118	Assume each floor has m steps. Each floor can be reached in Fib(m) ways as given in the first answer. For for reaching nth floor as per permutation it should be (Fib(m))^n	2014-12-10 11:56:33		
9492	fowai	118		2014-12-10 11:56:34		
9493	huiqq	118		2014-12-10 11:56:34		
9494	plapd	118	here is nice post on this question interviewmakertech.blogspot.in/2014/12/blog-post.html	2014-12-10 11:56:34		
9495	xhgls	119	I have posted N log N solution for this problem above but another simple solution of O (N^2) is as follows:  Step1: Consider first 2 servers with billion integers each. Use merge procedure of merge sort. Keep track of count while comparing elements of two arrays. If count becomes billion (For 2 billion elements on 2 servers together), we have reached the median. Take the average of the element at billion th position and billion -1 position to get the exact median value.  Step2: Now take billion elements from machine 3, Again we have 1 billion elements currently with us from machine 1 and 2 together and we have 1 billion elements from machine 3.  So we follow step1 again to merge the array and stop at billion th location to get the median.  Step3: Repeat the procedure for 10K servers.  Total time taken: Step3 times Step1: O(N^2)	2014-12-10 11:56:34		
9496	ufdxg	119	I forgot to mention a sorting step in this solution.  But the better solution still O(N^2) is as follows:  Step1: Sort billion numbers individually on each server .Since its a fixed sized 32 bit long integers, we can use LSD radix sort to sort in O(N) time.  Step2: Instead of considering only first 2 machines as given above, consider all the machines together.  Use merge procedure of merge sort. Keep track of count while comparing elements of 10K arrays. If count becomes 1000 * billion / 2 (This is half of 10K * billion numbers each), we have reached the median.  Now since this number is huge, we dont need to store all those elements on single machine, keep storing elements in new array and break the array as soon as the memory is full.  Now take the average of the element at 1000 * billion /2 th position and 1000 * billion / 2 -1 position to get the exact median value.  The time complexity is still O(N^2)	2014-12-10 11:56:34		
9497	wbqzu	119	That makes sense to me, but frankly I'm interested in hearing your O(NlgN) solution now.	2014-12-10 11:56:35		
9498	admin	119	The solution by Saurabh seems appropriate except a minor improvement of using quick sort to sort each of the server because , the number of integers is so huge and merge sort uses extra space whereas quick sort can do the sorting in place with almost equal efficiency. When finding the medians of these 10,000 servers we need to have 10000 variables pointing to each sorted array and we need to keep the count , also we need to identify and mark which server has what count.	2014-12-10 11:56:35		
9499	sgiwy	119	This is a distributed computing problem and you have to pay attention to how much data you transfer over the network (someone called it communication complexity).  The solutions given are shit (except the median of medians, which gives an approximate median, but does not answer the question correctly and is written in a shit way, showing a lack of understanding of the problem).	2014-12-10 11:56:35		
9500	bexbp	119	Very easy to modify quick select. Each server should have two queries: (1) given integer, give its sorted postion.(2) provide integer at sorted position.  select initial pivot is easy. query (1) rest of servers and recalculate new pivot.	2014-12-10 11:56:35		
9501	xhgls	119	Reply above mine sounds correct, but I think it needs a little more verbosity. Here is what I think it meant:  1. Sort each server. 2. Call (2) to get the middle element of each server. 3. The needed number is between min and max of the elements returned at step 2. So do a binary search between min and max. For each number you test call (1) on each server to get how many numbers lower, equal and higher than the test are on the server. Calculate 3 sums: number lower, number equal and number higher. 4. If nLower + nEqual >= nHigher && nLower <= nEqual + nHigher, then we are done and this is the median. 5. If nLower + nEqual < nHigher, then we should try a higher number. 6. Else we should try a lower number.  Let N be the number of integers per server (billion), and M is the number of servers (10,000). Then complexity of sorting is NlogN, complexity of binary search is logM*logN. So total complexity is NlogN.	2014-12-10 11:56:35		
9502	krxlv	119	I have a idea, that using selection algorithm. Selection algorithm whose running time is O(n) in the worst case. So on each sever we can use selection algorithm to find the (billion/2)th biggest element, and then we can get 10k integers that are medians of each sever. And then we use same procedure to find the (10k/2)th biggest element, which is the final result. The total time is linear time O(n).	2014-12-10 11:56:35		
9503	plapd	119	The median of all the medians is not necessarily the median of the entire combined dataset. Consider an example with just two machines:  Machine 1: 2, 3, 4, 5, 6. Median is 4. Machine 2: 6, 6, 6, 6, 6. Median is 6.  The correct answer for the median of the combined data would be 6, but here you would get 5.	2014-12-10 11:56:35		
9504	ftfck	119	Can you explain how would we get 5 in the above algorithm?	2014-12-10 11:56:35		
9505	dkebi	119	M is 10K servers, N is 1 billion integers each server has. The complexity to find the median is O(N*M*log(M)/2) = O(N*M*log(M)). The memory usage is O(M).  1. Sort each server takes O(Nlog(N)) 2. Use an array A (size M) to store the first elements from each server. 3.	2014-12-10 11:56:35		
9506	eucmc	119		2014-12-10 11:56:35		
9507	vanul	119		2014-12-10 11:56:35		
9508	fmzze	119	4. ret is result we want	2014-12-10 11:56:35		
9509	krxlv	119	M is 10K servers, N is 1 billion integers each server has. The complexity to find the median is O(N*M*log(M)/2) = O(N*M*log(M)). The memory usage is O(M).  1. Sort each server takes O(Nlog(N)) 2. Use an array A (size M) to store the first elements from each server. 3.	2014-12-10 11:56:35		
9510	dgjji	119		2014-12-10 11:56:35		
9511	krxlv	119		2014-12-10 11:56:35		
9512	qywrh	119	You can sum numbers locally then we have 2 options: 1 - correctness should be as high as possible. In this case we send full sum to some aggregate server which can sum all sums and then divide it to 10k* 1billion 2 - we can divide sum locally and send meaning then on aggregate server when we just power it by 1 bill sum with other sums and divide to 10k* 1billion  From example above:  Machine 1: 2, 3, 4, 5, 6. Sum is 20 Machine 2: 6, 6, 6, 6, 6. Sum is 30 Then Machine 1 receives 30 and 50 / 10 = 5  Here sum is a map operation and sum of sums is reduce operation You probably can get number type overflow, but create an custom type to store value in few buckets is efficient enough and transfer between node will not take a long time.	2014-12-10 11:56:35		
9513	nhibd	119	Since we have integers, we could create an array counts[MAXINT]. counts[i] equals the number of times integer value i present in the whole system. So each sever could pass it's total array to processing server holding the array. Processing server code is	2014-12-10 11:56:35		
9514	nhibd	119		2014-12-10 11:56:35		
9515	cfzie	119		2014-12-10 11:56:35		
9516	huiqq	119	Processing can be easily paralleled since counts arrays may be aggregated. Find the median is as easy as sum up counts until total reaches half of the total number of integers in the whole system. Correct me, if it is not O(n) time.	2014-12-10 11:56:35		
9517	bexbp	119	1- Find median in each server 2- Find median of the medians which ends up with two numbers since count is even 3- Find median of numbers within range of the above two number in each server 4- Repeat step 2 and 3 until each sever has no more than two numbers within the range, the two numbers are the final median.	2014-12-10 11:56:35		
9518	nwkeg	119		2014-12-10 11:56:35		
9519	zeice	119		2014-12-10 11:56:35		
9520	bexbp	119	6. keep count to track the index .Once index == totalsize/2 return median .	2014-12-10 11:56:35		
9521	wbqzu	119	1. On Each Server, find Min Max 2. Count ints in each server 3. Ask for MinCounts from each server and check whether it has reached to 1000 B or not	2014-12-10 11:56:35		
9522	huiqq	119	If the each integer is 32 bits, here i O(n) solution: Create an array of type long (64 bits) to hold all possible numbers from 2,147,483,648 to 2,147,483,647. A[num] = #count of num. Example: 1,4,4,5,1,2 --> A[1]=2, A[2]=1, A[4]=2, A[5]=1 Memory requirement is 4GB * 8 = 32 GB. Modern server should have this kind of memory.  Step 1: Loop through all numbers on all servers to count the occurrence of each number. This would take O(n).  Step 2: We know there are 10 trillion numbers. From the array, just find where the 5 trillion occurs. This would take 4 billion operations which is much smaller than n = 10 trillions.	2014-12-10 11:56:36		
9523	mrjku	119		2014-12-10 11:56:36		
9524	sqzqo	119		2014-12-10 11:56:36		
9525	sgiwy	119	If the each integer is 32 bits, here i O(n) solution: Create an array of type long (64 bits) to hold all possible numbers from 2,147,483,648 to 2,147,483,647. A[num] = #count of num. Example: 1,4,4,5,1,2 --> A[1]=2, A[2]=1, A[4]=2, A[5]=1 Memory requirement is 4GB * 8 = 32 GB. Modern server should have this kind of memory.  Step 1: Loop through all numbers on all servers to count the occurrence of each number. This would take O(n).  Step 2: We know there are 10 trillion numbers. From the array, just find where the 5 trillion occurs. This would take 4 billion operations which is much smaller than n = 10 trillions.	2014-12-10 11:56:36		
9526	tenuw	119		2014-12-10 11:56:36		
9527	rdfeo	119		2014-12-10 11:56:36		
9528	rdfeo	119	O(Nlogk) solution. k - number of servers + (time to request and pass n/2 numbers between the servers) Inspired by Saurabh's second solution.  1. Sort billion numbers individually on each server. Since its a fixed sized 32 bit long integers, we can use radix sort to sort in O(N) time.  2. Let's introduce min heap on one of the machines. Heap size would be equal to 10000 (k).  3. Ask each machine for min value and insert this values to the heap (keeping information which server this value came from)  4. Let's introduce counter to keep track of how many values we have considered.  5. Get min value from the heap, ask server-origin of this value for next min value and insert it into the heap. Increment the counter (O(logk) + query time)  6. Do step 5 till we get through half of the values. Compute median by picking exact value (if we can have one) or finding average of two values at the center.	2014-12-10 11:56:36		
9529	cfzie	119	Good question. Depends on what tradeoffs need to be made. Discuss with interviewer.	2014-12-10 11:56:36		
9530	dkebi	119	Here is how we can get the median of the billion numbers on each of 10K servers.  I am going to assume that since its a server, its going to have 32GB of RAM to perform calculations on those billion integers at once. If RAM on the servers is less, the logic still works well just that we have to break billion integers into group of say 2 and then perform the same logic.  Logic: We will find medians of those billion numbers separately on each of the 10K servers. [Step1] Get the median of the billion numbers on all 10K machines.  Getting the median of the billion numbers is a 2 step process a. Sort the numbers. Since its a 32 bit integer number (in java), we can sort them in O(N) time using LSD Radix Sort   [Step2] Now consider machine 1 and 2, We have 1 array each of billion numbers say arr1 and arr2 and we have 1 median each say m1 and m2.  Now we will compare those medians as follows  Case1: If m1 and m2 are same, we have the median on 2 servers. Its m1.  Case2:If m1 is greater than m2, then median is present in one of the below two subarrays. a) From first element of arr1 to m1 b) From m2 to last element of arr2  Case3: If m2 is greater than m1, then median is present in one of the below two subarrays. a) From m1 to last element of arr1 b) From first element of arr2 to m2  [Step3] Repeat Step2 until size of both the subarrays becomes 2. If size of the two arrays is 2 then we get median as Median = (max(arr1[0], arr2[0]) + min(arr1[1], arr2[1]))/2  [Step4] Now we found the median on 2 machines, to include machine 3 in median calculation, we calculate median of machine 3 billion numbers say m3.  We now follow the exact same 3 steps as of Step2. If m3 (median of m/c 3) is larger than m12 (median found in step3 of machine 1 and 2) then we create arr1 as all the elements of machine 1 and 2 greater than median m12.  This way we accommodate 1 machine at a time to calculate the median of all 10K machines.  I will post the program as soon as possible.  Total Time complexity: Step 1: sorting using LSD radix sort : O(N) Step2: Divide and Conquer Step O(N logN) Step3: Calculating median, constant time O(1) Step4: Repeating step for 10K -2 servers O(N)  Total Time Complexity: O(N logN)	2014-12-10 11:56:36		
9531	dgjji	119	Correction: Time complexity for Step2 is O(logN) and repeating this process for 10K server times O(N) * O(LogN)  Total Time Complexity: O(N logN)	2014-12-10 11:56:36		
9532	gilit	119	What is the communication complexity? How many numbers would you have to transfer over the network? Are you even getting the right answer? What are you optimizing for? Time? What about the cost of running the machines: why not optimize for that?  Basically this question needs discussion. It is good to have this question out here, and people can try thinking of approaches which optimize different things, like time, cost etc, maybe even question the original use case, and change the whole design (like partition data differently etc).	2014-12-10 11:56:36		
9533	sgiwy	119	You don't need to sort the billion integers, you can use the 'median of medians' algorithm to find the median in an unsorted array of integers in O(n).	2014-12-10 11:56:36		
9534	dgjji	119	Ehhh, probably shouldn't use "median of medians". It's a technique for finding the approximate median, not exact (which is what we want).	2014-12-10 11:56:36		
9535	fowai	119	Finding medians of each of 10,000 server and finding the median among them will work as it is stated that there billion integers(equal number of numbers). Problem breaks down into 1) finding median on each server 2) finding medians among the medians  As there are 1billion integers, 1billion/2th(or +1) biggest number will be the median. This becomes finding kth biggest number problem which has a complexity of O(N) Reference: Search for finding Kth biggest element in an unsorted array in stackoverflow Store this in an array of 10,000 and again find the 5000th biggest number in this array, whose complexity is O(M) So total complexity = O(N)	2014-12-10 11:56:36		
9536	rdfeo	119	Have min-max heap on each server. Have 1 min-max heap to maintain all the medians from each server. Basically you are finding median of medians.  retrieval of median from min-max heap is constant time. However, there is maintainance overhead. for every update in any of the server(s), you have to update the final find heap.	2014-12-10 11:56:36		
9537	rrmeu	119	That will only find the "approximate" median.	2014-12-10 11:56:36		
9538	rrmeu	119	min-max heap is supposed to return you the exact median value. not average. I only read a paper on that but haven't tried implementing. Let me work on that.	2014-12-10 11:56:36		
9539	gilit	119	Hi, Median is not the average of min and max element in the array. So min-max heap is not going to work. Median is the middle element of the sorted array if the total elements are odd, or the average of the middle 2 elements if the element count is even.  So for the elements {2,13,17,30,45} and {120,150,260,380} the median is 45.  With your logic, for first array min = 2, max = 45 so average = (45+2) / 2 = 23.5 for second array min=120, max=380 so average = 500/2 = 250  Now the avg of 250 and 23.5 is not 45.	2014-12-10 11:56:36		
9540	rdfeo	119	I said it is supposed to return median and not average.	2014-12-10 11:56:36		
9541	mrjku	119	@Algo,  So in the example of {1,2,3} and {4,5} you would return 2, 4, or 5? still incorrect	2014-12-10 11:56:36		
9542	admin	119	yeah, I get your point. median of medians is not right.	2014-12-10 11:56:36		
9543	admin	120	LOL :) You really made this board fully of joy! I like your answer very much. Anyway I will give my way to approve the result.	2014-12-10 11:56:37		
9544	tenuw	120		2014-12-10 11:56:37		
9545	dgjji	120		2014-12-10 11:56:37		
9546	ewigy	120	Hi Westlake, can you pls explain why probability of having only 2 children, 1 boy and 1 girl is 0.5^2. It should be 0.5 not 0.25  In general the probability formula for having k successes in n tries is (n!/(n-k)! * k!) * p^k * q^(n-k)  Here k = success (Getting a boy) n = number of tries (in 2 children case, number of tries are 2) p = Probability of success in 1 trial (Probability of getting a boy and a girl is 0.5 each) q = 1-p = Probability of failure in 1 trial (probability of failure, that is getting a girl child is 0.5)  So for p(2,1) = (2! / 1! * 1!) * 0.5 ^1 * 0.5^1 = 0.5	2014-12-10 11:56:38		
9547	huiqq	120	The couple have 2 children when they first had a girl and then a boy.  The change for a girl is 0.5 and the chance for a boy is 0.5. The chance for this combination is 0.5*0.5 = 0.25.	2014-12-10 11:56:38		
9548	vanul	120	How did you come up with this:	2014-12-10 11:56:38		
9549	krxlv	120		2014-12-10 11:56:38		
9550	eucmc	120		2014-12-10 11:56:38		
9551	ethan	120	??? I think	2014-12-10 11:56:38		
9552	ethan	120		2014-12-10 11:56:38		
9553	cfzie	120		2014-12-10 11:56:38		
9554	xhgls	120	This problem can be solved by using Negative Binomial distribution NB(r,p), where the r is the number of success(boys), in this case: r=1. Let X be the number of girls. You would need to calculate the expected value of girls: E(X)= pr/(1-p)=(1/2)/(1/2)=1 for NB distribution. So the ratio is E(X)/E(# of boys) = 1/1=1. This question can be extended: say the probability of having a boy is not 1/2, say 51/100, and # of boys each family want is 3. Now this ratio should be E(X)/r = p/(1-p) = 49/51. So the # of boys won't affect the ratio, while the probability of having a boy will.	2014-12-10 11:56:38		
9555	tenuw	120	In your consideration you missed the case when there are consecutive girls.	2014-12-10 11:56:38		
9556	nwkeg	120	I believe the answer is - there is eventually no one left. Eventually, you have all boys (whats left of them) and the next generation cannot proceed. This is because as each generation passes, you will have the possibility of having less girls than boys. When that happens, the next set of parents will less than the previous set. The boys who did not get married will die and not replace themselves for the next generation. On an infinite cycle, its inevitable that the boys will reduce. The girls could have been more than the boys in any given generation, but that is inconsequential becuase the excess girls cannot marry. Therefore, the number of boys can never increase.	2014-12-10 11:56:38		
9557	zeice	120	While this is a nice observation, it is the answer to a different question, and perhaps based on a different model.  You are asked to quantify the ratio of girls / boys not what happens to the whole population. What if there are no couples and the villagers are self-cloning aliens?  Regardless, based on your model, at any generation "t", we have E[boys] = E[girls]. This expected value could be vanishing-ly small, assuming a marriage model, or excessively large if we assume a self-cloning model.	2014-12-10 11:56:38		
9558	admin	120	I think it's one, because even you have more boys than girls, but one boy can only married to one girl. So this make the ratio to 1 in infinite years. The boys who don't have wife will die without children.	2014-12-10 11:56:38		
9559	nhibd	120	Huh?	2014-12-10 11:56:38		
9560	krxlv	120	Idiotic. Why do you think monogamy is a rule?	2014-12-10 11:56:38		
9561	gilit	120	While NOT mathematically what people where are expecting .. for that see the standard answer on summing together a infinite series which translates to ratio 1.. I agree with you. The answer looks valid to me. May be people are angry because the could not think beyond maths.  In the mathematical answer as well, there would be time when the ratio would be skewed from perfect 1. And so it would be in case of this answer as well.	2014-12-10 11:56:38		
9562	sqzqo	120	Sorry, this is a bogus answer. There was no assumption of single spouse marriage or mortality. Just because the final result is (probably) right does not mean the argument is right too.	2014-12-10 11:56:38		
9563	zeice	120	Expected number of children N = 1/2 + 2/2^2 + 3/2^3 + ...  2N = 1 + 2/2 + 3/2^2 + 4/2^3 + ...  N = 1 + 1/2 + 1/2^2 + ... = 2.  Thus we would expect the ratio of 1.	2014-12-10 11:56:38		
9564	ewigy	120	Explain?	2014-12-10 11:56:38		
9565	dkebi	120	I think...  Expectation = sum over x * (probability of x)  1 child = 1 * 1/2 2 child = 2 * 1/2 * 1/2 3 child = 3 * 1/2 * 1/2 * 1/2 ... and so on. Add them up.	2014-12-10 11:56:38		
9566	krxlv	120	Of course, that does not mean expected ratio of girls/boy is 1.	2014-12-10 11:56:38		
9567	cfzie	120	our typical indian family... boy.. SOLUTION!	2014-12-10 11:56:38		
9568	admin	120	Assuming having a village with 64 families.  After they all have their babies, the village will have 32 baby boys and 32 baby girls. The number of boys = number of girls. Now, 32 families who had boys will stop having babies.  Of the remaining 32 families... 16 will have boys and 16 will have girls. The "total" number of baby boys = total number of baby girls = 32+16=48  Now, we have 16 families still going at it... of these, 8 boys and 8 girls will come out. Total number of boys = total number of girls = 32+16+8 = 56  Now, 8 couples will produce 4 boys and 4 girls. We have 60 boys and 60 girls total.  Next, 4 couples will have 2 boys and 2 girls. 62 boys and 62 girls  2 couples left... 63 boys and 63 girls  And finally we have only 1 couple left... Ignoring this pop couple who have had 8 babies in a row... As counter-intuitive as it looks, we can see that the ratio of baby boys/baby girls remains constant.	2014-12-10 11:56:38		
9569	ftfck	120	for the people that are too concerned about the "infinite years"...  there will come a time, when the sun will turn into a black hole... in billions of billions of billions.... years... but definitely that will happen before "infinite years".  there will be no boys and no girls. the ratio of girls to boys will be undefined (divide by zero)  I think the intent of the interviewer was not to ask about "infinite years", but wanted the interviewee to take a limit as n goes to infinity in the expected value of the two numbers.	2014-12-10 11:56:38		
9570	ftfck	120	The ratio is 1. Think about it this way. Given "N", "N / 2" of families will have a single boy. The other "N / 2" will have a girl as a first child. Now let's assume the second "N / 2" give their first-born (girl) to the first "N / 2" family. So we have "N / 2" families with 1 boy and 1 girl, and "N / 2" families where they keep trying until they get a boy. By recursion, you find that the ratio has to be one.	2014-12-10 11:56:38		
9571	jippy	120	I like this answer the most! Thanks!	2014-12-10 11:56:39		
9572	eucmc	120	You're welcome! I have to admit though I first solved this the hard way by finding expectations.	2014-12-10 11:56:39		
9573	ewigy	120	The expected number of boys is 1, since they keep making babies until getting a boy :)  The expected number of children is C = 1/2 + 2/2^2 + 3/2^3 + ... + k/2^k + ...  With some tricks we can find that C = 2.  Thus in average each family have 2 children, 1 boy, 1 girl!  Tricks:	2014-12-10 11:56:39		
9574	sqzqo	120		2014-12-10 11:56:39		
9575	tenuw	120		2014-12-10 11:56:39		
9576	bjsiw	120	I have a different thought. If we consider the fact that human has limited life span, eventually someone will die. In infinite time, don't u think there will be no one left because there there will be less and less girl to match a man?	2014-12-10 11:56:39		
9577	zeice	120	I was mistaken. Actually i believe it is 1 too.	2014-12-10 11:56:39		
9578	rdfeo	120	Probability of having a boy=Probability of having a girl = 1/2  if a family has n children one among them is boy n-1 girls and1 boy  probability of having n children = 1/(2^n) because n-1 fails(n-1 girl children) * 1 pass(a boy)=1/(2^n-1)*1/2  now the expected number of children in each family is E[x]=Summation {number of children*probability of having them}  E[x]=1/2 + 2/2^2 + 3/2^3 + ... + k/2^k + ...  E[x]=2(already proven by many)  this means we can expect 2 children in each family but we know that each family has at least 1 boy that's why they stopped(except infinity case). that is 1 boy and 1girl so ratio is 1.	2014-12-10 11:56:39		
9579	bjsiw	120	"...they keep doing child..."  What the? That's disgusting!	2014-12-10 11:56:39		
9580	huiqq	120	The question asks what will be the population of the village after infinite years. This question has definitely incomplete data. The answer depends on probability for each generation that a given couple will have boy or a girl.  Lets say that for 1st generation (adam and eve) the probability of having boy is 0.25. Which means adam and eve will have to procreate 4 times and 4th child will be a boy. Population after 1st generation will be 4. Now population for 2nd generation also depends on probability of having a boy which can be any number. Hence to predict population for a given generation, we need probability distribution for random variable for the event having a boy which is not given.  If we assume uniform distribution of .25, then the infinite series will not converge and hence the answer is infinity.  The series can converge only if PDF can be such that infinite series can converge.  Hope the answer helps	2014-12-10 11:56:39		
9581	eucmc	120	Probability of having girls kid will be increasing generation by generation.... and for time before infinity time all girls will remain and there will not be any more generation.  Only the 'infinite time' mentioned in qus made me to think in this way else there is no certainty	2014-12-10 11:56:39		
9582	nhibd	120	Doesn't look like my approach is in here!  Since couples stop producing at 1 boy, then we have these possibilities.	2014-12-10 11:56:39		
9583	bexbp	120		2014-12-10 11:56:39		
9584	wbqzu	120		2014-12-10 11:56:39		
9585	jippy	120	Now let's look at the possibilities that these each happen:	2014-12-10 11:56:39		
9586	dgjji	120		2014-12-10 11:56:39		
9587	ethan	120		2014-12-10 11:56:39		
9588	xhgls	120	And the contribution to the ratio of boys in each of these:	2014-12-10 11:56:39		
9589	fmzze	120		2014-12-10 11:56:39		
9590	azmjc	120		2014-12-10 11:56:39		
9591	bjsiw	120	So we get an infinite series here:	2014-12-10 11:56:39		
9592	admin	120		2014-12-10 11:56:39		
9593	ftfck	120		2014-12-10 11:56:39		
9594	gilit	120	My series is shabby, but you can add the first few terms (1/2) and (1/8) and see that it is converging to 2/3.  Thus, over the long term and with a large enough population, 2/3 of the town will be boys and 1/3 of the town will be girls.	2014-12-10 11:56:39		
9595	admin	120	probability will be =1/2	2014-12-10 11:56:39		
9596	ufdxg	120	every male wil have exactly ONE male child,  number of girls may be 0,1,2,3,4,5......till a male child is born.  hence girls go on continuously increasing , but boys remain the same . hence girls / boys >>>>>>large.	2014-12-10 11:56:39		
9597	ufdxg	120	probability of having:	2014-12-10 11:56:39		
9598	rdfeo	120		2014-12-10 11:56:39		
9599	qywrh	120		2014-12-10 11:56:39		
9600	rdfeo	120	Math expectation of having girls:	2014-12-10 11:56:40		
9601	eucmc	120		2014-12-10 11:56:40		
9602	ewigy	120		2014-12-10 11:56:40		
9603	qywrh	120	Math expectation of having boy:	2014-12-10 11:56:40		
9604	mrjku	120		2014-12-10 11:56:40		
9605	tenuw	120		2014-12-10 11:56:40		
9606	rrmeu	120	which means that ratio girls/boy = sum(i=1;i<=n;) i/(2^(i+1)) which is infintiy	2014-12-10 11:56:40		
